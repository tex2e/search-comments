"#if 0" isn't valid, but it is common, so recognize it and handle it with a fixit elegantly.
"::" is semi-arbitrary, though whatever we choose must delimit possible class and method names, so we might as well ape the source syntax
"Adobe Photoshop Document Data Block": 8BIM...
"Binary" mode doesn't use/need text codecs
"Captured" local types require no context.
"Check conformance" on each declared protocol to build a conformance map.
"Color Image Quantization for Frame Buffer Display", Proc.
"Copy/grow" semantics:  Many of the functions that mutate arrays return an ArrayData* and take a boolean parameter called 'copy'.
"CryptoTokenKit", "DVComponentGlue",
"Deinitialize" an existential container whose contained value is allocated / but uninitialized, by deallocating the buffer owned by the container if any.
"Destructure" an ignored binding into multiple ignored bindings.
"Inst" is a ValueMetatype instruction.
"Inst" is an Upcast instruction.
"InstallerPlugins", "InstantMessage", "JavaFrameEmbedding",
"JavaVM", "Kerberos", "LDAP",
"QTKit", QTKit is unavailable on Swift.
"Simple op" handlers.
"VideoDecodeAcceleration",
"Weak" uses are used in optimizeActRecs.
"auto" tends to be used as a verb prefix.
"bring back" what was removed.
"de" can prefix a verb.
"foo." was allowed in earlier versions
"get" is implicit, so it can't be checked for.
"identifier ':' for/while/do/switch" is a label on a loop/switch.
"if let" implicitly looks inside of an optional, so wrap it in an OptionalSome pattern.
"inf","nan" and maybe other weird ones
"infinity" use position
"new"-style: setting - underscore, 4 chars of count, 4 chars of salt key - unlimited characters
"old"-style: setting - 2 chars of salt key - up to 8 characters
"os.name" and "os.version"
"re" can prefix a verb.
"remove" what was added.
"require implements" is only allowed on traits.
"return nil" is only permitted in a failable initializer.
"self" is always the first parameter list.
"set" could have a name associated with it.
"this" is automatically included.
"throws" or "rethrows" isn't a valid type without being followed by a return.
"try" cannot actually start any statements, but we parse it there for better recovery.
# of codes output (for debugging)
# of color components per pixel
# of hist cells in update box
# of locations in the LocationVault.
# payload cases in the low 24 bits, payload size offset in the high 8.
#Elements may be zero.
#available query: introduce a new refinement context for the statement condition elements following it.
#define Bad_float_h if your system lacks a float.h or if it does not define some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP, FLT_RADIX, FLT_ROUNDS, and DBL_MAX.
#define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.
#define DEBUGGING_ENVARS
#define DEBUG_MAIN_NETWORK 1
#define GD2_DBG(s) (s)
#define GD_SS_DBG(s) (s)
#define IBM for IBM mainframe-style floating-point arithmetic.
#define IEEE_BIG_ENDIAN for IEEE-arithmetic machines where the most significant byte has the lowest address.
#define IEEE_LITTLE_ENDIAN for IEEE-arithmetic machines where the least significant byte has the lowest address.
#define IM_MEMORY_CHECK
#define IO_DBG(s) (s)
#define Inaccurate_Divide for IEEE-format with correctly rounded products but inaccurate quotients, e.g., for Intel i860.
#define Just_16 to store 16 bits per 32-bit Long when doing high-precision integer arithmetic.
#define KR_headers for old-style C function headers.
#define Long int on machines with 32-bit ints and 64-bit longs.
#define MALLOC your_malloc, where your_malloc(n) acts like malloc(n) if memory is available and otherwise does something you deem appropriate.
#define No_leftright to omit left-right logic in fast floating-point computation of dtoa.
#define P DBL_MANT_DIG
#define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines that use extended-precision instructions to compute rounded products and quotients) with IBM.
#define ROUND_BIASED for IEEE-format with biased rounding.
#define Sudden_Underflow for IEEE-format machines without gradual underflow (i.e., that flush to zero on underflow).
#define VAX for VAX-style floating-point arithmetic.
#file, #line, #column, #function, #dsohandle.
#ifdef COMPILE_DL_MONGO
#include "hphp/runtime/base/typed-value.h" #include "hphp/runtime/base/struct-array.h"
#line at the start of a line is a directive, when within, it is an expr.
#line at the start of the line is a directive, but it's deprecated.
#line within a line is an expression.
#selector is only available when the Objective-C runtime is.
#selector only makes sense when we have the Objective-C runtime.
#sourceLocation() #sourceLocation(file: "foo", line: 42)
'--' indicates end of args if not followed by a known long option name
'--cc-args' separates swift-ide-test options from clang arguments.
'-code-completion' options.
'-syntax-coloring' options.
'.' cannot appear in the middle of an operator unless the operator started with a '.'.
'Fix' a tuple or tuple element structure kind to be a function parameter / or function type if we are currently inside a function type.
'Indices' is a paren or tuple pattern, / specifying the index list for a subscript.
'Self' can appear in types, skip it.
'Self' in protocol extensions is not dynamic 'Self'.
'Self' is only a dynamic self on class methods.
'T(x...)' is treated as a NominalTypePattern if 'T' references a type by name, or an EnumElementPattern if 'T' references an enum element.
'T.self as P.Protocol' can only succeed if T is exactly the type P, so is a concrete cast, whereas 'T.self as P.Type' succeeds for types conforming to the protocol P, and is an existential cast.
'V' type is a series with values only, while all other types are series with keys and values
'_' and / variable patterns are wildcards.
'_' cannot be a type, so it must be a parameter name.
'address' is exclusive with 'get', and 'mutableAddress' is exclusive with 'set'.
'as' and 'is' casts have fixed precedence.
'break' and 'continue' are valid only in scopes / where this is greater than one.
'break' with no label looks through non-loop structures except 'switch'.
'case' and 'default' are only valid at the top level of a switch.
'case' is terminated with a colon and so allows a trailing closure.
'catch' is terminated with a brace and so cannot.
'class' is a modifier on func, but is also a top-level decl.
'continue' with no label ignores non-loop structures.
'cur' is the method we're currently looking at.
'exit' has the same effect as crashing but without the crash log.
'fallthrough' is valid only in scopes where / this is greater than one.
'final' only makes sense in the context of a class declaration or a protocol extension.
'force_flush' is what they call a "soft flush" and it stops at the byte boundary of the compressed buffer.
'guard' statements fall through if all of the guard conditions are true, so we refine the range after the require until the end of the enclosing block.
'is' patterns are only similar to matches to the same type.
'let' isn't valid inside an implicitly immutable context, but var is.
'let' parameters are never settable.
'method' is the most final method in the hierarchy which we haven't yet found a compatible override for.
'rethrows' functions are a subtype of ordinary 'throws' functions.
'rethrows' is only allowed on function declarations for now.
'rethrows' only applies to functions that take throwing functions as parameters.
'self' is 'let' for reference types (i.e., classes) or when 'self' is neither inout.
'self' may need to be taken during an 'init' delegation.
'self' or 'super' will reference an instance, but the constructor is semantically a member of the metatype.
'set' and 'willSet' can have an optional name.
'set' and 'willSet' have a (value) parameter, 'didSet' takes an (oldValue) parameter and 'get' and always takes a () parameter.
'sh' if -CIA- or -CH, but not SCH, except SCHW.
'sh' in -TIA- or -TIO- else 'th' before H else T
'start' and 'length' can be arrays (in which case we step through them in sync with stepping through 'str'), or not arrays, in which case we convert them to ints and always use those.
'super.' must be followed by a member or initializer ref.
'swifterror' fixes this physically, but there's still a risk of miscompiles because the LLVM optimizer may forward arguments positionally without considering 'swifterror'.
'throw' is probably a typo for 'throws', but in local contexts we could just be at the end of a statement, so we need to check for the arrow.
'try' is not a valid way to start a decl, but we special-case 'try let' and 'try var' for better recovery.
'var' and 'let' patterns shouldn't nest.
'void' can only be imported as a function result type.
'zperiod' (the z is silent)
( -- not really an operator, but treated as one in some cases.
("final" would be inappropriate because the property can still be overridden.)
("rule_foo" functions)  Each transformation on the RC flowgraph has a shape of the graph it matches against, set of preconditions, and a "reprocess" point if it makes a transformation.
(*) Auto -- The default.
(*) ForScan -- Similar to Auto, but this type should not be marked as "pointer followable" (see below) if this is the only indexed type for the type.
(*) `t1' could also be defined by an instruction doing a load from that location, but it's even more obviously ok in that situation.
(*m_cactive) consistency is achieved via atomic operations.
(-1) catches illegal zero case as unsigned underflows to positive large.
(2) readSILFunction forces module scope.
(A Sig node may be a predecessor of the same Phi more than once.)
(Adapted from an algorithm from the comp.graphics.algorithms FAQ.)
(Admittedly these are the same as Swift's right now.)
(All of the base, direct target, and GOT entry need to be pointer-aligned for this to be OK.)
(Almost) all instructions that take a Local have its index at their first immediate.
(Also published in Collected Algorithms from CACM, algorithm number 199).
(Also, getRemainingTime does use this opportunistically, but it's best effort.)
(An ObjC class type wouldn't be const-qualified.)
(An extern alias would be an extern global.)
(And because everywhere you need a CallContext you also need that caller Context.)
(And note that for psuedomains we may in fact have to guard on the local type after this.)
(Any other possible resolutions were known to fatal, or it was actually unique.)
(As the array type table itself is not associated with any unit.)
(At present, that depth is limited to 2).
(Because of the LdLocPseudoMain stuff.)
(Breakpoints can still get hit if control reaches this site during a call that is part of this site because the flags are stacked.)
(But note that ObjC might think we have a superclass even if Swift doesn't, because of SwiftObject.)
(Call this when processing an interrupt since this probably means that execution has moved away from the previous interrupt site.)
(Can't trust DBL_MAX)
(Comparable is similar enough in spirit that it would make sense to live here too when we implement its derivation.)
(Cross-references to extensions are not allowed because they cannot be uniquely named.)
(Currently only return types.)
(Currently that is none.)
(E.g. GlobalsArray doesn't copy here.)
(E.g. MM().freeSmallSize() or MM().freeBigSize().)  When small blocks are freed (case b and c), they're placed in the appropriate size-segregated freelist.
(E.g. if the base is a number.)
(E.g. it unconditionally throws, or is an abstract function body.)  In this case, we leave the return type as TBottom, to indicate the same to callers.
(E.g. two adjacent AStack ranges, multiple AFrame locals.)
(Even when the runtime does, it will likely only track a subset of the spare bits.)
(Existential erasure could complicate this if we add that as a subtyping relationship.)
(FIXME: This leads to deadlocks in /   recursive cases, though we can avoid many deadlocks because most /   valid recursive types bottom out in fixed-sized types like classes /   or pointers.)
(Features which do not break BC don't need options here and can just always be turned on.)
(For example, We don't want to introspect an 'if' expression to see if it has default arguments.) Instead, we should bind the type variable to the first element type of the tuple.
(For example, we don't make any effort to optimize them for polymorphic accesses.)
(For traits the return typehint will always throw at run time, so it's safe to use TObj/TOptObj.)
(Hack says the return type comes first, PHP7 says the "use" clause comes first.)
(Hoisted so it's not allocated in the loop.)
(I would drop all the way down to write() but then I'd have to write the code again for Windows.)
(I.e. it has no predecessors other than `pred', and no successors other than `last'.)  This means middle can't be a Sig unless one of it's next or taken pointers is nullptr.
(I.e. it'll be the canonical() tmp, or the first LdCtx we saw.)
(I.e. this is a distributive FooInt opcode.)
(If a property type ever grows, the interpreter could infer something incorrect at some step.)
(If it did, we'd be calling that private method, which currently we don't ever resolve---we've removed it from the method table in the classInfo.)
(If it were specialized we'd be in the unionArr path, which handles trying to keep as much data as we can.)
(If the block special device really has zero length, the fact that it is empty will be detected and reported correctly when we read the file.)
(If the equivalence class of an element has already been merged with a previous one, skip it.)
(If they are delivered while blocked, the behavior is undefined per POSIX -- usually the kernel just zaps the process without giving it a chance to print a helpful message or anything.)
(If we happen to release the write lease after they jump but before they get into REQ_RETRANSLATE, they'll acquire it and generate a translation possibly for this same situation.)
(In particular early passes like optimizeExits that are looking for specific vasm sequences inside of a block.)
(In practice they should all be past---we don't currently ever remove below the top for actual stack elements.)
(In principle, this can be done in the callback storage if we need to.)
(In that case, we'll post a diagnostic while visiting the parent enum.)
(It can't be a local since Config::Bind will take and store a pointer to it.)
(It can't right now.)
(It doesn't really matter, since the enum can't be instantiated regardless.)
(It may have been set to `last'.
(It might have paused itself if it read a "break" command)
(It will call a C++ helper and we can push/pop around it normally.)
(It'd be nice if QString had a fromAsciiStrict or something that would throw an exception if the argument was outside ASCII.)
(It's a hacky closure)
(It's safe for other threads to concurrently read the class list without the lock.)
(Just going un-asserted for now.)
(Just saves a charset lookup.)
(Later we'll determine the real liveOut sets.)
(Leave a hole for test cases.)
(Local 0 will be the closure itself, and other locals will have used vars unpacked into them.)  We rely on hhbbc to assert these types.
(Merge-only-ness provides no measurable perf win in repo mode now that we have persistent classes, so we're not too worried about this.)
(Module outputs can be specified using -module-output-path, or will be inferred if there are other top-level outputs.
(NB: these instructions will likely require a DefInlineFP in their catch blocks to ensure that the callee is visited by the unwinder).
(Normally we want to though because they can be encoded different.)
(Note that it may not be included in the region due to the EvalJitMaxRegionInstrs limit.)
(Note that the program still may modify these memory locations in blocks that are reachable from the loop header, after exiting the loop.)
(Note that this potentially includes conventions which pass indirectly without transferring ownership, like Itanium C++.)
(Note that this special case generator relies on the exact implementation of the main appendReserved routine.)
(Note that we are not including extensions here -- default derivation doesn't apply in extensions.)
(Note that we do /not/ set the `hint' field at phi defs, nor do we try to use it at any point.)
(Note that we do not measure the total cost of all the inlined calls for a given caller---just the cost of each nested stack.)
(Note that we're emitting backwards, so this correctly goes before* the error pointer.)
(Note this might need to split into a different API: type aliases aren't allowed everywhere we're doing resolve_class calls.)
(Note: Zend will actually fatal if there's a user function named __lambda_func when you call create_function.
(Note: only unset can call ToMixed when we aren't about to insert.)
(Once this happens, we have to conservatively assume / that both the getter and setter could be called.)
(One conditional branch based on password length remains.
(Only that one cell MUST be filled, but
(Or also we sometimes use them just for some static_assertions relating to calls to helpers from mcg that hardcode these registers.)
(Or else ensure that we never use ElemS with an integer-like string.)
(Otherwise, in this case favoring is useless.
(Otherwise, the typeParam will be used as the `knownType'.)
(Pointer, Scalar): A pointer to a pointer can never alias a scalar.
(Quite possibly there is only one such image in existence.)
(Re)define some defines known by libjpeg
(References are not needed anymore.)
(Renumbering keys is not done by this routine currently.)
(SCHW is handled in S) S if -CI-, -CE- or -CY- dropped if -SCI-, SCE-, -SCY- (handed in S) else K
(SILGen should know how to peephole this.)
(Scalar, Scalar): If we have two scalar pointers, since we know that the types are already not equal, we know that they cannot alias.
(See below for more details).
(See killBeforePEI below.)  Final note about types:  Global DCE can change the types of locals in a way that spans basic blocks.
(Setting up module output will be handled below.)
(So in this case we'll skip the fcallKnownImpl stuff.)
(Some of them currently regress performance, presumably because the IR doesn't always handle the additional type information very well.
(Such as a chain of binary operator invocations.)
(Switching or masking will also require a cast to integer.)
(Technically debug information will be wrong if we stop under one of those cases.)  Note: if rVmSp is ever changed to refer to rsp, this code needs to change.
(The -1 value of zend.assertions corresponds to AssertEmitted being set to 0 above, and is not changeable at runtime.)
(The RPO ids are re-assigned per analysis.)
(The algorithm doesn't need this for correctness, but it might make it iterate less.)  Every block must be visited at least once, so we throw them all in to start.
(The assembler only emits a single unit, so it can't really be involved in creating a ArrayTypeTable.)
(The bound type and the collection type, which will always be the same in this case.) This will avoid exponential typecheck behavior in the case of nested array and dictionary literals.
(The choice of 16 is arbitrary, but let's stick to it now.
(The cleanups still happen, as they are threaded through here messily, but the explicit retains here counteract them, and then the retain/release pair gets optimized out.)
(The first condition is just a fast path.)
(The region selectors break a region whenever they hit a SrcKey that has already been optimized.)
(The second Offset is basically to the actual jump/switch/etc instruction, while the first points to the immediate.)
(The type might still not have a statically-known layout.
(They're only created in hhbbc.)
(This also covers other properties with that same name.) FIXME: We should still mirror the setter as a method if it's not already there.
(This assumes that the word doesn't end with a prefix of itself, e.g. "LikeableLike".)
(This can happen if a user declares a class with a getWaitHandle method that returns non-WaitHandle garbage.)
(This comment is repeated there.)
(This includes locals that were live going out of this block.)  This set is used by global DCE to remove locals that are completely unused in the entire function.
(This is a marker that the type is never actually req-heap allocated).
(This is also a restriction in PHP7 for similar reasons.)
(This is fixed in gcc 4.8.5.)
(This is largely to prevent certain holidays from occurring on the day before or after the Sabbath.)  2.
(This is used in test.mk when building/running tests.)
(This means all offsets in the FPI region will have the partial ActRec on the stack.)
(This only applies to function analysis information right now.)  Repeat until the work list is empty.
(This push doesn't actually get the value into memory---we're going to put it in the return value for AsyncRetCtrl and let enterTCHelper store it to memory.)
(This will get triggered when the epilog logic is simplified.)
(This will happen for side-exits from method regions, for example.)
(This will probably kill most of the type-checking, but maybe not.)
(U_BUFFER_OVERFLOW_ERROR means that *target buffer is not large enough).
(U_STRING_NOT_TERMINATED_WARNING usually means that the input string is empty).
(Unchecked) each stack offset in the type prediction list is valid.
(Variadic arguments also end up here, which is correct for our purposes.)
(We also use it to resolve phis.)
(We aren't in a situation where we can do a normal VMRegAnchor fixup right now.)  But moreover we shouldn't be running destructors if a fatal is happening anyway, so we don't want that either.
(We could get a more accurate k by invoking log10, but this is probably not worthwhile.)
(We could try to rule it out by figuring out if one must be defined based on the ctx.unit, but it's unlikely to matter for now.)
(We don't want to do this if the index expression is a literal type that differs from the return type of the subscript operation.)
(We have to skip discardStackTemps in this case because it will look for FPI regions and assume the stack offsets correspond to what the FPI table expects.)
(We might eventually check whether objects are final as part of this, but not right now.)
(We need a type for it.)
(We need to allow for cases like (Int, Int32).)
(We prevent its value from changing at runtime between values that would affect byecode emission.)
(We returned early if something didn't exist.)
(We should actually try to resolve that method, though.)
(We will probably either change it to be per-RCState later or fix the alias handling.)
(We'll unbox the value that gets passed to the magic setter, though, since __set functions can't take parameters by reference.)
(We've already stripped one layer of parentheses.)
(When we don't have an spOff, the caller of the service request was responsible for making sure rvmsp already contained the top of the stack.)
(With the exception of the last token which does not have the separator.)
(and we always use MixedArray)
(apply (thin_to_thick_function f)) to (apply f)
(buffer, optionalCallback)
(but *not* T.type) - constructor calls T()
(charset is not null, see assertion above)
(has a number of static buffers that are rotated).
(iOS only) No arguments.
(iOS/watchOS only) Two arguments, the second of which is a UIEvent.
(implying its okay to clobber TypedValue.m_aux)
(its also a bug because it shouldn't generate such warnings in its own headers).
(materializeForSet has to do this, for one.)  The onus is on the caller to ensure that formal access semantics are honored.
(noreturn isn't really reified at runtime though.)
(overwrite previously computed value if there is one)
(qigao) not calling stat at this point because the timestamp of local cache file is not valuable, maybe misleading.
(re)bind the parameters
(size + 1 because the size-th character might be the beginning of a grapheme cluster)
(try_apply (thin_to_thick_function f)) to (try_apply f)
(value)  or (value, indices)
* 4 is for octal representation, + 1 is for NUL
* An erroneous import-as-member will cause an extra iteration at the end, so that the loop can detect that nothing changed and return a failure.
* Import-as-member places an entity inside of an another entity that comes later in the translation unit.
* The object literal has no contextual type
* are a conditional branch that has an incoming edge that is dominated by DominatingSuccBB.
**  Please change html_tables/generate-html-table.py instead and then     ** run it in order to generate this file                                 **
********************************************************************* InitDynamic - Return a dynamically resizable void*
************************************************************************** DANGER
***************************************************************************** constructor
***************************************************************************** node addon required function
***************************************************************************** wraps gaining access to a given mutex
*NOTE* Associated types of self are not valid here.
*NOTE* In practice, wtable will be deserializedTable, but I do not want to rely on that behavior for now.
*NOTE* No instruction destruction can happen here since we may remove instructions that are insertion points for other instructions.
*NOTE* This ignores obvious ARC escapes where the a potential / user of the RC is not managed by ARC.
*NOTE* This means that unreachable predecessors will not have any BBState associated with them.
*NOTE* This means that we will process ChildNode multiple times potentially with different projection users.
*NOTE* We can only strip things here if we know that there is no semantic change in terms of upcasts/downcasts/enum extraction since this is used by other routines here.
*NOTE* We do not run this check when we have a generic type since generic types do not have type lowering and are always treated as non-trivial since we do not know the type.
*NOTE* We don't need to check types here.
*NOTE* we are ok with both being shared since we do not have a shared_external linkage.
*NOTE*: Apply instruction substitutions are for the Member from a protocol or class B, where this member was first defined, before it got overridden by derived classes.
*Now* apply the substitutions and get the type info for the instance's payload type, since we know this case carries an apparent payload in the generic case.
*Release/*Retain/*Autorelease
*_SECONDARY is a higher constant value than *_PRIMARY, so we sort descendingly by connection_type
*_SECONDARY is a higher constant value than *_PRIMARY.
*pbuf is a malloc()ed buf, but we need it emalloc()ed, *sigh*
+ 2 more bytes, 20-bit unsigned int  All of these represent an int64 value.
+1 or -1 depending on direction
+2 removes the "f_" prefix
, __out LPWSTR *ppwzErrorMessage
, llvm::Linker::DestroySource
, llvm::Linker::LinkerMode LinkerMode
- "Pointer followable".
- Analyze each instruction in the block, determining what state the spill space must be in before executing it.
- Auto-identify keys to functions which could be used to place things in APC - i.e., same per-request, but not cross-request unless, say, locale is considered.
- Avoid relying on the AST being type-checked or even well-formed during traversal.
- Both Func* and Class* must fit in 32-bit value (i.e. be low-malloced).
- Check if the faultOffset that raised the exception is inside a protected region, if so, if it can handle the Fault resume the VM at the handler.
- Check if we are handling user exception in an eagerly executed async function.
- Check that each block handling a given case tag of a switch_enum only produces an integer value and does not have any side-effects.
- Check that each one stems directly or indirectly from the same switch_enum instruction.
- Copyright (c) 2008 Christos Zoulas All rights reserved.
- Could the base be something (regardless of type) that is inside one of the things we're tracking.
- Discard all evaluation stack temporaries (including pre-live activation records).
- Each fault funclet is a contiguous region of bytecode that does not jump into other fault funclets or into the primary function body.
- Each fault or catch entry point begins a block.
- Each funclet must have all of its blocks contiguous, with the entry block first.
- Every node should be walked.
- Explicitly-written nodes should be walked in left-to-right syntactic order.
- Failing any of the above, pop the frame for the current function.
- Filter weight contribution results, after summing, are rounded to the nearest pixel color value instead of being casted to ILubyte (usually an int or char).
- Finally, the exit hook for the returning function can throw, but this happens last so everything is destructed.
- For each direct subclass, a dedicated checked_cast_br instruction is generated to check if a dynamic class of the instance is exactly this subclass.
- For each hoist group, perform the actual hoisting to the highest instruction with an exit that still dominates the rest of the hoist group.
- HAS_COPY_DISPOSE unless the capture type is POD
- HAS_STRET, if the invoke function is sret
- If all preds provide an equivalent value, insert a copy of the instruction defining that value after the DefLabel, replacing the phi.
- If an alias name can refer to more than one class, each of those classes must be marked redeclaring.
- If none of the src pixels within a sampling region differ, then the output pixel is forced to equal (any of) the source pixel.
- If the destructor for any of these things throws a fatal, it's swallowed, and we set surprise flags to throw a fatal from now on.
- If the preds provide only one unique value other than the dest of the phi itself, replace the phi with a Mov of that unique value.
- If the second case happened and we have to run another destructor, its enter hook will throw, but it will be swallowed again.
- If this check fails, then a different subclass is checked by means of checked_cast_br in a similar way.
- If this check succeeds, then it jumps to the code which performs a direct call of a method implementation specific to this subclass.
- In case of PHP_DNS_ANY we use the directly fetch DNS_T_ANY.
- Iterate over each typecheck that we decided would make sense to hoist.
- Last solution: average the colors
- Main entry point must be the first block.
- NeedSpill out: If the block has no in-unit successors, free spill space before the block-end instruction.
- NoSpill out: Allocate spill space on any edges to successors with NeedSpill in-states.
- Nodes should only be walked once.
- Nothing comes after the fault funclets.
- One SSATmp src, which must be either a constant or the globally-available FramePtr/StkPtr.
- Only a single increment by a literal.
- PHP5 semantics for such operations are machine-dependent.
- PHP7 defines negative shifts to throw an ArithmeticError.
- Passing a structural type should remove the need to pass its components separately.
- Pending and Processed are used while building phis to handle cycles of phis.
- Pop the frame for the current function.
- Record out-state for the block and propagate to successors.
- Remember for each case tag of the switch_enum instruction which integer value it produces.
- Sub-expressions and sub-statements should be replaceable.
- The SIL diagnostic in the first function will be gone.
- The argument might be unnamed, in which case we try to fix the problem by adding the name.
- The buffer parameter, (buffer: Builtin.RawPointer, inout storage: Builtin.UnsafeValueBuffer, indices...).
- The call must not be magic or static.
- The implicit 'self' argument if in a type context.
- The instruction immediately after the end of any fault-protected region begins a block.
- The keyword argument might be a typo for an actual argument name, in which case we should find the closest match to correct to.
- The start of each fault-protected region begins a block.
- Therefore either the weak retain must happen-before this function, or this function cannot see a weak reference count of 1, or there is a race.
- This does not make use of Archetypes since it is directly substituting in place of GenericTypeParams.
- This function logically decrements the weak reference count.
- This is the first point at which diagnostics must be emitted for bad conformances.
- We emulate an or'ed type mask by querying type by type.
- We must be in RepoAuthoritative mode.
- When that happens, exit hook sets localsDecRefd flag.
- Whitespace is not normally significant, but newlines may not be in the middle of a list of opcode arguments.
- a function to release a userdata struct when it is no longer being managed by the cache  In the event of a cache miss the cache is allowed to grow up to a specified maximum size.
- block, which match the Apple blocks extension: a ref-counted pointer to a mostly-opaque structure with the function pointer stored at a fixed offset.
- consumes reference of the given Exception object
- consumes reference of the given Exception object - produces reference for the returned StaticWaitHandle object
- consumes reference of the given cell - produces reference for the returned StaticWaitHandle object  Both the JIT and bytecode.cpp assume this function gives the nothrow guarantee.
- days after 21st March
- existential metatype to AnyObject conversion
- if there are no connections, simply return false
- metatype to AnyObject conversion
- metatype to Protocol conversion
- the callee in 'T(...)' is a struct or class type.
- the field offset vector (fieldOffsets)
- the immediate goal is to capture the module API, but we would like to be able to extend this format to carry ABI information in future.
- the rest of the arguments
- the second one is the new apply site.
- the substituted type
- then convert _ObjectiveCBridgeable._ObjectiveCType to a Swift type using _forceBridgeFromObjectiveC.
- true: documented value for success - null: undocumented default successful value - false: documented value for failure
- tuples of transformable values
- unfulfilled requirements
- upcasts from an archetype
-- "Trivial" incdec removal pass -- This module also contains a local optimization that removes IncRef/DecRefNZ pairs in a block that have no non-"pure" memory-accessing instructions in between them.
-- Allocate memory for our phoned_phrase --
-- Build the decoded string as UTF32 first because we need random access.
-- Effects of Pure Stores on Memory Support -- There are two main kinds of stores from the perspective of this module.
-- Memory Support -- This section is going to introduce the "memory support" concept, but details will be fleshed out further in following sections.
-- More about Memory -- Another consideration about memory in this module arises from the fact that our analysis passes make no attempt to track which object pointers may be escaped.
-- Must/May Alias Sets -- The passes in this file operate on groups of SSATmp's called "must-alias-set"s (or often "asets" in the code).
-- Overview -- This file contains passes that attempt to reduce the number and strength of reference counting operations in an IR program.
-- Parameter checks --
-- RC "lower bounds" -- A lower bound on the reference count of a must-alias-set indicates a known minimum for the value of its object's count field at that program point.
-- The first phoneme has to be processed specially.
-- The list of immediate predecessors that this block is control-dependent on along with the level number in the post-dominator tree of each of those predecessors.
-- The lowest level number of any predecessor below the given node in the post-dominator tree.
-- Weakening DecRefs -- This file contains a relatively cheap pass that can weaken DecRefs into DecRefNZ by proving that they can't go to zero (unless there is already a bug in the program).
--- Private functions.
--- Refutable patterns.
-1 is invalid (not-Counted tmps)
-1 stand for default case.
-Ounchecked might also set removal of runtime asserts (cond_fail).
-ve means no antialias
...and it has no scalar value, bail.
...and the predecessor instruction is a release_value on the same value as our retain_value...
...and the predecessor instruction is a strong_release on the same value as our strong_retain...
...as in ClassConstant statement We are handling this one here, not in ClassConstant, purely because we need "value" to store in constant table.
...but Clang isn't doing the emission.
...but only until the next sleeper (from any context) finishes.
...but remember to ignore it when we need the actual size.
...but we don't actually expose individual value witnesses (right now).
...but we shouldnt apply ref() to it unless the corresponding arg is refable
...in extensions that don't override other declarations.
...non-type-checked types should only ever show up here because of test cases using -enable-source-import, but unfortunately that's a real thing.
...or it was synthesized into an imported type.
...or to a representative dependent type that was in turn equated to a concrete type.
...other combinations are possible, but as long as AST lookups precede SIL linkage, we should be ok.
...so to strictly follow PHP's output
...so we don't mess up next array output
...then back to the requirement type using the abstraction pattern of the requirement..
...unless we're supposed to replace it with ().
...which may allow us to go on and do later tasks.
./ (safe to drop iff there is something before or after it)
.Some Single payload enums are guaranteed layout compatible with their payload.
/     (inouts are also nonaliased, but won't be destroyed in scope) / / (2) A local alloc_stack variable.
/     * Contains offsets into CHUNKS and STRINGS.
/     * Each CodeCompletionString is a length-prefixed array of fixed size /       CodeCompletionString::Chunks.
/    TODO: This is a terrible hack, but necessary because we need constant /    size and alignment for the final stack promotion decision.
/    The solution to this problem is that we need native support for tail- /    allocated arrays in SIL so that we can do the array buffer allocations /    with alloc_ref instructions.
/    Those calls are lowered by the LLVM SwiftStackPromotion pass.
/   * any retain must be matched by a release before we hit a make_unique.
/   - '_' may only exist on the LHS of an assignment expression.
/   - 'self.init' and 'super.init' cannot be wrapped in a larger expression /     or statement.
/   - Metatype names cannot generally be used as values: they need a "T.self" /     qualification unless used in narrow case (e.g. T() for construction).
/   - Partial application of some decls isn't allowed due to implementation /     limitations.
/   - warn_unqualified_access values must not be accessed except via qualified /     lookup.
/   TODO: this is not yet implemented.
/  / If a retain is sunk from Region A to Region B, that means there is no / blocking operation between where the retain was in Region A to where it is / sunk to in Region B.
/  / TODO: Move this to Utils.
/  2) implode the corresponding values in the RValue to a scalar value of /     tuple type and process them as a unit.
/ (actively matched values) and enough initial capacity for the / given number of rows.
/ * It has a preheader (the function will try to create one for critical edges /   from cond_br).
/ * retains must be matched by a release before hitting a mutating operation / * stores must not store an array value (only trivial stores are safe).
/ - If the type is dynamic-layout, we have to instantiate its metadata /   and project out its metadata.
/ - If the type is fixed layout, we can emit our own copy of the layout /   struct.
/ - actual return type and expected return type differ in optionality.
/ - both types are tuple-types and some of the elements need to be casted.
/ /   - Module values may only occur as part of qualification.
/ /   CHUNKS /     * A length-prefixed array of CodeCompletionStrings.
/ /   RESULTS /     * A length-prefixed array of fixed size CodeCompletionResults.
/ /   STRINGS /     * A blob of length-prefixed strings referred to in CHUNKS or RESULTS.
/ /  availability-spec: /     '*' /     version-constraint-spec
/ /  version-constraint-spec: /     identifier version-comparison version-tuple
/ / "Specialized" is essentially a form of subtyping, defined below.
/ / 'Safe' array operations are: /   * all array semantic functions /   * stores to array elements /   * any instruction that does not have side effects.
/ / (1) An "out" or inout argument.
/ / (2) A local alloc_stack variable.
/ / (2) A local variable, which may be copied from a by-val argument, / initialized directly, or copied from a function return value.
/ / * Array._adoptStorage(storage:count:) /   The stores on the returned array element buffer pointer.
/ / * It has an exiting header with a conditional branch.
/ / *NOTE* This counter is incremented *after* we return from visiting a call / site's children.
/ / *NOTE* This occurs in the same module as F.
/ / *NOTE* We do not touch the successors/predecessors of the current loop.
/ / *NOTE* We have to be careful here since exiting blocks may include BBs / that have been subsumed into a subloop already.
/ / - Convert trivial initializers to static initialization.
/ / - For global "lets", generate addressors that return by value.
/ / - In a protocol extension, the callback doesn't know how to capture /   or reconstruct the generic conformance information.
/ / - When the addressor is local to the module, be sure it is inlined to allow /   constant propagation in case of statically initialized "lets".
/ / A load can be eliminated if its value has already been held somewhere, / i.e. generated by a previous load, LSLocation stored by a known value.
/ / A scope is either a loop or the whole function.
/ / A store is dead if after the store has occurred: / / 1.
/ / After the live parts of the store are determined, they are merged into the / minimum number of stores possible using the reduce function.
/ / After the lower aggregates pass, SIL contains chains of struct_extract and / retain_value instructions.
/ / AggregateAddressUsers records uses of the aggregate value's address.
/ / Also inout formal access and parameter and result conventions are / handled here, with some special logic required for calls with +0 self.
/ / An epilogue release is a release that post dominates all other uses of a / pointer in a function that implies that the pointer is alive up to that / point.
/ / Another way to implement the DSE optimization is to keep the instructions / that read and/or write memory without breaking the memory read/written / using the ProjectionPath.
/ / ArgValues are the values feeding the specified Argument from each / predecessor.
/ / Array literal construction and array initialization of array values / associates a count with the array value.
/ / Array literal construction and array initialization of array values / associates element values with the array value.
/ / Array.append for example can capture another array value.
/ / Arrays are identified by their 'underlying' pointer to the array structure / which must either be an alloc_stack or a function argument.
/ / At the core of DSE, there is the LSLocation class.
/ / At the core of RLE, there is the LSLocation class.
/ / At this parsing has been performed, but we still have UnresolvedDeclRefExpr / nodes for unresolved value names, and we may have unresolved type names as / well.
/ / BBWriteSetMid is initialized to BBWriteSetOut of the current basic block / before instructions in the basic block is processed.
/ / Because size modifying instructions would create a copy of the storage this / is sufficient for the purpose of eliminating potential aliasing.
/ / Because these are builtin operations, we can make some structural / assumptions about the expression used to call them.
/ / Bodies of alive functions should not be removed, as LLVM may / still need them for analyzing their side-effects.
/ / BuildGenKillSet - Build the genset and killset of the basic block.
/ / Cache all blocks visited to avoid introducing quadratic behavior.
/ / Coming into this function, we assume that the code is in canonical form: / none of these calls have any uses of their return values.
/ / ComputeAvailGenKillSet - Build the genset and killset of the basic block.
/ / ComputeAvailValue - Compute the available value at the end of the basic / block.
/ / Consider any potentially mutating operation unsafe.
/ / Create a new block as a common target for all the current loop backedges.
/ / Create a single preheader and single latch block.
/ / Creates a private, unnamed constant containing the address of another / global variable.
/ / Creating an instance of this object will cause it to figure out / whether we are in the debugger function, whether it needs to swap  / the Decl that is currently being parsed.
/ / Currently only one property is handled and that's the isNativeTypeChecked / property for arrays.
/ / Currently this can only happen given a non-local edge in which case we / want the non-local edge to point at its parent's successor edge.
/ / Currently this only implements typed access based TBAA.
/ / Currently, we recursively look at all array value uses and if any use could / escape or change the array value we give up.
/ / Dead store elimination (DSE) eliminates such stores by: / / 1.
/ / Do not form a path with an IndexAddrInst because we have no way to / distinguish between indexing and subelement access.
/ / Don't do lookup into superclasses or implemented protocols.
/ / Essentially equivalent to forwardIntoIrrefutableSubtree, except it / converts AlwaysTake to TakeOnSuccess.
/ / Essentially equivalent to forwardIntoSubtree, except it preserves / AlwaysTake consumption.
/ / Every basic block keeps a map between LSLocation and LSValue.
/ / Existential types are nominal, so we potentially need to cast the / function to the appropriate object-pointer type.
/ / FIXME: Once Self has been removed in favor of opened existential types / everywhere, remove support for self.
/ / FIXME: Rework to use GenericSignature instead of AllArchetypes / FIXME: Rework for nested generics
/ / FIXME: SILGen doesn't currently allow local generic functions to / capture generic parameters from an outer context.
/ / FIXME: The latter reason is a hack.
/ / FIXME: This is only necessary due to our broken model for factory / initializers.
/ / FIXME: This whole thing is a hack, because name lookup should really / just find these members when it looks in the protocol.
/ / FIXME: We should identify nested loops with a common header and separate / them before merging the latch.
/ / FIXME: pointer_to_address should contain a flag that indicates whether the / address is aliasing.
/ / FIXME: this is an elaborate hack to badly reflect Clang's / submodule visibility into Swift.
/ / FIXME: we shouldn't just drop the original abstraction pattern / when we can't reabstract.
/ / For Swift protocols, this is a constant reference to the protocol descriptor / symbol.
/ / For example, a method reference 'self.method' decomposes into curry thunk / as the callee, with a single call site '(self)'.
/ / For example, given "NSFooBar" and "NSFooBas", returns "NSFoo" / (not "NSFooBa").
/ / For example, given "NSProperty" and "NSProperties", the full "NSProperty" / is returned.
/ / For example, given an explosion which begins with the / representation of an (Int, Float), consume that and produce the / representation of an (Int, T).
/ / For most types, the most general type is simply a fresh, / unrestricted type variable.
/ / For now, it is performed only for specializations in the / standard library.
/ / For now, it performs a lookup only in the standard library.
/ / For the first element in the enum, the raw value is 0.
/ / For the most part, this only distinguishes between Throws and / RethrowingOnly.
/ / Formally, an ApplyExpr in the AST always has a single argument, which may / be of tuple type, possibly empty.
/ / Furthermore, if the target type is a metatype, the source type must be / a metatype.
/ / General calls are unsafe because they may copy the array struct which in / turn bumps the reference count of the array storage.
/ / Generally, whether the parameter is +1 is handled before this.
/ / Given the case which the 2 fields of the struct both have available values, / RLE can find their LSValues (maybe by struct_extract from a larger / value) and then aggregate them.
/ / However, SIL functions take zero or more parameters and the natural entry / point of a method takes Self as an additional argument, rather than / returning a partial application.
/ / However, this may introduce a lot of extraction and aggregation which may / not be necessary.
/ / However, we actually can't reabstract arbitrary thin function / values while still leaving them thin, at least without costly / page-mapping tricks.
/ / If 'layout' is null, there is a single captured value of / Swift-refcountable type that is being used directly as the / context object.
/ / If Arg is replaced, return the cast instruction.
/ / If CheckOnly flag is set, then this function only checks if the / required casting is possible.
/ / If CheckOnly is not set, then a casting code is generated and the final / casted value is returned.
/ / If ObjC class is not exactly _ObjectiveCType, then / its conversion to a required _ObjectiveCType may fail.
/ / If a definition type is given, the result will always be an / llvm::GlobalVariable of that type.
/ / If a full type is being printed, use print() instead.
/ / If anything was found it will be added to DecToIncStateMap.
/ / If cacheVariable is null, we perform the direct access every time.
/ / If includeInaccessibleMembers is set to true, this burns compile time to / try to identify and classify inaccessible members that may be being / referenced.
/ / If it's not an unsafe addressor, this uses a callback function to / write the l-value back.
/ / If the access requires runtime initialization, that initialization / must be dependency-ordered-before any load that carries a dependency / from the resulting metadata pointer.
/ / If the callee that we are partially applying to create a box/closure / isn't generic, then the map is empty.
/ / If the condition is not true, complain about the problem and abort.
/ / If the definition type is specified, the result will always be a / GlobalValue of the given type, which may not be at the / canonical address point for a type metadata.
/ / If the initialization is non-null, the result plan will emit into it.
/ / If the input is malformed, this emits the specified error diagnostic.
/ / If the insertion point is valid (i.e., pointing to an existing / instruction) then split the block at that instruction and return the / continuation block.
/ / If the property is an override, we call the superclass setter.
/ / If the tuple is in memory, the result elements will also be in / memory.
/ / If there are more call sites than the natural uncurry level, they are / have to be applied recursively to each intermediate callee.
/ / If there are no enum elements but there are properties, attempts to map / an arbitrary property to an enum element using extractEnumElement.
/ / If this expression isn't a ClosureExpr or isn't convertible, this returns / null.
/ / If this has no parent pattern binding decl or statement associated, it / returns null.
/ / If we are unable to find all uses, for example, because we don't look / through struct_element_addr, then return false.
/ / If we found a make_mutable call this means that check_subscript was removed / by the array bounds check elimination pass.
/ / Immediately after this call, there will be an unconditional / branch to the continuation block.
/ / In SIL, one can access an aggregate as a whole, i.e. store to a struct with / 2 Int fields.
/ / In any other case, a metadata accessor should be called instead.
/ / In terms of ARC this means that if we do not remove User, all releases post / dominated by User are known safe.
/ / In the case that a non-null value is returned, FullArgs contains effective / argument operands for the callee function.
/ / In the type of the function declaration, none of the extended information / is relevant.
/ / In this case, one can replace the load instruction with the previous / results.
/ / Initially BBWriteSetIn is set to true.
/ / Initially the BBWriteSetOut is empty.
/ / Instructions in each basic block are processed in post-order as follows: / / 1.
/ / It is important that any Initialization created for a pattern that might / not have an immediate initializer implement finishUninitialized.
/ / It is not correct to use this value as a Protocol* reference directly.
/ / It is the responsibility of the caller of this function to delete / the given ApplyInst when inlining is successful.
/ / It uses an optimistic iterative data flow to compute where to insert the / retains and releases for every reference-counted root.
/ / LSValue consists of a base - a SILValue from the load or store inst, / as well as a projection path to which the field it represents.
/ / Let-value initializations cannot be broken into constituent pieces if a / scalar value needs to be bound.
/ / Mark specializations as public, so that they can be used by user / applications.
/ / NOTE: / Overall, this pass does not try to remove any information which can be / useful for LLVM code generation, e.g. for analysis of function's / side-effects.
/ / NOTE: Canonicalization does not solve the problem entirely.
/ / NOTE: The implementation of this function is very closely related to the / rules checked by SILVerifier::requireABICompatibleFunctionTypes.
/ / NOTE: This is never populated for functions which will only require 1 / data flow iteration.
/ / NOTE: This returns null if a varargs parameter exists in the list, as it / cannot be forwarded correctly yet.
/ / NOTE: this handles both objc_retain and swift_retain.
/ / NestingDetected will be set to indicate that the block needs to be / reanalyzed if code motion occurs.
/ / Note that all the instructions BEFORE the specified iterator / stay as part of the original basic block.
/ / Note that some functions don't have an implicit 'self' decl, for example, / free functions.
/ / Note that the check is whether 'metatype' is an *instance of* / 'targetType', not a *subtype of it*.
/ / Note that this decl is created, but it is returned with an incorrect / DeclContext that needs to be set correctly.
/ / Note that this intentionally loses any tuple sub-structure of the / formal result type.
/ / Note that we can have tuples down to arbitrary depths in the / type, but every branch should lead to an l-value otherwise.
/ / Note that we handle the general case of a destroy_addr of a piece of the / memory object, not just destroy_addrs of the entire thing.
/ / Note that, if the requested reference kind is a relative reference.
/ / Note, that a release in this modus (we don't have a uniquely identified / object) is not safe because the destructor of what we are releasing might / be unsafe (creating a reference).
/ / Note, this set is different from the PossiblyUnreachableBlocks as these / are the blocks that do contain user code and they might not be immediate / successors of a folded branch.
/ / Note, we rely on SILLocation information to determine if SILInstructions / correspond to user code.
/ / Note: Storage from a let property can only be removed if this / property can never be referenced from another module.
/ / Note: The code relies on the 'UpTo' basic block to stay within the rotate / loop for termination.
/ / Objective-C root class instance methods are also reflected as / class methods.
/ / Only intended for source files.
/ / Only valid for declarations that can have definitions, i.e., / functions, initializers, etc.
/ / Optimizations include: / /   - Merging together retain and release calls into retain_n, release_n /   - calls.
/ / Our goal as a result of this transformation is to: / / 1.
/ / PerformDSE - Perform the actual dead store elimination.
/ / PerformRLE - Perform the actual redundant load elimination.
/ / Performs an analysis on all Array users to ensure they do not interfere / with make_mutable hoisting.
/ / Places the new columns using the column-specialization algorithm.
/ / Populates the CallArgs with the converted arguments.
/ / Precondition: The client must make sure that it is valid to actually hoist / the call.
/ / Prints declarations with decl- and type-specific tags derived from the / UIDs used for decl/refs.
/ / Projections of the struct over its elements are all similarly recorded in / ElementAddressUsers, ElementLoads, and ElementValueUsers.
/ / Projections over the aggregate that do not access the struct are ignored.
/ / Propagation of the elements of one array allocation.
/ / Recursively walks the members and derived global decls of any nested / nominal types.
/ / Redundant Load Elimination (RLE) eliminates such loads by: / / 1.
/ / Return true if IndexVal is a constant index representable as unsigned / int.
/ / Return true if the instruction destroys the value at Address.
/ / Return true if the instruction initializes the value at Address.
/ / Returns a new instruction if optimization was possible.
/ / Returns a value of type i8*.
/ / Returns false if optimization is not possible.
/ / Returns false on error.
/ / Returns null if no module can be loaded.
/ / Returns the SILValue to store the result into if the specialized function / has a direct result.
/ / Returns true if an access can be replaced.
/ / Returns true on success.
/ / Set Oper to the Apply operand that passes Address.
/ / Set Oper to the operand that may be safely replaced by an address / pointing to an equivalent value.
/ / Set Oper to the operand that my be safely replaced by an address / pointing to an equivalent value.
/ / Similarly, the parsing of 'try' as part of expr-sequence-element / is not structural.
/ / Simple NRVO cases are handled naturally via backwardPropagateCopy.
/ / Since Swift does not natively support these features, we fake them by / importing them as declarations with generated names.
/ / Since emission notes generally change semantics, we enforce that all / notes must be claimed.
/ / Since this does not recurse through multi-operand instructions, no visited / set is necessary.
/ / Some type metadata has information before the address point that the / public symbol for the metadata references.
/ / StructLoads records loads of the struct value.
/ / Subclasses should only have to define visitScalar.
/ / TODO: / / - Analyze the module to move initializers to the module's public /   entry points.
/ / TODO: Check for other profitable constant propagation, like builtin compare.
/ / TODO: Completely eliminate make_mutable calls if all operations that the / guard are already guarded by either "init" or "mutate_unknown".
/ / TODO: Consider doing retain hoisting and release sinking.
/ / TODO: Don't occupy any storage for such let properties with constant / initializers.
/ / TODO: Handle this pattern: /   retain(array) /   call(array) /   release(array) / Whenever the call is readonly, has balanced retain/release for the array, / and does not capture the array.
/ / TODO: If this sticks around, maybe we'll make a BitMatrix ADT.
/ / TODO: In the "No" case, we can emit a fixit adding a default / initialization of the type.
/ / TODO: May not be fixed-layout if we capture generics.
/ / TODO: Move this to Utils.
/ / TODO: Replace this with a simple RPOT and use GraphUtils.
/ / TODO: Sinking retains can block releases to be hoisted, and hoisting / releases can block retains to be sunk.
/ / TODO: There are a lot of code duplications between retain and release code / motion in the data flow part.
/ / TODO: These diagnostics should be a lot better now that we know this is / all specific to closures.
/ / TODO: This needs to take a flag for the access mode of the witness table, / which may be direct, lazy, or a runtime instantiation template.
/ / TODO: Use this to remove nontrivial dead alloc_ref/alloc_stack, not just / dead arrays.
/ / TODO: We have not determined whether to support inexact type checks.
/ / The "-s", "-es", and "-ies" patterns cover every plural NS_OPTIONS name / in Cocoa and Cocoa Touch.
/ / The SILBuilder is left at the start of the ContBB block.
/ / The bitvector indicates which subelements we're interested in, and result / captures the available value (plus an indicator of which subelement of that / value is needed).
/ / The blocked jobs should be scheduled as soon as possible.
/ / The caller has already guaranteed that the lifetime of the copy's source / ends at this copy.
/ / The caller has already proven that lifetime of the value being copied ends / at the copy.
/ / The cloned literals will retain the SILLocation from the partial apply's / caller, so the cloned function will have a mix of locations from different / functions.
/ / The code relies on isIdentifiedUnderlyingArrayObject' to make sure that a / 'safe arrays' is not aliased.
/ / The collected use points will be consulted during forward and backward / copy propagation.
/ / The copy will be eliminated if the original is not accessed between the / point of copy and the original's destruction.
/ / The current heuristic hoists all initialization points within a function to / a single dominating call in the outer loop preheader.
/ / The first SILValue keeps the address of the live store and the second / SILValue keeps the value of the store.
/ / The first return value is the address, which will always be an / l-value managed value.
/ / The formal alignment of the opaque storage will be 1.
/ / The former is guaranteed to be stable, but may not reflect this version of / the AST.
/ / The function's input type is (value, metadataValue, protocol...) / The function's output type is (value, witnessTable...) / / The value is NULL if the cast failed.
/ / The goal of the most general type is to be (1) unambiguous to / compute from the substituted type and (2) the same for every / possible generalization of that type.
/ / The helper function will be shared between translation units within the / current linkage unit, so choose the name carefully to ensure that it / does not collide with any other helper function.
/ / The importer should use this rather than adding the attribute directly.
/ / The list of operations we constant fold might not be complete.
/ / The lowered function type of the callee defines an abstraction pattern / for evaluating argument values of tuple type directly into explosions of / scalars where possible.
/ / The lowering of function types is generally sensitive to the / declared abstraction pattern.
/ / The lsquare-starting and first expression have already been / parsed, and are passed in as parameters.
/ / The lsquare-starting and first key have already been parsed, and / are passed in as parameters.
/ / The main case that this handles here are builtins that via read none imply / that they cannot read globals and at the same time do not take any / non-trivial types via the arguments.
/ / The object pointer may be a tagged pointer, but cannot be null.
/ / The optimization is only done for stack promoted objects because they are / known to have no associated objects (which are not explicitly released / in the deinit method).
/ / The pattern is that subclasses should override an 'add' method / from the appropriate layout class and ensure that they call / setTargetOffset() when the appropriate location is reached.
/ / The question is whether we can introduce such operation while we hoist other / releases.
/ / The result is always a GlobalValue.
/ / The return value enables an analysis to bail early.
/ / The returned array value is known not to be aliased since it was just / allocated.
/ / The same logic currently applies to both uses of the array struct itself and / uses of an aggregate containing the array.
/ / The set of active cleanups should always be instantaneously / consistent: that is, there should always be exactly one cleanup / tracking a +1 value.
/ / The shortest path of a block is the sum of the shortest path from the scope / entry and the shortest path to the scope exit.
/ / The substitutions must carry origTy to substTy.
/ / The uncurry level specifies how far much of a curried value has already / been applied.
/ / The visitor argument is the witness type.
/ / There are some complications.
/ / Therefore, nested ApplyExprs applied to a constant are flattened into a / single call of the most uncurried entry point fitting the call site.
/ / Therefore, we only honor abstraction patterns on thick or / polymorphic functions.
/ / These restrictions are set by canUseScalarCheckedCastInstructions.
/ / This allows us to re-use the argument expression emitter for / some weird cases, like a shuffled tuple where some of the / arguments are going into a varargs array.
/ / This allows us to use an arbitrary conditional downcast to / evaluate an "is" / "as" pattern, which includes any kind of / downcast for which we don't have specialized logic.
/ / This also does some trivial peep-hole optimizations as we go.
/ / This arises in _BridgedNSError, where we wouldn't otherwise pull in / the witness table, causing dynamic casts to perform incorrectly.
/ / This behaviour improves experience for "expected token X" diagnostics.
/ / This builds the getter in a way that's compatible with switch / statements.
/ / This can return a new expression (for e.g. when a UnresolvedDeclRef gets / resolved) and returns null when the subexpression fails to typecheck.
/ / This causes two kinds of issues: / 1) Some DeclKinds require to be parsed in TopLevel contexts only.
/ / This check is supposed to use the same logic that is used / by searchInConformanceCache.
/ / This class evaluates true if an error occurred.
/ / This code is meant to enable RCIdentity to be ascertained in the following / cases: / / 1.
/ / This does not apply to addresses of elements within the array.
/ / This drives scoreCandidateTrial by trying the possible matches.
/ / This entry point is designed to be used when the witness for a / particular requirement and adoptee is required, before the / conformance has been completed checked.
/ / This entry point is only called from compiler-internal entry points, so does / only minimal validation.
/ / This function determines when and how a particular type is mapped / into a foreign language.
/ / This function first calls expand on a memory location.
/ / This function is appropriate for ordinary situations where the / construction of the metadata value just involves calling idempotent / metadata-construction functions.
/ / This function performs brace and quote matching, keeping a stack of / outstanding delimiters as it scans the string.
/ / This handles typealiases and structs provided by the standard library / for interfacing with C and Objective-C.
/ / This has a couple of tricks to make the code faster and more powerful.
/ / This helper only checks that the operands computing the array reference / are also hoistable.
/ / This is a SetVector since several blocks may lead to the same error / report and we iterate through these when producing the diagnostic.
/ / This is a bitset that conveniently flattens into a matrix allowing bit-wise / operations without masking.
/ / This is a conservative query given the information we know, so as we / perform the dataflow it may change value.
/ / This is also used to import enum case aliases.
/ / This is an awful hack that makes it possible to work around several kinds / of problems: /   - initializers currently cannot fail, so they always return non-optional.
/ / This is an intersection operation.
/ / This is done in the case of a typecheck failure, after we re-typecheck / partially-typechecked subexpressions in a context-free manner.
/ / This is following the same model of how we deal with SILFunctions in / function_ref.
/ / This is guaranteed to always emit an error message.
/ / This is interesting because in such cases, we must pessimistically assume / that we are merging in the empty set from Succ into Pred or vis-a-versa.
/ / This is necessary to handle C's awful declarator syntax.
/ / This is necessary whenever the inner type may not normally be represented / as a 'type-simple' production in the type grammar.
/ / This is only necessary because Sema fills in too much type information / before the type-checker runs, causing redundant work.
/ / This is only valid in a couple of special cases: / 1) The nominal type is generic, in which case we emit a call to the /    generic metadata accessor function, which must be defined separately.
/ / This is separate from the rest of libFrontend to reduce the dependencies / required by that library.
/ / This is to handle a case like this.
/ / This is true for array.props.isNative and false for / array.props.needsElementTypeCheck.
/ / This is used for both ProtocolTypes and ProtocolCompositionTypes.
/ / This is used for initializer delegation, so it covers only the narrow / subset of expressions used there.
/ / This is used to derive the common prefix of enum constants so we can elide / it from the Swift interface.
/ / This logic should be similar to checkSafeArrayElementUse
/ / This may also relocate the metadata object if it wasn't allocated / with enough space.
/ / This means that the two objects have the same base but access different / fields of the base object.
/ / This means that we can simply fix up those BB regions.
/ / This mention may only be used on immediate children of the current expr / node, because ClosureExpr parameters need to be treated specially.
/ / This method assumes that the caller made sure that no vtable existed in / Mod.
/ / This only applies to types whose Equatable conformance can be derived.
/ / This operation cannot fail.
/ / This operation corresponds to a standard "dot" lookup operation like "a.b" / where 'self' is the type of 'a'.
/ / This pass is more sophisticated than SILCodeMotion, as arc optimizations / can be very beneficial, use an optimistic global data flow to achieve / optimality.
/ / This pass is only enabled if SILOptions::SILOutputFileNameForDebugging is / set (i.e. if the -gsil command line option is specified).
/ / This proof also hinges on the fact that if release A interferes with / releases B then release B must interfere with release A.
/ / This relies on substitution correctly setting wasAbstract() on / MetatypeTypeRefs.
/ / This requires the getter's body to have a certain syntactic form.
/ / This returns false and sets Oper to a valid operand if the instruction is a / projection of the value at the given address.
/ / This returns false and sets Oper to nullptr for projections of the value at / the given address.
/ / This returns the alloc_stack if found, or null if not.
/ / This returns the base subexpression that looks immutable (or that can't be / analyzed any further) along with a decl extracted from it if we could.
/ / This returns true if it promotes away the shadow variable.
/ / This returns true if the load has been removed from the program.
/ / This routine assumes that the pattern is something very simple / like (x : type) or (x).
/ / This routine diagnoses a reference to an unknown type, and / attempts to fix the reference via various means.
/ / This routine handles the two-step literal conversion process used / by integer, float, character, extended grapheme cluster, and string / literals.
/ / This routine is used for 'simple' expressions that only need their / types simplified, with no further computation.
/ / This routine only examines the state of the instruction at hand.
/ / This routine promises to return a non-null result unless there was / a code-completion token in the pattern.
/ / This routine should only be used for bridging value types.
/ / This routine validates all of the types in the parsed inheritance clause, / recording the superclass (if any and if allowed) as well as the protocols / to which this type declaration conforms.
/ / This should be incremented any time we commit a change to the format of the / cached results.
/ / This should only be called on statements that have a dedicated counter.
/ / This should only return true when the entry isn't already nested / within a context.
/ / This string is suitable for display in diagnostics.
/ / This value must have a definition by the time the module is finalized.
/ / This will be its index in the list of protocol conformances on the / dependent type's substitution.
/ / This will be its index in the list of substitutions.
/ / This will print the type as bridged to Objective-C.
/ / This will properly handle nested function types (see / finishFunctionType()).
/ / To do so, we canonicalize LSLocations, i.e. traced back to the underlying / object.
/ / To do this, when the algorithm reaches the beginning of the basic block in / the loop it will need to invalidate the location in the BBWriteSetMid.
/ / To report unreachable user code, we detect the blocks that contain user / code and are not reachable (along any of the preceding paths).
/ / Top level code in the debugger is actually implicitly wrapped in / a function with a do/catch block.
/ / Using this property we can hoist the predicate above a region where no such / store can take place.
/ / Valid: InnerDirect, OuterResultAddr.
/ / Valid: InnerResult, OuterResult.
/ / Valid: InnerResultAddr, OuterResult.
/ / Valid: InnerResultAddr, OuterResultAddr.
/ / Valid: NumElements, OuterResult
/ / Valid: SomeDecl, OuterResult
/ / Valid: SomeDecl, OuterResultAddr
/ / Valid: reabstraction info, InnerAddress, OuterAddress.
/ / Valid: reabstraction info, InnerAddress, OuterResult.
/ / Valid: reabstraction info, InnerResult, OuterAddress.
/ / Valid: reabstraction info, InnerResult, OuterResult.
/ / Values should be forwarded down the decision tree with the / appropriate cleanups.
/ / We call this the "exception type" to try to avoid confusion with / the AST's ErrorType node.
/ / We can merge cond_fail instructions if there is no side-effect or memory / write in between them.
/ / We classify instructions wrt to their effect on arrays.
/ / We get the "currently active" part by passing through the DEVELOPER_DIR / environment variable (along with the rest of the environment).
/ / We have to prove that the array value is not changed in between the / creation and the method call to get_element.
/ / We have to prove that the size of the array value is not changed in between / the creation and the method call to count.
/ / We must only replace uses of this copy's value.
/ / We only use the instruction analysis here.
/ / We perform this computation by checking if V is an enum instruction without / an argument.
/ / We prefer to use approach #1 since it generates better code.
/ / We propagate the elements associated with calls of / / * Array.init(count:repeatedValue:) /   The 'repeatedValue'.
/ / We test it to catch any suspicious things in the earliest point.
/ / We test it to catch any suspicious things when memory location is / expanded, i.e. base is traced back and aggregate is expanded / properly.
/ / We use this when Clang code generation might populate the list.
/ / We will be performing an intersection in a later step of the merging.
/ / We will rotate at most up to the basic block passed as an argument.
/ / When a branch is modified existing pointers to the operand / (ValueUseIterator) become invalid as they point to freed operands.
/ / When a load or store instruction is encountered, the memory is broken down / to the indivisible components, i.e aggregates are broken down to their / individual fields using the expand function.
/ / When checking if two signatures should be equivalent for overloading, / we may need to compare the extended information.
/ / When we handle more types of casts, this can become a template.
/ / Whenever the decision tree branches, it must forward values down / correctly.
/ / entityType specifies a specific type to use for this decl/expr that may be / more resolved than the concrete type.
/ / expr-call-suffix: /   expr-paren selector-arg* /   expr-closure selector-arg* (except in expr-basic) / / selector-arg: /   identifier expr-paren
/ / expr-literal: /   '#' identifier expr-paren
/ / init_existential_addr instructions behave like memory allocation within the / allocated object.
/ / materializeForSet sometimes needs to be open-coded because of the / thin callback function, which is dependent but cannot be reabstracted.
/ / sourceType and sourceDecl will be adjusted to refer to the new / component.
/ / we could run DSE on functions with 256 basic blocks and 256 locations, / which is a large function.
/ / we could run RLE on functions with 128 basic blocks and 128 locations, / which is a large function.
/ 2) Sometimes the debugger wants a Decl to live beyond the current / function invocation, in which case it should be parsed at the / file scope level so it will be set up correctly for this purpose.
/ 2) The nominal type is a value type with a fixed size from this /    resilience domain, in which case we can reference the constant /    metadata directly.
/ A convenient macro for delegating an operation to all of the / various struct implementations.
/ A value of -1 means: not known yet.
/ A value of -2 means: not known and not visited yet.
/ All such operations return a tuple (result, overflow_flag).
/ All this is done in a single thread.
/ All this is done in multiple threads.
/ Also the a call to swift_deallocClassInstance (which stems from an inlined / deallocator) is not needed.
/ Always returns an i8*.
/ Applies heuristics that are suitable when trying to find the end of a list / of generic parameters, generic arguments, or list of types in a protocol / composition.
/ At the moment we only handle very simple induction variables that increment / by one and use equality comparison.
/ Both containers must be of the same existential type representable with no / witness tables.
/ Both containers must be of the same existential type representable with one / witness table.
/ Both containers must be of the same existential type representable with the / same number of witness tables.
/ But in the future, one could think of maintaining a cache / of optimized specializations.
/ Casts from NSArray, NSDictionary and NSSet may fail.
/ Changes the edge value between a branch and destination basic block at the / specified index.
/ Character, string, float, and integer literals are all keyed by value.
/ Class existentials can be represented directly as an aggregation / of a refcounted pointer plus witness tables instead of using an indirect / buffer.
/ Create a Substitution list mapping each nested archetype to a concrete / type, and resolve conformances for each generic parameter requirement.
/ Currently, this is true if the size and/or alignment of the type is / dependent on its generic parameters.
/ Currently, we only do partial dead store if we can form a single contiguous / non-dead store.
/ Currently: Decl, PrintStructureKind
/ DebugValueAddrInst maybe promoted to DebugValue, when this is done, / DebugValueAddrInst is effectively a read on the location.
/ Define a type 'swift::sma::TYPE_NAME' that is a "strong typedef" for / 'std::string'.
/ Defines an implicit cast operator on the iterator.
/ Destroys the stream position if the next entry is not a record.
/ Do this by checking for a store into the self box in the success branch.
/ Does not crash by itself.
/ Does not include any direct subclasses of given base class.
/ Dumping reflection metadata /
/ Either the instruction is somewhere inside the CFG pattern, then we move it / up, immediately before the SelectValueInst in the pattern's dominating / entry block.
/ Equal to the size of the payload minus the spare bits used for tags.
/ Essentially, we can implement the release code motion by inverting the retain / code motion, but this can also make the code less readable.
/ FIXME: Assumes the explosion is broken into word-sized integer chunks.
/ FIXME: Enumify this
/ FIXME: This notion should go away, because it's impossible to expand / out "all" archetypes
/ FUNCTOR should have signature: /   void (size_t index, const Metadata *type, size_t offset)
/ Float and integer literals are additionally keyed by numeric equivalence.
/ For ObjC protocols, descriptors are uniqued at runtime by the ObjC runtime.
/ For a dynamic enum, this queries the value witness table of the payload / type.
/ For details see EscapeAnalysis.
/ For details see SideEffectAnalysis.
/ For example, functions which may be referenced externally.
/ For example, if the ObjC type is exactly the expected / _ObjectiveCType type, then it would always succeed for / NSString, NSNumber, etc.
/ For generic metadata patterns, the address point is always at the / beginning of the template (for now...).
/ For now, return true when both can be traced to the same global variable.
/ For organizational purposes, the platform-independent logic for / constructing job invocations is also located in ToolChains.cpp.
/ Functions need to preserve their abstraction structure.
/ Generic functions and protocol witnesses carry polymorphic parameters.
/ However, the client needs to update the dominator of the exit blocks.
/ If 'static' is true, then this is self for a static method in the type.
/ If ObjC interop is disabled, we can use Swift refcounting entry / points, otherwise we have to use the unknown ones.
/ If a buffer is allocated on the stack it's not needed to explicitly set / the RC_DEALLOCATING_FLAG flag (except there is code which may depend on it).
/ If an instruction is encountered that might modify any array this method / stops further analysis and returns false.
/ If it is found, it tries to link this specialization.
/ If possible, replace the default with the corresponding unique case.
/ If target is an ObjC type, return this type.
/ If the array is empty, use null.
/ If the body is able to be inlined into functions in other resilience / domains, this ensures that only sufficiently-conservative access patterns / are used.
/ If the builder sees this node in a post-visitor, it will pop / the context from the stack.
/ If the value is 1, it prints 'bar'.
/ If this returns a value other than SILValue() then the instruction was / simplified to a value which doesn't overflow.
/ If we align them more, we'll need to introduce padding to / make protocol types work.
/ If we compare for equality we need to make sure that the range does wrap.
/ If we find a situation that we cannot handle, we bail and return false.
/ If you are making one of these objects to address issue 1, call / the constructor that only takes a DeclKind, and it will be moved / unconditionally.
/ If you have created the object, instead of returning the result / with makeParserResult, use the object's fixupParserResult.
/ In any reasonable calling convention the input and output function types / should be ABI-compatible.
/ In case when a simplification is not possible, a null SILValue is returned.
/ In deserializer, we use LocalValues to store the definitions and / ForwardLocalValues for forward-referenced values (values that are / used but not yet defined).
/ In this case the address-part may be null, which means that the buffer / is not allocated yet.
/ In this case we know that the callee cannot throw.
/ Inspired by ProtocolConformance::getTypeWitnessByName.
/ Intentionally not defined as a copy constructor to avoid accidental copies.
/ It is generated by the compiler in some corner cases, e.g. if a serialized / optimized module is imported into a non-optimized main module.
/ It provides a common logic for computing live (i.e. reachable) functions.
/ It should be removed when fixed.
/ Missing entries implicitly have value 0.
/ NOTE: this vector contains an approximation of whether there will be a / retain or release to a certain point of a basic block.
/ Not "empty" for all blocks which have non-load uses or contain the / definition of the memory object.
/ Note that (unlike in C) block comments can be nested.
/ Note that this is not a subtype or conversion check - that takes place / in isDeclAsSpecializedAs.
/ Notice that unlike other sinking methods in this file we do allow sinking / of literals from blocks with multiple successors.
/ On success, the returned pointer will point to the ')' at the end of the / interpolated expression.
/ Once all requirements have been added, this will be zero in well-formed / code.
/ Once we rip this out of SILGen, DI will be able to figure this out in a / more logical manner.
/ Only dumps if the compiler is built with assertions.
/ Ordered by decreasing depth.
/ Otherwise return CapturedDiagnostics.end().
/ Otherwise return null.
/ Otherwise returns true.
/ Otherwise, an empty optional.
/ Otherwise, return a (nullptr, nullptr) tuple.
/ Otherwise, return nil.
/ Otherwise, this returns Type().
/ Otherwise, we do a direct store of the value.
/ Performing the conformance check forces the function to be synthesized.
/ Propagation of the count of one array allocation.
/ Reading the pinned prevents us from moving the pin instructions across it.
/ Reducing the search space increases the chances of matching ref count / instructions to one another and the chance of sinking them.
/ Resolve each type in the list to a concrete type.
/ Retrieve the generic parameters of the specified declaration context, / without looking into its parent contexts.
/ Return None if no such operand could be found, otherwise return the index / of a suitable operand.
/ Return the hoisted self argument.
/ Return the lowered type for the class's 'self' type within its context.
/ Returns false if it can be proven that no overflow can happen.
/ Returns nil for universal or generic type references.
/ Returns null if no such declaration can be found.
/ Returns nullptr if the value witness table is dependent.
/ Returns the address of the destination object.
/ Returns the address of the uninitialized fixed-size buffer for the concrete / value.
/ Returns the array is this is the case.
/ Returns the new EndBlock or null if no one could be found.
/ Returns the newly created basic block on success or nullptr otherwise (if / the edge was not critical.
/ Returns true and initializes internal fields if optimization is possible.
/ Returns true if a diagnostic was emitted.
/ Returns true if an overflow can happen.
/ Returns true if function was erased from the module.
/ Returns true if the live out set changed.
/ Returns true if the return block is reachable, false otherwise.
/ Returns true if there's no point in considering other origins.
/ Returns true if they are both l-values.
/ Returns true on success.
/ Should use EnumPayload.
/ Since LLVM and many system linkers do not have a notion of relative symbol / references, we emit the symbol as a global asm block.
/ Since fallthrough-able case blocks must not bind variables, they are always / emitted in the outermost scope of the switch.
/ Since it is supposed to be a load from a let property with / statically known constant initializer, only struct_element_addr / and tuple_element_addr projections are considered.
/ Since we want this to round-trip, lower these as reference / types.
/ Splits all critical edges in a function.
/ Store the Substitution list in a ConcreteDeclRef attached to the attribute.
/ Store the actual SILValue into Val and the reversed list of instructions / initializing it in Insns.
/ StructAddressUsers records other uses of the struct address.
/ StructValueUsers records direct uses of the loaded struct.
/ TODO: Cache the "simple" flag for types to avoid repeating checks.
/ TODO: Move into utils.
/ TODO: This is only a workaround.
/ TODO: Use name from witness table here to lookup witness table instead of / recomputing it.
/ TODO: give this some reasonable name and possibly linkage.
/ TODO: this should be cached in RCIdentity analysis.
/ The LoweredValue of an alloc_stack keeps an owning container in / addition to the address of the allocated buffer.
/ The argument is appended at the end of the argument tuple.
/ The basic value-witness table for ObjC object pointers.
/ The call result is otherwise ignored.
/ The check is performed by recursively walking the computation of the / SIL value being analyzed.
/ The debug locations and scopes of all functions and instructions are changed / to point to the generated SIL output files.
/ The former preheader now dominates all of the former headers children.
/ The level of loop nesting.
/ The list returned includes the viable candidates as well as the unviable / ones (along with reasons why they aren't viable).
/ The pass writes all SIL functions into one or multiple output files, / depending on the size of the SIL.
/ The platform-specific subclasses are implemented in ToolChains.cpp.
/ The predicate argument must point to a global or static variable of static / extent of type swift_once_t.
/ The relationship represented by arithmetic operators represent the / information that the operation did not trap.
/ The result has the appropriate type for the witness.
/ The result is always a GlobalValue of ObjCClassPtrTy.
/ The result is captured in this enum value, where the earlier entries are / most specific.
/ The sequence is traversed inside out, i.e. / starting with the innermost struct_element_addr / Move into utils.
/ The sequence is traversed starting from the load / instruction.
/ The template subclasses do target-specific logic.
/ The type must be dynamically known to have enum witnesses.
/ The type must be dynamically known to have extra inhabitant witnesses.
/ The type must have dependent generic layout.
/ The unsubstituted result must be naturally returned directly.
/ The unsubstituted result must be naturally returned indirectly.
/ There are a few ways we can emit it: / / - If the type is fixed-layout and we have visibility of its value /   witness table (or one close enough), we can project the layout struct /   from it.
/ There is no need for the caller to explicitly traverse the children / of this node.
/ Therefore there is no need for a liveness computation.
/ These are used to ensure that we don't issue duplicate reports.
/ This analysis also checks if we can clone the instructions in the loop nest.
/ This avoids intermediate closure construction.
/ This can be empty in cases like calls to closure exprs.
/ This enables debugging and profiling on SIL level.
/ This function is modeled after readSILFunction.
/ This function simplifies such operations, but returns only the first / element of a tuple.
/ This function try to simplify such operations, but returns only a / simplified first element of a tuple.
/ This helps the devirtualizer to replace witness_method by / class_method instructions and then devirtualize.
/ This implements a "raw" access, useful for implementing cache / functions or for implementing dependent accesses.
/ This implies BitwiseTakable.
/ This includes rewriting them from assign instructions into their composite / operations.
/ This is a shallow one-step search and not a deep recursive search.
/ This is invalid for irrefutable pattern initializations.
/ This is needed in case we converted some parameters/results of the / specialized function from indirect to direct but the result function of the / partial_apply still needs them as indirect.
/ This is not a type-safety problem.
/ This is not really something we need to track.
/ This is null for top level code.
/ This is set in the first pass.
/ This is set in the second pass.
/ This is used by Sema.
/ This is used for metadata accessors that come about due to resilience, / where the direct access is completely trivial.
/ This is used to disambiguate function overloads that would otherwise be / identical after opening their parameter types.
/ This is very useful for certain classes of variant diagnostics.
/ This makes iterating over the edges easier.
/ This may happen e.g. when: / - a type of the return value is a subclass of the expected return type.
/ This pass merges cond_fail instructions by building the disjunction of / their operands.
/ This tests the expand function in LSLocation class.
/ This tests the expandTypeIntoLeafProjectionPaths function, which is / a function used extensively in expand and reduce functions.
/ To do it, try to back-propagate the Condition / backwards and see if it is actually equivalent to DomCondition.
/ To form the actual relative reference, you must pass the returned / result to emitRelativeReference, passing the correct base-address / information.
/ Use for fast lookup.
/ Use-points are only values which are relevant for lifeness computation, / e.g. release or apply instructions.
/ Used for viewing the callgraph as dot file with llvm::ViewGraph.
/ Used to distinguish between different instances of an inlined function.
/ We also need to replace the closure parameter with the partial apply / on the closure.
/ We always use the most overridden function to describe a method.
/ We always want a void function returning a tuple _instruction_.
/ We calculate it on demand, so that we don't have to do it if the / function does not have any stack promoted allocations.
/ We create a thunk which converts the direct parameters/results back to / indirect ones.
/ We need the use points only for getting the end of a reference's / liferange.
/ We need to load the unique reference from a global variable fixed up at / startup.
/ We only CSE semantic calls on high-level SIL because we can be sure that / e.g. an Array as SILValue is really immutable (including its content).
/ We only hoist semantic calls on high-level SIL because we can be sure that / e.g. an Array as SILValue is really immutable (including its content).
/ We pattern match the first dimension's array access here.
/ We update ForwardLocalValues in getLocalValue and when a value is defined / in setLocalValue, the corresponding entry in ForwardLocalValues will be / erased.
/ We will not rotate a loop where the header is equal to the latch except is / RotateSingleBlockLoops is true.
/ We would have trapped either when overflowing or when accessing an array / out of bounds in the original loop.
/ Will be the same as getConstantInfo if the declaration does not override.
/ Within a closure, we require that the source code contain "self." explicitly / because 'self' is captured, not the property value.
/ `constant` must refer to a method.
/ along some of the paths.
/ code generation functions
/ i.e. the base of the location is changed.
/ or a pessimistic would suffice.
/ return the result value of the new ApplyInst if created one or null.
/ return true if it is possible to devirtualize, false - otherwise.
/ returns True if a function was inlined.
/ returns instruction I if this condition holds, or nullptr otherwise.
/ the returned constant will not actually be a relative reference.
/ these stores come from partial dead stores.
/ used to facilitate fast RC roots to index lookup.
/ used to facilitate fast location to index lookup.
/**/ comments can be nested, keep track of how deep we've gone.
// no access to Def / destroy_addr Def / / Return true if a destroy was inserted, forwarded from a copy, or the / block was marked dead-in.
// no writes /   return
// this is the new EndBlock
/// The amount to copy from the pattern in words.
/// The instantiation function, which is called after the template is copied.
/proc/* parsing functions
/proc/self/cwd is not available.
0 for bgColor, nothing gets outside anyway
0 is QImage#save default
0) Special cases are specially handled
0x7F would be called ASCII text, but many systems might reasonably consider some characters outside this range to be alphabetic, so the file command would call such characters ASCII.
0x8f is both a valid one-byte opcode and the first byte of the 3-byte XOP prefix.
0x9F, which ISO-8859 considers to be control characters but the IBM PC and Macintosh consider to be printing characters.
0xFF, or one of the following control characters: backspace, tab, line feed, vertical tab, form feed, carriage return, escape.
0xff is legal padding, but if we get that many, something's wrong.
0xxxxxxx is plain ASCII
1 if this is an exclusion set.
1 means that we have the fp from the caller's frame, and 2 means that this fp is not enough to figure out sp.
1 means we just handled Kind, 2 means we just handled uncurryLevel.
1) Check the type guards.
1) Compare type guards
1) If current state dictates a certain behavior, follow that Notes relating to ignored diagnostics should also be ignored
1) If the enum only has one case, it can be lowered as the type of the case itself, and no tag bits are necessary.
1) If the expression is the silence operator, recurse on the inner expression.
1) If we find an init specifier and our name matches the return type, we import as some kind of constructor
1) The region has at least one block.
1) Update type guards.
1) for a "static" / "type" method, the base is a metatype.
1.8.1: remove dependency on jinclude.h
10 (LIST_MAP): followed by serialized values until STOP is seen.
10 for the 32bit int at max size
10) The block-retranslation chains cannot have cycles.
100 bytes written, not enough to flush
10000 is a magic value to indicate a host error.
101 is the highest priority allowed by the init_priority attribute.
10xxxxxx never 1st byte
11 (MAP): followed by serialized key/value pairs until STOP is seen.
11) All successors and predecessors sets are consistent (i.e., if B is a successor of A, then A is a predecessor of B).
11) Successors and predecessors sets are consistent.
11) nextRetrans and prevRetrans are consistent.
11xxxxxx begins UTF-8
12 (STOP): no data Marks the end of a LIST or a MAP.
12/13/887605, greater value raises interger overflow
13 (SKIP): no data If seen as an entry in a LIST_MAP, the next index in the sequence will be skipped.
14 (VECTOR): followed by n serialized values until STOP is seen.
16 bits should be enough
16 bits/cell is plenty for that too.) Since the JPEG code is intended to run in small memory model on 80x86 machines, we can't just allocate the histogram in one chunk.
1st attempt without offsetting base address
2) A Hack-specific reserved typehint while in the HH namespace.
2) Check the reffiness guards.
2) Compare input type predictions
2) Each block in the region has a different id.
2) For non-generic methods inside generic types, we return the generic type's parameters and nullptr.
2) If the enum only has no-payload cases, only tag bits are necessary, with the cases mapping to integers, in AST order.
2) If the expression is a list assignment expression, recurse on the RHS of the expression.
2) If the user provided a behavior for this specific diagnostic, follow that
2) If we find a likely self reference in the parameters, make an instance member (method or property)
2) Loads of the box, which have uses of self hanging off of them.
2) ProjectEnumPayload: Destructively stripping tag bits from the enum value, leaving behind the payload value, if any, at the beginning of the old enum value.
2) The original recursive algorithm for the decision tree has been made iterative.
2) The result of the partial_apply is re-abstracted anyway (and the re-abstracted function type matches with our specialized type).
2) Update the retranslation successors, first cleaning the original pointers.
2) Updating the retranslation successor blocks to rechain them in the new order.
2) We need to find an insertion place for the deallocation so that it preserves a properly nested stack allocation-deallocation structure.
2) deletion of stored-only objects - objects that are allocated and potentially retained and released, but are only stored to and don't escape.
2) for a classbound protocol, the base is a class-bound protocol rvalue, which is loadable.
2) pgoLayout() is enabled for Optimize, PGO-based regions.
2-DO: check splitting at phis
2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no points need to be drawn
2.0.10: before the drawing routines, some code to clip points that are outside the drawing window.
2.0.10: needs a transparent-index check that is still valid if the source is not truecolor.
2.0.12: Brush palette, image truecolor (thanks to Thorben Kundinger for pointing out the issue)
2.0.12: Slaven Rezic: palette images are not the only images with a simple transparent color setting.
2.0.12: Steven Brown: support a single totally transparent color in the original.
2.0.12: TBB: alpha in the destination should be a component of the result.
2.0.12: a new adaptation from the same original, this time by Barend Gehrels.
2.0.12: detect bad truecolor .gd files created by pre-2.0.12.
2.0.12: support truecolor properly in .gd as well as in .gd2.
2.0.12: this is finally a parameter
2.0.13: Bob Ostermann: don't force autohint, that's just for testing freetype and doesn't look as good
2.0.15: moved down below declarations to satisfy non-C++ compilers.
2.0.16: Optimization by Ilia Chipitsine -- don't waste time offscreen
2.0.16: Paul den Dulk found an occasion where total can be 0
2.0.16: clip to clipping rectangle, Matt McNabb
2.0.16: clipping rectangle, not image bounds
2.0.16: thread safety (the font cache is shared)
2.0.18: space was a oor choice for this.
2.0.1: use gdImageSetPixel to do the alpha blending work, or to just store the alpha level.
2.0.1: work around a gcc bug by being verbose.
2.0.21: we don't reallocate memory we don't own
2.0.22: save the APP14 marker to check for Adobe Photoshop CMYK files with inverted components.
2.0.22: very basic support for reading CMYK colorspace files.
2.0.24: inptr must not be incremented until after transparency check, if any.
2.0.2: alpha blending is now on by default, and saving of alpha is off by default.
2.0.5: can't use gdTrueColorGetRed, etc with palette
2.0.5: mode_mono fix from Giuliano Pochini
2.0.5: we should actually return this
2.0.9, Thomas Winzig: apply simple full transparency
2.0.9: Thorben Kundinger: Maybe the source image is not a truecolor image
2.0.9: fixed by Thomas Winzig
2.05: remap to the palette available in the destination image.
2.0: much easier when the destination is truecolor.
2.6.1 xsi:type 2.6.2 xsi:nil 2.6.3 xsi:schemaLocation, xsi:noNamespaceSchemaLocation
2/  Only one instruction in the original stream is modified.
20 bytes RIFF header 10 bytes VP8 header
3) A Hack-specific reserved typehint while in the global namespace when HH syntax is enabled.
3) All arcs involve blocks within the region.
3) An assign to the box, which happens at super.init.
3) Compare the reffiness guards
3) Finally, try to find a class to put this on as a static function
3) For all other cases we need to create a new re-abstraction thunk.
3) For any block that had a successor in the retranslation chain, remove all the chain blocks from its successors' set and add only the new root.
3) For non-generic local functions, we return the outer function's parameters and nullptr.
3) If the enum has a single payload case and one or more no-payload cases, we attempt to map the no-payload cases to extra inhabitants of the payload type.
3) If the user provided a behavior for this diagnostic's kind, follow that
3) InjectEnumCase: Given a payload value placed inside an uninitialized enum value, inject tag bits for a specified case, producing a fully-formed enum value.
3) Updating the any predecessor block in the region to go to the new chain root.
3) for a mutating method, the base has inout type.
3/  The modified instruction does not cross a cacheline boundary.
31 is the encoded register number for zr and sp
32-bit conditional branch
32-bit constants are unsigned.
32-bit unconditional branch
4 bytes or less and value is in the dir entry itself
4 for slashes at start, after root, and at end, plus trailing null
4) Compare the sets of successor blocks
4) Delete unnecessary blocks from the region.
4) Deleting the blocks that became unnecessary (unreachable) after rechaining.
4) For each arc, the bytecode offset of the dst block must possibly follow the execution of the src block.
4) If the enum has multiple payload cases, the layout attempts to pack the tag bits into the common spare bits of all of the payload cases.
4) Otherwise remap the diagnostic kind
4) Potential escapes after super.init, if self is closed over.
4) for a nonmutating method, the base is a general archetype rvalue, which is address-only.
40 Bytes should be more than enough for this format string.
404 redirection succeed
414-424) by Dale Schumacher  Additional changes by Ray Gardener, Daylon Graphics Ltd.
5) Each block contains at most one successor corresponding to a given SrcKey.
512KB written, but file is not 1 MB large yet so no fadvise
6 is the position after zip://
64-bit hash for 64-bit platforms
7) All blocks are reachable from the entry (first) block.
7) All blocks are reachable from the entry block.
7-bit unsigned int (NOTE: not used for the sole int value due to the compatibility requirement above) - 10......
8 NULL means undefined and should be ASCII...
8) For each block, there must be a path from the entry to it that includes only earlier blocks in the region.
8-bit conditional branch
8-bit unconditional branch
8-byte pointer and 8-byte size describing the code range for this FDE.
: (after unquoted string)
:) TODO: At some point, we should special case closures that just *read* from the escaped value (by looking at the body of the closure).
@(#)list.c 1.18 9/23/86 Public Domain - gnu  Comments changed and some code/comments reformatted for file command by Ian Darwin.
@NSManaged only applies to instance methods and properties within a class.
@NSManaged properties must be written as stored.
@NSManaged properties never get default initialized, nor do debugger variables and immutable properties.
@TODO: this is quite ghetto right now, but is useful as is to others.
@XXApplicationMain classes must conform to the XXApplicationDelegate protocol.
@autoclosure is only valid on parameters.
@callee_owned function calls implicitly release the context, which may call deinits of boxed values.
@class WebPageCallbacks
@convention(block) is a single retainable pointer so optionality change is allowed.
@convention(thick) callees are exploded as a pair consisting of the function and the self value.
@convention(witness_method) callees are exploded as a triple consisting of the function, Self metadata, and the Self witness table.
@effects(readonly) is worthless if we have owned parameters, because the release inside the callee may call a deinit, which itself can do anything.
@llvm.used Collect llvm.used globals already in the module (coming from ClangCodeGen).
@nonobjc can be used to silence this warning.
@nonobjc will silence this warning.
@note If you want to scan bytes that may contain NUL values, then use hphp_scan_bytes() instead.
@note If you want to scan bytes that may contain NUL values, then use yy_scan_bytes() instead.
@objc class types are okay.
@objc enums and protocols always have a fixed layout.
@objc enums can explicitly derive their _BridgedNSError conformance.
@objc enums lower to their raw types.
@objc enums must have a raw type that's an ObjC-representable integer type.
@objc enums must have a raw type.
@objc enums use their raw values as the value representation, so we need to force the values to be checked.
@objc existential types are okay
@objc existential types are okay Nothing to do.
@objc metatypes are representable when their instance type is.
@objc protocol metatypes.
@objc protocols do not have conformance records
@objc protocols don't need a materializeForSet since ObjC doesn't have that concept.
@objc-ness will be inferred (separately) and the selector will be checked later.
@param b a buffer created with yy_create_buffer()
@param file A readable stream.
@param in_str A readable stream.
@param input_file A readable stream.
@param new_buffer The new input buffer.
@param new_buffer The new state.
@param size The character buffer size in bytes.
@param uint32 cpu_id, the id of the logical cpu to be bound to.
@param user_defined The data to be associated with this scanner.
@param yyscanner The scanner object.
@pinstr should be pointing to the beginning of the li32 block TODO(gut) use Decoder, but for now, do it hardcoded
@pinstr should be pointing to the beginning of the li64 block
@return the allocated buffer state.
@return the newly allocated buffer state object.
@see WebPage::setupFrame(QWebFrame *) for details.
@see hphp_switch_to_buffer
@see http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
@see yy_switch_to_buffer
@src: The affine transformation.
@transparent is always ok on implicitly generated accessors: they can be dispatched (even in classes) when the references are within the class themself.
@unowned is basically like a reference type lowering except / it manipulates unowned reference counts instead of strong.
@warn_unused_result with arguments.
@warn_unused_result with no arguments.
@weak types are never loadable, so we don't need to handle them here.
A "." expression that refers to a member.
A "branchint" model takes a Bool expected value as the second argument.
A "conversion" of a DeclRef a C function pointer is done by referencing the thunk (or original C function) with the C calling convention.
A "load 32bits immediate" is mandatory
A "minimal" class for querying IRGen.
A "null" initialization that indicates that any value being initialized / into this initialization should be discarded.
A '+' was found, all remaining options are params
A '_' is an untranslated AnyPattern.
A 'public' typealias can have an 'internal' type.
A 'self.init' or 'super.init' application inside a constructor will evaluate to void, with the initializer's result implicitly rebound to 'self'.
A 'test candidate' is a class instance method that returns void, has no parameters and starts with 'test'.
A (case-insensitive) map from class method names to associated FuncFamily objects that group the set of possibly-overriding methods.
A (case-insensitive) map from class method names to the php::Func associated with it.
A (case-insensitive) map from interface names supported by this class to their ClassInfo structures, flattened across the hierarchy.
A (case-sensitive) map from class constant name to the php::Const that it came from.
A (possible) use of the result of a candidate store prevents the candidate from being moved past the use, and also prevents the candidate from being killed by a later store.
A + 1 does not trap if A is smaller than anything.
A +/- character is allowed.
A - 1 does not trap if A is greater than some other number.
A 4-connected neighbor:  pixel above, below, left, or right of a pixel.
A Bison parser, made by GNU Bison 2.4.1.
A C function imported as a method.
A CR bit parameter in ppc64 is a combination of X64's cc and sf variables: CR group (4 bits per group) is a sf and the CR bit (1 of the 4) is the cc
A CRTP ASTWalker implementation that looks for interesting / nodes for error handling.
A CRTP class for emitting witness thunks for the requirements of a / protocol.
A CRTP class for working with Clang's ABIArgInfo::Expand / argument type expansions.
A CRTP helper class for doing things that depends on type / classification.
A CRTP helper class for loadable but non-trivial aggregate types.
A CRTP helper for classes which are simply searching for a / specific index within the metadata.
A CRTP layout class for foreign class metadata.
A CRTP specialization of ClangExpand which projects down to / various aggregate elements of an address.
A CRTP type visitor for deciding whether the metatype for a type / is a singleton type, i.e. whether there can only ever be one / such value.
A CallArray pops the ActRec, actual args, and an array arg.
A CleanupBuffer is a location to which to temporarily copy a / cleanup.
A Cosine windowing function
A DeclRef 'E' that refers to an enum element forms an EnumElementPattern.
A DiscardAssignmentExpr (spelled "_") needs contextual type information to infer its type.
A JSON text is accepted if the end of the text is in state 9 and mode is Mode::DONE.
A LSLocation is an / abstraction of an object field in program.
A Lempel-Zim compression based on "compress".
A LiveRange is an closed-open range of positions where an interval is live.
A NUL character can be either whitespace we diagnose or a code completion token.
A ParenType wrapping a TupleType is a single parameter.
A RAII object for deciding whether this DeclKind needs special / treatment when parsing in the "debugger context", and implementing / that treatment.
A RAII object to save and restore BindOptionalFailureDest.
A RAII-ish object for forwarding a bunch of arguments down to one / side of a branch.
A RAII-ish object for undoing the forwarding of cleanups along a / failure path.
A REPL directive, such as ':help'.
A ReqBindJmp ends a unit and it jumps to the next instruction to execute.
A ReqRetranslate is generated if we're still generating IR for the first bytecode instruction in the region and the `target' offset matches the current offset.
A SILInstruction visitor that analyzes alloc stack values for dead live / range and promotion opportunities.
A SpillFrame will store over kNumActRecCells stack slots, and just like normal PureStores we can drop any support bits for them without reducing their lower bounds.
A StaticString can only be initialized by a StaticString constructor or StaticString::init().
A TakeAlways value becomes TakeOnSuccess for all but / last branch of the tree.
A TupleExpr propagate contextual type information down to its children and / can be erroneous when there is a label mismatch etc.
A TypeAliasDecl might have type set, but not the underlying type.
A TypeInfo implementation for address-only types which can never / be copied.
A TypeInfo implementation for bare non-null pointers (like `void *`).
A TypeInfo implementation for empty types.
A TypeInfo implementation for opaque storage.
A TypeInfo implementation for types represented as a single / scalar type.
A Use refers to the position where an interval is used or defined.
A arguments must be passed reference count neutral except for self.
A base class constraint that isn't NSError rules out the archetype being bound to NSError.
A base protocol is witnessed by a pointer to the conformance / of this type to that protocol.
A behavior in non-type or static context is never going to be able to satisfy Self constraints (until we give structural types that ability).
A binary operator can be part of a SILDeclRef.
A binary-operator reference only honors FuncDecls with a certain type.
A bit used as a payload tag bit is not a spare bit.
A bit vector for which the ith bit represents the ith LSLocation in / LocationVault.
A bit vector for which the ith bit represents the ith refcounted root in / RCRootVault.
A bit vector to keep the maximum number of stores that can reach a  / certain point of the basic block.
A block in the loop is guaranteed to be executed if it dominates the exiting / block.
A block is considered reachable from itself only if its entry can be / recursively reached from its own exit.
A block won't have it's reachability stored in this map until it's been computed.
A bounds_check is safe if no size / modifying instruction to the same array has been seen so far.
A bridged NSError is itself the value.
A buffer for all lines that the user entered, but we have not parsed yet.
A builder for ForeignClassMetadata.
A builder for ForeignEnumMetadata.
A builder for ForeignStructMetadata.
A builder for metadata templates.
A builtin call is considered reducible if its output is a constant and all its inputs are constants.
A builtin can only release an object if it can escape to one of the builtin's arguments.
A bunch of ugly macros to make it easy to declare certain common kinds of searcher.
A cache of information about whether particular nominal types / are representable in a foreign language.
A cached dominance analysis.
A call that's rethrowing-only can be handled by 'rethrows'.
A call to _adoptStorage has the buffer as AnyObject as the first argument.
A call to _allocateUninitialized has the count as first argument.
A call to materializeForSet exposes an address within the parent / object.
A callback which dispatches a failure case.
A callback which redispatches a set of specialized rows.
A canonical induction variable incremented by one from Start to End-1.
A case block has its own scope for variables bound out of the pattern.
A cast is almost like a projection.
A catch block has its own scope for variables bound out of the pattern.
A check for multi-threaded compilation: Is this the llvm module where the global is defined and not only referenced (or not referenced at all).
A checked_cast_br passes the result of the cast to the first basic block.
A child of this aggregate type.
A class controlling the emission of the decision tree for a pattern match / statement (switch, if/let, or while/let condition).
A class designated initializer must never be delegating.
A class for Builtin.UnsafeValueBuffer.
A class for building ObjC class data (in Objective-C terms, class_ro_t), / category data (category_t), or protocol data (protocol_t).
A class for collecting information about rethrowing functions.
A class for collecting the types of a Clang ABIArgInfo::Expand / argument expansion.
A class for expanding a polymorphic signature.
A class for finding a field offset in a class metadata object.
A class for finding a vtable entry offset for a method argument / in a class metadata object.
A class for finding the 'parent' index in a class metadata object.
A class for finding the start of the generic requirements section / in a type metadata object.
A class for loadable types.
A class for lowering Clang records.
A class for merging a particular kind of value across control flow.
A class for non-trivial, address-only types.
A class for reference types, which are all non-trivial but still / loadable.
A class for trivial, loadable types.
A class is allowed to implement two interfaces that share the same slot if we'll fatal trying to define that class, so this has to happen after all of those fatals could be thrown.
A class member is always better than a curried instance member.
A class that contains all analysis information we gather about our / function.
A class that walks the AST to find the innermost (i.e., deepest) node that / contains a target SourceRange and matches a particular criterion.
A class to walk over a local context and validate the correctness / of its error coverage.
A class to walk the AST to build the type refinement context hierarchy.
A class which lays out a specific conformance to a protocol.
A class which lays out a witness table in the abstract.
A class-constrained archetype may be bound to NSError, unless it has a non-NSError superclass constraint.
A class-constrained protocol composition can adopt the conforming class reference directly.
A cleanup that deallocates an uninitialized array.
A cleanup that deinitializes an opaque existential container / before a value has been stored into it, or after its value was taken.
A clever terminate handler may itself perform more memory allocation, which will throw another bad_alloc, and cause a recursive call to terminate.
A collision occurred, so we don't need our strdup'ed key.
A common base class for structs.
A common error is to try to define an operator with something in the unicode plane considered to be an operator, or to try to define an operator like "not".
A common level of optionality doesn't affect the feasibility.
A common pattern for us is to load an address into the frame pointer right before a PHP call.
A comparator for types with PointerLikeTypeTraits that sorts by opaque / void pointer representation.
A concrete conformance may be bindable to a different specialization of the same root conformance.
A concrete type is better than an archetype.
A concrete witness table, together with its known layout.
A cond_br is a forwarding use for its non-operand arguments in a similar way to br.
A cond_fail is only alive if its (identifiable) producer is alive.
A cond_fail that would have protected (executed before) a memory access must - after hoisting - also be executed before said access.
A conflict between two inferred type witnesses for the same / associated type.
A conformance in a different module file.
A conformance-requirement.
A connection has been established, and the proxy has responded with an interrupt giving us initial control.
A const pointer argument might have been imported as UnsafePointer, COpaquePointer, or a CF foreign class.
A constraint that binds any pointer to a void pointer is ineffective, since any pointer can be converted to a void pointer.
A container for declarations contained in some declaration context.
A context that handles errors.
A convenience initializer cannot chain to a superclass constructor.
A convenient class for parsing characters out of a string.
A convenient macro for delegating an operation to all of the / various tuple implementations.
A convenient method for failing out of a dynamic cast.
A convenient method for succeeding at a dynamic cast.
A convenient wrapper around getAddrOfLLVMVariable which uses the / default type as the definition type.
A conversion of a reference count value to a trivial value though could be used as a trivial value in ways that ARC dataflow will not understand implying we need to treat it as a use to be safe.
A copy_addr is like a 'store (load src) to dest'.
A copy_addr that is not a take affects the retain count of the source.
A crash occurred previously.
A critical edge has more than one outgoing edges from the source block.
A critical edge is an edge from a block with multiple successors to a block with multiple predecessors.
A datatype and depth can be provided
A dbg.declare is only meaningful if there is a single alloca for the variable that is live throughout the function.
A deallocating parameter can always be accessed directly.
A declaration found directly beats any declaration found via dynamic lookup, bridging, or optional unwrapping.
A declaration that can become a witness has shown up.
A default argument expression.
A deinit could deallocate array or put a different array in its location.
A delegating initializer does not initialize instance variables.
A dependent member type begins with a non-index, non-'d' character.
A description of an edge leading to a conditionally branching (or switching) / block and the successor block to thread to.
A designated initializer for a class must be written within the class itself.
A designated or required initializer has not been overridden.
A destination for an argument other than just "onto to the end / of the arguments lists".
A destructor only has one argument, self.
A dictionary expression can be of a type T that conforms to the DictionaryLiteralConvertible protocol.
A direct call to a ClosureExpr makes it noescape.
A direct reference to 'Self' is covariant.
A direct standalone function call, referenceable by a FunctionRefInst.
A directly-called closure can be emitted as a direct call instead of really producing a closure object.
A discriminated union.
A dominating cond_fail on the same value ensures that this value is false.
A dynamic_method_br passes the function to the first basic block.
A factory to generate a unique instance of a UserIniData which will eventually end up in either the per-request or system-wide table that maps ini settings to their callbacks.
A failable initializer cannot override a non-failable one.
A failed type witness binding.
A fancier test would sometimes let us do this for larger i values.
A far relative indirectable pointer.
A few of our optimization passes must be aware of every path out of a region, so throwing through jitted code without a catch block is very bad---and we abort in this case.
A field-info implementation for fields of Clang types.
A file is considered to be ISO-8859 text if its characters are all either ASCII, according to the above definition, or printing characters from the ISO-8859 8-bit extension, characters 0xA0 ...
A fix_lifetime (with a non-address type) is only alive if it's definition is alive.
A fix_lifetime instruction acts like a read on the operand.
A fixed-size buffer is always 16 bytes and pointer-aligned.
A flattened list of l-values.
A following comment counts as whitespace, so this token is not right bound.
A folly::none return signifies Variant.
A foreign error convention can affect the result type as seen in Objective-C.
A freed stub may be released by Treadmill more than once if multiple threads execute the service request before it is freed.
A full box metadata is non-type heap metadata for a heap allocation of a single value.
A full heap metadata is basically just an additional small prefix on a full metadata, used for metadata corresponding to heap allocations.
A full type metadata record is basically just an adjustment to the address point of a type metadata.
A function cast can succeed if the function types can be identical, or if the target type is throwier than the original.
A function reference.
A generalization of llvm::SmallSetVector that allows a custom comparator.
A generic param decl at module scope cannot refer to another module because we would have no way lookup the original module when serializing a copy of the function.
A good example of a control flow op that invokes PHP is IterNext.
A goto is used to prevent duplication
A guaranteed function argument is guaranteed to outlive the function we are processing.
A hack to blacklist particular types in the Darwin module on / Apple platforms.
A handful of builtins are varargs functions where the (not formally declared) varargs are pass-by-reference.
A handle to a row in a clause matrix.
A helper class for emitting materializeForSet.
A helper class for implementing a component that involves / calling accessors.
A helper class for implementing existential type infos that / store an existential value of some sort.
A helper class for working with existential types that can be / exploded into scalars.
A helper class to collect all nominal type declarations.
A helper class to sneak around C++ access control rules.
A helper class to translate the inner results to the outer results.
A helper for creating LLVM struct types.
A helper for creating SILArguments and binding variables to the argument / names.
A helper for creating pointer-to-struct types.
A helper function for creating a lambda-based DynamicPackingOperation.
A helper function that pulls an element off the front of an array.
A helper function to add a function error argument in the appropriate position.
A helper function to add an outer direct result.
A helper function to claim an inner direct result.
A helper function to return the depth of a requirement.
A helper function to return the depth of a type.
A helper function with context that tries to emit member refs of nominal / types avoiding the conservative lvalue logic.
A helpful little wrapper for a value that should be mangled / in a particular, compressed value.
A hoist group covers situations with a chain of dependent checks or of multiple checks that consume the same SSATmp.
A hoist group is a group of IRInstructions that all want to be hoisted to the same destination IRInstruction.
A large portion of the debug information lies within subprogram definitions, and scanning all of that consumes a large amount of time.
A layout can also have a suffix layout.
A layout can currently contain three different types of actions.
A layout contains a list of offsets and actions to perform at those offsets.
A leading slash is probably either // or /* and most likely occurs just in our testsuite for expected-error lines.
A let property provides more guarantees than the getter of a 'var' property.
A lexical scanner generated by flex
A linear time algorithm for placing phi-nodes.
A list of "suspicious" optional injections that come from / forced downcasts.
A list of CondFails that can be moved down.
A list of all functions forward-declared by a sil_scope.
A list of blocks that will require new Phi values.
A list of cond_fail instructions to remove.
A list of constraints that represent the value relationships.
A list of errata for this book has been posted to the sci.crypt newsgroup by the author and is available for FTP.
A list of nodes for which we already calculated the dominator frontier.
A list of optional injections that have been diagnosed.
A local availability overrides the incoming value.
A local context is needed for parsing closures.
A local generic context is a generic function.
A local reference is not a capture.
A lookup map for value decls.
A loose type equality check that disregards all sugar, qualification, looks through pointers, etc.
A lot of the code below is unfortunate and due to the inflexibility of / GraphUtils.
A lower bound is therefore always non-negative.
A lower bound of the actual reference count of the object that this alias set refers to.
A lowering for loadable but non-trivial enum types.
A lowering for loadable but non-trivial struct types.
A lowering for loadable but non-trivial tuple types.
A machine can belong to a tier, which can overwrite various settings, even if they are set in the same hdf file.
A map from PhysReg number to position.
A map from a Job to the commands it is known to be blocking.
A map from commands that didn't get to run to whether or not they affect / downstream commands.
A map from consumed SILArguments to the release associated with an argument.
A map from each BasicBlock to its BlockState.
A map from textual .sil scope number to SILDebugScopes.
A map from the PossiblyUnreachableBlocks to the folded conditional / branches that caused each of them to be unreachable.
A map of old to new available values.
A map with a single entry
A mapping from abstract storage declarations with accessors to / to the type refinement contexts for those declarations.
A mapping from generic parameters to the corresponding potential / archetypes.
A mapping from opaque value expressions to the open-existential / expression that determines them.
A mapping from requirements to the set of matches with witnesses.
A mark_dependence is safe if it is marking a dependence on a base that is the strong_pinned value.
A member of a "phi group"---i.e., the set of all variables which flow into one another via a set of corresponding phijmp's and phidef's.
A member of a protocol extension never conflicts with a member of a protocol.
A metadata pattern is a structure from which generic type metadata are allocated.
A method call using archetype dispatch.
A method call using class method dispatch.
A method call using dynamic lookup.
A method call using super method dispatch.
A method on NSArray may do arbitrary things including releasing the array.
A mock protocol descriptor with some default witnesses at the end.
A modified link is logically equivalent to IN_MOVED_FROM.
A module may contain multiple files.
A moment of convenience, a lifetime of compatibility.
A month always starts on or near a new moon and has either 29 or 30 days (a lunar cycle is about 29 1/2 days).
A more complex iteration test
A much simpler version of the above specialized for GP-arg-only methods
A must-alias-set's lower bound can be decreased in many situations, including: o An explicit DecRef or DecRefNZ of an SSATmp that maps to this must-alias-set.
A name-only resolution is guaranteed to be some kind of non-enum, non-type-alias object (see resolve_class).
A natively ObjC method witness referenced this way will end up going through its native thunk, which will redispatch the method after doing bridging just like we want.
A new SS context does not need to be created with both a Source and a Sink.
A new inferred source will never override an existing source.
A new month was started when the new moon was first observed.
A new option which is prefixed with "-" is expected
A new sender sets it to 1 and then expects an answer using version 2.
A new state is a number between 0 and 29.
A new underlying object is created, with a new handle.
A node in an expression tree of counters.
A node is covered if any region contains it.
A non-exhaustive catch within a non-throwing function.
A non-exhaustive switch would also produce an unreachable instruction.
A non-failable initializer cannot delegate to a failable initializer.
A non-failable initializer requirement cannot be satisfied by a failable initializer.
A non-final class  can satisfy this requirement with a method that returns Self.
A non-final class can model a protocol requirement with a contravariant Self, because here the witness will always have a more general type than the requirement.
A non-fragile function may not be inlined into a fragile function.
A non-generic declaration is more specialized than a generic declaration.
A non-throwing autoclosure.
A non-throwing function can be a subtype of a throwing function.
A non-throwing function.
A non-throwing source function can be cast to a throwing target type, but not vice versa.
A non-trivial case of the enum.
A nonprintable character is also wrong.
A noreturn source function can be cast to a returning target type, but not vice versa.
A normal conformance in this module file.
A normal value, represented as an exploded array of llvm Values.
A nullptr dest means the callee was intercepted and should be skipped.
A number of member instructions read locals without consuming an L from the symbolic stack through the normal path.
A page can optionally be provided
A pair of load and store that are independent of the CondFails and can potentially access the same memory.
A pair of source block number and successor index, used to identify an out-edge.
A pair of the array pointer and the array check kind (kCheckIndex or kCheckSubscript).
A parameter outline: - Parameters: - x: ...
A parent loop must contain all the blocks in its children loops.
A parse error will be reported at the signature's declaration site.
A partial equivalent of enterTCHelper, used to set up the ARM simulator.
A partial specialization for lambda-based packing operations / that return 'void'.
A pass for generating debug info on SIL level.
A path through a protocol hierarchy.
A phidef'd variable just need to be assigned a phi group if it doesn't already have one (i.e., from handling a phijmp).
A physical component which involves calling addressors.
A physical path component which force-projects the address of / the value of an optional l-value.
A physical path component which projects out an opened archetype / from an existential.
A physical path component which returns a literal address.
A placeholder may have any type, but default to Void type if otherwise unconstrained.
A pointer into something that has been relocated needs to be updated.
A pointer to the underlying php::Class that we're storing information about.
A polymorphic constructor type needs to refer to the constructor to get its generic parameters.
A port of LLVM's InstCombine pass to SIL.
A possibly-discontiguous slice of function parameters claimed by a / function application.
A potential binding from the type variable to a particular type, / along with information that can be used to construct related / bindings, e.g., the supertypes of a given type.
A potential reason why something might throw.
A potential solution to the set of inferred type witnesses.
A present-but-nullptr catch trace indicates that a call is explicitly not allowed to throw.
A pretty odd if statement, but consider the following situation.
A pretty-stack-trace node for demangling trees.
A print context which records the line numbers where instructions are / printed.
A prior failed lookup of bt already triggered a rebuild.
A private property from ctx trumps any other property we may have found.
A property with exactly this name.
A protocol cannot conform to itself if it has static members.
A protocol descriptor describes a protocol.
A protocol has an implicit generic parameter list consisting of a single generic parameter, Self, that conforms to the protocol itself.
A rather simple way to get at just the demangled function name (fully qualified i.e. Swift.String.init) without the argument and return types.
A redefinition is a hit in the scoped table at the same depth.
A reference to a declaration.
A reference to a member found via dynamic lookup.
A reference to a member.
A reference to a subscript found via dynamic lookup.
A reference to a subscript.
A reference to storage from within an accessor.
A reference to the Builtin.once declaration.
A reference to the lazily-allocated array of non-trivial enum cases.
A reference to the lazily-allocated children vector.
A region on a single empty block.
A release instruction may deallocate the pointer operand.
A release is only 'safe' if we know its deinitializer does not have sideeffects that could cause memory safety issues.
A release of a load from the self box in a class delegating initializer might be releasing an uninitialized self, which requires special processing.
A release that is mapped to an argument which already has a release that overlaps with this release.
A representative of the set.
A resilient indirect enum is still address only, because we don't know how many bits are used for the discriminator.
A result of trait flattening, as with the is_implements case above
A result plan for evaluating an indirect result into the address / associated with an initialization.
A result plan for working with a single value and potentially / reabstracting it.
A result plan which calls copyOrInitValueInto on an Initialization / using a temporary buffer initialized by a sub-plan.
A result plan which calls copyOrInitValueInto using the result of / a sub-plan.
A result plan which evaluates into the sub-components / of a splittable tuple initialization.
A result plan which produces a larger RValue from a bunch of / components.
A retain must be released before make_unique.
A retain on an arbitrary class can have sideeffects because of the deinit function.
A retainable pointer representation may be wrapped in an optional, so we need to provide inttoptr/ptrtoint in addition to bitcast.
A rethrowing function.
A return inst is always a non-failure exit bb.
A return value of nullptr indicates that all possible completions have been returned.
A reusable buffer for emitting records.
A row which we intend to specialize.
A running async function is active on the normal stack, and we cannot compute the location just by inspecting the async function wait handle alone.
A same named function is not a constructor in a trait
A same-type-requirement
A scalar type can be converted to an argument tuple so long as there is at most one non-defaulted element.
A scalar type is a trivial subtype of a one-element, non-variadic tuple containing a single element if the scalar type is a subtype of the type of that tuple's element.
A scalar value is being copied into the tuple, break it into elements and assign/init each element in turn.
A scanner is responsible for reporting pointer information about a set of types to the GC.
A scope encloses the condition and true branch for any variables bound by a conditional binding.
A scoped closure may not have a `cls', but we still need to preserve its `methodSlot', which refers to its slot in its `baseCls' (which still points to a subclass of Closure).
A set of ad-hoc rules to process instructions.
A set of apply inst that we have associated with a closure.
A set used to ensure we only visit users once.
A set which causes a destructor to run, a iteration init which causes an object's next() method to run, a RetC which causes destructors to run, etc.
A setter attribute can also override this.
A side effect free instruction cannot mutate the array.
A similar issue applies if you want to take out emptiness when a set occurs.
A simple array of 32-bit masks for lookup.
A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty well, but the smoother transfer function used below is even better.
A simple helper interface for buildStorageReference.
A simple index range.
A simple little state-machine to strip out html and php tags  State 0 is the output state, State 1 means we are inside a normal html tag and state 2 means we are inside a php tag.
A simple pass which replaces each apply of a generic function by an apply / of the corresponding pre-specialized function, if such a pre-specialization / exists.
A single copy_addr can appear multiple times if the source and dest are to elements within a single aggregate, but we only want to pick up the CopyAddrKind from the store.
A single result-translation operation.
A single tracked location.
A single unlabelled value is not a tuple.
A single-element tuple can be a trivial subtype of a scalar.
A single-expression body contains a single return statement.
A single-frame stack trace is used to aggregate stats for each function when called from different call sites.
A small optimization to reduce the graph size: we re-use the first field node as result node.
A small peep-hole optimization: If the operand is allocated on stack and there is no "significant" code between the set_deallocating and the final dealloc_ref, the set_deallocating is not required.
A special list of instructions known to access the current frame without explicitly depending on it are also blacklisted.
A special mangling for the very first generic parameter.
A specification can refer to another specification, so they form a chain.
A stable ordering of ID objects.
A stack maintains the states of nested structures.
A stack of contexts being printed, used to determine the context for / subsequent ASTPrinter callbacks.
A stack of expressions being walked, used to compute existential depth.
A stack of expressions being walked, used to determine where to / insert RebindSelfInConstructorExpr nodes.
A stack of opened existentials that have not yet been closed.
A storage structure for holding a destructured rvalue with an optional cleanup(s).
A store is dead if it is not read from any path to the end of the program.
A store is only safe if it is to an array element and the element type is trivial.
A store like this will generate 2 *indivisible* LSLocations, / 1 for each field and in addition to keeping a list of LSLocation, RLE also / keeps their available LSValues.
A store or assign is ok if the alloc_box is the destination.
A store to an alloc_stack can't possibly store to the array size which is stored in a runtime allocated object sub field of an alloca.
A stored ASTContext indicates that this is the canonical signature.
A stored property cannot be moved to an extension.
A stored property on a value type will have a mutating setter and a non-mutating getter.
A stream for counting line numbers.
A string that describes the Swift version number, e.g., "1.0".
A string whose data is globally-allocated.
A struct is safe if either it implements the _DestructorSafeContainer protocol and all the type parameters are safe types.
A struct nested inside another struct will either be logically a sibling of the outer struct, or contained inside of it, depending on if it has a declaration name or not.
A structure for collecting generic arguments for emitting a / nominal metadata reference.
A structure for conveniently claiming sets of uncurried parameters.
A structure for holding a r-value or l-value
A sub-layout is used to insert a layout into another layout N times.
A substitution may be either the module name of a protocol or a full type name.
A suffiently smart imm-folder could handle this for us.
A suffix type is used as the basis for a suffix layout as described above.
A switch is needed since there are more than two cases.
A switch_enum can implicitly pass the enum payload.
A template for computing the size of a metadata record.
A template for generating target-specific implementations of the / RemoteASTContext interface.
A test fixture with version ranges
A test invocation may initialize the options to be used for subsequent invocations.
A test program so we can actually test things involving object or class types.
A thick context parameter is required (but can be passed undef) if an error result is required.
A thick function also references the boxed partially applied arguments.
A thin function looks like a plain pointer.
A thread with the write lease may be modifying b.m_frontier while we call b.used() but it should never modify b.m_base.
A three-byte-character lead-byte not followed by two trail-bytes represents itself.
A timeout of 0 indicates an infinite timeout that blocks.
A tolerance has been implemented using GD_EPSILON.
A transaction id must be provided
A tuple pattern propagates its tuple-ness out.
A tuple that can be constructed from a scalar has a value of that scalar type as its supertype.
A tuple type is safe if its elements are safe.
A tuple type metadata record has a couple extra fields.
A tuple with a single, unlabelled element is just parentheses.
A two-byte-character lead-byte not followed by trail-byte represents itself.
A type expressing the result of classifying whether a call or function / throws.
A type implementation for 'weak' existential types.
A type implementation for a class archetype, that is, an archetype / bounded by a class protocol constraint.
A type implementation for address-only reference storage of / class existential types.
A type implementation for existential metatypes.
A type implementation for loadable record types imported from Clang.
A type implementation for loadable struct types.
A type implementation for non-fixed struct types.
A type implementation for non-loadable but fixed-size struct types.
A type implementation for resilient struct types.
A type info implementation for BridgeObject
A type info implementation for class existential types, that is, / an existential type known to conform to one or more class protocols.
A type is interesting if the scanner generated for it would be non-trivial.
A type metadata record is the structure pointed to by the canonical address point of a type metadata.
A type refinement does /not/ indicate a change in value, so the various changed flags are not touched.
A type sized and aligned the way Swift wants Int128 (and Float80/Float128) to be sized and aligned.
A type that is properly aligned for any stack member.
A type witness has shown up, and will have been recorded.
A type-info implementation suitable for an ObjC pointer type.
A typed value is expressed by 4 IDs: TypeID, TypeCategory, ValueID, ValueResultNumber.
A typedef to a typedef should get imported as a typealias.
A typesafe union of contexts that the printer can be inside.
A un-rewritten URL is always relative, so remove prepending /
A use of an inlined frame that can be modified to work without the frame is called a "weak use" here.
A useful addition might be to allow multiple of all types, but for now, multiple function or exception breakpoints results in the most recent silently being used (matching php5 xdebug).
A utility array to add new Nodes to the list so we maintain while processing the current worklist we maintain only completed items at the end of the list.
A utility function for cloning the apply instruction.
A value bound to _ is unused and can be immediately released.
A value is expressed by 2 IDs: ValueID, ValueResultNumber.
A value loaded from memory.
A value of None for a given branch indicates that / the branch does not introduce a new refinement.
A value of class type is a single retainable pointer.
A value that represents a statically-known function symbol that / can be called directly, represented as a StaticFunction.
A value that represents an Objective-C method that must be called with / a form of objc_msgSend.
A value witness table is dereferenceable to the number of value witness pointers.
A variable used in a pseudomain only need to do this once...
A vector consisting of closures that we propagated.
A vector containing all of the archetypes, expanded out.
A vector containing the same-type requirements introduced into the / system.
A vector of ClassInfo that encodes the inheritance hierarchy, unless this ClassInfo represents an interface.
A vector of the declared interfaces class info structures.
A vector type we don't know how to map.
A version number for the format of the serialized code completion results.
A version number is either an integer (8), a float (8.1), or a float followed by a dot and an integer (8.1.0).
A version of the above where the tag value is dynamic.
A very basic conversion approach, TBB
A very common case if for the specifier to be the last thing on the line.
A very simple dead code elimination pass that just removes trivial nop instructions.
A very simple dominance check.
A very simple dominator check: just walk up the single predecessor chain.
A visitor class for emitting a reference to a metatype object.
A visitor class for emitting a reference to a type layout struct.
A visitor class which walks an entire l-value expression.
A visitor for breaking down formal result types into a SILResultInfo / and possibly some number of indirect-out SILParameterInfos, / matching the abstraction patterns of the original type.
A visitor for consuming tuples of l-values.
A visitor for creating a flattened list of LValues from a / tuple-of-lvalues expression.
A visitor for traversing a pattern, creating / global accessor functions for all of the global variables declared inside.
A visitor for turning formal input types into SILParameterInfos, / matching the abstraction patterns of the original type.
A visitor that does delayed parsing of function bodies.
A walker that looks for 'return' statements that aren't nested within closures or nested declarations.
A walker that looks for 'try' or 'throw' expressions that aren't nested within closures, nested declarations, or exhaustive catches.
A weight for an inlining benefit.
A whitelist exists for builtin functions which are safe to call without a valid caller frame.
A whitelist of protocols allowed to be use in xml external entities.
A whitelisted type should be ignored entirely.
A widening union on types that are already stable should not move the type anywhere.
A width value was supplied.
A wildcard or name pattern cannot appear by itself in a context which requires an explicit type.
A will strip any trailing whitespace
A witness is always more specialized than the requirement it satisfies.
A witness method always provides Self.
A witness method always provides the witness table for Self.
A wrapper around a MapVector with generalized operations on the map.
A wrapper for `zip_open` that prepares a full path file name to consider current working directory.
A wrapper has already been registered for that scheme
AFTER ALL ABOVE FAILED
AFrame and AStack can contain multiple locations.
ALGORITHMS  SERIAL DAY NUMBER TO JEWISH DATE  The simplest approach would be to use the rules stated above to find the molad of Tishri before and after the given day number.
ALGORITHMS  The calculations are based on three different cycles: a 400 year cycle of leap years, a 4 year cycle of leap years and a 5 month cycle of month lengths.
ALGORITHMS  The calculations are based on two different cycles: a 4 year cycle of leap years and a 5 month cycle of month lengths.
ALPHACHANNEL constants
AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
APE processes Authorization: Basic into PHP_AUTH_USER and PHP_AUTH_PW
APE sets CONTENT_TYPE and CONTENT_LENGTH without HTTP_
API availability ranges are contravariant: make sure the version range of an overridden declaration is fully contained in the range of the overriding declaration.
API interface to fetch a connection
API to allocate a new object from JS
API to call from object-data at property resolution.
ARCHITECTURE ASSUMPTIONS: This code used to have some nasty ones, but these have been removed by now.
ARM currently can't handle floating point returns.
ARM machines really only have 32 GP regs.
ARM requires marker assembly for objc_retainAutoreleasedReturnValue.
ARRAY_INFO(1, arg, 0)
ASCII magic -- try to detect text encoding.
AST Walker shouldn't go into the type recursively.
AST and module printing options.
AST printing options.
AST stream printer that adds extra indentation to each line.
AST type of the base expression, in case the accessor call / requires re-abstraction.
AST walker that infers requirements from type representations.
AST walker that records the keyword arguments provided at each / call site.
Aaaand we're done - oops not thread safe.
Abandon all received finished events.
Abandon any current cache.
Abort if "Mutable" appears twice.
Abort if the array value / could escape or be changed.
Abort the reply that we attached to the Network Timeout
Above cases push at most one stack cell.
Absent some sort of user "max alignment" annotation (or having reached the platform maximum alignment, if there is one), these are part and parcel.
Absolute "path" so that handleTestInvocation doesn't try to make it absolute.
Absorb ConvIntToBool.
Absorb boolean comparisons.
Absorb integer comparisons against constant zero.
Abstract base class for refutable pattern initializations.
Abstract description of a scanner.
Abstract state for a program position.
Abstraction changes: - functions
Abstractly represents a callee, which may be a constant or function value, / and knows how to perform dynamic dispatch and reference the appropriate / entry point at any valid uncurry level.
Abuse CovariantReturnConversionExpr to fix this.
Academic Press, 1991).
AccKind should always be either IsGetter or IsSetter here, based on whether a reference is a mutating or non-mutating use.
Accelerate shutdown if all requests that were enqueued are done, since no more is coming in.
Accept a client connection from a server socket, using an optional timeout.
Accept and remove the 'final' attribute from members of protocol extensions.
Accept loads from the unowned-referenced object.
Accept singlethread if present.
Accept volatile and singlethread if present.
Accept weak, volatile, and singlethread if present.
Accepts ownership of the response object.
Access locals thru VarEnv.
Access strategies should be set by the abstract class layout, not using the concrete type information we have.
Access the base as inout if the accessor is mutating.
Access this directly instead of going through (e.g.) observing or trivial accessors.
Access to Element node is implemented as a convience method
Access to Impl.SyntaxInfo is guarded by Impl.AccessMtx
Access to the Index for this program.
Accesses to members in values of reference type (classes, metatypes) are always done through a the reference to self.
Accesses to value types with a non-mutable self are also done through the base type.
Accessibility attr may only be used on value decls and extensions.
Accessibility checks depend on the relationship between the class that first declared the method (baseClass) and the context class (ctx).
Accessor  methods (get/set functions) to struct members.
Accessor for the non-fixed offsets of a struct type.
Accessor methods for yylval and yylloc
Accessor methods to globals.
According to c-client docs (internal.txt) this shouldn't be used.
According to php-fpm, some servers don't set SCRIPT_FILENAME.
According to the book "Jewish Calendar Mystery Dispelled" by George Zinberg, the patriarch Hillel II published these rules in 358 A.D.
According to the information I was using, 2 measn meters.
According to this thread in the ICU mailing list, it should be safe to assume the UCollator object is thread safe so long as you're only passing it to functions that take a const pointer to it.
According with ABI, the GP index must be incremented after a floating point function argument
Account for the 'EnumName_Constant' convention on enumerators.
Account for the 'kConstant' naming convention on enumerators.
Account for the sentinel.
Accumulate each channel
Accumulate it into the full set.
Accumulate our result.
Accumulate run and reset for next run.
Accumulate the layout requirements of the payloads.
Accumulate the result.
Accumulative amount of allocated bytes on the stack.
Acquire a cryptographic provider context handle.
Acquire count for auto-release.
Acquire the archetype's static metadata.
Acronym doesn't get lowercased.
ActRec is torn down as well
Action is a description of any special behavior an object type needs when generating a scanner for it.
Action number for EOF rule of a given start state.
Activate the destroy cleanup.
Active clauses are handled by the normal AST walk.
Active members are attached to the enclosing declaration, so there's no need to walk anything within.
Actual T_ELSEIF, continue on.
Actual allocated length
Actual implementation of TypeParser for DWARF.
Actually call the native implementation.
Actually convert the source element.
Actually get the input from the socket.
Actually import the methods.
Actually remove the diagnostic from the list, so we don't match it again.
Actually substitute the diagnostic arguments into the diagnostic text.
Actually update the type guards.
Actually very simple, but do a lot of sanity checking on the result.
Actually we compute the coordinates of the center of the corner histogram cell, which are the lower bounds of the volume we care about.
Actually we compute the coordinates of the center of the upper-corner histogram cell, which are the upper bounds of the volume we care about.
Actually we only add instructions which may release a reference.
Actually, the final release would crash.
Actually, the input type is either a single type or a tuple type.
Adapt all known users of the partial_apply.
Adapted from: apptype.c, Written by Eberhard Mattes and put into the public domain  Notes: 1.
Adapter for tuple types.
Adapter providing a common interface for a SourceFile/Module.
Adar I, the month added for leap years, is sometimes referred to as the 13th month, but I have chosen to assign it the number 6 to keep the months in chronological order.
Add ".0" to a float that (a) is not in scientific notation, (b) does not already have a fractional part, (c) is not infinite, and (d) is not a NaN value.
Add 'phantom' object to the global scope
Add (match, offset) pair to the return value
Add (match, offset) to the return value
Add 2 to the loop variable because we can only scale by at most 8.
Add BBRegion to the ParentRegion.
Add Fix-Its that correct the optionality in the witness.
Add New to the worklist.
Add Objective-C property names.
Add SILDeclRef to ListOfValues, so we can reconstruct it at / deserialization.
Add StrongPinInst to available pins.
Add Swift decls if we are printing the top-level module.
Add V to the worklist.
Add a "(value : T, indices...)" argument list.
Add a 32-bit relative offset to a mangled typeref string / in the typeref reflection section, or globally if 'global' is 'true'.
Add a bit for the percentage of the candidate matched.
Add a bunch of numbers to the map concurrently.
Add a call site to the curry.
Add a character to the end of the current packet, and if it is 254 characters, flush the packet to disk.
Add a checked cast constraint.
Add a cleanup for the temporary we allocated.
Add a conversion constraint between the element type of the sequence and the type of the element pattern.
Add a conversion constraint between the types.
Add a curried 'self' type.
Add a dependency from the field to the extracted value.
Add a dependency from the operand to the value at the store-address.
Add a dependency from the tuple itself to the extracted element.
Add a dependency from the value at the address to the loaded value.
Add a domain error member, as required by conformance to _BridgedNSError / Returns true on success, false on failure
Add a dummy entry for the metatype itself, and then for each conformance.
Add a file_section to image_info returns the used block or -1.
Add a fixit to replace '.dynamicType' with '.self'.
Add a format string value to image_info MUST BE NUL TERMINATED
Add a jump from middleLabel to destLabel, taking into account any special instructions at the beginning of destLabel.
Add a level of function application by passing in its possibly / unevaluated arguments and their formal type
Add a level of function application by passing in its possibly / unevaluated arguments and their formal type.
Add a lifetime-resolving copy from `s' to `d'---without touching the instruction stream.
Add a materializeForSet accessor to the given declaration.
Add a member to this context.
Add a new constraint between these types.
Add a new set of arguments to the function.
Add a new set of cookies
Add a new set of cookies foor this URL
Add a non-fixed-size element to the aggregate at offset zero.
Add a note describing why we need an initializer.
Add a padding argument if required.
Add a padding field if required.
Add a pointer to the given type as the next parameter.
Add a real (highly compressible) file for it to read in.
Add a retain of each non-address type capture argument, because it will be consumed by the closure body.
Add a row for each clause.
Add a row for each label of each case.
Add a self clause to the substituted type.
Add a setter to a stored variable unless it's a let.
Add a stack slot that was copy-initialized from the inout on entry / to the analysis.
Add a stack slot that was take-assigned to the inout from an exit BB / to the analysis.
Add a string value to image_info MUST BE NUL TERMINATED
Add a suffix node if there's anything left unmangled.
Add a tag from IFD to image_info
Add a temporary forward declaration for a type.
Add a token for the quote character.
Add a trivial setter and materializeForSet to a / ComputedWithMutableAddress storage decl.
Add a type annotation.
Add a value to image_info
Add a value witness marker.
Add a zero initializer.
Add accessors to the storage, since we'll need them to satisfy the conformance requirements.
Add all adjacent nodes to the WorkList.
Add all modified instrs to worklist.
Add all of the blocks to the function.
Add all of the conformance and superclass requirements placed on the given generic parameters and their associated types.
Add all of the constraints in the disjunction.
Add all of the inherited protocol requirements, recursively.
Add all of the requirements of the archetype to the given type.
Add all of the same-type requirements.
Add all options which influence the llvm compilation but are not yet reflected in the llvm module itself.
Add all parsed vardecls to this scope.
Add all results from this lookup.
Add all the early sources.
Add all the ids for this line.
Add all the subpatterns to it
Add all those arguments.
Add an Argument to the basic block.
Add an AvailableAttr to the declaration for the given / version range.
Add an `unreachable` to be the new terminator for this block
Add an array of protocols
Add an element at a non-fixed offset to the aggregate.
Add an element at the fixed offset of the current end of the / aggregate.
Add an empty element to the aggregate.
Add an entry for IRInstructions that have no associated machine code.
Add an entry to the table so we don't look again.
Add an entry to the vtable.
Add an entry to this context.
Add an expression segment.
Add an extra empty tuple level to represent the captures.
Add an implicit 'override' attribute.
Add an index-forwarding clause.
Add an int value to image_info
Add an operation to finish the enum initialization.
Add an optional operand.
Add an output file for each input action.
Add an output file for each input job.
Add an overload set that selects this field.
Add an unconditional jump at the end of the block.
Add an unreachable terminator.
Add any archetypes from this scope into the set of active archetypes.
Add any autolinking scripts to the arguments
Add any catch edges found, and stop at the first enclosing fault funclet, as in step 1.
Add any codecomplete.open specific flags.
Add any constraints that aren't already active to the worklist.
Add any defined macros to the bridging header lookup table.
Add any function attributes and set the calling convention.
Add any relevant custom completions.
Add any synthesized conformances.
Add any variable declarations to the current scope.
Add args for any pattern variables
Add argument labels, then fallthrough to get values.
Add arguments for all the parameters.
Add attributes to the root init node
Add backward pointers.
Add blockRegion's blocks and arcs to region.
Add branch arguments to destination phi nodes.
Add capture list variables to scope.
Add classes that don't require dynamic initialization to the ObjC class list.
Add compare_objects for MongoId
Add conformance requirements.
Add conformances to the given Objective-C protocols to the / given declaration.
Add constraint on args.
Add constraints accordingly.
Add constructors for the struct.
Add declared methods.
Add delimiter only if entry had ancestors
Add dependencies from array elements to the tuple itself.
Add dependencies from predecessor's terminator operands to the block arguments.
Add dependencies from the array operands to the struct array-fields.
Add dominator tree nodes for the new basic blocks.
Add each named local to the returned array.
Add each of the protocols.
Add each variable, filtering out superglobals
Add effects from the parameters.
Add entries for each loaded conformance.
Add entropy to s2 by calling gettimeofday() again
Add explicit dependency on -lc++abi, as -lc++ doesn't re-export all RTTI-related symbols that are used.
Add filters to determine if a Clang availability attribute applies in Swift, and if so, what is the cutoff for deprecated declarations that are now considered unavailable in Swift.
Add fix-it to insert ".self".
Add fix-t to insert '()', unless this is a protocol metatype.
Add flags implied by -embed-bitcode.
Add for any character in the key one byte of the alternate sum.
Add forward pointers.
Add history regardless, since we know that there are no duplicate entries.
Add image_info to associative array value.
Add implicit conformances to the given declaration.
Add imports to the worklist.
Add in the partial applies function name if we can find one.
Add inferred attributes.
Add information to track a value field at the current offset.
Add inherited conformances.
Add inherited protocols.
Add init() as member of the metatype.
Add interface methods that the class may not have implemented yet.
Add internal analysis passes from the target machine.
Add it as a derived global decl to the nominal type.
Add it to our call site list.
Add it to our list and continue.
Add it to the JobCache, so we don't construct the same Job multiple times.
Add it to the callee list and return true.
Add it to the front of the chain.
Add it to the module in a DerivedFileUnit.
Add it to the stats_count global.
Add its knowledge to knownType before doing anything else.
Add key for numbers not divisible by 7.
Add key or last result.
Add keywords even if type checking fails completely.
Add literal completions that conform to specific protocols.
Add location information for the given continuation to the given frame.
Add lower PC bound to function DIE
Add macros to the lookup table.
Add members from any extensions.
Add members from each of the extensions that we have not yet visited.
Add methods, properties, and protocol conformances from a JITed extension / to an ObjC class using the ObjC runtime.
Add must-alias-set ids to the block's GEN set if it has a use in the block that implies its reference count can't be zero on entry to the block.
Add new columns to the end of the row.
Add new decls if they provide a new overload.
Add newly parsed decls to the module.
Add no-parameter, non-void method names.
Add one because the way we compute whether there is enough space on lookupAdd will look at m_elms + 1.
Add only exit block successors by skipping blocks in the loop.
Add opaque storage at the given offset.
Add opaque storage for bitfields spanning the given range of bits.
Add operator methods from the given declaration type.
Add operator methods.
Add or remove functions from the debug-set from gdb.
Add other requirements.
Add padding to get up to the given offset.
Add pc to the breakpoint filter and the func exit filter
Add pending iterator if applicable
Add private imports to the extra search list.
Add protocol conformances and synthesized protocol attributes
Add protocol declarations to the enum declaration.
Add protocols for any synthesized protocol attributes.
Add reachable instructions to our worklist.
Add read preferences to cursor
Add requirements for associated types.
Add requirements for each of the associated types.
Add requirements for the nested types.
Add requirements placed directly on this associated type.
Add resolutions for livein sets.
Add resolutions for phis.
Add results for all imported modules.
Add results from current module.
Add salt for numbers not divisible by 3.
Add self to JavaScript world
Add signature elements for the source metadata.
Add some notes that the conformance is behavior-driven.
Add some number of elements, then delete a few to leave us some tombstones.
Add storage for an (optional) Swift field at the given offset.
Add sub-types of NTD.
Add substitution for the dependent type T._ObjectiveCType.
Add successor blocks to the worklist since their predecessor list is about to change.
Add superclass requirement, if needed.
Add target-cpu and target-features if they are non-null.
Add target-independent options first.
Add that to the result, further expanding if necessary.
Add the "(value)" and subscript indices parameter clause.
Add the # of props then short circuit if we are too deep.
Add the #if block itself as a TLCD if necessary
Add the 'dynamic' attribute.
Add the 'rethrows' attribute.
Add the 'self' clause back to the substituted formal type of / this protocol method.
Add the 'self' parameter back.
Add the 'self' parameter to the function type.
Add the 'self' parameter to the function types.
Add the 'self' type to the substituted function type of this / dynamic callee.
Add the DBGP_COOKIE environment variable
Add the RawRepresentable conformance implied by the raw type.
Add the SILArguments and use them to initialize the local argument values.
Add the Self type back to the interface and context types.
Add the Set to the callback.
Add the appropriate Boolean constraint.
Add the appropriate function map
Add the argument label.
Add the argument labels.
Add the argument to our list.
Add the argument to the block.
Add the attributes here so if we need them while parsing the body they are available.
Add the block argument.
Add the body of a wrapper.
Add the branch instruction with the block.
Add the breakpoint info.
Add the breakpoint state
Add the breakpoint, write out the id
Add the buffers for the indirect results if needed.
Add the call file/line.
Add the character to the string.
Add the character to the temporary buffer.
Add the children in the dom-tree to the worklist.
Add the compound function name for the given function.
Add the constraint on the type used for the 'Self' type for a member / reference.
Add the constraint that the index expression's type be convertible to the input type of the subscript operator.
Add the constructor, possibly including any default arguments.
Add the conversion from the argument to the function parameter type.
Add the converted argument.
Add the counts from jumps directly to the label (such as breaks)
Add the current instruction to the region.
Add the data pointer if we have one.
Add the deallocating destructor to the vtable just for the purpose that it is referenced and cannot be eliminated by dead function removal.
Add the decrement to the decrement to move set.
Add the default-entry of the original instruction as case-entry.
Add the diagnostic consumers back.
Add the diagnostic the expected number of times.
Add the domain error member
Add the entry slot to the analysis.
Add the error code's error message
Add the error propagated from the previous line to form the complete error correction term for this pixel, and round the error term (which is expressed * 16) to an integer.
Add the error result if we have one.
Add the exception type and the current line # for exception breakpoints
Add the exit slot to the analysis.
Add the extension to the nominal type.
Add the extensions produced by importing categories.
Add the extra tag bits.
Add the fields for the standard heap header to the given layout.
Add the file/line # for line breakpoints
Add the function type as the parameter.
Add the given global value to the Objective-C class list.
Add the given number of arguments.
Add the given offset to the free list for its size.
Add the given protocol conformance to the list of conformances for which / runtime records will be emitted in this translation unit.
Add the guard to the SrcRec.
Add the heap header if necessary.
Add the hit condition and count
Add the hits in the discarded tail to m_untracked.
Add the implicit 'self' parameter patterns.
Add the implicit 'self' to Params, if needed.
Add the indirect results.
Add the inherited entry.
Add the inner results (and don't filter them).
Add the isASCII argument in case of UTF8.
Add the last (match, offset) pair to the return value
Add the last argument, or the only argument.
Add the last piece to the return value
Add the link from proto to base if necessary.
Add the literal instruction to represent the result of the cast.
Add the literal instruction to represent the result of the division.
Add the literal instruction to represent the result.
Add the match sets to the output array and clean up
Add the member constraint for a subscript declaration.
Add the member to the list of declarations without notification.
Add the members of the nominal declaration to the table.
Add the memory buffers first, these will be associated with a filename and they can replace the contents of an input filename.
Add the message node then send the response
Add the method, possibly including any default arguments.
Add the new allocations to the worklist for recursive processing.
Add the new members to the lookup table.
Add the new tuple element, with the new type, no initializer,
Add the old decrements to the delete list.
Add the old increments to the delete list.
Add the operand as the final callsite.
Add the output file argument if necessary.
Add the padding to the fixed layout.
Add the parameter to our specialization list.
Add the parameters into scope.
Add the parent protocols.
Add the pass to the pass manager...
Add the path to the resource dir to rpath to support using the dylib from the default location without copying.
Add the pattern, possibly including any default arguments.
Add the payload value to the shifted payload tag.
Add the phi use of `r' at `pos' to the phi group given by `pgid'.
Add the piece DWARF expression.
Add the piece to the return value
Add the protocol decl to ExternalDefinitions so that IRGen can emit metadata for it.
Add the protocols we inherited.
Add the requirement to the representative.
Add the requirement, if we haven't done so already.
Add the requirements as constraints.
Add the requirements clause to the builder, validating the types in the requirements clause along the way.
Add the requirements for the given potential archetype and its nested / potential archetypes to the set of requirements.
Add the requirements from the declaration.
Add the rest of Path to P and return P.
Add the rest of the arguments.
Add the result to the phi, creating it (unparented) if necessary.
Add the results from scoped imports.
Add the results from unscoped imports.
Add the retired constraints back into circulation.
Add the runtime library link path, which is platform-specific and found relative to the compiler.
Add the same-type constraint.
Add the selector value.
Add the self argument, upcasting if required because we're calling a base class's method.
Add the source lazily.
Add the specified capture to the closure's capture list, diagnosing it / if invalid.
Add the specified value as an operand of the PHI for the specified / predecessor block.
Add the starting values of the context according to FIPS 180-2:6.2.2 step 4.
Add the starting values of the context according to FIPS 180-2:6.3.2 step 4.
Add the stderr to the output
Add the struct decl to ExternalDefinitions so that IRGen can emit metadata for it.
Add the subexpression.
Add the subloop region to the subregion data.
Add the superclass to the list of inherited classes.
Add the syntax map token.
Add the terminating null here since it wasn't added incrementally above once the whole string has been composed.
Add the type and the original size
Add the type binding constraint.
Add the type decl to ExternalDefinitions so that we can type-check raw values and SILGen can emit witness tables for derived conformances.
Add the unmanaged LLVM values lowered from a SIL value to an explosion.
Add the value and create the evaluation string
Add the witness marker.
Add the witnesses to the conformance.
Add these fields to the builder.
Add these into the running sums, and simultaneously shift the next-line error sums left by 1 column.
Add this as an external definition.
Add this binding to the diff.
Add this conformance.
Add this constraint to the constraint graph.
Add this declaration to the lookup set under its compound name and simple name.
Add this element to the list.
Add this entry to the lookup table.
Add this key/value pair.
Add this object to the global scope
Add this option / argument pair to the result hash.
Add this parameter to the scope.
Add this request to the stack of active requests.
Add this set of overload choices to the diff.
Add this solution's binding to the results.
Add this solution's overload choice to the results.
Add to `coveredArcs' all `cfg's arcs going from `src' to 'dst' or any of `dst's retranslations in `dstRegion'.
Add to outer loop if there is one.
Add to sets coveredNodes and coveredArcs the cfg arcs that are now covered given the new region containing the translations in `region'.
Add to the breakpoint filter and the func entry filter
Add to the breakpoint filter and the line filter
Add to the current inlining set (immutably, so we only affect the set during this call and recursive subcalls).
Add to the end of the list.
Add to the score based on context.
Add top-level potential archetypes to the stack.
Add trivial accessors to a Stored or Addressed property.
Add tuple completion (item, item).
Add type specific info.
Add type variable for the code-completion expression.
Add user to the FoldedUsers list and perform the necessary cleanups, RAUWs, etc.
Add variable bindings from the pattern to our current scope and mark them as being having a non-pattern-binding initializer.
Add variable bindings from the pattern to the case scope.
Add weights for all the loops BB is in.
Added 7/24/95: support transparent copies
Added hdpi and vdpi to support images at non-screen resolutions, i.e. 300 dpi TIFF, or 100h x 50v dpi FAX format.
Added in the early phase.
Added runtime option to change m_scriptFilename to s_pathTran which will allow mod_fastcgi and mod_action to work correctly.
Added support for reading as well as support for 'tell' and 'seek'.
Adding 24 bytes so that we can copy in 32-byte groups.
Adding 5 to the font index so we will never have font indices that overlap with the old fonts (with indices 1-5).
Adding contexts such as class would make sense
Adding nonempty values when we already have a single refcounted pointer means we don't have a single value anymore.
Adding the rpaths might negatively interact when other rpaths are involved, so we should make sure we add the rpaths last, after all user-specified rpaths.
Additional SIMD args wind up on the stack and can autobox with integer types
Additional constants for use with loading html
Additional delimiter argument
Additional functions are available for simple rotation or up/downscaling.
Additional functions we might need to serialize.
Additional headers for NetWare
Additional length to account for loop iterations.
Additional records associated with authoritative name servers
Additionally it will enable a user to exactly simulate / Swift's LLVM pass pipeline by using the same pass pipeline building / machinery in IRGen, something not possible with opt.
Additionally since we are going through the loop nest bottom up, all of our subloops have already been summarized.
Additionally, when retrieving the main systemlib from the current executable, honor the HHVM_SYSTEMLIB environment variable as an override.
Addqi and subqi can't be lowered to addq and subq if the destiny is rsp().
AddrToTransFragmentMapper
Address only 'let' values are passed by box.
Address parameters are all ABI-compatible, though the referenced values may not be.
Address-only with payload
Addressed storage gets a setter if it has a mutable addressor.
Addresses aren't compatible with values.
Addresses consist of a single pointer argument.
Adds a CFG edge from the unterminated NewRetBB to a merged "return" block.
Adds a CFG edge from the unterminated NewRetBB to a merged "return" or / "throw" block.
Adds a CFG edge from the unterminated NewThrowBB to a merged "throw" block.
Adds a function which implements a vtable or witness method.
Adds a range of PCs to the filter given a collection of offset ranges.
Adds an optimized FCallBuiltin for max with 2 operands to SystemLib
Adds an optimized FCallBuiltin for min with 2 operands to SystemLib
Adds conditional or watch clause to the breakpoint info if needed.
Adds no type annotations to the region beyond those known from the context.
Adjust a function type to have a slightly different type.
Adjust checksum to count the "chksum" field as blanks.
Adjust cursor to the start of the potential label.
Adjust down to the defining subclass type if necessary.
Adjust for 'size' and 'flags', which are always 32 bits rather than pointer-sized.
Adjust for 'size', which is always 32 bits rather than pointer-sized.
Adjust for the foreign-error argument if necessary.
Adjust for the std::reverse_iterator offset.
Adjust i386-macosx to x86_64 because there is no Swift stdlib for i386.
Adjust iLast accordingly.
Adjust internal breakpoints accordingly.
Adjust jemalloc otherwise we'll double count the direct allocation.
Adjust line and char if it's not small stepping
Adjust m_pos so that is points at this new first element.
Adjust potentially live references that point into the relocated area.
Adjust result type for failability.
Adjust size to reflect that we're adding a new element.
Adjust the cc1 triple string we got from clang, to make sure it will be accepted when it goes through the swift clang importer.
Adjust the class object extents.
Adjust the given type to become the self type when referring to / the given member.
Adjust the insertion location to point at the end of this line (i.e., the start of the next line).
Adjust the path to refer to our copy of the Clang resource directory under 'lib/swift/clang', which is either a real resource directory or a symlink to one inside of a full Clang installation.
Adjust the position of the diagnostics.
Adjust the position of the tokens.
Adjust the relative reference to the nominal type descriptor.
Adjust the relative references to the nominal type descriptor and parent type.
Adjust the result type for a throwing function.
Adjust the result type of a throwing function based on the / imported error information.
Adjust the start of TC relative to hot runtime code.
Adjust the start of the year.
Adjust the time backwards by the value of the hour, minute and second fields.
Adjust the type of the given declaration to appear as if it were / in the given subclass of its actual declared class.
Adjust the type of the reference.
Adjust to the B.C./A.D.
Adjust to the end of the starting token.
AdjustColorspace:  6.
AdjustColorspaceBack:
Adjusting the FP and offset is critical to prevent the callee stack from being smashed when reentering the VM, while changing the fixup source key is done to preserve invariants in the fixup map.
Adjusts the addresses in asmInfo and fixups to match the new location of the code.
Admin users always authenticate on the admin db, even when using other databases
Adopt the requested name.
Advance Builder to the fall-thru path and return a SILArgument holding the result value.
Advance YYPTR to a properly aligned location for the next stack.
Advance bitstream cursor to the next record.
Advance by the field's size to start the next field.
Advance over this immediate.
Advance pixel pointers to next column
Advance stable iterator.
Advance the address point to the end of the private storage area.
Advance the enum element iterator.
Advance the generator.
Advance the iterator if that would happen.
Advance the linked list.
Advance the offset and align it for the next piece.
Advance the sequence...
Advance the source key past the cached prefix.
Advance to the first case without a custom name, deprecated or not.
Advance to the next piece.
Advance to the position right after the last full match
Advances the builder to the successful type check's block.
After / eliminating any dead stores in single blocks, it computes a genset and / killset for each block.
After DebuggerSignalTimeout seconds that no active thread picks up the signal, we send it to dummy sandbox.
After Seed 5, we should be able to recognize if a switch_enum handles all cases except for 1 and has a default case.
After a fatal error subsequent diagnostics are suppressed.
After a null check, if it's actually an object we can just do LdPropAddr, otherwise we just give out a pointer to the init_null_variant (after raising the appropriate warnings).
After all requests finish executing OR all connections close OR ServerShutdownListenWait seconds elapse, stop the VM.
After all this, the instance type fields should still be valid.
After all, we're not really supposed to rework JPEGs and write them out again anyway.
After an entry, we know more about the node as a whole.
After assigning current properties' indexes, we will use these negative indexes to assign new indexes to parent properties that haven't been overlayed.
After assigning indexes for current properties, we reassign indexes to parent properties that haven't been overlayed to make sure that they are greater than those of current properties.
After calling semget(), if a process finds that the usage count is 1, it will set the value of SYSVSEM_SEM to max_acquire.
After cloning this edge will become critical if it came from inside the cloned region.
After disection, the effective type we can assume for the array key is in `type'.
After finalizeGenericParamList(), the generic parameters will be assigned to archetypes.
After finishing a request, check to see if we've allowed any triggers to fire and update the time of the oldest request in flight.
After handling any conditional initializations, check to see if we have any cases where the value is only partially initialized by the time its lifetime ends.
After initialization, we also smash the slow path call to point instead to a lookup routine for the out-of-line method cache (allocated above).
After invalidation the old index must not be equal to the new index.
After llvm-ir they have no use and show up as calls in the final binary.
After merging, BlockState now contains lists of available LSLocations and their values that reach the beginning of the basic block along all paths.
After numParams use vars, the remaining instance properties hold any static locals.
After our first pass, note that we've explored these types.
After parsing optional attributes above we should be at 'var' or 'let'
After parsing the expected type, the / caller of this function can choose the one that has the expected type.
After promoting unchecked_ref_cast_addr to unchecked_ref_cast, the SIL verifier will assert that the loadable source and dest type of reference castable.
After receiving this error, the connection is in an invalid state, and we do not need to call xpc_connection_cancel().
After register allocation, some lifetime intervals may have been split, and their Vregs assigned to different physical registers or spill locations.
After restart we need to finish the dependency registration for our package so allow the package to go present.
After running this pass all of the functions we will remove should consist only of one basic block terminated by UnreachableInst.
After scanning, if we did not find a value marked with the SProp marker then there is no work to do
After tearing down this frame, the VM stack should be completely empty
After that, gle_pp is either still NULL, or set to something if one of the options was found
After the candidate list is formed, it can be filtered down to discard / obviously mismatching candidates and compute a "closeness" for the / resultant set.
After the data flow converges, run last iteration and perform load forwarding.
After the first branch is processed, the arguments vector is populated.
After the maximum size is reached then the least-recently-used element is discarded to make room for the new.
After this pass is done the only thing that will reference the arguments is the partial apply that we will create.
After this phase we are left with up to one load and store per block and the last store is recorded.
After this step, all swift_retain's have been / replaced with swift_retain.
After this we'll no longer be able to get this_ from Debugger::findProxy(), which means no new interrupts for this proxy.
After we do that we can move the notification code below back into the main loop above.
After we have hoisted the first release this release would prevent further hoisting.
After we have scanned the entire region, diagnose variables that could be declared with a narrower usage kind.
After we made the decision for all allocations we can handle the deallocations.
Again in such a case by merging the first release with the second release, we would be introducing an additional copy.
Again since we only deal with iterators, the intersection must be iterator information, and we know it only intersects if they are the same iterator id.
Again we need to be careful here, because ssa construction (with the existing representation) can change the operand from under us.
Again, don't call the failure callback unless there was an uncaught exception or fatal error.
Again, it's important that the EndBlock is the first in the WorkList.
Again, pull a value witness table from the source metadata if we can't use a protocol witness table.
Aggregate composition is like assigning the aggregate fields to the resulting aggregate value.
Aggregate formation by themselves do not create new uses since it is their users that would create the appropriate uses.
Aggregate together all of the subelements into something that has the same type as the load did, and emit smaller) loads for any subelements that were not available.
AggregateAvailableValues - Given a bunch of primitive subelement values, / build out the right aggregate type (LoadTy) by emitting tuple and struct / instructions as necessary.
Aggregation results will be stored in the "result" key of the response.
Aggregation results will be stored in the "retval" key of the response.
Ahead of time whole program optimizations need to assume it can see all the code, or it really can't do much.
Alas, we have more work to do in this under Windows, so we can't be this small :(
Alerts user to cirular dependency in extensions e.g. Unable to resovle dependencies for extension(s): A(depends: B) B(depends: C) C(depends: A)
Algorithm for reflow: 1.
Algorithm:  Start by running an analyze pass on every class or free function.
Algorithm: Maintain a GIFBITS character long buffer (so that 8 codes will fit in it exactly).
Alias parent's static property.
Aliases for Objective-C runtime entry points.
Aliases for Swift runtime entry points for Objective-C types.
Aliasing inouts is unspecified, but we still want aliasing to be memory- safe, so we can't mark inouts as noalias at the LLVM level.
Align the current size appropriately
Align with Func start instead of with param decls.
Align without registering fixups.
Aligned version should work as long as we don't read beyond end of the buffer.
Alignment must be a power of two.
Alignof always returns non-negative results.
All (sub-)Intervals for a given Vreg are connected as a singly linked list, sorted by start position.
All / redundant safe array accesses seen up to the instruction can be removed.
All C++ builtins can do this but many hot functions do not.
All GeneralEffects instructions are assumed to possibly do so.
All Objective-C methods and non-final native Swift methods use dynamic dispatch.
All SILFunctionTypes are canonical.
All Swift properties are (nonatomic).
All YAML scalar types found at http://yaml.org/type/index.html.
All added together, they still cannot cause an overflow.
All alloc_ref instructions which allocate the object on the stack.
All args after this are intended for the PHP application
All argument values must be StructInst.
All arguments except one match.
All array types must be the same.
All base classes of pointer followable object types are also pointer followable (to handle polymorphism).
All bits are significant.
All block in-states start here.
All block types look like Builtin.UnknownObject.
All blocks reachable from `startBlock' are also cloned, so that there is no path from the cloned blocks to the original blocks in the `unit'.
All blocks within the inlined callee from which the InlineReturn is reachable.
All branches are considered useful.
All canonical elts means this is canonical.
All cases must be covered
All cast operations currently return null on failure.
All centennial years are leap years in the Julian calendar.
All children finished.
All class types have the same layout.
All classes conform to AnyObject.
All classes have eagerly-emitted metadata (at least for now).
All colors within a histogram cell will be mapped to the same colormap entry, namely the one closest to the cell's center.
All constructors have their initializing constructor in the vtable, which can be used by a convenience initializer.
All dispatch is done through objc_msgSend.
All doubles are implicitly less than arrays.
All entries of the dependency graph, which represent fields.
All entries of the dependency graph, which represent values or AllocStack.
All enums used by the uchar APIs.
All errors thrown by the do body are caught, but any errors thrown by the catch bodies are bounded by the throwing kind of the do body.
All exnNode ids must be unique.
All found calls to get-property semantic functions.
All fpass instructions spill the stack after they execute, because we are sure to need that value in memory, regardless of whether we side-exit or throw.
All funclets aren't in the main section.
All function types have the same layout regardless of arguments or abstraction level.
All function types of a given convention have the same value semantics, so they share a value witness table.
All function vtable entries must be at their natural uncurry level.
All functions which implement the method.
All implementations of derived classes may be called.
All instructions that are OutCInput or OutCInputL cannot push uninit or a ref, so only specific inner types need to be checked.
All instructions with these properties are handled above
All ints are implicity less than arrays.
All jobs which have been scheduled for execution (whether or not / they've finished execution), or which have been determined that they / don't need to run.
All jobs which have finished execution or which have been determined / that they don't need to run.
All keys are already static strings.
All let values are guaranteed to be held alive across their lifetime, and won't change once initialized.
All levels of class metatypes support subtyping.
All marker codes start with this
All methods are visible if the context is the class that declared them.
All methods which take one UChar32 argument and return bool
All methods which take one UChar32 argument and return same
All new Creates will overwrite the SharedStringData* in the slot and not use this one.
All new settings should use the ini path of this method (i.e., pass a bogus Hdf or keep it null)
All next level locations are alive, create the new aggregated location.
All no-payload cases have the same payload tag, so we can just use the payload value to distinguish between no-payload cases.
All no-payload cases have the same payload tag, so we can just use the payload value to distinguish between them.
All nodes: top level functions + inlined functions.
All nominal types can derive their ErrorProtocol conformance.
All non-degenerate affine transforms are invertible.
All of its methods must be usable from a separate / thread and so shouldn't touch anything outside of the EditLine, History, / and member object state.
All of the active clauses are already walked by the / AST walker, but we also want to handle the inactive ones to avoid false / positives.
All of the cases project an empty explosion.
All of the complexity here is tied up with class types.
All of the direct superclass's designated initializers have been overridden by the subclass.
All of the objects will be added unmanaged.
All of the parameter names should match.
All of these cases initialize 'length' chunks in newData.
All of these have a single definition, and the definitions dominate uses.
All of these have to be global to relative reference each other, and the instantiator function.
All of these just return true as they have already had their operands and types checked
All of this is autogenerated.
All original initialization points must be dominated by / the final initialization calls.
All other calls can be consider valid.
All other compilation modes perform specialization themselves.
All other function signature optimization is done later by modifying the function signature elements themselves.
All other functions are not inlined in cold blocks.
All other instructions marked dead.
All other licensing and usage conditions are those of the Apache Software Foundation.
All other metatypes are bridged.
All other mutable pointers map to UnsafeMutablePointer.
All other predecessors, where the outcome of the checked_cast_br along the path is not known.
All other source types should be concrete enough that we have conformance info for them.
All other specializations currently have exactly one location.
All other things considered equal, if any overload choice is more more constrained than the other, increment the score.
All other types should be imported in a non-bridged way.
All other values need to have contextual archetypes bound.
All other version components must be numbers.
All outputs of the instruction must have constant types for this to be allowed.
All pairs of non-equivalent primitives are not related by either subtypeOf or couldBe, including if you wrap them in wait handles.
All parameters are at the same depth.
All parameters can be the same matrix (safe to call using the same array for all three arguments).
All path elements are the same.
All predecessors should either unconditionally branch to the current BB or be another checked_cast_br instruction.
All pure memory access and pointer logic can be transformed, in particular: LdLoc, StLoc, LdLocAddr, CheckLoc, HintLocInner, and AssertLoc.
All reference count bounds are non-negative.
All region arcs are taken into account, including retranslation arcs.
All remaining components use qualified lookup.
All resilient structs have the same opaque lowering, since they are indistinguishable as values.
All scalar values are cast to a string before being returned.
All set, let's do it.
All special member markers should be static, so ignore anything that's not.
All subsequent molads can be calculated from this starting point by adding the length of a lunar cycle.
All successors are dead, so continue hoisting.
All such operations return a tuple.
All symbols defined below should begin with yy or YY, to avoid infringing on user name space.
All the argument types must be materializable (before inout is applied).
All the builtin types are leaves.
All the classes are known to be unique, and we just got here, so all were successfully defined.
All the following invariants only apply to non-interfaces.
All the indirect conventions pass a single pointer.
All the non-SIL, non-type-trait builtins should use the named-builtin logic, which just emits the builtin as a call to a builtin function.
All the places to place the new retains or releases after code motion.
All the release block state for all the basic blocks in the function.
All the retain block state for all the basic blocks in the function.
All the retains or releases originally in the function.
All the sources to the original instruction must be available, and non-reference counted values reachable through the source chain are also always available.
All the stub entrypoints share the same ret.
All the top-level code will be lowered separately.
All the translation routines expect this.
All the unique refcount roots retained or released in the function.
All the use(s) and def(s) of that instruction are live at some point within it, but their lifetimes nonetheless do not overlap.
All the value types are basically similar.
All these methods only exist in Mongo, and no longer in MongoClient
All things equal, we can merge the tyvars for the function types.
All this cannot decrement reference counts.
All threads tl_bases are kept in a set, to allow iterating Local and Normal RDS sections across threads.
All types aside from integer and string will be cast to string, and we also convert int-like strings to integers.
All types considered identical.
All users of these functions start with the flags set to Warn.
All uses that weren't dealt with in side exiting traces need to be handled specially.
All vtable entries must be decls in a class context.
All we have to do here is incorporate our knowledge of the percentage of this pixel that is really "lit" by pushing the alpha value up toward transparency in edge regions.
All we really need to do is use a single TopLevelCodeDecl.
All wrappers should have ODR linkage so that a linker can detect them and leave only one copy.
Alloc box introduces a ref count of +1 on its container.
Alloc ref dynamic always introduce references at +1.
Alloc refs always introduce new references at +1.
AllocBox introduce their container result at +1.
AllocObj re-enters to call constructors, but if it weren't for that we could ignore its loads and stores since it's a new object.
AllocOptimize - This performs load promotion and deletes synthesized / allocations if all loads can be removed.
AllocRef* are always allocating new classes so they are introducing new values at +1.
Allocate Floyd-Steinberg workspace if necessary.
Allocate Floyd-Steinberg workspace if we didn't already.
Allocate Floyd-Steinberg workspace.
Allocate `bytes' from the current slab, aligned to kSmallSizeAlign.
Allocate a StaticMethodFCache and return its RDS handle.
Allocate a TypedValue array and copy 'a' and the contents of 'argv'
Allocate a box of the given type.
Allocate a boxed existential container with uninitialized space to hold a / value of a given type.
Allocate a fixed-size buffer on the stack.
Allocate a multiple of s_pageSize, and no less than m_minChunkSize.
Allocate a new ArrayData with the specified capacity and dup all the elements (without copying over tombstones).
Allocate a new ProtocolInfo.
Allocate a new archetype.
Allocate a new cache slot and drill down to it.
Allocate a new element.
Allocate a new locator and add it to the set.
Allocate a new metadata object.
Allocate a new object using the layout.
Allocate a new object.
Allocate a new page if we haven't already.
Allocate a new pattern that matches a tuple.
Allocate a temporary.
Allocate additional space for kDeleted part.
Allocate an objc_super struct.
Allocate an uninitialized array of a given size, returning the array / and a pointer to its uninitialized contents, which must be initialized / before the array is valid.
Allocate and construct the new signature.
Allocate and fill in the error_limiter table
Allocate and initialize a new element.
Allocate and initialize an input buffer state.
Allocate and insert a new node between two adjacent nodes, returning the new node, handling backlinking appropriately.
Allocate and project the box.
Allocate another word of private data storage in the conformance table.
Allocate enough memory so that even if each character is quoted, we won't run out of room
Allocate enough room for the instruction with tail-allocated EnumElementDecl and SILSuccessor arrays.
Allocate enough room for the instruction with tail-allocated EnumElementDecl and operand arrays.
Allocate enough room for the instruction with tail-allocated data for all the case values and the SILSuccessor arrays.
Allocate enough space that the relocated cold code doesn't overlap the emitted cold code.
Allocate enough space to cache all possible timezones, if needed.
Allocate in the destination fixed-size buffer.
Allocate match sets array and initialize the values.
Allocate memory for the destination buffer (it will be zero-terminated).
Allocate memory for the offsets array
Allocate memory, then copy the input, replacing invalid sequences with either the substitution character or nothing, depending on the value of RuntimeOption::Utf8izeReplace.
Allocate opaque storage for the callback to use.
Allocate scratch space to invoke the runtime.
Allocate space for the args.
Allocate spill space on edges from a NoSpill out-state to a NeedSpill in-state.
Allocate storage for the completed colormap, if required.
Allocate storage for the field vector.
Allocate storage for the object.
Allocate the "self" value.
Allocate the 'self' value.
Allocate the Input buffer front-end.
Allocate the JPEG palette-storage
Allocate the Output buffer front-end.
Allocate the buffers.
Allocate the concrete value inside the container.
Allocate the existential.
Allocate the fixed-size buffer now, but don't allocate the value inside it.
Allocate the histogram/inverse colormap storage
Allocate the local variable for 'self'.
Allocate the local variable for the inout.
Allocate the metadata.
Allocate the new entry.
Allocate the new node.
Allocate the object on the heap.
Allocate the object on the stack.
Allocate the output buffer --- it will be released when done with image
Allocate the protocol descriptor.
Allocate the request-local one-way method cache for this lookup.
Allocate the result set array
Allocate the thread-stack
Allocate the tuple cache entry, which includes space for both the metadata and a value-witness table.
Allocate the variables and build up an Initialization over their allocated storage.
Allocate the witness table and fill it in.
Allocate the witness table and initialize it.
Allocate the witness table with the correct size, and fill in default requirements at the end as needed.
Allocate workspace for box list
Allocates the stack if it does not exist.
Allocating/deallocating anything less than 1K is trivial these days, and we want avoid string copying as much as possible.
Allocation ABI Shims While the Language is Bootstrapped
Allocations are safe.
Allow ExtInfos to differ in these ways: - the overriding type may be noreturn even if the base type isn't - the base type may be throwing even if the overriding type isn't
Allow a local array to be initialized outside the loop via a by-value argument or return value.
Allow about one typo for every two properly-typed characters, which prevents completely-wacky suggestions in many cases.
Allow all instructions in between, which don't have any dependency to the store.
Allow an arbitrary number of trailing blocks.
Allow anything that isn't bridged to NSNumber.
Allow breaks for previously disabled breakpoints that do not match the site of cmd.
Allow bridged conversions to CVarArg through NSObject.
Allow casting a struct by value when all elements in toType correspond to an element of the same size or larger laid out in the same order in fromType.
Allow casting a tuple by value when all elements in toType correspond to an element of the same size or larger in fromType in the same order.
Allow casting an enum by value when toType is an enum and each elements is individually castable to toType.
Allow casting from a value that contains an aligned pointer into another pointer value regardless of the fixed width.
Allow conversion from an import hint to an import hint kind, / which is useful for switches and comparisons.
Allow escaping of ``relations''
Allow filtering of the visible declarations based on various criteria.
Allow for a custom global symbol name and implementation.
Allow for close braces to appear in the replacement text.
Allow for transparency
Allow it to default to () if there are no return statements.
Allow l-value contractions when binding parameter types.
Allow multiple non-recursive references to the same array/object
Allow non-materializable tuples to be bound to anonymous parameters.
Allow null property types to match non-null ones, which only happens when one property is from a generic extension and the other is not.
Allow one level of optionality.
Allow our threads to fight for the lock.
Allow references to types as a part of: - member references T.foo, T.Type, T.self, etc.
Allow responses to drain for up to ServerGracefulShutdownWait seconds.
Allow silencing this warning using parens.
Allow strings to be passed to pointer-to-byte or pointer-to-void types.
Allow the diagnostic to fire on the 'try' if we don't have anything else to say.
Allow the result of the subexpression to be an lvalue.
Allow the signal polling thread to send CmdSignal messages to the client to see if it there is a signal to repond to.
Allow the substituted type to add thick-ness, but not remove it.
Allow this lookup to find hidden names.
AllowMergeWithDefBody
Allowances for daylight saving time changes and leap second.
Allowed datatypes for property_set
Allowed to pass null.
AllowedDirectories is a list of prefixes, so if x is a substring of y, we dont need y (also remove any duplicates).
Allowing a use exactly at the end facilitates lifetime splitting when the use at the position of an instruction clobbers registers as a side effect, e.g. a call.
Allowing us to perform the same optimization as for the store.
Allows the guarantee that any instance of an xdebug server is valid
Allows us to safely look ahead an arbitrary # of letters
Almost always the first one will be empty, so that path is inlined---everything else delegates to slow.
Almost ready for another flush
Along the way, it creates a PHP variable.
Already accounted for in the arguments.
Already accounted for in the parameters.
Already at the size, just strip profiles
Already emitted code for this.
Already fully diagnosed.
Already have an active connection
Already in the sweep list from init call, no need to add again
Already matching (as in, there are no labels).
Already matching (no labels).
Already representing the same integer.
Already saw an entry.
Already saw globals-as-members table.
Already setup for this key.
Already walked children.
Alright, the retain is 'available' for merging with a release from a successor block.
Also CSE semantic calls.
Also NDIG must be reasonable smaller than NUM_BUF_SIZE.
Also add the alias, if needed.
Also add the subscript entry, if needed.
Also adjust the affected char range accordingly.
Also allow enum of enum, which usually can be combined to a single instruction.
Also as a hack, always mark the setter mutating if we're inside a protocol, because it seems some things break otherwise -- the root cause should be fixed eventually.
Also at this point we know what locations are dead.
Also check the interface type.
Also compute the MaxStoreSet at the current position of the basic block.
Also deals with MemoryRef vasms like above but these ones have Immed data too.
Also determine which ones will need to be passed through the eval stack, and which ones will need conversions.
Also do block compression with an adaptive reset, whereby the code table is cleared when the compression ratio decreases, but after the table fills.
Also don't forget to update mangleUnitPHP7Options if needed.
Also ensure the current line hasn't already been set as the active line breakpoint.
Also fail if our predicted position exceeds bounds.
Also fix the Objective-C name, if needed.
Also for getting bulk fixits.
Also frees con_error_message
Also ignore ASIUser (only kicks in if ASIUser is the original apply).
Also ignore RuntimeOption::DisableStructArray here.
Also insert release_value in the normal block (done below).
Also keep track of the blocks with uses.
Also make sure to process any intermediate files that may contain SIL
Also map the original argument to the cloned instruction.
Also match against the parent.
Also need to add a zlib.output_handler ini setting as well.
Also note that any exit head must have a callee main block predecessor.
Also note that if a function takes a param by ref, it might come in as a Cell still if FPassC was used.
Also note that no collection check is done.
Also note this down as code error
Also perform the same recovery as the main parser to capture tokens from this decl that are past the code completion token.
Also provides utility methods for creating the new empty function.
Also remember the first pattern which matched that property.
Also remove superflous range checks.
Also retrieves and updates location information stored in the client.
Also returns true for cmds that should always break, like SessionStarted, and returns true when we have special modes setup for, say, breaking on RequestEnded, PSPEnded, etc.
Also sets all catch-traces to null to ensure that they are reset as appropriate in any future translation (the unwinder always_asserts on null catch trace annotations).
Also suppress name changes if there's a collision.
Also this is wrong if we wrap a reference in multiple levels of optionality
Also to determine back / edges, we need to compare post order numbers potentially of loop headers, / not the loops themselves.
Also track whether DC is just a type ancestor of the decl.
Also worth discussing is that there are several runtime objects in the VM with operations that have behavioral differences based on whether the reference count is greater than one.
Also, add factored exit edges for exceptional control flow through any parent protected regions of the region(s) that pointed at each fault handler.
Also, allow people to simply close out at the signin stage
Also, attribute the prologue (code before the first byte in the mapping) to the first line.
Also, collect all of the 'opens'.
Also, if resetKeys is true, postSort() will renumber the keys 0 thru n-1.
Also, if the closure is cloned, the cloned function is added to / the worklist.
Also, if we have a lazy definition for it, be sure to queue that up.
Also, no backtracking will occur unless a rule applies.
Also, set Uninit properties to TBottom, so that analysis of 86pinit methods sets them to the correct type.
Also, the beginning of a year varied from one culture to another - not all accepted January as the first month.
Also, the caller hasn't set up the m_invName area on the ActRec (unless it was a magic call), since it's the prologue's responsibility if it's a non-magic call.
Also, the prop initialization above can throw, so we don't want to have the object allocated already.
Also, today's epoch, 1 A.D.
Also, unreachable instructions are not user code, they are "expected" in unreachable blocks.
Also, we know that ctx cannot be the same or an ancestor of this, so we don't need to check if ctx declares a private property with the same name and we can fail fast here.
Also, we need to inspect the Funcs now (while we still have a references to parent) to determine which ones we will eventually need to free.
Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
Alternate "loose" transition table to support unquoted keys.
Alternatively, try to add 'es'.
Alternatively, we can have a local variable.
Although func doesn't fit in a signed 32-bit immediate, it may still fit in an unsigned one.
Although getDataTypeString also handles the null type, it returns "null" (lower case).
Although the CPU is little endian the FP has different byte and word endianness.
Although the PHP doc about proc_close() says that the pipes need to be explicitly pclose()'ed, it seems that Zend is implicitly closing the pipes when proc_close() is called.
Although the onFastPath builtin has no side-effects we don't want to (re-)move it.
Although the onFastPath builtin has no side-effects we don't want to remove it.
Although this builtin is provided by clang rt builtins, it isn't provided by libgcc, which is the default runtime library on Linux, even when compiling with clang.
Although this software can handle dates all the way back to 4713 B.C., such use may not be meaningful.
Although this software can handle dates all the way back to 4714 B.C., such use may not be meaningful.
Although we have a lock, so we're the only ones modifying this, there could be any number of readers.
Although we require an initializer, recover by parsing as if it were merely omitted.
Although we will cope with a later change in dither_mode, we do not promise to honor max_memory_to_use if dither_mode changes.
Always a value, don't need to save category
Always add the stdlib
Always allow mismatches here.
Always an address, don't need to save category
Always called from recv and implements specific logic for deserializing a list command received via Thrift.
Always called from recv and must implement the subclass specific logic for deserializing a command received via Thrift.
Always called from send and implements specific logic for serializing a list command to send via Thrift.
Always called from send and must implement the subclass specific logic for serializing a command to send via Thrift.
Always canonicalize to the outermost frame pointer.
Always carries polymorphic parameters for the Self type.
Always clone the ivar descriptors.
Always consider cond_fail instructions as potential for DCE.
Always consider unreachable code cold.
Always diagnose the new class.
Always do direct access.
Always extract the argument as a "char *" pointer.
Always have something on the stack.
Always leave space for a context argument if we have an error result.
Always look at the parameters in the last parameter list.
Always mark through the starting node, even if it's already marked.
Always normalize name before autoloading
Always occurs as part of some other stmt / or decl.
Always print rvalues, not lvalues.
Always return something of the right type.
Always returns / an i8**.
Always returns an i8**.
Always returns an i8*.
Always set a flag saying that this is a Swift 1.0 class.
Always set remoteAddr, even if it is empty
Always start with a blank array
Always strip off type information.
Always strip the auto-closure and no-escape bit.
Always use the Swift entry point, which will be a bridging thunk if we're calling ObjC.
Always use the same access kind for the base.
Always use this to ensure we don't miss out on NRVO anywhere.
Always verify the node as a parsed node.
Always zero histogram
Always-unavailable imported constructors are factory methods that have been imported as constructors and then hidden by an imported init method.
Ambiguities should be ruled out by parsing.
Amount of stuff to slurp up with each read.
Amount of text matched not including the EOB char.
An 'unavailable' requirement is treated like optional requirements.
An AST section consists of one or more AST modules, optionally with headers.
An ASTPrinter for annotating declarations with XML tags that describe the / key substructure of the declaration for CursorInfo/DocInfo.
An ASTVisitor for decomposing a nesting of ApplyExprs into an initial / Callee and a list of CallSites.
An ASTVisitor for generating SIL from method declarations / inside nominal types.
An ASTVisitor for populating SILVTable entries from ClassDecl members.
An ASTWalker that maps ASTNodes to profiling counters.
An ArrayRef that we use in our SILParameterList queue.
An Await opcode is used in the codegen for an async function to suspend execution until the given wait handle is finished.
An ExprPattern only exists before sema has resolved a refutable pattern into a concrete pattern.
An IPv4 mapped address.
An Identifier is "pointer like".
An IdentityExpr doesn't change its argument, but it *can* propagate its / contextual type information down.
An Interval represents the lifetime of a Vreg as a sorted list of disjoint ranges and a sorted list of use positions.
An Objective-C class reference reference.
An Objective-C protocol's name is unmangled.
An RAII class to scope source file codegen.
An RAII object for restoring all the interesting state in an / error-coverage.
An RAII type to exclude tokens contributing to private decls from the / interface hash of the source file.
An RC-identity cache.
An abstract class for transforming first-class SIL values.
An abstract class for working with results.
An abstract conformance can be bound to a concrete one.
An abstract enum value can be thought of as supporting three primary operations: 1) GetEnumTag: Getting the current case of an enum value.
An abstract enum value consists of a payload portion, sized to hold the largest possible payload value, and zero or more tag bits, to select between cases.
An abstract interface for producing bridged errors.
An accessor for the non-fixed offsets for a tuple type.
An accessor function might still be necessary even if the witness table can be shared.
An action is a negative number between -1 and -9.
An actual segment, append it to the destination path
An adapter class which turns a metadata layout class into a / generic metadata layout class.
An adapter for laying out class metadata.
An adapter for laying out struct metadata.
An adapter that turns a metadata layout class into a foreign metadata / layout class.
An additional grant of patent rights can be found in the PATENTS file in the same directory.
An additional method that can be provided by data source modules is the resync_to_restart method for error recovery in the presence of RST markers.
An aggregate type that contains references (potentially recursively).
An alarm may be set in http-server.cpp to kill this process after ServerPreShutdownWait + ServerShutdownListenWait + ServerGracefulShutdownWait seconds 1.
An alloc_box returns its address as the second value.
An alloc_stack itself does not introduce any non-native swift arrays.
An alloca may only be described by exactly one dbg.declare.
An alternative, conservative approach to stores, for example, might be to eagerly attempt to reduce the lower bound on the must alias set for value being stored at the location of the store itself.
An anonymous context won't have access if it wasn't public.
An application of possibly unevaluated arguments in the form of an / ArgumentSource to a Callee.
An application, which we look through to get the function we're calling.
An apply expression is a potential throw site if the function throws.
An apply is ok if the argument is used as an inout parameter or an indirect return, but counts as a possible mutation in both cases.
An archetype conforms to a protocol if the protocol is listed in the archetype's list of conformances.
An archetype may map to another archetype if the constraint system substituted one for another.
An argument has one result value.
An argument is converted from indirect to direct.
An array can hold at most INT_MAX elements
An array expression can be of a type T that conforms to the ArrayLiteralConvertible protocol.
An array is only mapped to a call once the analysis has determined that no make_mutable calls are required within the loop body for that array.
An array of arguments.
An array of sets of matches for each subpattern after a global match
An array of the overloaded builtin kinds.
An assignment isRefable, but the rhs may not be.
An associated type takes up a spot for the type metadata and for the witnesses to all its conformances.
An autoclosure body is the part of the enclosing function body for the purposes of deciding whether a try contained a throwing call.
An empty parameter list gives an empty map.
An entry in the dependency graph.
An entry in the input array
An enum cannot be smaller than its payload.
An error source that bridges a native error.
An error source that produces nil errors.
An error-handling context.
An evaluation string must be provided
An example of such an operation would be append.
An excellent reference on the underlying algorithm (and related algorithms) is:  B.
An exception has already been thrown
An existential conforms to a protocol if the protocol is listed in the existential's list of conformances and the existential conforms to itself.
An existential type cannot be used if the protocol has an associated type.
An existing specialization was found.
An expect of an integral constant is the constant itself.
An explicit graph data structure for the call graph.
An exploded parameter list: - parameter x: ...
An exponent is allowed.
An exponent is not allowed until there has been at least one digit.
An expression can be converted to an auto-closure function type, creating an implicit closure.
An extern variable expected by LLVM's hashing templates.
An immediate that points into the range being moved, but which isn't tagged as an addressImmediate, is most likely a bug and its instruction's address needs to be put into fixups.addressImmediates.
An implementation of DynamicPackingPHIMapping for Addresses.
An implementation of DynamicPackingPHIMapping for a single LLVM value.
An implementation of MetadataReader's BuilderType concept that / just finds and builds things in the AST.
An implementation of packing operations based around a lambda.
An implementation of what I call the "Sea of Stars" algorithm for POSIX fnmatch().
An implied conformance is better than a synthesized one.
An important note is that the bits in memory_support can represent memory locations that possibly alias (via ALocMeta::conflicts).
An index of 13 (for the "extra" days at the end of the year) will return the string "Extra".
An index of zero will return a zero length string.
An indexed type is a combination of a type and a set of actions associated with.
An indexed type is a combination of a type and an action.
An indirect case should have a payload.
An indirect function value.
An initialization of a local 'var'.
An initialized 'let' property has a single value specified by the initializer - it doesn't come from an argument.
An initializer declared in a protocol is required.
An initializer that conforms to a requirement is required.
An inout parameter is +0 and guaranteed, but represents an lvalue.
An inout/lvalue type that is described by a debug value has been promoted by an optimization pass.
An input number that is greater than this value, if followed by a legal input character, is too big.
An instance of an existential metatype is a concrete type conforming to the existential, say Self.
An int is already a valid key.
An intentionally funny-looking-in-core-dumps constant for uninitialized instruction pointers.
An invalid site is missing something like an ActRec, a func, or a Unit.
An iterative data-flow analysis to compute the livein sets for each block is necessary for two reasons:  1.
An iterator on Regions that first iterates over subregions and then over / successors.
An lvalue of type T1 can be converted to a value of type T2 so long as T1 is convertible to T2 (by loading the value).
An observing property backed by its own storage (i.e. which doesn't override anything) has a trivial getter implementation, but its setter is interesting.
An obvious improvement would to output an extra "temporary" attribute, but for now this logic just follows xdebug
An operand marked as UA means use-across.
An operation that always throws can only be handled by an all-handling context.
An operation that escapes or modifies the array value.
An operation to be performed for various kinds of packing.
An optimistic iterative dataflow is performed on the genset and killset / until convergence.
An optimistic iterative intersection-based dataflow is performed on the / gensets until convergence.
An option has been passed which requires a module, but the user hasn't requested one.
An optional requirement is trivially satisfied with an empty requirement.
An optional requirement might not have a witness...
An ordinary reference doesn't ignore anything.
An outer-scope source always overrides an existing source.
An output stream which calculates the MD5 hash of the streamed data.
An output_buf parameter is required by the method signature, but no data is actually output (in fact the buffer controller is probably passing a NULL pointer).
An owned or 'in' parameter is passed in at +1.
An unavailable initializer is always worse than an available initializer.
An unconditional cast instruction is finished here.
An unlabeled 1-element tuple type is represented as a parenthesized type.
An unowned parameter is passed at +0, like guaranteed, but it isn't kept alive by the caller, so we need to retain and manage it regardless.
An unpin, through destruction of an object can have arbitrary sideeffects.
An unresolved member expression '.member' is modeled as a value member constraint
Analyse canonical induction variables in a loop to find their start and end / values.
Analyse one instruction wrt.
Analyse one potential induction variable starting at Arg.
Analyse the current loop for reads that can be hoisted.
Analyse the loop for arrays that are not modified and perform dominator tree / based redundant bounds check removal.
Analysis passes will be kept.
Analysis results for memory locations known to contain balanced reference counts.
Analysis was successful.
Analysis whether it is safe to specialize this loop nest based on the / array.props function calls it contains.
Analyze a function expr and break it into a candidate set.
Analyze a single BB for refcount inc/dec instructions.
Analyze an instruction that operates on the Address of a backward propagated / value.
Analyze an instruction that operates on the Address of a forward propagated / value.
Analyze each block to compute its transfer function.
Analyze every method in the class until we reach a fixed point on the private property states.
Analyze return result information.
Analyze some special cases
Analyze the 'struct' instruction and check if it initializes any let properties by statically known constant initializers.
Analyze the alloc_stack instruction's uses.
Analyze the argument information.
Analyze the array object uses.
Analyze the array storage uses.
Analyze the assigned value and check if it is a constant statically known initializer.
Analyze the destructor for the class of ARI to see if any instructions in it / could have side effects on the program outside the destructor.
Analyze the destructor to make sure it has no side effects.
Analyze the function and replace each apply of a generic function by an apply of the corresponding pre-specialized function, if such a pre-specialization exists.
Analyze the given TransArgs and return the region to translate, or nullptr if one could not be selected.
Analyze the init value being stored by the instruction into a property.
Analyze the use graph of AllocRef for any uses that would prevent us from / zapping it completely.
Analyzing the body of this class destructor is valid because the object is dead.
Anchor the SerializedSILLoader v-table.
And Other is also nominal...
And XOR with the next 8 characters of the key.
And a LdRef or CheckRefInner automatically constrains the value to be a boxed cell, specifically.
And add it to the output array
And an empty object is null by default.
And attempt to find our matching argument.
And commutatively, swapping A and B.
And finally initialize the object by calling the constructor.
And for each remaining predecessor...
And gives its output to the linker.
And hoist decrements to predecessors.
And if they do share states, then / its not possible for CallB to block CallA and CallA not to block CallB.
And if we are not asked to report errors, just return nullptr.
And importantly, the memory support bits are may-information: just because a bit is set, doesn't mean that we know for sure that memory location contains a pointer to this object.
And in general, accesses to memory must maintain this invariant when they are done outside of small regions that may temporarily break that invariant.
And initialize it with a call to swift_initStackObject.
And is not a release_value, return None.
And issue a warning in HipHop syntax.
And it has substitutions, return false.
And its destination block has more than one predecessor.
And make sure any inherited conformances also get completed, if necessary.
And memory locations that we saw check instructions for in the loop.
And modules don't come with SourceLocs right now.
And must be representable either an object or bridged.
And not because it has to be for overriding.
And not on certain value decls.
And now, just to make sure things don't run too fast.
And of course this will affect backup programs
And only do it in optimized builds.
And our payload is refcounted, insert a strong_retain onto the payload.
And rather than giving each Class its own persistent handle that always points to an immutable 'true', share one between all of them.
And remove all Callee releases that we found and made redundant via owned to guaranteed conversion.
And remove all callee retains that we found and made redundant via owned to unowned conversion.
And replace the call to swift_bufferAllocate with a call to swift_bufferAllocateOnStack.
And since it can be determined whether the year is a leap year by simple division, the lengths of Adar I and II can be easily calculated.
And substitutions for D1 are not available directly in a general case.
And that must be a releasing instruction.
And the Apply itself.
And the StoreInst writes to the GlobalAddrInst.
And the first time a thread starts using the Treadmill it allocates a new thread id from s_nextThreadIdx with fetch_add.
And the instructions.
And the order of the field must be identical to the construction order.
And the states match, the enum state propagates to this BB.
And then emit our property using whether or not base is at +0 to discriminate whether or not the base was guaranteed.
And then mangle the generic specialization.
And then override the linkage with the new linkage.
And then transitively deserialize all SIL referenced by those functions.
And there are functions which are read-none and have a retain, e.g. functions which _convert_ a global_addr to a reference and retain it.
And they avoid using fprintf because _that_ might be in bad shape too.
And this is the entry block to the CFG pattern.
And we also need to kill `last', to update preds.
And we are not asked to produce diagnostics, just return nullptr...
And we are only interested in deserializing a specific requirement and don't have that requirement, don't deserialize this method.
And we do not need to worry about the compiler because the address dependency naturally forces an order to the memory accesses.
Android's libc implementation Bionic currently only supports the "C" locale (https://android.googlesource.com/platform/bionic/+/ndk-r11c/libc/bionic/locale.cpp#40).
Annot_array_get_count
Annot_array_get_int64
Annot_array_get_string
Annot_array_get_value
Annot_dictionary_get_string
Annot_dictionary_get_value
Annot_int64_get_value
Annot_string_get_length
Annotate the x86 with its bytecode.
Anonymous enumerations simply get mapped to constants of the underlying type of the enum, because there is no way to conjure up a name for the Swift type.
Anonymous functions currently always have Freestanding CC.
Anonymous functions have shared linkage.
Another 512KB, after one more byte a fadvise will be called
Another SIL_DEFAULT_WITNESS_TABLE record means the end of this WitnessTable.
Another SIL_FUNCTION record means the end of this SILFunction.
Another SIL_VTABLE record means the end of this VTable.
Another content node to actually load the element.
Another extension of the / same class in the same module gets a category name with a number appended, / e.g., NSObject (MySwiftModule1).
Another record means the end of this WitnessTable.
Another thing to note about memory support is that we may have more bits set than the current lower bound for an object.
Another thread stored subpat_names already.
Any Objective-C initializer, because failure propagates from any initializer written in Objective-C (and there's no way to tell).
Any SILArgument with a single predecessor from a "phi" perspective is dead.
Any archetype with the same / constraints is equivalent for type lowering purposes.
Any archetype with the same constraints is equivalent for type lowering purposes.
Any base which has been included with the custom base scanner should be ignored here, as we'll do one call to the custom scanner.
Any block that ends with anything other than NoSpill needs to be walked to look for places to free spill space.
Any block with a NeedSpill out-state and no successors must free spill space right before the block-end instruction.
Any blocks containing a DestroyPoints where hoistDestroy did not find a use are now marked in DeadInBlocks.
Any bridgeable object type can be a class.
Any bytes are allowed except three quotes in a row (""").
Any changes to the logic here also need / to be reflected in PrintAsObjC, so that the Swift type will be / properly printed for (Objective-)C and in SIL's bridging logic.
Any control flow command gets installed here and we continue execution.
Any copy from the inout outside of an exit block fails the analysis.
Any copy from the inout outside of the entry block fails the analysis.
Any early exit before we store a value into the existential must clean up the existential container.
Any empty value is a valid value.
Any functions or closures defined in it will not be hoistable.
Any functions that return void are treated as though they returned nullptr.
Any include/require (or eval) op kills all locals, and private properties.
Any instruction that can raise an error can run a user error handler and have arbitrary effects on the heap.
Any instructions not special cased above produce a new value, so there's no guard for us to constrain.
Any loaded value is good for the duration of this expression evaluation.
Any locals that we know point to that cell can have their inner type predictions updated.
Any loop that contains another loop's header block also contains its pre-header block.
Any obviously useless copy will be eliminated.
Any other bytes present in the string should therefore be emitted as-is, without any escaping.
Any other failures relate to the index list.
Any other interesting mapped types should be hinted here.
Any other type is would be a valid type in the AST.
Any output from them should be ignored as it doesn't make sense to try and send data after the request has ended.
Any particular type can be part of multiple indexed types but with different actions.
Any path from this block to a Block that expects values must be from a Jmp instruciton.
Any reference to "self" can be done at +0 so long as it is a direct access, since we know it is guaranteed.
Any refinement contexts introduced in the statement condition will end at the end of the last condition element.
Any remaining allocated memory is assumed to be filled with instances of T.
Any route to the closure context must yield the same class, or things downstream won't understand.
Any successors that are inside the loop but are not back edges are / left alone.
Any successors that are inside the loop but are the head of a backedge / have the edge removed.
Any type syntax is valid.
Any typehint not on this list is assumed to be normal "class-name" typehint.
Any use occuring within an exit-block is accepted as these uses will have access to the sunk frame pointer.
Any use of this will be an error anyway.
Any value bound here will just be dropped.
Any writebacks for this access are tightly scoped.
Any writebacks should be scoped to after the load.
AnyObject has no requirements (other than the object being a class), so needs no method dispatch.
AnyObject is implicitly conformed to by anything with a class bound.
AnyObject only requires that the type be a class.
AnyObject results can come from different modules, including the current module, but we always assign them the OtherModule semantic context.
AnyPatterns (i.e, _) don't require any storage.
Anything Clang imported is trivially representable in Objective-C.
Anything deprecated in OSX 10.9.x and earlier is unavailable in Swift.
Anything deprecated in iOS 7.x and earlier is unavailable in Swift.
Anything else -- give up
Anything else is not statically derived.
Anything else requires more complicated analysis than belongs in the simplifier right now.
Anything else we do at least potentially adds storage requirements.
Anything else, just pass along.
Anything in an Objective-C category or extension is adjusted to the class context.
Anything other than array for ini_get can be converted to the expected string result for this function call.
Anything that was definitively allocated by the MemoryManager allocator should be counted in this number even if we're otherwise zeroing out the count for each thread.
Anything with Local in its output or a member base input can modify a local.
Anything within the inout isn't a parameter anymore.
Anything without a fix is better than anything with a fix.
Anyway, go back to the beginning of the getter code to ensure that the diagnostics point to correct tokens.
Anyway, it would be possible to support that here, but since it's not currently required...
Apache adds character set for these two types
Apparently invariant, left over from compress
Apparently, Mac OSX needs this
Apparently, the same logic can be used recursively on the something, so there is an infinite chain of blocked wait handles.
Append a terminal escape sequence in "literal mode" so that editline / ignores it.
Append an additional argument to represent varargs.
Append an invalid character so that nothing can resolve to this name.
Append another backpath, including trailing slash if present.
Append each function's regions into the encoded buffer.
Append extra zeroes if necessary to ensure that the size of the filenames and coverage mappings is a multiple of 8.
Append it to the list.
Append it unchanged to the result.
Append length (before padding)
Append order doesn't matter here (unlike in setMethods()).
Append string to buffer - check if to be encoded...
Append target's USR if this is a member of a synthesized extension.
Append the address to disambiguate.
Append the current function name
Append the first argument name to the base name.
Append the new ones, filtering out Nops.
Append the next path component and lstat() it.
Append the prefix for constant propagation 'cp'.
Append this extraction to the target locator path.
Append to the main argument list if we have uncurry levels remaining.
Append values by moving -- Caller assumes we update refcount.
Append version, passes, digest length, and message length
Appending empty file to -c options to avoid loading defaults
Applies an array of tagsets to the read preference.
Apply 'self' if provided.
Apply a storage qualifier, like 'weak', 'unowned' or 'unowned(unsafe)' to a type with reference semantics, such as a class reference or class-bound existential.
Apply a substitution to the given SILFunctionType so that it has / the form of the normal SILFunctionType for the substituted type, / except using the original conventions.
Apply a substitution to this polymorphic SILFunctionType so that / it has the form of the normal SILFunctionType for the substituted / type, except using the original conventions.
Apply and return the closure in the function context.
Apply any ABI-compatible conversions before doing thin-to-thick.
Apply arguments from call sites, innermost to outermost.
Apply attributes to the type.
Apply base type substitutions to get the fully-substituted nested type.
Apply debug configuration as early as possible
Apply default settings
Apply default settings to the page
Apply generic arguments to the given type.
Apply instruction being optimized.
Apply instructions that may read from memory can read the pin bit.
Apply instructions used to construct left string literal.
Apply instructions used to construct right string literal.
Apply may only come from a string.concat invocation.
Apply omit-needless-words to the given declaration, if possible.
Apply primitive translation to the given value.
Apply read preference query option, but only if we have a MongoS connection
Apply rule 1 after the others because it can cause an additional delay of one day.
Apply sanitizer attributes to the function.
Apply substitutions to the callee type.
Apply the JSON config settings to this very object
Apply the fixes, building up a new buffer as an std::string.
Apply the generic arguments to the type.
Apply the mask and test.
Apply the mask if it's interesting.
Apply the omit-needless-words heuristics to both names.
Apply the path to the given witness table.
Apply the solution to the expression.
Apply the solution to the iteration pattern as well.
Apply the solution to the pattern as well.
Apply the substitutions.
Apply the sugar onto it.
Apply this transformation to all the elements of a tuple value, / which just entails mapping over each of its component elements.
Apply this transformation to an arbitrary value.
Apply those attributes that do apply.
Apply trait rules and import the methods.
Applying a function does not cause the function to escape.
Applying the inverted matrix will restore the original values.
Approximately up to this cost level a function can be inlined without / increasing the code size.
Arbitrarily pick one of the predecessor's branch locations.
Arbitrarily sort by name to get a deterministic order.
Arbitrarily truncate to 10 characters.
Arbitrary ordering of layouts.
Arch-dependent stack pointer.
Archetype builders are stored on the ASTContext.
Archetype function references.
Archetype metatypes have non-trivial representation in case / they instantiate to a class metatype.
Archetypes and existentials are only class references if class-bounded.
Archetypes are never statically derived.
Archetypes may or may not be ObjC classes and need unwrapping to get at the class object.
Architectures which can shift addresses left by 2 bits with no extra cost
Architectures with no complicated addressing modes supported
Arclite depends on CoreFoundation.
Arcs that survive this function may still be trimmed by the other checks in visit().
Are all available values identicalTo each other.
Are the arguments to this block used outside of the block.
Are the getter and the setter in the same type.
Are we building genset and killset.
Are we building the genset and killset.
Are we computing genset and killset.
Are we computing max store set.
Are we computing the genset and killset.
Are we loading a value from an address in a struct defined at a point dominating the hoist point.
Are we performing dead store elimination.
Are we performing the actual DSE.
Arena 1, the low_malloc arena, also uses this setting, but that arena is not tuning-sensitive.
Arg isn't null, so treat it like the underlying type for coersion purposes.
ArgBB is not the entry block and has predecessors.
ArgBB is the entry block.
ArgSpecialDest isn't copyable, so we can't just use append.
Args should be a list of pairs, the first number is a TypeID, the second number is a ValueID.
Argument extraction and printing.
Argument labels are not correct.
Argument list mismatch.
Argument to pass to function
Arguments are section name, cookie, and stage name.
Arguments of the new StringLiteralInst to be created.
Arithmetic ops that overflow ints to floats
Arrange for convenient computation of quotients: shift left if necessary so divisor has 4 leading 0 bits.
Arranging for additional bytes to be discarded before reloading the input buffer is the application writer's problem.
Array address uses are safe if they don't store to the array struct.
Array comparisons can produce arbitrary side-effects, so we can only eliminate the comparison if its checking for sameness.
Array count calls that are dead as a consequence of propagating the count value.
Array downcasts are handled specially.
Array for named subpatterns
Array for subpatterns
Array get_element calls and their matching array element value for later replacement.
Array is always greater than everything else.
Array loads and stores
Array of subpattern offsets
Array semantic clients rely on the signature being as in the original version.
Array value projection.
Array, possibly for collection initialization.
Array-to-pointer conversions are better than inout-to-pointer conversions.
Array/Dictionary elements are siblings to align with each other.
ArrayData objects could be static
ArrayData* Append(ArrayData*, Cell v, bool copy)  Append a new value to the array, with the next available integer key.
ArrayData* Copy(const ArrayData*)  Explicitly request that an array be copied.
ArrayData* CopyStatic(const ArrayData*)  Copy an array, allocating the new array with malloc() instead of from the request local allocator.
ArrayData* CopyWithStrongIterators(const ArrayData*)  Explicitly request an array be copied, and that any associated strong iterators are moved to the new array.
ArrayData* Escalate(const ArrayData*)  Arrays must be given a chance to 'escalate' to more general kinds prior to some unusual operations.
ArrayData* EscalateForSort(ArrayData*, SortFunction)  Must be called before calling any of the sort routines on an array.
ArrayData* Merge(ArrayData*, const ArrayData* elems)  Perform part of the semantics of the php function array_merge.
ArrayData* PlusEq(ArrayData*, const ArrayData* elems)  Performs array addition, logically mutating the first array.
ArrayData* Prepend(ArrayData*, Cell v, bool copy)  Insert `v' as the first element of the array.
ArrayData* RemoveInt(ArrayData*, int64_t key, bool copy)  Remove an array element with an integer key.
ArrayData* RemoveStr(ArrayData*, const StringData*, bool copy)  Remove an array element with a string key.
ArrayData* SetInt(ArrayData*, int64_t key, Cell v, bool copy)  Set a value in the array for an integer key.
ArrayData* SetStr(ArrayData*, StringData*, Cell v, bool copy)  Set a value in the array for a string key.
ArrayData::m_size is a uint32_t but we need to do a 64-bit comparison since idx is KindOfInt64.
Arrays are safe if there is no function call that could mutate their size in the loop.
Arrays can be specialized in different ways, here we check if the constant array fits the kind()/type() of the specialization of rhs, if any.
Arrays can contain an element with NaN, so only equality comparisons can be negated.
Arrays of arrays are not allowed.
As ASI is an operand of ASIUser, SingleWrite dominates ASIUser if it is in the same block as ASI or ASIUser.
As a consequence of being called via callfaststub, we can't safely use any Vregs here except for status flags registers, at least not with the default vwrap() ABI.
As a debugging hack, print the instruction itself if there is no location information.
As a fast path, if there is no override, definitely no thunk is necessary.
As a hack to avoid completely redoing how the module is indexed, we take the simple-name-based lookup then filter by the compound name if we have one.
As a hack, assume class archetypes never have spare bits.
As a hack, scan the decl to find out if any of the variables are immutable, and if so, we print as 'let'.
As a hack, we look at the text of the result type and look for 'Void'.
As a placeholder give them the / location of the newly cloned function.
As a precaution, bail out if we have a self-loop.
As a result of removing these arguments, remove any newly dead object projections.
As a result of trait flattening, the PreClass of this normal class contains a requirement.
As a result, only the day number of the start of the year is required.
As a result, put the frontend into EmitModuleOnly mode.
As a result, substitutions provided by AI are for Member, whereas substitutions in ClassInstanceType are for D2.
As a result, we can't reliably distinguish member functions for static functions on clang.
As a safety net, if an address is provided, but its abnormally low, ignore it.
As a sop to error cases, allow the name to have an empty string.
As a special case, Clang functions and globals don't get mangled at all.
As a special case, an ErrorProtocol existential can be represented as a reference to an already existing NSError or CFError instance.
As a special case, an initializer with a single, named parameter of type '()' is always representable in Objective-C.
As a special case, assume NSObject has a fixed layout.
As a special case, diagnose conversion to NilLiteralConvertible, since we know this is something involving 'nil'.
As a special case, don't introduce a local variable for Builtin.UnsafeValueBuffer, which is not copyable.
As a special case, functions can have manually mangled names.
As a special case, if all the classes are potentially hoistable, we don't list them twice, but instead iterate over them again.
As a special case, mangle nothing if there's a single generic parameter at the initial depth.
As a special case, return 0 if an ordinary "syntax error" message will do.
As a special case, when we're injecting the result of an ObjC constructor into an optional, do it using an unchecked bitcast, which is opaque to the optimizer.
As above, assume that we don't need to reabstract 'self'.
As above, but opcode was already 1 byte, so the reduction is only 3 bytes this time.
As above, the Objective-C runtime will slide the field offsets within the class metadata to adjust for the superclass size.
As addErrorDomain above, but performs a lookup
As all registers are 64-bits wide, a smaller number from the memory should have its sign extended after loading except for the 'z' vasm variants
As an additional complication, the linkage of any nested class is inherited from its parent, so when a template's linkage changes, it must be bubbled down to any of its nested classes.
As an example, consider PtrToRMembInt - PtrToRefStr.
As an optimization, avoid actually building a TypeInfo for any obvious TupleTypes.
As an optimization, we do want to perform direct accesses of stored properties declared inside the same resilience domain as the access context.
As append, but skip a repeated word at the boundary.
As currently written, it also works on non-ssa input.
As eval_const, but don't divide/mod by zero at compile time.
As far as the linetable is concerned, cleanups at the end of a lexical scope should point to the cleanup location, which is the location of the last instruction in the basic block.
As include() and require() support streams, we sometimes need to look up a wrapper outside of a request - eg in HPHP::lookupUnit when using StatCache.
As it holds references to request-allocated data, this leads to intermittent segfaults.
As it's being closed, we can't actually do anything with filter output
As long as DefInlineFP exists, FramePtr SSATmps aren't truly SSA.
As long as any secondary blocks are inserted after the current IP instead of at the end of the function, we're fine.
As long as it's a pointer type it doesn't matter exactly which for either ABI type generation or standard Obj-C type encoding, but protocol extended method encodings will break.
As long as you retain this notice you can do whatever you want with this stuff.
As per curl docs, an empty post must set POSTFIELDSIZE to be 0 or the reader function will be called
As slaveOkay really only means "read from any secondary" that does not conflict.
As specializations are created, the attributes should be removed.
As stated above, layout is a description of a particular scanner.
As stated above, the linkage of templates is tricky.
As such, all elements must be initialized and super.init must be called.
As such, if we're continuing a non-case pattern, do a bit more lookahead to disambiguate this.
As such, the body of the 'defer' is actually type checked within the closure's DeclContext.
As such, the string will be freed at the end of the request.
As such, there is a 7/8 chance that last few bytes will be held by the compressor.
As such, we have no choice but to map functions like strtod_l, which should respect the given locale_t parameter, to functions like strtod, which do not.
As such, we have to push the releases up the CFG to where the / value is initialized.
As such, we need to allow formation of the address for this captured value.
As such, we only remove allocations if:
As the code stands, it will do the right thing for R,G,B and B,G,R orders.
As the fact that it's not really a socket is an implementation detail, user code needs to be able to call shutdown on it.
As the tile image can contain the same color as the color to fill.
As we do for other favored constraints, if a favored overload has been specified, let it be the first term in the disjunction.
As we do the coersions, params.value gets updated so whenever we call these catch block creation functions it will only decref things that weren't yet converted.
As we model the ref_element_addr instruction as a content-relationship, we have to go down one content level if just one of the values is a ref-counted object.
As we move into the range of mapped optionals, start lowering the depth.
As we remove the function from the table we have to store the name string elsewhere: in zombieFunctionNames.
As we visit blocks, we propagate states to their successors and across their back edges---when state merges cause a change to the block stateIn, we will add it to this queue so it gets visited again.
As we walk down the domtree, we / look to see if instructions are in this: if so, we replace them with what / we find, otherwise we insert them so that dominated values can succeed in / their lookup.
As will all I/O modules, most functions are for local use only (called via function pointers in the I/O context).
As with other optimizations a mandatory DCE must be performed after the module is run.
Ask curl_multi for its handles directly This is preferable as we get to know which are blocking on reads, and which on writes.
Ask every thread in this proxy's sandbox and the dummy sandbox to "stop".
Ask for uncompressed data (a holdover from the original API).
Ask the ConformanceInfo to emit the wtable.
Ask the Objective-C runtime to name ObjC classes.
Ask the TaskQueue to execute.
Ask the enum implementation strategy to extract the enum tag as an integer value.
Ask the handler (that can be an analysis, a pass, or some other data structure) if it wants to receive delete notifications.
Ask the lexer to interpret the entire string as a literal segment.
Ask the parent module.
Ask the runtime for the unique metadata record we've canonized.
Ask the runtime to derive the tag index.
Ask the runtime to do our layout using the payload metadata and number of empty cases.
Ask the runtime to extract the dynamically-placed tag.
Ask the runtime to find the case index.
Ask the runtime to lay out the class.
Ask the runtime to lay out the struct.
Ask the runtime to set up the metadata record for a dynamic enum.
Ask the runtime to store an extra inhabitant.
Ask the runtime to store the tag.
Ask the runtime what case we have.
Ask the runtime whether this is class metadata.
Ask the target for the string.
Ask the value type for its mask.
Ask whether Builtin.UnknownObject uses native reference counting.
Asked for more than whole string, treat like len.isNull case
Assemble the parameter type list.
Assembler::fmov (which you'd think shouldn't be a macro instruction) will emit a ldr from a literal pool if IsImmFP64 is false.
Assert invocation with a primary file.
Assert that the current IR IP (if valid) is immediately prior to the initial IR block for the next primary SIL block.
Assert that the indirect results are set up like we expect.
Assert that the layout query functions for fixed-layout enums work, for LLDB's sake.
Assert that the optional value is present.
Assert that the size passed into the scanner is a multiple of the type size.
Assert that two types are equal.
Assert that we consumed and produced all the indirect result information we needed.
Assert that we copied the extra prefix data from the superclass.
Assert that we copied the shared prefix data from the subclass.
Assert that we copied the subclass suffix data.
Assert that we set the superclass field.
Assert to check this and return.
AssertRAT* instructions can appear while these values are live but they will never throw.
Asserting in these situations doesn't add any information.
Asserting them now so they are revisited here if they aren't true anymore.
Asserts / that there are at least so many characters.
Asserts if an instruction mutates `sp' in an untrackable way.
Asserts that / there is at least one remaining character.
Asserts that there is at / least one remaining character.
Assign "wide" locations when possible (when all uses and defs can be wide).
Assign a debug scope pointing into the void to the top level function.
Assign a level number to each node in the post-dominator tree, and
Assign a unique ID to each basic block of the SILFunction.
Assign a value ID to each SILInstruction that has value and to each basic block argument.
Assign all of the member variables appropriately.
Assign an even numbered position to every instruction.
Assign and copyaddr of trivial types cannot drop refcounts, and 'inits' never can either.
Assign consecutive subindices for nodes which map to the same value.
Assign counters for cases so they're available for fallthrough.
Assign each indexed type its appropriate index into the list.
Assign fixed types to the type variables solved by this solution.
Assign from the local variable to the inout address with an 'autogenerated' copyaddr.
Assign lowering may split the block.
Assign slots, keeping track of the largest assigned slot and the total number of uses for each slot.
Assign the cleanup location to this instruction.
Assign the next available spill slot to `ivl'.
Assign the rest of the source elements parameter types that will cause the recursive walker to ignore them.
Assign the same IDs to SILValues as the SILPrinter does.
Assign tmp2 into storage.
Assign virtual registers to all SSATmps used or defined in reachable blocks.
Assigning to YYVAL unconditionally makes the parser a bit smaller, and it avoids a GCC warning that YYVAL may be used uninitialized.
Assignment has fixed precedence.
Assignment to a StaticString is ignored.
AssignmentExpression::onParseRecur essentially adds constants to the constant table so we skip it.
Assigns ids to all of the local variables eagerly.
Associate the given replica set name with all the server definitions from the seed
Associate the loop body's closing brace with this branch.
Associated type requirements handled above.
Associated types can inherit a class.
Assume "internal", which is the most common thing anyway.
Assume WMO, if a -primary-file option was not provided.
Assume all submodules are missing.
Assume anything else isn't a definition.
Assume at least two args because of PHP signature
Assume failure until we post-visit this node.
Assume implicit decl captures are OK.
Assume it may be important in C.
Assume largest possible
Assume local file if scheme is empty
Assume missing because value is too large.
Assume new array is on top of stack
Assume no part of the uname string will be more than 128 chars
Assume no promotion for string bases and promotion in other cases.
Assume that ArrayLiteralConvertible contains a single associated type.
Assume that a C-language API doesn't have substitution reabstractions.
Assume that any instruction with side-effects may depend on the RC_DEALLOCATING_FLAG flag.
Assume that casts to or from existential types or involving dependent types can always succeed.
Assume that it's a libmemcached behavior option
Assume that one tag bit is enough if the precise calculation overflows an int32.
Assume that the member only partially projects the enclosing value.
Assume that the returned 'self' is the appropriate subclass type (or a derived class thereof).
Assume that we are converting from a literal if the Source size is 2048.
Assume that we don't need to reabstract 'self'.
Assume the compiler knows what it's doing.
Assume the current eval stack matches that of the forward branch
Assume the error parameter doesn't have interesting lowering.
Assume whoever's doing this knows what they're doing.
Assumes Apply has already been type-checked.
Assumes exactly one of setMainExecutablePath() or setRuntimeIncludePath()  is called before setTargetTriple() and parseArgs().
Assumes it is not already attached.
Assumes len is a multiple of 4.
Assumes len is a multiple of 8.
Assumes that 0 bytes will be missing in the end.
Assumes that inst.source and inst.unit have been properly set.
Assumes that scopes contains no duplicate entries
Assumes two's complement representation.
Assuming that we've applied the same substitutions to both types, abstraction equality should equal type equality.
Assuming this lets us save an introducer character in the common case when a generic parameter is constrained.
Assuming uniform distribution, we'll expect to iterate through half of the array's data.
Assumption : low and high water mark are power of 2 aligned
Assumptions: AI substitutions contain first the substitutions for a class of the method being invoked and then the substitutions for a method being invoked.
Assumptions: Chars are 8 bits long.
Assure two bytes in the buffer so we can peek ahead -- handle case where first byte of header is at the end of the buffer after the last gzip segment
Async function has its own surprise check.
Async function support helpers
Async function wait handles may have a source location to add.
Async functions instructions
Async generators always return AsyncGenerator object.
AsyncFuncImpl defines a minimum C++ stack size but that only applies to threads we manually create.
AsyncMysqlClientStats
At -O0, create an alloca to keep the type alive.
At -O0, emit a shadow copy of an Address in an alloca, so the / register allocator doesn't elide the dbg.value intrinsic when / register pressure is high.
At EOF, write the rest of the buffer.
At Onone, consider all uses, including the debug_info.
At a first sight, a 100 rows at a time seemed a good start point.
At a minimum, compaction is required.
At each conditional assign, resolve the ambiguity by inserting a CFG diamond.
At each failure block, mark the self value as having been consumed.
At each initialization, mark the initialized elements live.
At each release point, release the reaching values that have been stored to this address.
At each step, we fetch from the PreClass is important because the order in which getMethods returns matters
At least 1 color must be allocated
At least confirmed for: OSF1 V4.0 878
At least one non-back edge predecessor.
At least one of the values must be a non-escaping local object.
At least one operand to OR must have the top bit set.
At least one predecessor.
At least one round of SSA optimization and inlining should run after this to take advantage of static dispatch.
At least one value feeding the specified SILArgument is a Struct.
At most one ASet will be supported by any location at a time, to fit the "exclusivity" condition on lower bounds.
At most one should exist in a given unit.
At most siz-1 characters will be copied.
At present, BaseSets only support int values and string values, so if this BaseSet is non empty and the iterable is non empty the zip operation will always fail
At some point the parser hack may have to go away.
At some point we will expand this to check for regions that are post dominated by unreachables.
At that stage, the function name GV used by the profiling pass is hidden.
At that stage, this code will have to change, as well as other parts of the debugger.
At the bottom of the hierarchy.
At the end of each block, propagate its out-state to successors, adding them to the worklist if their in-state changes.
At the end of the loop CommonSpareBits.size() will be the size (in bits) of the largest payload.
At the end of the request we clear the m_createdFunc map, JIT'ing the unit would be a waste of time and TC space.
At the final ActRec in this nesting level.
At the moment this handles only the identity function.
At the moment we can only add arguments to br and cond_br.
At the moment, I am unsure.
At the same time, compute exactly which stores are available at each point.
At the time of calling this function, we may not have the type of the / Decl yet.
At the top of the hierarchy, no more finally blocks to run.
At this occasion we record additional weight increases.
At this point by iterating through the decl context hierarchy we should have encountered the first type context in the stack.
At this point curN contains the 7/16 error value to be propagated to the next pixel on the current line, and all the errors for the next line have been shifted over.
At this point it is known that there is only one remaining method implementation which is not covered by checked_cast_br checks yet.
At this point it is safe to free memory, the source or even ourselves (if this is part of the destructor).
At this point it might help to go look at one or two of the transformation rule examples below (e.g. rule_inc_dec_fold), but that documentation is not duplicated here.
At this point the typeID (and field num, if applicable) should've already been written to the output so all we need to do is write the payload.
At this point there may be still some violations because of the new adjacent edges of the To node.
At this point we are executing as the child process
At this point we calculated the locations of all of the new Phi values.
At this point we have an interrupt, but we don't know if we're on the thread the proxy considers "current".
At this point we know for each predecessor of ArgBB if its reached over the success, failure or unknown path from DomBB.
At this point we know that the request thread is busy running, so we let it enter the jit.
At this point we know that we must have a release_value and a non-trivial payload.
At this point, "diff" is zero iff the correct and buggy algorithms produced exactly the same result.
At this point, all IR invariants must hold, because we've restored the only one allowed to be violated before fullDCE in prepareBlocks.
At this point, all the relocated code should be correct, and runable.
At this point, both t1 and t2 are of the same type category.
At this point, either the tested type is a subtype of the src type, or they are non-disjoint but neither is a subtype of the other.
At this point, if tupleInit is non-null, we must emit all of the elements into their corresponding contexts.
At this point, the arguments of the first BB will not match.
At this point, the layouts in the indexed types are correct.
At this point, there is not enough information to attach a sandbox.
At this point, valTempLocal and keyTempLocal if applicable, contain the key and value for the iterator.
At this point, we are performing a partial dead store elimination.
At this point, we can perform general name lookup into any type.
At this point, we can remove the instruction as long as all of its users can be removed as well.
At this point, we definitely know which types will be conservative scanned or not, so we do not need the guards anymore.
At this point, we have 3 possibilities:
At this point, we know that the next thing should be a pattern to follow in the series.
At this point, we know that this element satisfies the definitive init / requirements, so we can try to promote loads to enable SSA-based dataflow / analysis.
At this point, we know that we have *some* NoPayloadEnums.
At this point, we know we have a closure signature.
At this point, we must have a type with the builtin member.
At this point, we will need additional characters from the string to proceed.
At this point, we've either failed to find any epilogue retains or all the post-dominating epilogue retains.
At translation time, we don't necessarily know what function we're calling.
At various points we may walk the rbp chain to do such things as generate backtraces.
Atomically compare-exchange a pointer to our vector into the slot.
Atomically rename the file into its final location.
Atomically swap in bi, but delete it if this this thread loses the initialization race.
Attach an objc_runtime_name attribute with the Objective-C name to use for this class.
Attach an objc_runtime_name attribute with the Objective-C name to use for this protocol.
Attach succeed, wait for next interrupt
Attach the foreign error convention.
Attach the parameters to the closure.
Attempt a conditional cast without destroying on failure.
Attempt again using the up-to-date AST.
Attempt batch commit.
Attempt read-only lookup of cache entry.
Attempt to / replace the Argument with a new Struct in the same block.
Attempt to backward propagate.
Attempt to create a region at this SrcKey
Attempt to demangle the source string.
Attempt to derive the witness.
Attempt to diagnose a failure without taking into account the specific / kind of expression that could not be type checked.
Attempt to diagnose a specific failure from the info we've collected from / the failed constraint system.
Attempt to diagnose problems where obvious aliasing introduces illegal code.
Attempt to dig the apply out from this result.
Attempt to discover the size and alignment of the given type.
Attempt to emit code for the given IRUnit to `code'.
Attempt to find a specific callee for the given conformance and member.
Attempt to find a superclass for the given CF typedef.
Attempt to find the unit/line combo
Attempt to forward CurrentDef to all uses of the copy's value.
Attempt to forward, then backward propagate this copy.
Attempt to generate scanner automatically.
Attempt to get the instance for S, whose static type is the same as its exact dynamic type, returning a null SILValue() if we cannot find it.
Attempt to hoist a destroy point up to the last use.
Attempt to import all modules we found.
Attempt to infer stream type only if it was not explicitly specified.
Attempt to initialize our state with our first predecessor's state by just copying.
Attempt to load the VTable from the SerializedSILLoader.
Attempt to lookup our name from the output module.
Attempt to lookup the Vtbl from the SILModule.
Attempt to lookup the witness table from the table.
Attempt to merge Other into this ref count state.
Attempt to omit needless words from the given function name.
Attempt to open optional log file
Attempt to open the passed filename.
Attempt to parse the input.
Attempt to peek at one byte from the stream, checking for: i)  recv() closing gracefully, or ii) recv() failed due to no waiting data on non-blocking socket.
Attempt to perform the breakpoint, detach the server if something goes wrong
Attempt to produce a diagnostic for a mismatch between an expression's / type and its assumed contextual type.
Attempt to put it into our arc opts map.
Attempt to re-type-check the entire expression, allowing ambiguity, but ignoring a contextual type.
Attempt to read the default witness table.
Attempt to read the witness table.
Attempt to refer to 'Self' within a non-protocol nominal type.
Attempt to remove the array allocated at NewAddrValue and release its refcounted elements.
Attempt to resolve a type witness via a specific value witness.
Attempt to resolve a type witness via member name lookup.
Attempt to resolve a witness via derivation.
Attempt to resolve this nested type to an associated type of one of the protocols to which the parent potential archetype conforms.
Attempt to simplify the ith argument of BB.
Attempt to solve again, capturing all states that come from our attempts to select overloads or bind type variables.
Attempt to solve the constraint system.
Attempt to specialize each apply we collected, deleting any that we do specialize (along with other instructions we clone in the process of doing so).
Attempting to use better types when not in a situation like this would just make the compiler complacent, leading to a long tail of undiscovered crashes.
Attempts to attach the xdebug profiler to the current thread.
Attempts to avoid / unnecessary copies by emitting the payload directly into the enum / payload, or into the box in the case of an indirect payload.
Attempts to load the default idekey from environment variables
Attempts to return a constant heap metadata reference for a / class type.
Attempts to return a constant type metadata reference for a / nominal type.
AttrPublic bits are not valid on class (have other meaning)
Attribute visitor that checks how the given attribute should be / considered when overriding a declaration.
Attribute with no content in it's text node
Attributes like cc(x,y,z)
Augmentation data length.
Authenticates a connection  Returns 1 when it worked, or 0 when it didn't - with the error_message set.
Auto import a few functions from the HH namespace TODO(#4245628): merge those into m_fnAliasTable
AutoClosureExpr is introduced by CSApply.
Autoclosure may imply noescape, so add a noescape attribute if this is a function parameter.
Autoclosures aren't recursively referenceable, so their special treatment isn't a problem for this.
Autoclosures look strange if there isn't a region, since it looks like control flow starts partway through an expression.
Autoclosures need to be numbered and potentially reparented.
Autoload succeeded, try to grab a typedef and if that doesn't work, a class.
Automatically generate a global symbol name if it is required by the calling convention.
Automatically register FastCGIServerFactory on program start
Automatically register ProxygenServerFactory on program start
Autorelease a return value.
Autorelease the 'self' value to lifetime-extend it.
Auxiliary macros to handle vasms with different attributes
Availability of elements within the block.
AvailabilitySet - This class stores an array of lattice values for tuple / elements being analyzed for liveness computations.
Available since 7.10.6
Available since 7.10.7
Available since 7.10.8
Available since 7.11.0
Available since 7.11.2
Available since 7.12.2
Available since 7.12.3
Available since 7.13.0
Available since 7.14.1
Available since 7.15.0
Available since 7.15.1
Available since 7.15.2
Available since 7.15.3
Available since 7.15.4
Available since 7.15.5
Available since 7.16.0
Available since 7.16.1
Available since 7.16.2
Available since 7.16.3
Available since 7.16.4
Available since 7.17.0
Available since 7.17.1
Available since 7.18.0
Available since 7.18.2
Available since 7.19.0
Available since 7.19.1
Available since 7.19.3
Available since 7.19.4
Available since 7.19.6
Available since 7.20.0
Available since 7.21.0
Available since 7.21.2
Available since 7.21.3
Available since 7.21.4
Available since 7.21.6
Available since 7.22.0
Available since 7.24.0
Available since 7.25.0
Available since 7.34.0
Available since 7.37.0, PHP doesn't currently support these
Available since 7.43.0
AvailableValues - This scoped hash table contains the current values of / all of our simple scalar expressions.
Avoid "Possible bad confg node" warning for unused keys.
Avoid 'this' pointer overwriting by reserving it as an argument.
Avoid SIGFPE when dividing the miniumum respresentable integer by -1.
Avoid a weird leak warning in debug mode when freeing the stream
Avoid a weird race: two threads come through at once, the first gets as far as binding propHandle, but then sleeps.
Avoid cloning destroy_addr instructions and splitting critical edges before mandatory diagnostic passes.
Avoid colors here, we don't properly detect that the debug window inside Xcode doesn't support colors.
Avoid confusion from exponents so large that e might overflow.
Avoid creating a prefix where the rest of the string starts with a number.
Avoid creating negative-weight arcs.
Avoid duplicate invalidations for non-links.
Avoid duplicate invalidations.
Avoid emitting a delayable definition if it hasn't already been referenced.
Avoid floating point comparison issues by doing a bitwise comparison.
Avoid including the iso646.h header because some headers from OS X frameworks are broken by it.
Avoid indexing the indices, only walk the getter/setter.
Avoid indirect call, as we know it is a MixedArray
Avoid indirect call, as we know it is a packed array.
Avoid iterating the list, as abort() will unlink(), leaving the list iterator in a corrupt state.
Avoid killing and re-emitting the cleanup if the enclosed value isn't a tuple.
Avoid later argument label fix-its for this argument.
Avoid possible race condition
Avoid printing the code twice in such cases.
Avoid race condition, we may (likely) finish destructing before the timeout cancels
Avoid raw_ostream's write_escaped, we don't want to escape unicode characters because it will be invalid JSON.
Avoid realloc() most cases
Avoid reprocessing functions needlessly.
Avoid running PHP code when exception from destructor is pending.
Avoid running PHP code when unwinding C++ exception.
Avoid soft deadlock: do not read if there is nothing to read from sockets and pipes.
Avoid sprintf, as that infringes on the user's name space.
Avoid tail-call optimization which may convert the call to the final release to a jump, which is done after the stack frame is destructed.
Avoid trying to generate a USR for some declaration types.
Await / Yield opcodes mark a suspend points of async functions and generators.
Await child and suspend the async function/generator.
Await the next value.
AwaitAllWaitHandle::fromArray() always returns a WaitHandle.
Awkwardly munge absolute filenames into a vector of StringRefs.
B range is +/- 128MB but this uses BR
B.cond range is +/- 1MB but this uses BR
BB is either unreachable or not in a loop.
BC: Close master when no arguments passed
BEGIN Facebook: json_utf8_loose
BEGIN WebServerResponse
BEL BS HT LF    FF CR
BLA doesn't work here
BS2000 uses the EBCDIC char set instead of ASCII
BSD-derived systems set errno correctly Solaris returns -1 from getsockopt in case of error
BSD/OS X has localeconv_l, which actually returns data held onto by the locale itself -- and since that's thread-local (since this object instance is) we can just use that.
BUG: should also map here accented letters used in non
Back to analyzing the candidate list with self applied.
Back up from the current location until we hit the beginning of a line (or the buffer).
BackedgeBlock: br HeaderBlock:
Backing storage for Swift.Process.arguments.
Backpatch instances of __COMPILER_HALT_OFFSET__
Backward pass that weakens DecRefs to DecRefNZ if they cannot go to zero based on future use of the value that they are DecRefing.
Bad UTF-8 sequences are converted to valid Tcl_UniChars and processing continues.
Bad compressed data stream
Bad or unexpected data.
Bail early if this isn't a push.
Bail if a value of a property is not a statically known constant init.
Bail if any generic types parameters of the class instance type are unbound.
Bail if any generic types parameters of the concrete type are unbound.
Bail if has a shared visibility, as there are no guarantees that an implementation is available elsewhere.
Bail if it is a declaration already
Bail if it is not a required linkage.
Bail if nothing was found and we are not sure if this function exists elsewhere.
Bail if string literal concatenation could not be performed.
Bail if the cases aren't homogeneous
Bail if the cast between the actual and expected return types cannot be handled.
Bail if the signature has any dependent types as we do not currently support these.
Bail if the source type is not a class reference of some kind.
Bail if there is any unknown (and potentially writing) instruction.
Bail if there is no external implementation of this function.
Bail if this address is stored to another object.
Bail if this class_method cannot be devirtualized.
Bail if we couldn't find the method or __call
Bail if we have an instruction which may read the RC_DEALLOCATING_FLAG flag.
Bail if we have multiple "once" calls in the addressor.
Bail if we're trying to do a recursive count()
Bail on multiple payloads.
Bail out conservatively if this isn't a function declaration.
Bail out early if we don't have polymorphic parameters.
Bail out if an unexpected error occurred.
Bail out if current BB cannot be duplicated.
Bail out if our parent isn't the swift standard library.
Bail out if string literals concatenation optimization is not possible.
Bail out if there are any errors.
Bail out if we couldn't find the method or __call
Bail out if we didn't resolve method witnesses.
Bail out if we didn't resolve type witnesses.
Bail out if we found an instruction that we can't handle.
Bail out immediately if the set is empty.
Bail out immediately on a void result.
Bail out on other kinds of contexts.
Bail out so the general ambiguity diagnosing logic can handle it.
Bail, if the lookup of VTable fails.
Bail, if there is no self argument.
Bail, if this struct is known to contain nothing interesting.
Ban value-to-optional conversions.
Bare functions and thunks should not have any line numbers.
Base cases for the various stages of verification.
Base class constraints are introduced by a class type mangling, which will begin with either 'C' or 'S'.
Base implementation for fixed-sized boxes.
Base is not a string.
Base might be a string.
Base native property handler class, that is reused by derived DOM classes with the similar handling.
Base offsets must be monotonically increasing.
Base the plan on whether the single result is direct or indirect.
Base value still unknown, this will need to be updated later.
BaseSC and BaseSL may push back a C that was on top of the A they removed.
BaseSC and BaseSL remove an A that may be on the top of the stack or one element below the top, depending on the second immediate.
Based on GD.pm code by Lincoln Stein for interfacing to libgd.
Based on an algorithm by Mark Rabkin with two changes: 1) Uses MurmurHash64A to hash the original key and to generate additional bits by recursively rehashing.
Based on netpbm fixes by Alan Cox.
Based on that, compute an overload set.
Based on the constraints we have, build up a representation of what we expect the adjacencies to look like.
Based on the induction variable information this comparison is known to be / true.
Based on the status, we pick a different exception class.
Basic block of the current checked_cast_br instruction.
Basic blocks to be added to for reprocessing after jump-threading is done.
Basic layout and common operations for box types.
Basic relationship between the class types and object types.
Basic ripemd function
Basic: display-string
Basically this check is to make sure that we autoprime delegate generators when needed, and not if they're shared.
Basically this is doing dynamic dispatch without a vtable in IRExtraData, instead using the Opcode tag from the associated instruction to discriminate the runtime type.
Basically, CallBuiltin observes the reference count (at level 2) for their possibly-boxed args, even though they can't decref the pointer through the memory locations for those args.
Be careful between here and the updateMarker() below, where the caller state isn't entirely set up.
Be careful not to delete the region's entry block.
Be conservative and don't zap it.
Be conservative and return MayAlias.
Be conservative and return false.
Be conservative and return that V1, V2 may alias.
Be conservative for everything else.
Be conservative for now.
Be conservative if the dest may be the final release.
Be less specific about the previous definition.
Be nice and preserve the current debug location until after we're done with this function.
Be robust against manually crafted inputs with conflicting elements
Be sure not to consume the cleanup for an inout argument.
Be sure to use a CleanupLocation so that unreachable code diagnostics don't trigger.
Because PHP callees can side-exit (or for that matter throw from their prologue), the program is ill-formed unless we have balanced reference counting for all memory locations.
Because PHP is insane you can have a use variable with the same name as a param name.
Because catch bodies can only be executed if the do body throws an error, and because the do is non-exhaustive, we can skip checking the catch bodies entirely.
Because fcall is a variable length instruction, and because we sometimes delete instructions from the instruction stream, we need to use fpi regions to find the fcall.
Because it can appear in PHP expressions, the emitter pretends that it pushed a value on the eval stack (and iopExit actually does push Null right before throwing).
Because it only has a read lock on the data, deletion from expiration has to happen after the lock is released
Because more decls may be added to the SourceFile, we can't assume anything about the compilation context.
Because of how we build MustAliasSets (essentially canonical(), or groups of LdCtx instructions), it is guaranteed that this widestType includes all possible values for the set.
Because of other codepaths, an un-normalized name might enter the table without a Class* so we need to check if it's there.
Because of same-type requirements, these aren't well-ordered.
Because of the surprise page at the bottom of the stack we lose an additional 256 elements which must be taken into account when checking for overflow.
Because of the way that phi nodes are represented we have to collect all uses before we update SSA.
Because of this it pays to keep it separate from the other cases so they don't need to be littered with RepoAuthoritative checks.
Because of this we cannot add the stack positions within the inline function to the kill set here as they may be live having been stored on the main trace.
Because of this, Sema isn't able to rebuild it in terms of interface types.
Because only the first one that matches in the VirtualHosts vector gets applied and used.
Because our old lower bound is non-zero (from the memory support), we don't need to deal with the possibility of may-alias observes or may-alias decrefs here.
Because signals on Windows are fake, and because it doesn't provide sigaction(), we cannot rely on reraising the exception.
Because the body may be a compound statement, we may have to indent multiple lines.
Because the follow-up instructions need to reuse the same archetype uuid which would only work if we used a cloner.
Because the swift compiler relies on Clang to setup the Module, the clang CU is always created first.
Because these attributes might not be appertaining to the accessor, but to the first declaration inside the implicit getter, we need to save the parser position and restore it later.
Because these don't provide a human readable locale string as output, the implementation maintains a thread-local object to persist the currently active locale settings.
Because this intermediate value only needs 36 to 37 bits and the other numbers are constants, the process has been reduced to just a few steps.
Because this is a hot path, this keeps the overhead of the check low, and is twice as fast.
Because this object will be used by other classes, it needs to be ready ASAP.
Because type arguments are not actually translated separately, whether they are trivially representable or bridged representable doesn't impact our final result.
Because v1 was shared, we know this won't release it.
Because v1 was shared, we know this won't release the string.
Because we're transforming an existing tuple, the weird corner case where TupleType::get does not return a TupleType can't happen.
Before a "return," "continue" or similar statement, emit pops of all the braces up to its target.
Before a basic block is processed, it / is initialized to the intersection of BBWriteSetIns of all successors of the / basic block.
Before adjusting the stack or doing anything, check the suspend hook.
Before anything else, set up the 'self' argument correctly if present.
Before beginning the actual layout generation, we can speed things up a bit by marking any types which we know are always pointer followable.
Before being actually used, hphp_compiler_parse must be called with a NULL `code' parameter to do initialization.
Before doing so, strip attributes off the function type so that they don't confuse the issue.
Before parsing the body, disable all of the bound variables so that they cannot be used unbound.
Before recording substitutions, make sure we didn't end up doing it recursively.
Before the decision on whether taken branch is traversed, instructions may observe the reference count of their args.
Before the memory allocation, store zero in the control variable.
Before type checking, chains of binary expressions will not be fully parsed, so associativity has not yet been encoded in the subtree.
Before we begin emitting code to generate the actual path, try to find the latest point in the path that we've cached a value for.
Before we can call zend_strtod from zend compatibility extensions, we need to initialize it.
Before we can match a release with a retain we need to check that we have not already matched the release with a retain we processed earlier.
Before we create the preheader, gather all of the original preds of header.
Before we do, save the catch block attached to the call in a side table so the return helpers and unwinder can find it when needed.
Before we recurse mark the type as safe i.e if we see it in a recursive position it is safe in the absence of another fact that proves otherwise.
Before we start the webserver, make sure the entire binary is paged into memory.
Before we've done the fixed point analysis the states in the info structures are not necessarily meaningful.
Before we've inserted arrays into either a ArrayTypeTable::Builder or an actual ArrayTypeTable, they can't be compared just using their ids, so we have these.
Begin all the formal accesses for a set of inout arguments.
Begin by finding the "base" of V1, V2 by stripping off all casts and GEPs.
Begin by using loop info and loop region info to find all of the exiting regions.
Begin filters function
Begin rotate function
Begin the formal accesses to any inout arguments we have.
Begin walking a path from reg.
Begin with the 'self' value.
Beginning in 2.0.12 truecolor is indicated by the initial 2-byte signature.
Begins a ripemd128 operation, writing a new context.
Begins a ripemd160 operation, writing a new context.
Begins a ripemd256 operation, writing a new context.
Begins a ripemd320 operation, writing a new context.
Begins an MD5 operation, writing a new context.
Begins an SHA1 operation, writing a new context.
Begins an SHA256 operation, writing a new context.
Begins an SHA384 operation, writing a new context.
Behavior conformances are always private.
Behavior conformances can't be reflected.
Behaviors should be able to control whether they interact with memberwise initialization.
Being marked transparent controls this.
Bell filter, default radius 1.5
Belonging to an indexed type generally marks that the type is allocated on the req-heap (with one exception).
Below link discusses some numbers and formula where 16MB block would use only 6 extra bytes.
Below we compute retT, which is a rough conservative approximate of the intersection of stackT and tcT.
Besides self, don't suggest mutability for explicit function parameters.
Besides, if it is corrupt, the size might be messed up, too.
Best case scenario, user behaved
Between `r1' and `r2', choose the one whose position in `pos_vec' is closest to but still after (or at) `pos'.
Between different kinds of convenience initializers, keep the one that was introduced first.
Beware this doesn't call PlainFile::sweep().
Beware, if the data has been truncated, the final CR could have been followed by a LF.
Beyond here, we're using AnyObject.
Beyond that, this is identical to headers_list().
Big 5 mapping: use "JIS-8 half-width katakana" coding from 8-bit characters.
Bind a named pattern to a given value.
Bind a refutable wildcard pattern to a given value.
Bind a tuple pattern by aggregating the component variables into a TupleInitialization.
Bind a variable into the current scope.
Bind all the archetype access paths.
Bind all the fulfillments we can from the formal parameters.
Bind all the irrefutable patterns in the given row, which is / nothing but wildcard patterns.
Bind all the irrefutable patterns in the given row, which is nothing / but wildcard patterns.
Bind all the refutable patterns first.
Bind all the static prop handles.
Bind an UnresolvedDeclRefExpr by performing name lookup and / returning the resultant expression.
Bind an incoming address value to a SILArgument's LLVM phi node(s).
Bind an incoming explosion value to a SILArgument's LLVM phi node(s).
Bind an incoming explosion value to an explosion of LLVM phi node(s).
Bind an irrefutable wildcard pattern to a given value.
Bind arguments for cases that want them.
Bind local type data from the metadata argument.
Bind local type data from the metadata arguments.
Bind necessary bindings, if we have them.
Bind operator functions to the corresponding operator declaration.
Bind polymorphic arguments.
Bind the 'Self' type from the first extension to the type parameter from opening 'Self' of the second extension.
Bind the 'Self' type variable to the provided type.
Bind the associated types.
Bind the current process to a specified CPU.
Bind the declaration's generic context for nested decls.
Bind the error result by popping it off the parameter list.
Bind the generic arguments.
Bind the generic parameters from that.
Bind the generic parameters from the given list and its parents.
Bind the given function declaration, which declares an operator, to / the corresponding operator declaration.
Bind the member's type variable as a type member of the base.
Bind the metadata instance to our local type data so we use it to provide metadata for generic parameters in field types.
Bind the rest of the patterns.
Bind the specified generic arguments to the type variables in the open type.
Bind the stream to a local address
Bind the type variable.
Bind the value, branching to the destination address if there's no value there.
Bind them together into a single tuple.
Bind things from 'self' preferentially.
Bind this parameter to the argument.
Bind to a named pattern by creating a memory location and initializing it with the initial value.
Bind to a random cpu so that we can use rdtsc instruction.
Bind type metadata for Self.
Bind type1 to Void only as a last resort.
BindParam constraints are not reflexive and must be treated specially.
Binding an operator overloading to a generic operator is weaker than binding to a non-generic operator, always.
Binding default dependenant on whether we are using an OSS build or not, and that is set at initialization time of CoreDumpReportDirectory.
Bindings are only necessary at all if the type is dependent.
Bindings specify the arguments that source the parameter.
Bit 0 is reserved as an 'initialized' flag
Bit 0 is reserved to indicate whether or not the rest of the bits are initialized yet.
BitVector manipulation functions.
Bitcast an arbitrary pointer to be a pointer to this type.
Bitcast indirect argument pointers to the right storage type.
Bitcast it to the class reference type.
Bitcast of non-negative is non-negative
Bitcast of zero is zero.
Bitcast the incoming class reference to ErrorProtocol.
Bitcast the temporary to the expected type.
Bitcast to swift.refcounted*, and hand to swift_release.
Bitcast to swift.refcounted*, and retain the pointer.
Bitfields are currently never mapped, but that doesn't mean we don't have to copy them.
Bitfields are imported as computed properties with Clang-generated accessors.
Bitset of Vreg numbers.
Bizaarly, comparison against a string is done by converting both the string and the resource to a double and comparing the two.
Bizarrely, comparison against a resource is done by converting both the string and the resource to a double and comparing the two.
Blacklist the location
Blame conformance failures on the containing type.
Block and function pointers.
Block any threads that might be interrupting from communicating with the client until we're done with this poll.
Block ourself until we are released to start working.
Block pointer types are mapped to function types.
Block storage types need to substitute their capture type by these same rules.
Block the threads we are about to create.
Block-local environment.
BlockState summarizes how LSLocations are used in a basic block.
Blocking until Ctrl-C is issued by end user and DebuggerProxy cannot find a real sandbox thread to handle it.
Blocks are ObjC objects, so can share the Builtin.UnknownObject value witnesses.
Blocks are ObjC objects.
Blocks are not imported (although block types can be imported).
Blocks change in all sorts of ways, due to bridging.
Blocks do not have subregion data, so everything should just clean up via RAII.
Blocks may be visited multiple times if loops are present.
Blocks must be non-empty.
Blocks should only take direct +0 parameters.
Blocks take their context argument first.
Blocks where the value is live at the end of the block and which have a frontier block as successor.
Bodies of public transparent and always-inline functions are serialized, so use conservative access patterns.
Bonus for matching the beginning of the candidate.
Bonus if the match is the first or second token.
Bool to Int conversion
Boolean is a special case.
Bootstrap the PhantomJS scope
Borrow the base for the getter.
Borrow the context archetypes from the enclosing function.
Borrow the mangling scheme from reabstraction thunks, which is what we are in spirit.
Borrow the parameters from the requirement declaration.
Borrowed from proxygen
Both IP and PORT provided
Both PHP and libcurl are documented as return 0 to continue, non-zero to abort, however this is what Zend actually implements
Both TrackVtsc and TrackCPU mean "do CPU time profiling".
Both are bitsets, including cases when one is empty.
Both blocks must be in a loop otherwise the split block is outside the loop.
Both formats are cool
Both have data, and the intersection allows it, so it depends on what the data says.
Both input and output are exploded tuples, easy case.
Both instructions need to exist.
Both members are in protocol extensions.
Both names were provided, so pass them in directly.
Both of these allocations/projections should be no-ops.
Both of these can be found by considering only the corners of the box.
Both operands to AND must have the top bit set for V to.
Both passes are idempotent and can be run independent of other modules.
Both ranges must be considered before we can decide which function we're after.
Both return and parameter adjustments.
Both source and target type are ObjC types.
Both source and target type are Swift types.
Both tRNS and true alpha are supported.
Both the code that is used to set up a closure object and the (beginning of) the closure itself has the AbstractClosureExpr as location.
Both the condition and the increment are reached through the backedge.
Both the key and value types need to be bridged.
Both the left- and right-hand sides are implied, so determine where the conformance should go.
Both types are not optional.
Both types are optional.
Both types are unique classes so they "could be" if they are in an inheritance relationship
Both types need to be valid.
Both types of DCE here need to be type-aware, but they must visit blocks backward.
Both ways go to the same block.
Both, key and value can also be copy_addr instructions.
Bottom is a subtype of everything, nothing couldBe Bottom, and the union_of anything with Bottom is itself.
Bound closures should be scoped.
Bound generic types are invariant.
Bound generic types have type arguments.
Bound variables all get their initial values from the generator.
Bound variables can be changed to mutable explicitly if desired by using a 'var' pattern.
Boundary markers that indicate the beginning and end of a token stream.
Bounds of source pixels window
Boutell almost a simple global replace from T.
Box `v' if it is not already boxed, and then insert a KindOfRef that points to v's RefData.
Boxed bases may have their inner value changed but the value of the box will never change.
Boxes are always native-refcounted.
Boxes have to be deallocated even if the payload was consumed.
Boxes themselves can be contained within "super-boxes".
Branch based on that.
Branch instructions are not user code.
Branch on the boolean based on whether we're testing for true or false.
Branch on the success of the cast.
Branch on whether the input is optional, this doesn't consume the value.
Branch straight to the destination.
Branch to the cleanup destination.
Branch to the continuation block.
Branch with the result as a BB argument.
Branches can be handled trivially and CondBranch edges can be split.
Break down a struct expansion if necessary.
Break down an expression that's the formal argument expression to / a builtin function, returning its individualized arguments.
Break down structural types so that we don't eagerly pass metadata for the structural type.
Break down the time with localtime and subtract the number of seconds since the start of the period.
Break down the values.
Break if block is not the first and it corresponds to the main function body entry.
Break if region would be larger than the specified limit.
Break infinite recursion when visiting ill-formed classes with circular inheritance.
Break intentionally missing
Break off a chunk of the mask.
Break off a piece of the mask and value.
Break out if the line is no longer the same.
Break out of for loop
Break out of the while loop so that we can fall through to the to the call the the PHP5 autoload impl below.
Break out otherwise we end up appending an empty token to the end of the array
Break out the parameters.
Break out to handle the actual construction below.
Break out when the end-tag is found
Break the conversion into three stages: 1) changing the representation from foreign to native 2) changing the signature within the representation 3) changing the representation from native to foreign
Break the dependency chain by zeroing out the XMM reg.
Break the inheritance cycle for a class by removing its superclass.
Break the inheritance cycle for a protocol by removing all inherited protocols.
Break the inheritance cycle for an enum by removing its raw type.
Break these apart and check them separately.
Break ties in extensions by putting smaller extensions last (in reverse order).
Break type name ties by mangled name.
Break up the source r-value.
BreakIterator parts iterator
BreakIterator's iterator
Breakpoint displays the current file/line number
Breakpoint id must be provided
Breakpoint manipulation
Bridge Bool back to ObjC bool, unless the original Clang type was _Bool or the Darwin Boolean type.
Bridge Bool to ObjCBool or DarwinBoolean when requested.
Bridge ErrorProtocol to a foreign error type.
Bridge Objective-C to thick metatypes.
Bridge a native function to a block with a thunk.
Bridge a result type.
Bridge all the arguments.
Bridge an optional foreign error type to ErrorProtocol.
Bridge argument types and adjust retain count conventions for an ObjC thunk.
Bridge blocks back into native function types.
Bridge input and result types.
Bridge native functions to blocks.
Bridge retain may modify the input reference before forwarding it.
Bridge the arguments.
Bridge the base to its corresponding Objective-C object.
Bridge the given Objective-C object to its corresponding Swift / value, using the appropriate witness for the / _ObjectiveCBridgeable._unconditionallyBridgeFromObjectiveC requirement.
Bridge the given Swift value to its corresponding Objective-C / object, using the appropriate witness for the / _ObjectiveCBridgeable._bridgeToObjectiveC requirement.
Bridge the given object from Objective-C to its value type.
Bridge the given value to its corresponding Objective-C object / type.
Bridge the input types.
Bridge the parameters.
Bridge the result back to ObjC.
Bridge the source value to an object.
Bridge thick to Objective-C metatypes.
Bridge via _ObjectiveCBridgeable.
BridgeObject exposes only null as an extra inhabitant for enum layout.
Bridgeable object types are interchangeable.
Bridging casts cannot be further simplified.
Bridging from a value type to an Objective-C class type.
Bridging from an ErrorProtocol to an Objective-C NSError.
Bridging from an Objective-C class type to a value type.
Bring the parameter to +1.
Brotli does not have a utility to compute max size of the buffer in case data is incompressible.
Buffer for error messages, and its allocated size.
Buffer like gray8 gray16 or rgb8 will require some tweak and can be done in this function (called from the autocrop function.
Buffer remaining input
Bug 17545 - segfault when zval_dtor is attempted on this argument
Bug 22630 - throw exception if no path given
Build APInt from string.
Build a Set of the keys that were present in all of the containers
Build a Set of the values that were present in all of the containers
Build a Substitution vector from the conformance.
Build a TypeLoc to preserve AST location info for the reference chain.
Build a TypeRepr from the head of the full path.
Build a binary operation declaration.
Build a binary predicate declaration.
Build a buffer with the pretty-printed declaration.
Build a builtin function declaration.
Build a case type accessor for enum payloads.
Build a clause that looks like 'origParamType' but uses 'selfType' / in place of the underlying archetype.
Build a compound value name given a base name and a set of argument names / extracted from a parameter list.
Build a convenient list of use-variables.
Build a custom epilog block, since the AST representation of the constructor decl (which has no self in the return type) doesn't match the SIL representation.
Build a declaration for a binary operation with overflow.
Build a declaration for an Objective-C subscript getter.
Build a declaration for an Objective-C subscript setter.
Build a default initializer for the given type.
Build a default initializer string for the given pattern.
Build a demangled type tree for a nominal type.
Build a demangled type tree for a type.
Build a doubly-null-terminated list of field names.
Build a field type accessor for stored properties.
Build a getelementptr operation declaration.
Build a list of Substitutions.
Build a list structure from the given array of objects.
Build a map from partial_apply to the indices of the operands that will be promoted in our rewritten version.
Build a mapping from arguments to parameters.
Build a mapping from subpattern numbers to their names.
Build a name for the thunk.
Build a new normal protocol conformance.
Build a new set of minimized requirements.
Build a new specialized conformance.
Build a normal array slice type for recovery.
Build a parameter list which can forward the formal index parameters of a / declaration.
Build a partial application of the delegated initializer.
Build a private global variable as a structure containing the / given fields.
Build a reference to the generic member.
Build a reference to the init(stringInterpolation:) initializer.
Build a reference to the subscript index variables for this subscript / accessor.
Build a result plan for the results of an apply.
Build a setter thunk with the latter signature that maps to the former.
Build a site to represent the URL.
Build a specific value-witness function.
Build a sub-plan that doesn't know about the initialization.
Build a sub-plan to emit into the temporary.
Build a substitution map to replace `self` and its associated types.
Build a table that points at the next pattern character so we skip through candidate faster.
Build a timestamp and return a pointer to it.
Build a user-comprehensible name for a type.
Build a value witness that initializes an array back-to-front.
Build a value witness that initializes an array front-to-back.
Build a zero initializer of the result type.
Build an AST for the subscript declaration.
Build an argument list type to filter against based on the expression we have.
Build an array of APCHandle* to mirror the declared properties in the object.
Build an expression that evaluates the specified parameter list as a tuple / or paren expr, suitable for use in an applyexpr.
Build an identity mapping with the derived conformances.
Build an initialization which recursively destructures the tuple.
Build an l-value for the storage of a declaration.
Build completions by doing visible decl lookup from a context.
Build conformance table
Build import depth map.
Build it if necessary.
Build lifetime intervals and analyze hints.
Build lookup maps for the short options and the long options
Build out an environment that conceptually matches what we'd see if we were to iterate the environment and call getenv() for each name.
Build property accessors for the ivar if necessary.
Build refinement contexts, if necessary, for all declarations starting with StartElem.
Build regex matcher from compiled pattern and passed-in subject.
Build result existential
Build the "if" around the early return.
Build the CFG, then the dominator tree, then use it to validate SSA.
Build the Clang function type.
Build the ExecutionEngine.
Build the SILConstantInfo and cache it.
Build the SILFunctionType for the vtable thunk.
Build the appropriate TypeLowering subclass for the given type.
Build the argument to the operation.
Build the bitfield getter and setter using Clang.
Build the block descriptor.
Build the body of a transformation thunk.
Build the bottom-up order.
Build the cache structure.
Build the case type accessor.
Build the cases for the SelectValueInst and find the first dominatingBlock.
Build the conformance entry (if it hasn't been built before).
Build the conformance record, if it lives in this TU.
Build the constructor reference.
Build the descriptor signature.
Build the early return inside the if.
Build the field name list.
Build the field type accessor function.
Build the field type vector accessor for a nominal type.
Build the field type vector if we didn't already.
Build the fields of the private metadata.
Build the final results view.
Build the function name.
Build the function type.
Build the function_ref and partial_apply.
Build the generic function type.
Build the init(rawValue:) initializer for an imported NS_ENUM.
Build the initializer expression, 'Self.initStorage()', using the conformance.
Build the inline tree.
Build the inline-tree for a function.
Build the invoke function signature.
Build the invoke function type.
Build the list of case names, payload followed by no-payload.
Build the member reference.
Build the metadata name.
Build the minimized signature.
Build the module name path (in reverse), which we use to build the name of the buffer.
Build the necessary decl.
Build the nested types array.
Build the parameter witness method.
Build the parent hierarchy.
Build the property attribute string for a property decl.
Build the rawValue getter for an imported NS_ENUM.
Build the representation of the Clang module in Swift.
Build the result phi.
Build the resulting (non-generic) function type.
Build the return value.
Build the specialized-rows array.
Build the subscript declaration.
Build the token table.
Build the trees for all top-level functions.
Build the type expansion for the leaf nodes.
Build the type of a function transformation thunk.
Build the type refinement context for a StmtCondition and return a pair / of optional version ranges, the first for the true branch and the second / for the false branch.
Build the type refinement hierarchy for the primary file before type checking.
Build the union field getter and setter.
Build the value to be assigned, reconstructing tuples if needed.
Build the witness table.
Build tuple literals for tuple types.
Build type annotation.
Build up a Set containing the keys that are present in all the containers (except container1)
Build up a Set containing the values that are present in all the containers (except container1)
Build up an IdentTypeRepr and see what it resolves to.
Build up the conflict sets.
Build up the list of input jobs.
Build wrapper and add to results.
Builder that helps construct a lookup result from the raw lookup / data.
Builder to be used for creation of new instructions.
Building a fixed-size tuple doesn't require type metadata.
Builds a constant LLVM struct describing the layout of a heap closure, / the types of its captures, and the sources of metadata if any of the / captures are generic.
Builds the type refinement hierarchy for the IfStmt if the guard / introduces a new refinement context for the Then branch.
Builds the type refinement hierarchy for the WhileStmt if the guard / introduces a new refinement context for the body branch.
Builds the type refinement hierarchy for the body of the function.
Builtin arguments should never be substituted, so use the value's type as the parameter type.
Builtin extra args are not stored in varenv.
Builtin floating-point types are always valid SIL types.
Builtin functions get some extra information.
Builtin functions will implicitly start the return block during the inlined call.
Builtin types FIXME: Layering violation to use the ClangImporter's define.
Builtin.BridgeObject uses its own specialized refcounting implementation.
Builtin.NativeObject uses Swift native reference-counting.
Builtin.UnknownObject requires ObjC reference-counting.
Builtins and generators don't have a file and line number
Builtins don't have a file and line number.
Builtins must be fully applied at the point of reference.
Builtins without side effects also do not release.
Bump the 'curx' and 'cury' to point to the next pixel
Bump the current X position
Bump the current buffer pointer forward *before* calling parseInput, so we don't get stuck in an infinite loop if parseInput throws.
Bump the degree of the adjacency.
Bump the generation count.
Bump the reference count of functions referenced by this table.
Bump the reference count of witness functions referenced by this table.
Bump the request count.
Bump up refcounts as needed.
Bump up the unnamed local count
Bundled blowfish crypt()
Busy loop for 5 miliseconds.
But 'self' is treated as the context if it has pointer representation.
But /    since the original partial apply no longer will have that corresponding /    -1, we need to insert a release for the old partial apply.
But I don't understand their uses and interactions well enough to feel comfortable fixing now.
But NewObjectExpression is written to use the class as the function name, so clear it here, to take care of the dynamic case.
But avoid this in the common case.
But callers can disable this by passing a null result type.
But do it at the beginning, so that an explicit -Xcc -working-directory will win.
But don't do this transformation during code completion, as the source may be incomplete and the type mismatch in return statement will just confuse the type checker.
But don't even trust 'throws' for autoclosures.
But don't expect to see 'self' if it's been moved to the context position.
But each one can be omitted if no entries exist in the module file.
But eg if it has unlikely paths into cold code that has not been relocated, then the cold code will still point back to the original, not the relocated versions.
But for 'self' it is just noise.
But for input(), there's no matching to consider.
But for now we aren't bothering.
But for some reason `iResult` ends up being 1.
But for this case, we've already thrown away the overlap by setting stags to None above.
But if it may have been altered, we can't rewrite.
But if only some of the cpu's on a node were disabled, then calling numa_run_on_node will enable them all.
But if some of the types in the signature are public, it could actually end up getting picked in overload resolution.
But if the -s option has been given, we skip this optimization, since on some systems, stat() reports zero size for raw disk partitions.
But if the abstraction pattern is opaque, and the tuple type is materializable -- if it doesn't contain an l-value type -- then it's a valid target for substitution and we should not expand it.
But if the dominating exact checked_cast_br succeeds, then the current non-exact cast would always succeed as well.
But if the dominating non-exact checked_cast_br fails, then the current exact cast would always fail as well.
But if the expression didn't type-check, suppress diagnostics.
But if the func has been removed from the AtomicHashMap, we don't want to process it.
But if the outstanding weak retain count is 1, then anyone attempting to increase the weak reference count is inherently racing against deallocation and thus in undefined-behavior territory.
But if there's a hint, we may have needed that (recorded already above).
But if they are different print it out so we find the error.
But if this is 'self', consider passing an extra metatype.
But if we are, we need to be constantly mixing values.
But if we do, advise the programmer that it's 'repeat' now.
But if we ever need to set it for that purpose we will have to fix that here.
But if we had an OutputArg, we did not DecRef the old value, and the post-coercion value is a RefData* or nullptr.
But if we need to re-abstract, we'll see a lot of benefit from figuring out that we can use TakeAlways here.
But if we're unwinding through the constructor's RetC, the constructor has logically finished and we're unwinding for some internal reason (timeout or user profiler, most likely).
But in addition, a possibly interfering store following a candidate store prevents the candidate from moving past the store, but does not prevent the candidate from being killed by a later store.
But in case all paths from this block end in unreachable then the final release of the object may be optimized away.
But in php5 xdebug, property_value is exactly the same as property_get, without support for the constant context.
But in the future, one could think of / maintaining a cache of optimized specializations.
But it also doesn't matter because we're going to throw a special VMReenterStackOverflow in that case so the unwinder won't worry about it.
But it can return Invalid if a type-checking / failure prevents it from deciding that, and it can return None / if the function is an autoclosure that simply doesn't throw at all.
But it could just happen by bad luck, so just log it.
But it does not / create a SILFunction object.
But just delete them if they're not actually separating any arguments, e.g. in "()(y: Int)".
But just in case, use snprintf() and make sure the buffer is zero-terminated
But looking at the Cannon powershot's files, inches is the only sensible value.
But luckily stl only looks at this env var the first time it tries to do an alloc, and caches what it finds.
But magic setters are only possible in define contexts.
But not enums with enums with data.
But note that default arg generators can't capture anything right now, and if we ever add that ability, it will be a different capture list from the function to which the argument is attached.
But note that later phases should set/get the attribute directly on the FunctionScope, rather than on the FileScope
But note that mergeUnit is called for systemlib etc before the stack has been setup.
But note that unless the user created the array manually, and added reference params at the correct places, we'll still get warnings, and the array elements will not be passed by reference.
But now readMetaData is gone ...
But only do this if tvRef was used in this iteration, otherwise we may wipe out the last reference to something that we need to stay alive until the next iteration.
But only if the lowered type matches exactly.
But only when the repl_set_name in the server definition struct is actually *set*.
But our memory is not infinite.
But please keep this copyright notice.
But propagate the error bit.
But silence the warning if the base was explicitly qualified.
But since requests are still coming in, it may not be very useful, and has some performance penalties.
But that does not mean that we cannot eliminate this pair with a peephole.
But thats ok, because it doesnt matter whether they see the old contents or the new.
But the error case noted above is quite difficult to test.
But the target is an instruction, so skip over any nops that might have been inserted (eg for alignment).
But their constant values can still be propagated into their uses whenever possible.
But there are cases where we can get an unapplied declaration reference back.
But there might be requests in flight that still thought they were profiling, so we need to clear it on the treadmill.
But they can optionally ask for it, in case it is needed.
But they make a real mess on VT100-style displays if they're not paired properly, so we are probably better off not calling them text.
But this always gets the uncompressed size no matter what.
But this case can also occur on unrelated classes that happen to have a same-named function at the same method slot, which means we still have to check whether the new function is static.
But this happens less often with canonicalization.
But this is how Zend does it and there is no other good way
But this is just the dominance condition we wanted: every path through the program to this load must have defined `t1', so its definition dominates the load.
But this is the skeleton for when we do.
But this method is used as a last resort.
But this only propagates down to subclasses whose superclass type depends on the subclass's generic context.
But to do that they need to be able to initialize all properties, i.e. all properties should be accessible by the extension.
But unmaterializable types are not / valid results of substitutions, so this does not apply.
But usually / it is the less frequent case and we want to ignore it.
But we also don't want to extend regions past it, so the JIT treats it as terminal and uses InterpOneCF to execute it.
But we assume that in-place gets aren't all that important.
But we can do it anyway when we need more free memory, e.g., when a new instance of the server is about to start.
But we can't assert that it is because background threads are allowed to clear surprise bits concurrently, so it could be cleared again by now.
But we can't do it if the Class* or Func* might be freed.
But we can't use the value itself, because if it is null the key will act like the empty string.
But we can't, the cycles are detected and avoided at blockOn() time.
But we default to 1 second for historical reasons
But we do not create any body.
But we do want to signal that we specialized a closure.
But we do want to walk into the initializers of local variables.
But we don't need a loop block unless the 'do' statement is labeled.
But we know this is a closure, and we can get a Func* via getInvokeFunc(), so just bypass all that decode process to save time.
But we might also have a foreign error.
But we need this ordering to ensure that as long as you hold an accessor to m_expMap, its key converted to a char* will be a valid c-string.
But we want our state structures to have support_map pointing to at most one must-alias-set for each location.
But we want the maximum correction applied to a pixel to be much less, otherwise obviously wrong pixels will be created.
But we want to calculate the hash later because later we can do it multi-threaded.
But within one JIT region, right now we declare it illegal to generate IR that uses an object after a DecRef that might take it to zero.
But you gotta do what you gotta do.
But, according to The Encyclopedia Judaica, Hillel II may have only published the 19 year rule for determining the occurrence of leap years.
But, if no page load is requested, #2 is the only one to fire.
But, it's exactly the same as the error noted below.
But: this might be not the case if BB is unreachable.
By "any", we don't mean existentials.
By / keeping the LSLocation and LSValue in their indivisible form, one / can easily find which part of the load is redundant and how to compute its / forwarding value.
By Authors:  Spencer W.
By adding KEEP_SECTION, both these functions end up in the same section, and by doing something reasonably silly in this one, we can ensure that no code folding takes place.
By construction, the final canonical IRInstruction for a hoist group is the first check in that group.
By default UnicodeString isn't NULL terminated
By default, just use the in-memory cache.
By default, just visit the declarations that are actually injected into the enclosing context.
By default, put the preposition on the argument label.
By default, treat stdin as Swift input.
By default, use the astNode to create the location.
By defaults, new connections will target the default dispatch concurrent queue.
By doing it to only one of these two, we deviate from a state that could be directly specified by a password to the buggy algorithm (and to the fully correct one as well, but that's a side-effect).
By instead keeping track of the fact that that memory location may contain a pointer to that must-alias-set until it may be decref'd later, we can keep the lower bound higher for longer.
By laying out the enum this way we can avoid the branch and just transition by adding 2 to the current state.
By looking at bar without any knowledge of foo, we can know that it is safe to promote this to a by-value capture, allowing x to live on the stack under the following conditions:
By observing the types during this initial pass, we can often use a specialized comparator and avoid performing type checks during the actual sort.
By setting to 0xAA, we expose bugs in yy_init_globals.
By splitting critical edges we ensure that it's impossible to have an exit head that also has a side exiting predecessor.
By the spec, only the above cases are allowed
By the time that DI gets here, we've validated that all uses / of the memory location are valid.
By these conditions, a pointer followable type is one which is known to be allocated out of the request heap, and transitively leads to a countable type via some chain of pointers.
By turning the error handling mode to EH_NORMAL temporarily, we circumvent this problem.
By-value let's have no address.
Bypass RepoQuery, in order to avoid triggering exceptions.
Bypass the cache for the empty tuple.
Byte of 0's (future expansion)
Byte order is little-endian
Bytecode instructions that must be interpreted.
Bytecode regions for every function must not overlap and must exactly divide up the bytecode of the whole unit.
Bytecode-level control flow.
Bytes to reserve for sort keys
Byteswap an mmap'ed file if needed
C ABI wackiness may cause a single-field struct to have different layout from its field.
C LALR(1) parser skeleton written by Richard Stallman, by simplifying the original so-called "semantic" parser.
C enums have arbitrary values and we don't preserve the mapping between the case and raw value at runtime, so don't emit any case names at all so that reflection can give up in this case.
C function imported as a function.
C function imported as a method.
C functions imported as members should be referenced as C functions.
C functions imported as static methods don't consume any real arguments.
C++ code generation functions:
C++ doesn't allow declaring empty arrays like C does, so we give it size 1 and use m_classVec's offset as the true size of Class when allocating memory to construct one.
C-compatible enums have scattered inhabitants.
C-style character escapes, no support for unicode escapes or whatnot.
C-style escapes are also supported.
C-style variadic functions cannot be called from Swift.
C99 requires __STDC__ to be defined as 1.
C99 says to define __STDC_LIMIT_MACROS before including stdint.h, if you want the limit (max/min) macros for int types.
C::Constant inside a class
CALENDAR OVERVIEW  Julias Ceasar created the calendar in 46 B.C.
CALENDAR OVERVIEW  The French republican calendar was adopted in October 1793 during the French Revolution and was abandoned in January 1806.
CALENDAR OVERVIEW  The Gregorian calendar is a modified version of the Julian calendar.
CALENDAR OVERVIEW  The Jewish calendar is based on lunar as well as solar cycles.
CF function results can be managed if they are audited or the ownership convention is explicitly declared.
CF type as foreign class
CLO8 - Return the number of leading ones in the specified 8-bit value.
CODE has a useless total size field
COLOR_* constants Colortype constants.
COMPRESSION constants
CR_NET_READ_INTERRUPTED
CR_NET_WRITE_INTERRUPTED
CR_NEW_STMT_METADATA makes the statement unusable
CSE - This pass does a simple depth-first walk over the dominator tree, / eliminating trivially redundant instructions and using simplifyInstruction / to canonicalize things as it goes.
CURLE_PARTIAL_FILE is returned by HEAD requests
Cache alignment is required for mutable instructions to make sure mutations don't "tear" on remote CPUs.
Cache cold blocks per function.
Cache for evaluated constants.
Cache key for element associated with m_pos in order to update m_pos after the compaction has been performed.
Cache missed - we need to look through all of the assocty sections for all images that we've been notified about.
Cache of the analysis whether a loop is safe wrt.
Cache our results for use next time.
Cache the canonical type for future queries.
Cache the entry under the original type and the exemplar type, so that we can avoid relowering equivalent types.
Cache the foundation module name so we don't need to look for it again.
Cache the mapping so we don't need to troll imports next time.
Cache the result if it is trustworthy.
Cache the result, so we don't perform string manipulation again.
Cache the successor blocks because splitting critical edges invalidates the successor list iterator of T.
Cache the uniqued set of transitive captures.
Cache the value under both its compound name and its full name.
Cache this entry in the dependent or independent cache appropriate to it.
Cached process statics
Caches an estimate of the number of named entities we have.
Caches the set of associated types that are referenced in each / requirement.
Caching the name of each field is important to avoid unnecessary calls to CodeCompletionString::getName().
Calculate all the non-fixed layouts.
Calculate how many bytes are needed to convert an UTF16 string into UTF8 UTF16 string
Calculate how many times a callee is called from this caller.
Calculate immediate dominators with the iterative two-finger algorithm.
Calculate metonicCycle * HALAKIM_PER_METONIC_CYCLE.
Calculate non-fixed field offsets.
Calculate number of bits we are expecting
Calculate output length and upper bound while processing
Calculate r2r1 / HALAKIM_PER_DAY.
Calculate string length based on imap's rfc822_cat function.
Calculate the aliasing result and store it in the cache.
Calculate the century (year/100).
Calculate the class constraint and number of witness tables for the protocol set.
Calculate the correct bound-generic extended type.
Calculate the generic signature for the given imported generic param list.
Calculate the hash of the whole llvm module.
Calculate the inlining cost of the callee.
Calculate the month and day of month.
Calculate the names to search for: fqdn and wildcard.
Calculate the profFactor for the callee as the weight of the caller block over the weight of the entry block of the callee region.
Calculate the result.
Calculate the size of the buffer needed to hold ustr, converted to UTF-8.
Calculate the size of the offsets array
Calculate the size of the offsets array, and allocate memory for it.
Calculate the summary information.
Calculate the time of the starting molad for this metonic cycle.
Calculate the window style based on the theme style and command display value.
Calculate unknown size
Calculates EstimatedStackSize.
Calculates and adjusts "start" and "length" according to string's length.
Calculates the nesting depth of the current application.
Call a helper that decrefs the first argument
Call an associated-type witness table access function.
Call breakpoints add function + class (optionally)
Call getAbsolutePath() on the returned File object
Call path invalidation callback once for each path associated with this node and/or remove paths.
Call syntax forms a pattern if: - the callee in 'Element(x...)' or '.Element(x...)' references an enum element.
Call the (unconditional) dynamic cast.
Call the FunctionSuspend hook.
Call the _getBool library intrinsic.
Call the accessor if there is one.
Call the builtin conversion operation.
Call the builtin method.
Call the callback before we mutate the to be deleted instruction in any way.
Call the debugger hook and continue
Call the destroying destructor.
Call the destructor method
Call the free_storage handler, invalidate the bucket and reuse its handle.
Call the generator function we were provided.
Call the generic metadata accessor function.
Call the global accessor to get the variable's address.
Call the init(stringInterpolation:) initializer with the arguments.
Call the initialization callback if present.
Call the initializer.
Call the inline-assembly marker if we need one.
Call the instantiation function to initialize dependent associated type metadata.
Call the llvm.memcpy intrinsic.
Call the mutable addressor.
Call the native entry point.
Call the native function.
Call the native implementation.
Call the normal conformance destructors last since they could be referenced by the other conformance types.
Call the object's clone handler, like what the PHP VM's ZEND_CLONE handler does
Call the runtime to allocate the box.
Call the standard library implementation of _diagnoseUnexpectedNilOptional.
Call the superclass's -dealloc.
Call the witness that builds the array literal.
Call the witness that builds the dictionary literal.
Call this out in a separate diagnostic.
Call through "hasValue" on the decl ref.
Call unprotect to ensure that the memory is marked executable.
Call-context sensitive return types are cached here.
Call/return hand-shaking is a bit funny initially.
CallBuiltin doesn't count because it is not a php-level call.
CallGraph GraphTraits specialization so the CallGraph can be / iterable by generic graph iterators.
Callback based constant
Callback invoked by libmcrouter (by way of McRouter::onReply()) We're in the worker thread here, so we can't do any request allocations or the memory manager will get confused.
Callback made by Debugger::SwitchSandbox() when the switch is successful.
Callback used to get a type member of a type variable.
Callbacks and helpers
Called by TypeAliasReq to get resolved TypeStructure for type aliases.
Called by one of the other *visit* methods.
Called by the IJG JPEG library upon encountering a fatal error
Called by the VM when a class definition is loaded.
Called by the VM when a file is loaded.
Called by the VM when a function definition is loaded.
Called from timer handler, Lets non-signal code know the timer was fired.
Called in response to a host of VM events that the debugger is interested in.
Called right after a function is finished.
Called right before a function call.
Called to clear out the tracked local values at a call site.
Called when a breakpoint is reached, to produce the console spew showing the code around the breakpoint.
Called when the ctor was terminated by an exception
Callees which are inlined into this function.
Caller must ensure that off is at least within the entire func's bytecode region.
Caller must ensure we are synchronized (either hold funcInfoLock or be in a single threaded situation).
Caller should allocate height * pixwpl bytes of memory before calling this routine.
Callers are not designed to deal with PHP exceptions.
Callers depending on fields of this structure will probably fail.
Callers must cope with dependent types directly.
Callers of the requirement can expect to receive 'nil', but / the witness will never produce one.
Callers of the requirement can provide 'nil', but the witness / does not handle it.
Calling all of these library functions in a signal handler is completely undefined behavior, but we seem to get away with it.
Calling closeWithReset() will cause readEOF to be called immediately which will call shutdown().
Calling into internal functions here is unsafe from other threads so we enqueue the work for the event base.
Calling isResilient() with this scope will always return false.
Calling lookupConformance on a BoundGenericType will return a specialized conformance.
Calls FunctionReturn hook.
Calls are identical if the callee and operands are identical and we know that the call is something that is "readnone".
Calls are not treated as basic-block ends.
Calls hp_sample_stack() if its time.
Calls that time out (try 1 ms) should return a status code of -1
Calls through opaque protocols can be done with +0 rvalues.
Calls to getMorePostData may invalidate data, so make a copy iff we're trying to coalesce the entire POST body.
Calls to the int_instrprof_increment intrinsic are emitted during SILGen.
Calls with a depth other than default should be rare.
Callstack walking is necessary, because we may get called from a uniqueStub.
Camel case matched better.
Camel case matches should have higher priority.
Can be NULL if no characters were read.
Can be either a call to _adoptStorage or _allocateUninitialized.
Can be mangled without an introducer.
Can be overridden by subclassers to emit other dependent metadata.
Can be white space now and should be at the end of the string then...
Can convert a decl ref to a global or local function that doesn't capture context.
Can convert a literal closure that doesn't capture context.
Can convert from an ABI-compatible C function pointer.
Can happen, e.g., in exception scenarios.
Can never trust these PHP people...
Can not find an epilogue release instruction for the argument.
Can only access private properties via the debugger.
Can only capture a variable that is declared before the capturing entity.
Can only change the array argument.
Can only process new data if we aren't currently waiting on a call to readNext() to free up the key/value beffers
Can't be added in an extension.
Can't build a thunk without context, so we require ownership semantics on the result type.
Can't call QApplication::exit() here, because we may be called before app.exec()
Can't checkInvariants yet, since we haven't populated the payload.
Can't clone alloc_stack instructions whose dealloc_stack is outside the loop.
Can't constprop at this eval_cell, because of the effects on locals.
Can't constprop yet because of no INS_1 support in bc.h
Can't constprop yet because of no INS_2 support in bc.h
Can't currently have array() info.
Can't do anything else with it.
Can't do much if we don't even know the types.
Can't grow it, we don't own it.
Can't handle non-zero ptr values.
Can't handle unknown values.
Can't hoist allocation and dealloc stacks.
Can't hoist if the instruction could read from memory and is not marked as safe.
Can't hoist instructions which may have side effects.
Can't hoist terminators.
Can't infer anything.
Can't load from an inout value.
Can't open a glob as a file, it's meant to be opened as a directory if the function was called via FCallBuiltin, we'll get a bogus name as the stack frame will be wrong
Can't push true in the non env.findLocal case unless we know whether this function can have a VarEnv.
Can't really import variadics well
Can't resolve this to a literal name at emission time
Can't right-pad 0's on integers
Can't store it anywhere
Can't take from a box since the value may be shared.
Cancel backtracking and build that name.
Cancelling ourselves isn't needed for correctness, but we can go ahead and do it now instead of waiting on it later, so why not.
Candidate must be incorrect for some other reason.
Cannot be extension, which is not a ValueDecl.
Cannot be more code points than bytes in input.
Cannot call initializers from a superclass, except for inherited convenience initializers.
Cannot call static functions on non-metatypes.
Cannot compare type declarations this way.
Cannot drop 'throws'.
Cannot extend a bound generic type.
Cannot extend a metatype.
Cannot force initializers into class methods.
Cannot handle throwing functions.
Cannot have an implicit getter after other accessor.
Cannot import variadic types unless specially handled before calling this function.
Cannot merge irSPOff state, so assert they match.
Cannot parse correctly.
Cannot promote loads and stores from within an existential projection.
Cannot reference enum elements on non-metatypes.
Cannot return an optional bridged type, because 'nil' is reserved to indicate failure.
Cannot use instance properties on metatypes.
Cannot use static properties on non-metatypes.
Cannot use the String constructor directly, as it has subtle different behavior in the case where ptr is null, and length is 0, and it breaks flib to change that.
Canonical ordering for dependent types in generic signatures.
Canonical signatures store the ASTContext directly.
Canonical swift requires all non cond_br critical edges to be split.
Canonicalise the path
Canonicalization will promote to loads and releases if appropriate.
Canonicalize BB arguments, replacing argument-of-casts with / cast-of-arguments.
Canonicalize Void return type into something that isTrivialReturnBlock expects.
Canonicalize a select_enum: if the default refers to exactly one case, then replace the default with that case.
Canonicalize a select_enum_addr: if the default refers to exactly one case, then replace the default with that case.
Canonicalize all switch_enum and switch_enum_addr instructions.
Canonicalize and lower the l-value's object type.
Canonicalize boolean comparisons.
Canonicalize constants to the right.
Canonicalize generic parameters.
Canonicalize inserted phis to avoid extra BB Args.
Canonicalize loop exit blocks so that they only have predecessors inside the / loop.
Canonicalize multiplication by a stride to be such that the stride is always the second argument.
Canonicalize switch_enum instructions.
Canonicalize the determined sign bit on the left.
Canonicalize the given DeclContext pointer, in terms of / producing something that can be looked up in / ClosureDiscriminators.
Canonicalize the loop for rotation and downstream passes.
Canonicalize the loops, invalidating if we need to.
Canonicalize the parameters and requirements.
Canonicalize the resulting set of protocols.
Canonicalize the retain so that nothing uses its result.
Canonicalize the signature.
Cap to prevent insane things.
Capture a pprof (C++) dump when we OOM a request TODO: (t3753133) Should dump a PHP-instrumented pprof dump here as well
Capture generic parameters from the enclosing context if necessary.
Capture inout parameters by pointer.
Capture lists need to be reparented to enclosing autoclosures.
Capture match offsets: yes/no
Capture the atom if desired.
Capture the first parameter name.
Capture the metadata and witness tables from this existential into the given archetype.
Capture the methods in this source file.
Capture the tuple expression, if there is one.
Capture value parameters by value, consuming them.
Captured parameters are always appended to the function signature.
Captures at nonlocal scope are order-invariant.
Careful in these functions: they can be called when tl_regState is REGSTATE_DIRTY.
Careful: from here 're' needs to be freed if something throws.
Careful: this isn't necessarily the real entry point.
Carefully move iterator to avoid invalidation problems.
Carries out commands that change the status of a breakpoint.
Carries out the "break list" command.
Carries out the Break command.
Carries out the Quit command by informing the server the client is going away and then getting the client to quit.
Carry out the operations required for an indirect conditional cast / using a scalar cast operation.
Carry over the spare bits from the element.
Carry the rvmfp to VM stack around on all vasm calls.
Case 1: both ways lead to the same block.
Case 2: branch constantly goes one way.
Case label items in a case statement are siblings.
Case numbering must not depend on any information that is not static in this resilience scope.
Case on the type for the rest
Case sensitive uppercase first character.
Case where the input type is an exploded tuple.
Case-exits only leave themselves post-terminator if they use the continuation block, so we're in an acceptable insertion state.
Cases are handled in visitSwitchStmt.
Cases where it's not public should've already been filtered out in the indexer.
Cases where we break apart an enum and then reform it from its individual / cases.
Cases with payloads are numbered consecutively, and only required testing the tag.
Cast a function that takes all pointer arguments and returns to a / function type that takes different pointer arguments and returns.
Cast a generic argument to its specialized type.
Cast a value into the expected, ABI compatible type if necessary.
Cast all non-arrays to strings since that is what everything used ot be
Cast argument if required.
Cast both addresses to opaque pointer type.
Cast expressions 'x as T' get resolved to checked cast patterns.
Cast from existential metatype to existential metatype may still succeed, even if we cannot prove anything statically.
Cast the base to i8*, apply the given inbounds offset (in bytes, / as a size_t), and cast to a pointer to the given type.
Cast the base to i8*, apply the given inbounds offset (in bytes, / as a size_t), and create an address in the given type.
Cast the callback to the correct polymorphic function type.
Cast the callee pointer to the right function type.
Cast the instance pointer to an opaque refcounted pointer.
Cast the messenger to the right type.
Cast the parameters to word pointers because the fill indexes are word-indexed.
Cast the predicate to a OnceTy pointer.
Cast the storage to the block type to produce the result value.
Cast the unwrapped value.
Cast the value if necessary.
Cast the witness pointer to i8*.
Cast the witness to the appropriate function type.
Cast the wrapped value.
Cast to Builtin.RawPointer.
Cast to the function type.
Cast to the result type.
Cast will succeed Replace by unconditional_addr_cast, followed by a branch.
Casting to a less-optional type can always fail.
Casting will succeed.
Casts are necessary due to xml api
Casts between a value type and a class cannot be optimized.
Casts between the same types can be always handled here.
Casts do not use pointers in a manner that we care about since we strip them during our analysis.
Casts from class existential into a non-class can never succeed.
Casts from class existential metatype into a concrete non-class metatype can never succeed.
Casts from non-existentials into existentials and vice-versa cannot be improved yet.
Casts involving non-bound generic types cannot be optimized.
Casts to archetypes thus must always be indirect.
Casts to concrete metatypes.
Casts to existential metatypes.
Casts to or from generic types can't be statically constrained in most cases, because there may be protocol conformances we don't statically know about.
Casts to/from existential types cannot be further improved.
Catalog all of members of this declaration context that satisfy requirements of conformances in this context.
Catch any issues with this early, instead of waiting for the full check function.
Catch any other implicit uses of self with a generic diagnostic.
Catch blocks are special: we need to sync vmfp() and vmsp() so that the unwinder knows to free the inlined frame.
Catch nested types and emit their definitions /after/ this class.
Catch reentrancy bugs.
Catch the common case in which we've already hoisted the initializer.
Catch-all to make sure we don't silently accept something we shouldn't.
CatchMaker makes catch blocks for calling builtins.
Catches are handled in visitDoCatchStmt.
Category declarations by their signatures.
Cause a token to be read.
Cause the next inner indirect result to be emitted directly into / the given outer result address.
Cause the proxy to debug the given thread.
Center the window on the monitor with the mouse.
Centralize try_get() calls to document that despite the scary name, it won't fail under any conditions we subject it to.
Certain builtin function refs we know can never use non-trivial values.
Certain case statements can be entered along multiple paths, either because they have multiple labels or because of fallthrough.
Certain compilers (usually Clang) will emit debug information for template instantiations, but fail to emit information about the template parameters.
Certain interesting aspects of a static function are only present in its definition.
Certain llvm intrinsic require constant values as their operands.
Certain semantic functions are generally safe because they don't release / the array in unexpected ways.
Certificate Signing Request
Chain inner failures onto the outer failure.
Chain the retranslation blocks.
Change 'foo' to 'fog' by replacing the last character.
Change LdCtx in static functions to LdCctx, or if we're inlining try to fish out a constant context.
Change address mode to kBase_Index
Change aggregate values into scalar values.
Change all the OrdStr uses into Movs
Change any aggregate loads into field loads + aggregate structure.
Change any aggregate stores into extracts + field stores.
Change defaults for these since they make assumptions about the system
Change every other comma into a colon.
Change its linkage to public, so that other applications can refer to it.
Change the DeclContext for any variables declared in the defer to be within the defer closure.
Change the DeclContext of any contained parameters to the specified / DeclContext.
Change the DeclContext of any parameters to be this closure.
Change the context we're contextualizing to.
Change the control flow of the exiting instruction to go through the new block.
Change the current working directory.
Change the file mode mask
Change the immediate dominator for children of the successor to be the current block.
Change the immediate dominators of the children of the block we splitted to the splitted block.
Change the ivar offset to point to the respective entry of the field-offset vector, as discussed above.
Change the parser state to know that the pattern we're about to parse is implicitly mutable.
Change the representation without changing the signature or abstraction level.
Change the state and iterate.
Change the thread mode, and mark the given (or calling) thread as the current thread for this proxy, depending on the thread mode.
Change the type to include the autoclosure bit.
Change the type to include the noescape bit.
Change the type to the appropriate reference storage type.
Change their linkage to public, so that other applications can refer to it.
Change uses in different basic blocks to undef.
Changed by gzdecode(), sigh.
Changed by gzencode(), sigh.
Changed during the course of the request
Changed types are overwritten, while refined types are intersected with the current type.
Changes that we wish to apply to a row which we have specialized.
Changes to either the strong and weak reference counts occur in a total order with respect to each other.
Changing the body here may require changing / TypeCheckPattern.cpp as well.
Changing the definition of GD2_DBG (below) will cause copious messages to be displayed while it processes requests.
Characters are mapped into these 32 symbol classes.
Chase down the box value to see if there are any releases.
Chase up the dominator tree and see if we find a parent loop.
Check 32-bit alignment.
Check RHS in getter context
Check a bunch of integers.
Check a super.init call.
Check accessibility when relevant.
Check again after we have the lock, other threads may have already created a new chunk.
Check against the commands
Check against the defined features
Check all cross-module dependencies as well.
Check all default witness tables.
Check all instructions of the function
Check all of the designated initializers in the direct superclass.
Check all of the members of the enum.
Check all of the subexpressions independently.
Check all of the types listed in the inheritance clause.
Check all operands of a partial_apply
Check all overridden decls.
Check all parameter effects.
Check all predecessor values which come from non-cold blocks.
Check all protocols implemented by the type.
Check all the catch clauses independently.
Check all the inputs for unknown values.
Check all the pattern/init pairs in the PBD.
Check all the potential splits.
Check all the results.
Check all witness tables.
Check and build thumbnail
Check and fold binary arithmetic with overflow.
Check and record normal conformances.
Check and simplify binary arithmetic with overflow.
Check any generic parameters for something with the given name.
Check array bounds semantic.
Check array semantic calls.
Check availability of accessor functions
Check before the string, we have to be careful not to go off the front of the buffer.
Check both the native stack and VM stack for overflow.
Check check_subscript.
Check compatibility vs interface and abstract declarations
Check conformances before visiting members, since we might synthesize bodies for derived conformances
Check conversion from iterator to const_iterator.
Check conversions from non-protocol types into protocol types.
Check copying of const_iterators.
Check default witness methods.
Check dominance of the parent blocks.
Check each branch target lands on a valid instruction boundary within this region.
Check each method for a match
Check each non-covered literal protocol to determine which ones
Check each of our immediate children to see if any of them are independently invalid.
Check each of the conformances associated with this context.
Check each of the elements.
Check each of the expression nodes to verify that there are no type variables hanging out.
Check each of the requirements.
Check each of the tuple elements in the destination.
Check each of the unsatisfied optional requirements.
Check environment variable
Check error-handling correctness for all the functions defined in this file.
Check extra inhabitants.
Check file exists and is readable
Check first if the whole path exists
Check for "fsync" in options array
Check for "j" in options array
Check for 'throws' and 'rethrows' after the type and correct it.
Check for Infinity and NaN
Check for OOM before doing a potentially large allocation.
Check for Swift module and overlays.
Check for Unicode BOM at start of file (Only UTF-8 BOM supported now).
Check for a ',', which indicates that there are more protocols coming.
Check for a () suffix, which indicates a call when constructing this member.
Check for a () suffix, which indicates a call.
Check for a .foo suffix.
Check for a CF type name (drop the "Ref")
Check for a CFString literal of the form CFSTR("string").
Check for a common input value.
Check for a few common cases that can cause missing members.
Check for a hit in the request local cache---since we've failed on the immediate smashed in the TC.
Check for a postfix-operator suffix.
Check for a query error
Check for a specialized emitter.
Check for a trailing closure, if allowed.
Check for active/inactive intervals that have expired or which need their polarity flipped.
Check for alternations whenever we fail to match.
Check for an abstraction difference.
Check for an access to the base class through an Upcast.
Check for an exact match.
Check for an exact type match first.
Check for an existing cache entry.
Check for an existing context created by the parser.
Check for an existing context we can re-use.
Check for an existing forward declaration of the address point.
Check for an existing generic signature.
Check for an existing mapping for the key.
Check for an explicit attribute.
Check for any errors while generating layouts.
Check for any members in lhs.m_bits that aren't in rhs.m_bits.
Check for any uses of basic blocks that were not defined.
Check for apply insts that we can ignore.
Check for array buffer allocation.
Check for associated types.
Check for builtins that we can ignore.
Check for cases that are obviously better or obviously worse.
Check for certain standard types.
Check for circular dependencies in our requests.
Check for circular inheritance of the raw type.
Check for circular inheritance within the protocol.
Check for circular inheritance.
Check for collisions among Objective-C initializers.
Check for completeness of the solution
Check for conflicting warning control flags
Check for conformance to all the protocols.
Check for conformance to the literal protocol.
Check for conformances for the type that apply to the original substituted archetype.
Check for correct version number
Check for deep match if desired.
Check for default arguments in the shuffle.
Check for duplicate enum members.
Check for each predecessor, if the incoming value coming from it is equivalent to the DomCondition.
Check for empty protocol composition.
Check for empty() after wait(), in case of spurious wakeup.
Check for ending label on this line.
Check for errors in the format string.
Check for existence of a function with a given name and required linkage.
Check for index buffer overflow
Check for key buffer overflow
Check for literals that don't fit in 64-bits.
Check for literals that fit, but set the sign bit.
Check for matching ExpectedTypes.
Check for methods that return 'DynamicResult'.
Check for missing argument error.
Check for mutations of the address component.
Check for non-cond_br critical edges.
Check for old-style whitelist
Check for open colors at the end, so we can reduce colorsTotal and ultimately BitsPerPixel
Check for potential unavailability because of the minimum deployment version.
Check for protocol conformance of archetype via superclass requirement.
Check for protocol conformances and fill in the witness tables.
Check for pseudomain.
Check for required protocol conformances.
Check for shallow match.
Check for some invalid imports
Check for special case that d is a normalized power of 2.
Check for special constraints on llvm intrinsics.
Check for special existentials.
Check for stack overflow in the same place func prologues make their StackCheck::Early check (see irgen-func-prologue.cpp).
Check for stream wrapper
Check for string value ("majority", or a tag)
Check for swift object allocation.
Check for swift_newtype
Check for the 'not set' sentinel.
Check for the 'throws' keyword.
Check for the ErrorProtocol protocol conformance, which should be the only one we need.
Check for the existence of this function in another module without loading the function body.
Check for the literal series of tokens (void*)0.
Check for the strength specifier: "weak", "unowned", or "unowned(safe/unsafe)".
Check for the swift_bridge attribute.
Check for the wildcard exception breakpoint
Check for this and recover nicely if they wrote that.
Check for this situation and handle it gracefully.
Check for too many substrings condition.
Check for tuple splat.
Check for type variables that escaped the type checker.
Check for unknown arguments.
Check for unsupported options
Check for unused variables, as well as variables that are could be declared as constants.
Check for value arguments that need to be passed indirectly.
Check function calls, looking through implicit conversions on the function and inspecting the arguments directly.
Check generic parameters, if needed.
Check generic parameters.
Check graph invariance 4)
Check how to optimize this function.
Check if BB is reachable from a single enum case, which means that the immediate predecessor of BB is the switch_enum itself.
Check if BB is reachable from multiple enum cases.
Check if I is a sequence of projections followed by a load.
Check if Inst is located before (or at) the last use.
Check if PotentialDecrement can decrement the reference count associated / with the value we are tracking.
Check if PotentialDecrement can decrement the reference count associated with the value we are tracking.
Check if PotentialGuaranteedUser can use the reference count associated with the value we are tracking.
Check if PotentialUser could be a use of the reference counted value that requires user to be alive.
Check if Right's lexicographical order is greater than Left.
Check if SinglePred has a switch_enum terminator switching on RCIdentity...
Check if Start can decrement or check Op's ref count.
Check if Start can use Op in an ARC relevant way.
Check if User set a file via File Picker
Check if `calleeAR' was set.
Check if a buffer was created in the middle of the snapshot updates.
Check if a builtin is inlinable.
Check if a checked trunc instruction can overflow.
Check if a getter was generated already.
Check if a given SILFunction can be a static initializer.
Check if a given let property can be assigned externally.
Check if a given let property can be removed, because it is not accessible elsewhere.
Check if a given property is a non-static let property / with known constant value.
Check if a given type conforms to _BridgedToObjectiveC protocol.
Check if a given type conforms to _Error protocol.
Check if a loop has only 'safe' array operations such that we can hoist the / uniqueness check even without having an 'identified' object.
Check if a parent of a tuple is a "let"
Check if a precision was specified
Check if a precision was specified  XXX: an unreasonable amount of precision may be specified resulting in overflow of num_buf.
Check if a predecessor BB terminates with a switch_enum instruction
Check if a width was specified
Check if all enum cases and the default case go to one of our collected blocks.
Check if all possible cases are covered.
Check if all predecessors of BB have a single common predecessor (which should be the block with the switch_enum).
Check if all predecessors stem from the same switch_enum instruction.
Check if all the predecessors supply the same arguments to the BB.
Check if an address does not depend on other values in a basic block.
Check if any casting is required for the return value.
Check if any classes in the inheritance hierarchy have generic parameters.
Check if any cookie has expired
Check if any indirect subclasses use an implementation of the method different from the implementation in the current class.
Check if any jump-threading is required and possible.
Check if any of the operands will become dead as well.
Check if at least one of the successors contains user code.
Check if both blocks pass the same arguments to the common destination.
Check if both nodes may point to the same content.
Check if both operand values are passed to the same block argument in the successor block.
Check if breakpoint's exception is registered.
Check if code-bloat would be too big when this BB is jump-threaded.
Check if comment is on same line but after the declaration.
Check if conditions are equivalent along a subset of reaching paths.
Check if conditions of CCBI and DomCCBI are equivalent along / all or at least some paths.
Check if conversion was successful.
Check if data field exists.
Check if delegate is non-null.
Check if exactly one argument was passed to this function, otherwise we obviously have a mismatch
Check if execution of a given Apply instruction can result in overflows.
Check if instead User set a file via uploadFile API
Check if instruction I is a load from instruction V or / or a struct_element_addr from instruction V.
Check if is a bridging cast, i.e. one of the sides is / a bridged type.
Check if it is a "let" in the parent struct.
Check if it is a call of a generic function.
Check if it is a cast between bridged error types.
Check if it is a conversion of a non-throwing function into a throwing function.
Check if it is already created, and update linkage if necessary.
Check if it is legal to perform the propagation.
Check if it's a boolean inversion of the condition.
Check if it's a load from a stack location in the caller.
Check if it's a store to a stack location in the caller.
Check if its parent is a "let".
Check if name changed
Check if name conflicts with a reserved typehint.
Check if next exists in the Decl.
Check if out predecessor has any other successors.
Check if predecessor and successor edges are linked correctly.
Check if profiling has been enabled before trying to dump.
Check if prop already declared as non-static
Check if some of the predecessor blocks provide a constant for the cond_fail condition.
Check if sourceValue has the _ObjectiveCType type required by the protocol.
Check if src and dest types are optional.
Check if tag is in a set of tags  states:  0 start tag 1 first non-whitespace char seen
Check if the 'Content-Type' requires decoding
Check if the Nth argument in all predecessors is identical.
Check if the ObjC runtime already has a descriptor for this protocol.
Check if the argument passed to the first predecessor is a literal inst.
Check if the callee is passed as an argument.
Check if the case values directly map to the tag values, maybe with a constant offset.
Check if the common predecessor block has a switch_enum.
Check if the cond_fail has the same condition as the cond_br in the predecessor block.
Check if the condition is a single-used argument in the current block.
Check if the converted function type has the same number of arguments.
Check if the current predicted type for the location in ii is specific enough for what the current opcode wants.
Check if the decl has an explicit accessibility attribute.
Check if the declaration had the attribute.
Check if the element type is a trivial type.
Check if the explicitly-written enum type matches the type we're coercing to.
Check if the funcd of `inst' has any characteristics which prevent inlining, without peeking into its bytecode or regions.
Check if the function has any 'owned' parameters.
Check if the function matches this breakpoint
Check if the generator has started yet
Check if the guy tries to do a -: kind of flag
Check if the inhabitant has any reserved low bits set.
Check if the inhabitant is below the least valid pointer value.
Check if the inputs changed.
Check if the instruction at block `b', index `i' of `env.unit' is an `op'.
Check if the instruction corresponds to user-written code, also make sure we don't report an error twice for the same instruction.
Check if the instruction is already in the user's block.
Check if the instruction we are visiting could potentially decrement the reference counted value we are tracking in a manner that could cause us to change states.
Check if the instruction we are visiting could potentially decrement the reference counted value we are tracking...
Check if the instruction we are visiting could potentially use our instruction in a way that requires us to guarantee the lifetime of the pointer up to this point.
Check if the last command parsed by the client has an argument to change the status of a breakpoint.
Check if the lookup we're about to perform a lookup within is a Clang module.
Check if the loop iterates from 0 to the count of this array.
Check if the memory addressed by the argument may alias any writes.
Check if the merge is good for the callee.
Check if the merge is good for the caller.
Check if the method implementation is the same in a super class, i.e. it is not overridden in the derived class.
Check if the name conflicts with a reserved typehint.
Check if the next expected diagnostic should be in the same line.
Check if the next instruction is an acceptable FCall.
Check if the node needs to be processed.
Check if the normal and error blocks are empty, except the ARC uses.
Check if the normal and error blocks have a common single successor.
Check if the normal and error results only have ARC operations as uses.
Check if the object "content", i.e. a pointer to one of its stored properties, can escape to the called function.
Check if the object itself can escape to the called function.
Check if the optimizer knows how to cast the return type.
Check if the partial_apply has generic substitutions.
Check if the pattern is a Bool literal
Check if the predecessor is not produced by a switch_enum instruction.
Check if the root value for Value that comes / along the path from DomBB is equivalent to the / DomCondition.
Check if the select_enum's result is a single integer scalar.
Check if the site is valid.
Check if the source is a subclass of the target.
Check if the step in command is active.
Check if the store is the only use.
Check if the subclass overrides a method
Check if the subclass overrides a method and provides a different implementation.
Check if the target is an existential that Optional always conforms to.
Check if the target is supported for this sanitizer.
Check if the type conforms to _BridgedToObjectiveC, in which case we'll extract its associated type.
Check if the type conforms to _BridgedToObjectiveC.
Check if the type is an enum and check the constraint if it is.
Check if the type-protocol entry exists in the cache entry that we found.
Check if the unknown type is in the type remappings.
Check if the value is not live anywhere in Inst's block.
Check if the value is the this-argument of the array method.
Check if the value of V is computed by means of a simple initialization.
Check if the value of this alloc_stack is set only once by a store instruction, used only by CCABI and then deallocated.
Check if there are any private properties or any internal properties and it is a whole module compilation.
Check if there are enough bytes left in the buffer
Check if there is a store to this property.
Check if there is already a name defined in this request for this NamedEntity.
Check if there is any input waiting on us.
Check if there is only a single statically known implementation of the method which can be called by the default case handler.
Check if there's any parent.
Check if this alloc_stack is only initialized once by means of a single init_existential_ref.
Check if this alloc_stack is only initialized once by means of single init_existential_addr.
Check if this block is post dominated by ARC unreachable blocks.
Check if this call to "make_mutable" is hoistable, and move it, or delete it / if it's already hoisted.
Check if this callee is a candidate for DefInlineFP sinking
Check if this class is effectively final.
Check if this class is implemented in its adapter.
Check if this escape can reach the current loop.
Check if this file contains raw hip hop bytecode instead of php.
Check if this file has already been included.
Check if this instruction is the first call to noreturn in this block.
Check if this invocation should execute a subcommand.
Check if this is a function declaration which is within a transparent extension.
Check if this is the member we were looking for.
Check if this loop has multiple latches.
Check if this method is declared in the context that conforms to / NSAccessibility.
Check if this name already was defined as a type alias, and if so make sure it is compatible.
Check if this protocol is implemented in its adapter.
Check if this specialization should be linked for prespecialization.
Check if this struct has any let properties.
Check if this zval could be dtor()'ed somehow
Check if two addresses can potentially access the same memory.
Check if two width constraints have any overlap.
Check if we already had a raw type.
Check if we already have a declaration or definition for this witness table.
Check if we already have a pre-exit block, return it.
Check if we already have an equivalent phi.
Check if we already reported a decl with the same signature.
Check if we are converting a constant integer.
Check if we are hitting a call breakpoint
Check if we are hitting a line breakpoint.
Check if we are hitting a return breakpoint
Check if we are past the imaginary EOF, and synthesize a tok::eof in this case.
Check if we are the true case, ie, we know that we are the given tag.
Check if we can simplify a cast into: - ObjCTy to _ObjectiveCBridgeable._ObjectiveCType.
Check if we can skip the llvm part of the compilation if we have an existing object file which was generated from the same llvm IR.
Check if we can statically predict the outcome of the cast.
Check if we come to the Pred block by comparing the input value to a constant.
Check if we found a superclass we are looking for.
Check if we have 'didSet'/'willSet' after attributes.
Check if we have a CDF file
Check if we have a consistent value for all non-cold predecessors.
Check if we have a raw spec.
Check if we have a runtime function with the buffer as argument.
Check if we have a tar file
Check if we have a unary '-' with number literal sub-expression, for example, "-42" or "-1.25".
Check if we have allocated a region for this BB.
Check if we have already associated this apply inst with a closure to be specialized.
Check if we have any more conversions remaining.
Check if we have at least one complete line.
Check if we know more about the type from our whitelists.
Check if we need the inner parentheses.
Check if we need to emit a body for this function.
Check if we need to wrap the bridged result in an optional.
Check if we require a re-abstraction thunk.
Check if we should stop due to flow control, breakpoints, and signals.
Check if we still have some nodes which don't reach a points-to edge, i.e. points not yet in the WorkList.
Check if we were the last request on this channel
Check if we've already computed the TBAA relation.
Check if we've already computed this result.
Check if we've reached a fixed point yet.
Check immediately for an existing cache entry.
Check inherited protocols for class-ness.
Check instanceof using instance bitmasks.
Check instanceof using the superclass vector on the end of the Class entry.
Check instruction and its immediates.
Check invariants about the bytecode instructions in this Block.
Check invariants about the metadata for this Block.
Check is the function that checks for overflow, Over is the function that returns the overflowed value.
Check is trivially true.
Check it's a valid JSON format
Check iterator variable state.
Check locally to see if any elements are satisfied within the block, and keep track of which ones are still needed in the NeededElements set.
Check metatype objects directly.
Check minimum supported OS versions.
Check non-type requirements.
Check now to ensure that they meet our expectations.
Check nullability of the parameter.
Check number of args...
Check of a given name could be a name of a white-listed / specialization.
Check of this escape can reach the current loop.
Check one block for being well formed.
Check other direction on the support_map.
Check other expected properties of the C type.
Check our persistent storage and determine if it's an SSLSocket or just a regular socket.
Check out all of the type variables lurking in the system.
Check out the operator attributes.
Check parent context.
Check property and subscript overriding.
Check protocol conformance.
Check protocol conformances table.
Check protocol conformances.
Check representations only for the top-level metatypes as only those are SIL-lowered.
Check return type, free pending iterators and actually return.
Check runtime functions responsible for implicit bridging of Objective-C / types.
Check safety of error-handling in the declaration, too.
Check section 6 of rfc 822 http://www.faqs.org/rfcs/rfc822.html
Check signage of expo
Check some cloning related constraints.
Check some invariants around InitCtx: 1.
Check some runtime options
Check special-case names first.
Check stack depth to avoid overflow.
Check surprise flags in the same place as the interpreter: after setting up the callee's frame but before executing any of its code.
Check that T conforms to all inherited protocols.
Check that a normal protocol conformance is complete.
Check that all of the operands are extracts of the correct kind.
Check that all of the values are initialized properly.
Check that all of the values that we inserted are in the map.
Check that all storage users are in the Array's live blocks.
Check that all stored properties have in-class initializers.
Check that all users of the destination address of the copy are dominated by / the copy.
Check that argument counts and convention match.
Check that conditions are the equivalent in this case as well.
Check that different values don't give the same index.
Check that each dst is defined only once.
Check that every allocation in heap has been freed before destruction.
Check that every byte in the unit's bytecode is inside exactly one function's code region.
Check that every generic parameter type from the signature is among referencedArchetypes.
Check that everything preceding the match is neither a lowercase letter nor a '_'.
Check that if the apply is of a noreturn callee, make sure that an unreachable is the next instruction.
Check that indexing is persistent.
Check that indexing is still persistent.
Check that invalidation works.
Check that it has the correct selector.
Check that it is a dominating checked_cast_br.
Check that it returns two size_t's and takes no other arguments.
Check that no two status-flag register lifetimes overlap.
Check that nodes marked invalid have the correct type.
Check that non-terminators look ok.
Check that requirements are semantically valid
Check that requirements are semantically valid.
Check that setcc/xor pair is collapsed with different condition.
Check that the 'value' property from the protocol matches the declared property type in context.
Check that the Array is not retained with this loop and it's address does not escape within this function.
Check that the Objective-C method(s) provided by the witness have / the same selectors as those required by the requirement.
Check that the allocated type is a struct or a tuple and that there are no unreferenced fields.
Check that the archetype isn't constrained in a way that makes the binding impossible.
Check that the argument has the same incoming edge values as the value / map.
Check that the argument is passed as an in type.
Check that the argument is passed as an inout or by value type.
Check that the argument is passed as an inout type.
Check that the argument is passed as an out type.
Check that the argument types are matching.
Check that the arguments and result match.
Check that the arguments are the same and in the right order.
Check that the array is a member of an inout argument or return value.
Check that the array value is released before a mutating operation happens.
Check that the branch argument is of the expected dynamic method type.
Check that the constructed struct and the extracted struct are of the same type.
Check that the constructed tuple and the extracted tuple are of the same type.
Check that the declaration attributes are ok.
Check that the discriminator is unique in its context.
Check that the fixed layout matches the runtime layout.
Check that the function takes the expected arguments and returns the expected result type.
Check that the generic requirements line up with the archetypes.
Check that the given inner region is valid, within the outer region, and the inner region boundaries are exact instructions.
Check that the given type is a legal SIL value.
Check that the incoming value is identical to the first literal.
Check that the input type can be value cast to the output type.
Check that the instructions match cases in the same order.
Check that the length of the list is correct.
Check that the member "name" is a valid index into the tuple.
Check that the mutating bit is ok.
Check that the new and old offset still point to the same token.
Check that the offset is within the region and it lands on an exact instruction start.
Check that the optional printf format in description matches the type of the magic.
Check that the pat and str tails match
Check that the raw value is unique.
Check that the request matches the signature
Check that the result isn't null.
Check that the stack height is consistent coming from all entry points into this BB.
Check that the two l-value expressions have the same type.
Check that the type is a nominal type.
Check that the type matches the pattern type.
Check that the type parameter is well-formed and set it up for returning.
Check that the type witness meets the requirements on the associated type.
Check that the type, if explicitly spelled, is ok.
Check that the types of this value producer are all legal in the function / context in which it exists.
Check that the update region is still well-formed.
Check that the use of an Array element is safe w.r.t.
Check that the use of an Array value, the value of an aggregate containing / an array, or the value of an element within the array, is safe w.r.t / make_mutable hoisting.
Check that there are no accidental collisions.
Check that there is a matching retain before the unsafeGuaranteed builtin with only retains inbetween.
Check that there is a payload at the address.
Check that there is no decrement or check from the increment to the end of the basic block.
Check that there is nothing preventing removal.
Check that this alloc_stack is initialized only once.
Check that this block only produces the value, but does not have any side effects.
Check that this is actually the response we want
Check that this literal is only used by the terminator.
Check that this operand appears in the use-chain of the value it uses.
Check that we can actually derive Equatable for this type.
Check that we can actually derive Hashable for this type.
Check that we didn't get any unknown values.
Check that we don't have any missing or extra arguments.
Check that we don't have collisions.
Check that we have a payload.
Check that we have a single Apply user.
Check that we have a single WMI user.
Check that we have a stored access strategy.
Check that we have an array initialization call with a known count.
Check that we have an array initialization call with known elements.
Check that we have the needed symbols in the frameworks.
Check that we imported an initializer name.
Check the APP1 for Exif Identifier Code
Check the Dest expression in a setter context.
Check the FailureBB if it is a BB that contains a class_method referring to the same value as a condition.
Check the ObjC protocol conformances if there were any.
Check the SILLLocation attached to the instruction.
Check the argument types for each of the parameters.
Check the array element type parameter.
Check the availability of the type.
Check the base the array element address is dependent on.
Check the cache for a concrete value.
Check the cache in ASTContext.
Check the cache to see if we have already computed the destructor behavior for its SILType.
Check the caches again.
Check the callee, looking through implicit conversions.
Check the catch pattern.
Check the class constraint if necessary.
Check the condition on line breakpoints.
Check the conformance below.
Check the context, introducing the default if needed.
Check the correctness of error handling within the given enum / element's raw value expression.
Check the current set of type witnesses.
Check the debug scope.
Check the declaration itself.
Check the default argument definitions.
Check the default arguments that occur within this pattern.
Check the default definition, if there is one.
Check the entire protocol conformance, ensuring that all / witnesses are resolved and emitting any diagnostics.
Check the expression as a condition.
Check the extra inhabitant cases if we have any.
Check the first ID to decide if we are using indices to the Decl's Archetypes.
Check the folding set to see whether we already have an exemplar matching this archetype.
Check the fpi region to be sure.
Check the general memory behavior for instructions we didn't handle above.
Check the generic arguments against the generic signature.
Check the generic parameter list.
Check the generic parameters for something with the given name.
Check the generic parameters if our context is a generic type or extension thereof.
Check the generic parameters in the given generic parameter list (and its / parent generic parameter lists) according to the given resolver.
Check the generic parameters of an extension, recursively handling all of / the parameter lists within the extension.
Check the get_element_addr call.
Check the given explicit protocol conformance.
Check the given list of protocols.
Check the guard expression, if present.
Check the hit condition
Check the inactive regions of a #if block to disable warnings that may be due to platform specific code.
Check the inline cache.
Check the length of the class vectors.
Check the location kind.
Check the module file's last modification time.
Check the next two values for correctness.
Check the order of the declarations.
Check the parameter patterns.
Check the parameter types.
Check the parameters.
Check the pattern, it allows unspecified types because the pattern can provide type information.
Check the payloads to see if we can take advantage of common layout to optimize our value semantics.
Check the profitability of specializing the closure argument.
Check the raw value expr, if we have one.
Check the raw values of the cases.
Check the representation of the function type.
Check the request kinds.
Check the requirements on the generic arguments.
Check the rest of the gzip header
Check the result type of the function.
Check the retain/release around the check_subscript call.
Check the retain/release around the get_element_addr call.
Check the running OS version to determine whether it is in the range specified by elt.
Check the signature of F to make sure that it is a function that we can specialize.
Check the signature of a generic function.
Check the stack depth, abort if we've reached the limit
Check the stored properties.
Check the substitutions passed to an apply or partial_apply.
Check the type of the array.
Check the uses list to see if there are any non-store uses left over after load promotion and other things DI does.
Check the uses of the operand, but do not recurse down into other apply instructions.
Check the visibility of this property.
Check this / recursively.
Check this type against the protocol requirements.
Check threshold value
Check to ensure that we have an OverloadedDeclRef, and that we're not favoring multiple overload constraints.
Check to make sure all inputs are containers
Check to make sure that all blocks are well formed.
Check to make sure we are dealing with a regular file
Check to make sure we are not going to go past the ExifLength
Check to see if D and PrevDecl are valid in the same overload set.
Check to see if a function of this name has been forward referenced.
Check to see if any found diagnostics have the right line and classification, but the wrong text.
Check to see if any loaded subelements are being used, and if so, explode the copy_addr to its individual pieces.
Check to see if it is in the request-local cache
Check to see if it is used by an apply that came from a call to self.init.
Check to see if it is used by an apply that came from a call to super.init.
Check to see if lookup succeeds if part is split off, and record the matches found.
Check to see if the TLCD has an expression that we have to transform.
Check to see if the address of the alloc_stack is only passed to one apply_inst.
Check to see if the alloc_box was used by a mark_uninitialized instruction.
Check to see if the contextual type conforms.
Check to see if the convention fulfills a source of the metadata we need.
Check to see if the encoding is valid.
Check to see if the first argument expects an inout argument, but is not an lvalue.
Check to see if the given function application throws.
Check to see if the given pattern is a specializing pattern, / and return a semantic pattern for it.
Check to see if the instruction immediately before the insertion point is a copy_addr from the specified operand.
Check to see if the instruction immediately before the insertion point is a retain_value of the specified operand.
Check to see if the instruction immediately before the insertion point is a strong_retain of the specified operand.
Check to see if the range is in reverse order.
Check to see if the requested value is fully available, as an aggregate.
Check to see if the specified VarDecl is part of a larger / PatternBindingDecl, where some other bound variable was mutated.
Check to see if the stored location is either fully uninitialized or fully initialized.
Check to see if the type of the tuple can be inferred accurately from the elements.
Check to see if there is an argument label.
Check to see if there is anything going on here.
Check to see if this constraint came from a cast instruction.
Check to see if this ctor has zero arguments, or if they all have default values.
Check to see if this is a locator referring to something we cannot or do here: in this case, we ignore paths that end on archetypes witnesses, or associated types of the expression.
Check to see if this is a potentially unsupported partial application.
Check to see if this is a use of self or super, due to a method call.
Check to see if this is already defined.
Check to see if this is an impossible candidate.
Check to see if this is the last character in the set, in which case it is not a range and we should add the previous character as well as the dash.
Check to see if this looks like a type.
Check to see if we already have an entry for this decl.
Check to see if we can DCE the instruction.
Check to see if we can instsimplify the instruction.
Check to see if we can pairwise coerce Swift's exploded scalars to Clang's expanded elements.
Check to see if we can pairwise-coerce Swift's exploded scalars to Clang's expanded elements.
Check to see if we had this expected diagnostic.
Check to see if we have a function by this name already.
Check to see if we have a global by this name already.
Check to see if we have an importer loaded.
Check to see if we have any incorrect diagnostics.
Check to see if we have multiple inout arguments which obviously alias.
Check to see if we need a default block.
Check to see if we need to back up because we only got a sign or a trailing x after a 0.
Check to see if we need to back up because we saw a trailing 'e' or sign.
Check to see if we're returning self in a class initializer before all the ivars/super.init are set up.
Check to see if we've already computed the market.
Check to see if we've already emitted an error at this location.
Check to see if we've already seen this protocol composition before.
Check to see if we've already seen this tuple before.
Check to see if we've maybe got a local reference already.
Check to see if workarounds are enabled.
Check to see if you have "x+y" (where x and y are type aliases) that match the canonical result type.
Check to see whether the optional is present, if not, jump to the current nil handler block.
Check to see whether we are seeing a redundant release.
Check to see which tuple elements this instruction defines.
Check type metadata records
Check using sp(env) in the -R version---remember that fp(env) does not point into the eval stack.
Check valid successor/predecessor edges, and identify reachable blocks.
Check vtable methods.
Check what was the value stored in the allocated stack slot.
Check whether Clang considers it an override.
Check whether Copy is before UserInst.
Check whether V is up to date.
Check whether a constraint failed.
Check whether a dominating check of the condition let's us replace the condition by false.
Check whether a locator with this anchor + path already exists.
Check whether a reference for this selector already exists.
Check whether a retain on the pointer is available in the predecessors.
Check whether a superclass has already declared this as a protected/public property.
Check whether a superclass has already declared this protected property.
Check whether a type conforms to a protocol.
Check whether a type conforms to the given protocols, filling in a / list of conformances.
Check whether all of the inherited protocols can have existential types themselves.
Check whether all operands are loop invariant.
Check whether an expression pattern is satisfied.
Check whether an unknown class instance is actually a class object.
Check whether another method with the same selector has already been imported into this context.
Check whether any associated types in this protocol resolve nested types of this potential archetype.
Check whether any needless words were omitted.
Check whether any of the associated types are dependent.
Check whether any of the associated types we care about are referenced in this value requirement.
Check whether any of the inherited protocols are dependent.
Check whether any of the inherited protocols fail to conform to themselves.
Check whether any of the substitutions are dependent.
Check whether any of the substitutions are refer to dynamic self.
Check whether any path leads to a non-trivial type.
Check whether anything changed.
Check whether database is writable by adding and removing a row in the 'writable' table.
Check whether encoding actually needs to be changed
Check whether it has integer type.
Check whether it is 'Self'.
Check whether it's already cached.
Check whether mmap(2) supports the MAP_UNINITIALIZED flag.
Check whether one declaration is better than the other.
Check whether rObjClass points to a strict subclass of rTestClass, set dst with the bool true/false result, and return dst.
Check whether releasing this value can call deinit and interfere with User.
Check whether the BBSetIn has changed.
Check whether the BBSetOut has changed.
Check whether the BBWriteSetIn has changed.
Check whether the ForwardSetOut has changed.
Check whether the SIL module defines it.
Check whether the addition is overflow checked by a cond_fail or whether code in the preheader's predecessor ensures that we won't overflow.
Check whether the argument is 'super'.
Check whether the argument is a dynamic member reference.
Check whether the array semantic operation could change an array value to / not be uniquely referenced.
Check whether the back-edge block is just a split-edge.
Check whether the base is 'super'.
Check whether the constraint graph knows about this constraint.
Check whether the context of any of the fields in the chain is a union.
Check whether the current end of the vector is a clean multiple of the chunk size.
Check whether the declarations are in a class.
Check whether the extension is in the overlay.
Check whether the first parameter is a subtype of the second.
Check whether the first type is a subtype of the second.
Check whether the given declaration contains its own generic parameters, / and therefore is not representable in Objective-C.
Check whether the given function is generic over a single, / unconstrained archetype.
Check whether the given function is non-generic.
Check whether the given type is Builtin.Int1.
Check whether the given type is Builtin.Word.
Check whether the given type is Optional applied to the given / type argument.
Check whether the given type representation will be / default-initializable.
Check whether the given type witness can be used for the given / associated type.
Check whether the instruction invalidate any locations due to change in / its location Base.
Check whether the low bit is set.
Check whether the macro is defined.
Check whether the metadata match.
Check whether the module in which the declaration resides has a module prefix and will map into Swift as a type.
Check whether the name can be found in the superclass.
Check whether the name changed.
Check whether the new self is null.
Check whether the nominal types match.
Check whether the optional has a value.
Check whether the other conforms to that protocol.
Check whether the parameter types match.
Check whether the previous declaration had a semicolon after it.
Check whether the process's active memory limit has been exceeded, and if so, stop the server.
Check whether the property already got imported.
Check whether the return type is dynamic 'Self'.
Check whether the self type matches.
Check whether the source and destination alias.
Check whether the source is bridged to Objective-C.
Check whether the store is to the address obtained from a getElementAddress / semantic call.
Check whether the string is processed well.
Check whether the supplied argument is the same as the default argument.
Check whether the target is bridged to Objective-C.
Check whether the type conforms to _BridgedToObjectiveC.
Check whether the type variable must be bound to a materializable type.
Check whether the types are identical.
Check whether there are any obvious reasons why the two given declarations do not have an overriding relationship.
Check whether there are any unsatisfied requirements.
Check whether there are needless words that could be omitted.
Check whether there is a conflict here.
Check whether there is a function with the same name as this property.
Check whether there is a superclass method for the getter that is *not* suppressed, in which case we will need to suppress this property.
Check whether there is a swift_bridge attribute.
Check whether there is a user-declared constructor or an instance variable.
Check whether there is already a method with this selector.
Check whether there's already an entry that's at least as good as the fulfillment.
Check whether there's some special method to import.
Check whether this CF typedef is a Mutable type, and if so, / look for a non-Mutable typedef.
Check whether this a single basic block loop - ignoring split back edges.
Check whether this entry matches any existing entry.
Check whether this failure is due to losing the schema initialization race with another process.
Check whether this initializer overrides an initializer in its superclass.
Check whether this initializer satisfies a requirement in a protocol.
Check whether this instruction blocks any RC root code motion.
Check whether this instruction will invalidate any other locations.
Check whether this is a 'array.props' instruction and whether we can hoist it.
Check whether this is a SILArgument.
Check whether this is a bridging upcast.
Check whether this is a known Foundation entity that conflicts with the standard library.
Check whether this is a release instruction.
Check whether this is a release on part of a guaranteed function argument.
Check whether this is a supertype requirement.
Check whether this is the depth 0, index 0 generic parameter, which is / used for the 'Self' type of a protocol.
Check whether this literal type conforms to the builtin protocol.
Check whether this macro has already been imported.
Check whether this mapping matches either the given decl directly or one of its overridden decl.
Check whether this method is in the class we care about.
Check whether this nominal type derives conformances to the
Check whether this protocol conforms to itself.
Check whether this requirement uses Self in a way that might prevent conformance from succeeding.
Check whether this selector already exists.
Check whether this string already exists.
Check whether this type conforms to the protocol.
Check whether we already found a value for this element.
Check whether we already have a cached answer.
Check whether we already have an archetype builder for this signature and module.
Check whether we already have an entry in the set of lookup tables.
Check whether we already imported this method.
Check whether we already know about the property.
Check whether we already know about this conformance.
Check whether we can downcast the source value to the Objective-C type.
Check whether we can hoist 'array.props' calls out of loops, collecting the preheader we can hoist to.
Check whether we can hoist make_mutable based on the operations that are in the loop.
Check whether we can hoist the dependent instructions resulting in the / array reference passed to the make_mutable call.
Check whether we can hoist the dependent instructions resulting in the array reference.
Check whether we can perform qualified lookup into this declaration context.
Check whether we can perform this binding.
Check whether we have a constructor that can be called with an empty tuple.
Check whether we have a default argument.
Check whether we have a direct substitution for the dependent type.
Check whether we have a duplicate.
Check whether we have a forced downcast.
Check whether we have a macro defined in this module.
Check whether we have a path that terminates at an archetype locator.
Check whether we have a simple identifier type.
Check whether we have a specified result type.
Check whether we have a string literal.
Check whether we have a typedef for "BOOL" or "Boolean".
Check whether we have a typedef that refers to a CoreFoundation type.
Check whether we have a valid selector piece.
Check whether we have a valid signature for semantic calls that we hoist.
Check whether we have already imported a method with the given / selector in the given context.
Check whether we have an Objective-C-defined class in our inheritance chain.
Check whether we have an apply initializing the enum.
Check whether we have an extension.
Check whether we have an identifier followed by another backtick, in which case this is an escaped identifier.
Check whether we have an implementation.
Check whether we have an overload choice in this solution.
Check whether we have nolock as an option
Check whether we have seen this destination block already.
Check whether we have the type expansion.
Check whether we inherited from the same type twice.
Check whether we need to bridge the key through an Objective-C class.
Check whether we need to bridge the value through an Objective-C class.
Check whether we need to bridge through an Objective-C class.
Check whether we need to run an optimistic iteration data flow.
Check whether we recursively imported this method
Check whether we should try to import this factory method as an initializer.
Check whether we're bridging to a class.
Check whether we're importing an Objective-C container of some sort.
Check whether we're looking up a factory initializer with class_method.
Check whether we've already cached this information.
Check whether we've already cached this.
Check whether we've already created a node for this type variable.
Check whether we've already created a subscript operation for this getter/setter pair.
Check whether we've already created the constructor.
Check whether we've already dealt with this dependent member.
Check whether we've already looked for and cached this protocol.
Check whether we've already performed this lookup.
Check whether we've already translated this protocol.
Check whether we've created the function already.
Check whether we've created the global variable already.
Check whether we've seen this protocol before.
Check witness methods.
CheckInitMem's pointee is TUninit on the taken branch, so update outState.
Checked Conversion instructions.
Checking and caching of Swift protocol conformances.
Checking configure timezone
Checking for key-length
Checking for passed proxy user and password
Checking functions whitelist
Checking if Int is a subset of Str shows us that removing Ref from lhs would erase types not present in rhs.
Checking specialization dropping.
Checking that all types are the same make guarantees that this cannot happen.
Checking that benefits from having the whole module available.
Checking the function parameter patterns might (recursively) end up setting the type.
Checks 4) and 5) below don't make sense for arcs corresponding to inlined calls and returns, so skip them in such cases.
Checks if Start to End is the range of 0 to the count of an array.
Checks if a given candidate is a type itself, one of its / superclasses or a related generic type.
Checks if a given global variable is assigned only once.
Checks if a given property may have any unknown uses which cannot be analyzed by this pass.
Checks if an address value does escape.
Checks if the block contains a cond_fail as first side-effect instruction / and tries to move it to the predecessors (if beneficial).
Checks if the given function breakpoint matches the given function.
Checks if the given region is well-formed, which entails the following properties:  1) The region has at least one block.
Checks if the interrupt type and site matches this breakpoint.
Checks if this JSONValue has a child at the given index. Use IsArray() before using this method.
Checks if this JSONValue has a child at the given key.
Checks if we can promote a buffer and returns the size of the buffer.
Checks if we don't need to import the typedef itself.
Checks in this file ensure that fatalError behaves as expected, but without stack traces.
Checks is a function is alive, e.g. because it is visible externally.
Checks relating to StaticStr and StaticArr are not, in general, precise.
Checks the command arguments, report errors and returning as appropriate.
Checks the given declaration's accessibility to make sure it is valid given / the way it is defined.
Checks to see if it is time to sample the stack.
Checks whether the apply instruction is checked for overflow by looking for / a cond_fail on the second result.
Checks whether the cmd has any breakpoints that match the current Site.
Checks whether two RefPredVecs contain the same elements, which may appear in different orders.
Child is the AFWH we're going to block on, nullptr iff this is a suspending generator.
Children have values from different bases, We need to create extractions and aggregation in this case.
Choose a register to allocate to `current', either via a hint or by various heuristics.
Choose a register to be the hint.
Choose an appropriate hint for the (sub-)interval `ivl'.
Choose split point along selected axis, and update box bounds.
Choose the Objective-C header output path.
Choose the dependencies file output path.
Choose the right implementation.
Choose the serialized diagnostics output path.
Choose the side further along in the sequence.
Choose the swiftdoc output path.
Choose the swiftmodule output path.
Choose which axis to split the box on.
Chop of the beginning of the name.
Chop off a "lib" prefix if we're building a library.
Chunk collection object
Chunked replies are sent async, so there is no way to know the time it took to flush the response, but tracking the bytes sent is very useful.
Claim --driver-mode here, since it's already been handled.
Claim and return all the rest of the characters.
Claim and return the next character.
Claim any additional unnamed arguments.
Claim only the self parameter.
Claim that the result is discarded to preserve the lvalue type of the expression.
Claim the address of each and then perform the writeback from the temporary allocation to the source we copied from.
Claim the correct number of inout arguments as well.
Claim the exception value.
Claim the foreign "self" with the self param.
Claim the foreign error with the method formal params.
Claim the next N inner args for this inner argument.
Claim the next argument with the name of this parameter.
Claim the next argument.
Claim the next character if it exists and equals the given / character.
Claim the next destination, returning a null pointer if there / is no special destination.
Claim the next few characters if they exactly match the given string.
Claim the next inner result from the plan data.
Claim the next inner result.
Claim the next len characters.
Claim the next outer result from the plan data.
Claim the self argument from the end of the formal arguments.
Claim the var initializer as the parameter to the `initStorage` method.
Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8)
Clamping to allow for rounding errors above
Clang believes that it can force tl_perf_counters into 16-byte alignment, and thus emit an inlined version of memcpy later in this file using SSE instructions which require  such alignment.
Clang declarations are public and can't be assured of having a unique defining location.
Clang expects this to be like an actual command line.
Clang extensions (categories) are always printed in source order.
Clang gives linkage names to things that don't actually have linkage.
Clang imported inline functions do not have a Swift body to typecheck.
Clang is currently broken...
Clang is doing the same thing here.
Clang may have defined the variable already.
Clang tracks the redefinition types separately, so it can provide fallbacks in certain cases.
Clang uses CGM.getTargetCodeGenInfo().getDependentLibraryOption(...).
Clang-generated accessors are "uncurried" here and not in the below loop because ClangType AbstractionPatterns don't support currying.
Clang-imported types should never get a default constructor, just a memberwise one.
Class and ObjC existential metatypes can be bridged, but metatypes can't directly conform to protocols yet.
Class and protocol metatypes are interoperable with certain Objective-C runtime classes, but only when ObjC interop is enabled.
Class bases are stored on the symbolic stack in a "virtual" way so we can resolve them later (here) in order to properly handle php evaluation order.
Class constructors have separate entry points for allocation and initialization.
Class declarations cannot be transparent.
Class ends with a dynamically sized array, m_classVec.
Class existentials are represented as record types.
Class existentials can't recursively contain existential containers, so we can fast-path by not bothering to recur.
Class existentials consist of a single retainable pointer followed by witness tables.
Class existentials, etc.
Class extension methods are only dynamically dispatched if they're dispatched by objc_msgSend, which happens if they're foreign or dynamic.
Class instance is already an ObjC object.
Class maps to AnyObject.Type.
Class member lookup table, which is a member lookup table with a second / table for lookup based on Objective-C selector.
Class metadata can be used as an object when ObjC interop is available.
Class metatypes bridge to ObjC metatypes.
Class metatypes have non-trivial representation due to the / possibility of subclassing.
Class names must be globally unique.
Class that performs enum tag state dataflow on the given BB.
Class type operations here are very conservative for now.
Class type or existential that inherits from NSObject.
Class values are currently never metatypes in the native runtime.
Class-constrained and boxed existentials are refcounted.
Class-constrained existential metatypes can be converted to AnyObject.
Class-constrained generic parameters, from ObjC generic classes.
ClassInfo was not able to serialize the value, so ext_reflection prepared a stdClass error object.
Classes and Objective-C existentials bridge verbatim.
Classes and class-bounded archetypes.
Classes and class-constrained archetypes.
Classes and protocols implemented in Objective-C have a special context mangling.
Classes are represented as DW_TAG_structure_type.
Classes are sources of metadata.
Classes can have subclasses, so the metatype is always thick.
Classes can inherit from a class.
Classes can never be initialized statically at compile-time.
Classes conform to AnyObject.
Classes do not alias non-classes.
Classes don't fallback to the global namespace.
Classes imported from Objective-C never requires dynamic initialization.
Classes known to be implemented in Swift can be assumed not to have tagged pointer representations, so we can use spare bits for enum layout with them.
Classes that might not have Swift metadata use a different symbol name.
Classes with NativeData structs allocate extra memory prior to the ObjectData.
Classes with separate class hierarchies do not alias.
Classes, then functions, then constants mimics the order of our existing warmup scripts
Classify a potential CF typedef.
Classify a throwing function according to our local knowledge of / its implementation.
Classify an argument being passed to a rethrows function.
Classify an argument to a 'rethrows' function that's a tuple literal.
Classify an argument to a 'rethrows' function that's a tuple shuffle.
Classify each element into three cases: known initialized, known uninitialized, or partially initialized.
Classify how close this match is.
Classify the given Clang enumeration to describe how to import it.
Classify the instruction.
Classify the operand.
Classify the part of speech of the word before the type information we would strip off.
Classify the provided optionality issues for use in diagnostics.
Classify the type according to its stored properties.
Classify this declaration.
Classify usages of Self in the given type.
Classref symbolic flavor
Clause start, note that the first clause start location is the same as that of the whole statement
Clean the graphs up, so they're easier to pattern match against in the optimize pass.
Clean up a bunch of request state.
Clean up and reassign
Clean up anything that we've placed into a stack to check.
Clean up the given declaration type for display purposes.
Clean up the given requirement type for display purposes.
Clean up the old collection that we no longer need
Clean up the source if we're supposed to.
Clean up tvRef2 before overwriting it.
Clean-up standard streams
Cleaning up after these passes can expose more inlining opportunities.
Cleaning up just in case they have been set before
Cleanup SIL to make it suitable for IRGen.
Cleanup after this initialization.
Cleanup all resources owned by this proxy, including any threads it owns.
Cleanup any created chunks from the chunks collection
Cleanup any created chunks from the chunks collection.
Cleanup any proxies in our retired proxy queue.
Cleanup instructions/builtin calls not suitable for IRGen.
Cleanup locations point to the decl of the value that is being destroyed (for diagnostic generation).
Cleanup that always has to occur after the function call.
Cleanup that writes back to an inout argument on function exit.
Cleanup the builder and return whether or not we made any changes.
Cleanup the captured argument.
Cleanup the merged node.
Cleanup to destroy an initialized 'var' variable.
Cleanup to destroy an initialized variable.
Cleanup to destroy an uninitialized box.
Cleanup to destroy an uninitialized local variable.
Cleanups we introduced when splitting.
Clear AllocStack state.
Clear all cached data before exiting, so it is not detected as leaked.
Clear annotations from the failed attempt.
Clear any Xenon flags that might still be on in this thread so that we do not have a bias towards the first function.
Clear any added tagsets to avoid an inconsistent state
Clear any previous setting.
Clear any releases found for this argument.
Clear any stored exception
Clear any tag bits stored in the payload area of the given address.
Clear any timeout handlers to they don't fire when the request has already been destroyed.
Clear argument map and map ApplyInst arguments to the arguments of the callee's entry block.
Clear each time we run so that we can run multiple times.
Clear existing tagsets
Clear generator's key.
Clear lower byte Place only the byte into the register, keeping the higher 56bits
Clear non-request-local state without deleting `this`.
Clear oom/timeout while handling exception and restore them afterwards.
Clear our delete list.
Clear out any exceptions that might be left over from previous requests.
Clear out other "failed" state.
Clear out result parameters.
Clear out the class requirement location.
Clear out the error convention.
Clear out the hash table
Clear out the old value to avoid double-frees
Clear out the target locator result.
Clear out the type of the decl.
Clear tag bits out of the payload area, if any.
Clear the AA_opacity array behind us.
Clear the body of BB.
Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps cannot get any information.
Clear the cache if we haven't refreshed it in a while
Clear the debugger blacklist PC upon last detach if JIT is used
Clear the existing value's name so we can steal it.
Clear the extra-lines buffer
Clear the flow filter
Clear the instructions we are tracking currently, but leave that we saw a release on them.
Clear the list of constraint on every block.
Clear the pc filters.
Clear the persistence flag
Clear the ref count state in preparation for more pairs.
Clear the ref count state so it can be used for future pairs we may see.
Clear the state if the basic block has no predecessor.
Clear the worklist-flag for the next call to computePredsLiveOut().
Clear them from the set we're scanning from.
Clear tracked information for slots pushed and popped.
Clear up at the beginning of each SILFunction.
ClearSilver is not thread-safe when calling hdf_init(), so guarding it.
Clearing these lets us merge together more duplicates.
Client code should use apache_request_headers() to retrieve the original headers if they are security-critical.
Client initiated shutdown.
Clients can do what they want in walkToTypeLocPre.
Climb the DeclContext hierarchy to see if any of the containing declarations matches the predicate.
Climb up to the top-most macro invocation.
Clobber rvmsp in debug builds.
Clobbering an existing file is fine.
Clone FRI and PAI, and replace usage of the removed closure argument with result of cloned PAI.
Clone a new, non-DWARF Mangler for the DeclContext.
Clone a single exit multiple exit region starting at basic block and ending / in a set of basic blocks.
Clone all instructions from Insns into DestBB
Clone and fixup the load, retain sequence to the header.
Clone anything else about the component that we might need in the writeback.
Clone constructor, allocates a new ParamDecl identical to the first.
Clone each of the blocks.
Clone each of the instructions in the block.
Clone generic parameters.
Clone or create the generic parameters.
Clone the `unit's CFG starting at `startBlock', and rename SSATmps according to `tmpRenames' map along the way.
Clone the arguments from header into the pre-header.
Clone the basic blocks in a loop.
Clone the basic blocks in the loop.
Clone the blocks in the loop.
Clone the closure with the given promoted captures.
Clone the component if this isn't final.
Clone the component without cloning the indices.
Clone the components.
Clone the dominator tree from the original region to the cloned region.
Clone the existing generic parameter list.
Clone the function the existing partial_apply references.
Clone the generic arguments.
Clone the given generic parameters in the given list.
Clone the instructions in this basic block and recursively clone successor blocks.
Clone the instructions to the exit before specializing.
Clone the original partially applied function into the new specialized / function, replacing some arguments with literals.
Clone the parameter list over for a new decl, so we get new ParamDecls.
Clone the partially applied function, replacing incoming arguments with / literal constants.
Clone the referenced function of each partial_apply, removing the operands that we will not need, and remove the existing partial_apply.
Clone the region from the new preheader up to (not including) the exit blocks.
Clone the struct for the end index.
Clone the struct for the start index.
Clone the tuple elements.
Clone using a data-specific clone function.
Cloning such blocks can allow ARC to sink retain / releases onto the ObjC path.
Close all connections
Close main() with the final data from when profiling was turned off.
Close the code completion connection.
Close the current log file handler
Close the dangling stack with the last entry.
Close the loop on relative references.
Close the old socket, it may still be open.
Closing all proxy connections will force the local proxy to pop out of it's wait, and eventually exit the main thread.
Closure argument lists are allowed to be missing types.
Closure classes can be cloned and rescoped at runtime, so it's not safe to assert the exact type of closure objects.
Closure classes must be defined before anything else in the Unit.
Closure classes must be unique and defined in the unit that uses the CreateCl opcode, so resolution must succeed.
Closure expressions always have function type.
Closure expressions implicitly return the result of their body expression.
Closure object properties are the use vars followed by the static locals (which are per-instance).
Closure static locals are represented as special instance properties with a mangled name.
Closure static variables are per instance, and need to start uninitialized.
ClosureExpr's evaluate their bound variables.
Closures and generators from closures don't satisfy the "one static per source location" rule that the inline fastpath requires
Closures and initializers can't themselves be generic, but they can occur in generic contexts.
Closures are currently never natively generic.
Closures are implemented by anonymous classes that extend Closure.
Closures are the specialest.
Closures can't be rethrowing-only unless they're defined within the rethrows context.
Closures do not have destructors.
Closures have a hidden local that's always the first (non-parameter) local, which stores the closure itself.
Closures have an interal 0Closure variable
Closures have an m_this but they aren't in object context.
Closures inside of classes are analyzed in the context they are created in (this affects accessibility rules, access to privates, etc).
Closures should appear at the VERY top of the file, so if any class in the same file tries to use them, they are already defined.
Closures will not have an 86pinit body, but still may have properties of kind KindOfUninit (they will later contain used variables or static locals for the closure body).
Cluster the blocks based on weights and sort the clusters.
Coalesce Nodes if possible with adjacent free nodes
Code 80 *also* comes from recv_header() (abs()) recv_data() stream handlers
Code and data alignment factors.
Code completion for the generic type params.
Code completion was inside the signature, don't attach the body.
Code emitted in the branch can emit into our buffer for address-only conditionals.
Code executed at the beginning of each rule, after yytext and yyleng have been set up.
Code executed at the end of each rule.
Code mostly swiped from folly, but with significant modifications.
Code motion that hoists releases into diamonds.
Code taken from libxml2 (2.6.20) xmlNewReconciliedNs  Find a close prefix which is not already in use.
Code that has an autoclosure as location should not show up in the line table (rdar://problem/14627460).
CodeGen can't build ssa for objc methods.
CodeMotionContext - This is the base class which retain code motion and / release code motion inherits from.
CodeSmasher is used to overwrite all the relocated code with ud2 and int3 to ensure that we never execute it after the code has been relocated.
Codegen may fail and cause us to clear the partially-populated fixups, so we wait until after that to manually add the alignment fixup.
Coding style component
Coerce an 'is' pattern by determining the cast kind.
Coerce argument types for those cases where the IR type required by the ABI differs from the type used within the function body.
Coerce each parameter to the respective type.
Coerce each subpattern to its corresponding property's type, or raise an error if the property doesn't exist.
Coerce each tuple element to the respective type.
Coerce from a tuple to a tuple.
Coerce memoized methods to private.
Coerce scalar to tuple.
Coerce the base to the container type.
Coerce the element to the expected type.
Coerce the expression to the scalar type.
Coerce the given 'isa' pattern via a conditional downcast.
Coerce the index argument.
Coerce the input to whatever type is specified by the CoerceExpr.
Coerce the object type, if necessary.
Coerce the operand to the exception type.
Coerce the pattern to the exception type.
Coerce the pattern to the subject's type.
Coerce the pattern, in case we resolved something.
Coerce the specified parameter list of a ClosureExpr to the specified / contextual type.
Coerce the subpattern to the destination type.
Coerce the subpattern.
Coerce the then/else branches to the common type.
Coerce to an r-value.
Coerce to the property type.
Coercion by itself is a no-op.
Coercion exprs have a rigid type, so there's no use in gathering info about them.
Coercion from a subclass to a superclass.
Coercion from archetype to its (concrete) superclass.
Coercion from one function type to another, this produces a FunctionConversionExpr in its full generality.
Coercion from one metatype to another.
Coercion from subclass to superclass.
Coercion to an autoclosure type produces an implicit closure.
Coercions from a type to an existential type.
Coercions from an lvalue: load or perform implicit address-of.
Coercions to function type.
Coercions to tuple type.
Collect a full candidate list of callees based on the partially type checked function.
Collect a separate set of copies that can be removed via NRVO.
Collect all array.props calls in the cloned basic blocks stored in the map, / asserting that we found at least one.
Collect all arrays in this function.
Collect all case infos from the merge block's predecessors.
Collect all generic params referenced in parameter types, return type or requirements.
Collect all getCount users and check that there are no escapes or uses that / could change the array value.
Collect all get_element users and check that there are no escapes or uses / that could change the array value.
Collect all nodes which are reachable from the SourceNd via a path which only contains defer-edges.
Collect all of the Objective-C methods with this selector.
Collect all of the Objective-C selectors in the method table.
Collect all of the PartialApplyInsts that are used as arguments to ApplyInsts.
Collect all of the archetypes in this declaration context and its / parents.
Collect all of the archetypes.
Collect all of the constraints known to the constraint graph.
Collect all of the following bitfields.
Collect all of the generic parameter lists.
Collect all of the generic parameter types at every level in the generic / parameter list.
Collect all of the keys and sort them.
Collect all of the methods with this selector.
Collect all of the remaining archetypes.
Collect all of the results in order.
Collect all of the stores into the AllocStack.
Collect all of the visible declarations.
Collect all reachable blocks by walking the successors.
Collect all recursively hoistable calls.
Collect all summary of all sub loops of the current loop.
Collect all the fields from the type.
Collect all the fields of a union.
Collect all the instruction ranges for the current block and sort them.
Collect all the loop live out values in the map that maps original live out / value to live out value in the cloned loop.
Collect all the nested archetypes.
Collect all the primary archetypes.
Collect all the required substitutions.
Collect all users of element values.
Collect all users of the address and loads.
Collect all uses of a struct given an aggregate value that contains the / struct and access path describing the projection of the aggregate / that accesses the struct.
Collect all uses of the Struct value.
Collect all uses of the value at the given address.
Collect all uses that are calls to array.count.
Collect all uses, before casting.
Collect and analyze all functions to recompute, starting at Initial.
Collect and sort the set of module names.
Collect any builtin types referenced from this type.
Collect any concrete type metadata that's been passed separately.
Collect any early sources and bind local type data from them.
Collect any linked expressions.
Collect any required metadata for a witness method from the end of / the given parameter list.
Collect arguments from the apply instruction.
Collect array.props calls in all cloned blocks, excluding the exit blocks.
Collect bit depth info
Collect blocks for which we have to calculate the out-availability.
Collect blocks to tail duplicate.
Collect both the value and the pointer.
Collect captures if the accessor has them.
Collect conformances by looking up the conformance from replacement / type and protocol decl in GenericParamList.
Collect conformances for the type.
Collect constraints from the element pattern.
Collect constraints from the pattern.
Collect disjunctions.
Collect existential types.
Collect fields from this class and add them to the layout as a chunk.
Collect global variables for static properties.
Collect hint metadata for phis.
Collect information about the retain count result as well.
Collect innermost loops.
Collect input arguments to the generic metadata accessor, as laid out by the GenericArguments class.
Collect instructions that either initialize or release any values at the object defined by defInst.
Collect jump threadable edges and propagate outgoing edge values of conditional branches/switches.
Collect llvm.compiler.used globals already in the module (coming from ClangCodeGen).
Collect loops for a recursive bottom-up traversal in the loop tree.
Collect non-function captures.
Collect non-trivial generated values.
Collect out of loop uses of this value.
Collect outside uses.
Collect parameters for a call to a builtin.
Collect pins that we have to clear because they might have been released.
Collect property access information for the whole module.
Collect property names from all categories and extensions in the same module as the class.
Collect property names from all extensions in the same module as the class.
Collect property names from the class definition.
Collect property names from the class.
Collect references to the protocol descriptors.
Collect requirements at the current depth.
Collect requirements for this level.
Collect results from the searches
Collect the BBArg index of each struct oper.
Collect the applies for this block in reverse order so that we can pop them off the end of our vector and process them in forward order.
Collect the arguments to the implementation.
Collect the arguments to the uncurried call.
Collect the arguments.
Collect the array.props call that we will specialize on that we have cloned in the cloned loop.
Collect the block arguments, which may have nonstandard conventions.
Collect the captures, if any.
Collect the cases and specialized rows.
Collect the complete set of generic arguments.
Collect the complete set of generic parameter types.
Collect the conformances for all the protocols of an existential type.
Collect the conformances that need witness tables.
Collect the constraints for this component.
Collect the context generic parameters for the witness.
Collect the decrement insertion point if we have one.
Collect the direct and indirect subclasses for the class.
Collect the elements of the tuple patterns for argument and body parameters.
Collect the exit blocks dominated by the loop - they will be dominated by the check block.
Collect the exploded elements.
Collect the increment insertion point if it has one.
Collect the interesting information that gets encoded in a type layout record, to see if there's one we can reuse.
Collect the linker options already in the module (from ClangCodeGen).
Collect the locations and their corresponding values into a map.
Collect the lowercase letters up to the next word.
Collect the native arguments, which should all be +1.
Collect the nested types, sorted by name.
Collect the parameter type names.
Collect the primary archetypes first.
Collect the remaining (unnamed) inputs.
Collect the requirements placed on the generic parameter types.
Collect the reserved and invoke pointer fields.
Collect the rows to specialize.
Collect the same type constraints.
Collect the same-type constraints by their representative.
Collect the selector pieces.
Collect the set of associated types rooted on Self in the signature.
Collect the set of nested types of this archetype, and put them into the archetype itself.
Collect the set of protocols inherited by this conformance.
Collect the set of requirements placed on the given generic parameters and / their associated types.
Collect the set of visible Objective-C methods with this selector.
Collect the set of witnesses that came from this context.
Collect the stored properties of the type.
Collect the tuple elements, which should all be maximally abstracted to go in the optional payload.
Collect the type infos for the context parameters.
Collect the users of this instruction.
Collect the uses of the value.
Collect the value witnesses for a particular type.
Collect the witness tables.
Collect those submodules that are actually imported but have no import decls in the module.
Collect together all the instructions after this point
Collect type variables.
Collect values defined in the loop but used outside.
Collect virtual calls that may be specialized.
Collected information for a select_value case or default case.
Collecting the correct servers
Collection accessors can read from their inner array buffer, but stores COW and behave as if they only affect collection memory locations.
Collection iterator specialized functions.
Collection of all instructions that should be deleted.
Collections are not allowed
Collections can't contain refs, so check for any refs in the input array and look for int-like string keys at the same time.
Collections can't contains refs, so we need to check for their presence before taking ownership of this array.
Collects the post-conditions associated with the current state, which is essentially a list of local/stack locations and their known types at the end of `block'.
Colorize the response output.
Combine adjacent Req nodes.
Combine checks that want to be hoisted to the same destination into hoist groups.
Combine into the interval already at the back of the vector.
Combine the given base name and first argument label into a single / name.
Combine the header, function records, and mappings together.
Combine the values and store to the destination.
Combine the whitespace after ':' into the type name.
Come up with a shorter name.
Coming out of SILGen, we assume that raw stores are initializations, unless they have trivial type (which we classify as InitOrAssign).
Command line handling.
Commands COMMAND(NAME, CLASS) NAME is the command name CLASS is the corresponding class
Commands elements in ExecutionContext::getCallerInfo
Commands in MongoDB are case-sensitive
Comment is past the clang node.
Commit units individually if an error occurred during batch commit.
Common Vector/ImmVector
Common base class for enums with one or more cases with data.
Common base template for enum type infos.
Common case is that we actually find the alias:
Common case is we have an empty string or a string with size bigger than one.
Common case: a single set of generic arguments, for which we need no allocation.
Common case: nothing left to resolve.
Common code for handling entities.
Common extension init
Common implementation for POD boxes of a known stride and alignment.
Common implementation for empty box type info.
Common implementation for non-fixed box type info.
Common implementation for single-refcounted boxes.
Common preconditions for Equatable and Hashable.
Common reporting for TU/module file.
Common type implementation details for all archetypes.
Common value witnesses
Commonly-used Clang classes.
Compare 'this' lvalue and the 'rhs' lvalue (which is guaranteed to have / the same dynamic PathComponent type as the receiver) to see if they are / identical.
Compare a variety of literals.
Compare argument names.
Compare each declaration to every other declaration.
Compare each of the bound arguments for this parameter.
Compare it with the class wrapper kind.
Compare low 32bits of each source
Compare operand with a case tag value.
Compare overload sets.
Compare specializations only if `rhs' is specialized.
Compare the element types.
Compare the extracted values
Compare the fixed scores by themselves.
Compare the load result against null.
Compare the stored extra inhabitant against the fixed extra inhabitant pattern.
Compare the type variable bindings.
Compare the whole object, not just the array representation
Compare this signature against the signature of other declarations with the same name.
Compare to SILValues structurally.
Compare tuple expressions.
Compare two declarations to determine whether one is a witness of the other.
Compare two left-aligned numbers: the first to have a different value wins.
Compare two sequences of SIL instructions.
Compares the strings via the Unicode Collation Algorithm on the root locale.
Comparison function for pending priority queue.
Comparisons against null are turned into comparisons with the empty string.
Comparisons against the empty string can be optimized to a comparison on the string length.
Comparisons against the empty string can be optimized to checks on the string length.
Compat function for systems that do not have strndup().
Compatibility is transitive, so we can forget our original method and just keep going up.
Compatibility with old code that looked in .mime
Compile a static string as HHAS
Compile pattern and display a warning if compilation failed.
Compile regex or get it from cache.
Compile with main function
Compiled regular expression
Compiler arguments do not matter
CompilerInvocation doesn't own the buffers, copy to a new buffer.
Compiles the given evaluation string and returns its unit.
Compiles the given expression so that when evaluated the expression result is returned.
Complain about '#selector'.
Complain about any ambiguities we detected.
Complain about functions that aren't called.
Complain about inconsistencies.
Complain about l-values that are neither loaded nor stored.
Complain about redundant conformances.
Complain about single-quote string and suggest replacement with double-quoted equivalent.
Complain about unresolved entries that remain.
Complain and pretend we saw it.
Complain and recover by chopping off everything after the first name.
Complain if that isn't what we got.
Complain if the adoptee is a non-final class.
Complain if we didn't reach the end of the inputs.
Complain if we should have a body.
Complain on the first offender.
Complain that the type does not conform, once.
Complain that there is no suitable type.
Complain that we couldn't find anything.
Complain that we expected '('.
Complete any conformances that we used.
Complete cmds should not be asked to do work.
Complete the conditional execution.
Complete the next completion stem in the cycle.
Completely ignore attributes that aren't serialized.
Completely ignores sites that don't throw.
Completely naive search.
Complex cases involve unnamed local temporaries.
Component 2 is not used.
Component registration
Components union trivially (i.e., to "unspecialized") unless they are equal.
Composite Operator Constants
Compositions of special protocols aren't special.
Compound l-values like (a,b) have tuple type, so this check also prevents us from getting into that case.
Compute (square of) distance from minc0/c1/c2 to this color
Compute a batch size that causes each thread to process approximately 16 batches.
Compute a mapping of an object type's offset to its location in the m_all_objs vector.
Compute a new 'arg', from the bits we have.
Compute a new substituted type if we have a base type to apply.
Compute a starting point for ppIn/ppOut based on global availability.
Compute a transfer function for each block.
Compute adj so that the IEEE rounding rules will correctly round rv + adj in some half-way cases.
Compute adjusted flags.
Compute allChainBlockIds, allChainPredIds, and newRootId to be used in 3) below.
Compute alternate SHA256 sum with input KEY, SALT, and KEY.
Compute alternate SHA512 sum with input KEY, SALT, and KEY.
Compute an absolute value safely, without using unary negation on INT_MIN, which is undefined behavior.
Compute block summaries.
Compute cactiveLimit based on s_cactiveLimitCeiling, as computed in threadStatsInit().
Compute captures for functions and closures we visited.
Compute dominator tree node levels for the function.
Compute error fractions to be propagated to adjacent pixels.
Compute fixed point on the out_used sets.
Compute insertion point generated by MayUse terminator inst.
Compute insertion point generated by SILArgument.
Compute insertion point generated by the edge value transition.
Compute insertion point generated within the basic block.
Compute insertion point within the basic block.
Compute its original lifetime.
Compute layouts for the protocols we ascribe to.
Compute length of the concatenated literal.
Compute lifetime intervals and use positions of all Vregs by walking the code bottom-up once.
Compute livein set for each block.
Compute matching sets of increments, decrements, and their insertion points.
Compute mlo -- check for special case that d is a normalized power of 2.
Compute number of bytes mod 128
Compute number of bytes mod 64
Compute real pat length if it was initially unknown/-1
Compute real str length if it was initially unknown/-1
Compute relative score.
Compute representation error for this pixel
Compute stack depths for each block.
Compute substitutions for the intrinsic call.
Compute the AvailSetMax at the beginning of the basic block.
Compute the BBSetIn and BBSetOut for the current basic / block with the generated gen and kill set.
Compute the BBSetIn and BBSetOut for the current basic block with the / generated gen and kill set.
Compute the BBSetIn at the beginning of the basic block.
Compute the BBSetOut at the end of the basic block.
Compute the BBWriteSet at the beginning of the basic block.
Compute the BBWriteSetOut and BBWriteSetIn for the current basic / block with the generated gen and kill set.
Compute the BBWriteSetOut at the end of the basic block.
Compute the CCD width, in milimeters.
Compute the CanSILFunctionType for the optimized function.
Compute the ForwardSetIn at the beginning of the basic block.
Compute the MaxStoreSet at the end of the basic block.
Compute the SILLocation which should be used by all the inlined instructions.
Compute the SILParameterInfo list for the new cloned closure.
Compute the access path down to the field so we can determine precise def/use behavior.
Compute the allocating and initializing constructor types for / the given constructor.
Compute the appropriate LLVM type for the function.
Compute the arguments for our new function.
Compute the begin/end line
Compute the callees for each method that appears in a VTable or / Witness Table.
Compute the canonical signature.
Compute the capture list, now that we have analyzed the expression.
Compute the common prefix.
Compute the concrete reference.
Compute the conformance for the inherited type.
Compute the conformances for each protocol.
Compute the connected components of the constraint graph.
Compute the constant initializer and the offset of the type metadata candidate within it.
Compute the cost of the best entry if we haven't done so already.
Compute the cutoff value between legal numbers and illegal numbers.
Compute the declared type.
Compute the distances for all loops in the function.
Compute the distances for the function itself.
Compute the distances from the entry block.
Compute the distances to the exit block.
Compute the distances.
Compute the dominator tree levels for DT.
Compute the edit distance between matching argument names.
Compute the edit distance between the two names.
Compute the edit distance.
Compute the effective context.
Compute the element shuffles for conversions.
Compute the element type based on the getter, looking through the implicit 'self' parameter and the normal function parameters.
Compute the elements of the resulting tuple.
Compute the explosion schema for the given type.
Compute the expression that advances the generator.
Compute the facet (static/non-static + public/private).
Compute the final extended type.
Compute the final release points of the closure.
Compute the flags to pass to swift_dynamicCast.
Compute the formal type that we expect +allocWithZone: to have.
Compute the full root node debug node by walking down the projection tree.
Compute the function name.
Compute the function type.
Compute the genset and killset for every basic block.
Compute the genset and killset for every root in every basic block.
Compute the genset and killset for the current basic block.
Compute the genset and killset for this instruction.
Compute the genset and killset.
Compute the immediate-dominators map.
Compute the immediate-post-dominators map.
Compute the information used to describe an Objective-C redeclaration.
Compute the insertion point where each RC root can be moved to.
Compute the interface type of hashValue().
Compute the interface type of the getter.
Compute the interface type of the given enum element.
Compute the interface type of the initializer.
Compute the interface type.
Compute the kill set for the basic block.
Compute the length down to this base.
Compute the let properties of this struct.
Compute the linear position range of each block.
Compute the liveness of each element according to our predecessors.
Compute the message schedule according to FIPS 180-2:6.2.2 step 2.
Compute the message schedule according to FIPS 180-2:6.3.2 step 2.
Compute the number of elements to track in this memory object.
Compute the offset from `sp' to the spill area at each block start.
Compute the options we want to use for type checking.
Compute the page and the start/end indices Note that php xdebug doesn't support pages except for at the top level
Compute the partial solutions produced for each connected component.
Compute the property type.
Compute the re-sugared tuple type.
Compute the reference to the generic constructor.
Compute the representative color for each box, fill colormap
Compute the requirement and witness types we'll use for matching.
Compute the result type of the partial_apply, based on which arguments are getting applied.
Compute the scope between two potentially-matching names, which is / effectively the sum of the edit distances between the corresponding / argument labels.
Compute the selector.
Compute the set of endpoints, which will be used to insert releases of temporaries.
Compute the set of member substitutions to apply.
Compute the set of solutions.
Compute the set of substitutions we'll need for the witness.
Compute the set of substitutions.
Compute the short and full name of the passed value
Compute the shortest-path analysis for the callee.
Compute the shortest-path analysis for the caller.
Compute the sign bit of the LHS and RHS.
Compute the signature optimization.
Compute the source string.
Compute the substitution for the given archetype and its replacement / type.
Compute the substitutions used to reference the subscript.
Compute the substitutions.
Compute the type of hashValue().
Compute the type of indices for our own subscript operation, lazily.
Compute the type of indices for the subscript we found.
Compute the type of self.
Compute the type of the getter.
Compute the type of the initializer.
Compute the type of the memory object.
Compute the type of the reference.
Compute the type to which the source must be converted to allow assignment to the destination.
Compute the underlying type of the enumeration.
Compute the underlying type.
Compute the updated 'from' tuple type, since we may have performed some conversions in place.
Compute true coordinates of update box's origin corner.
Compute true coordinates of update box's upper corner and center.
Compute vtable slots for all interfaces.
Compute what the vtable for each Class will look like, and build up a list of all interfaces.
Compute whether this gives us an apparent payload or dynamic layout.
ComputeAvailSetMax - If we ignore all unknown writes, what is the max / available set that can reach the a certain point in a basic block.
ComputeMaxStoreSet - If we ignore all reads, what is the max store set that / can reach a particular point in a basic block.
Computed and static properties are not initialized.
Computed captures should have been lowered away.
Computerized output has a line for exit events
Computes a color in im's color table that is part way between the background and foreground colors proportional to the gray pixel value in the range 0-NUMCOLORS.
Computes the approximate number of times that `loop' was invoked (i.e. entered) using profiling data.
Computes the isAscii flag of a concatenated UTF8-encoded string literal.
Computes the length of a concatenated string literal.
Computing layouts for indexed types is the purpose of the scanner generator.
Computing the interrupt site here pulls in more data from the Unit to describe the current execution point.
Computing the set of inherited protocols depends on the complete inheritance clause.
Concat all of the primitive types in the custom union type
Concats two affine transforms together, i.e. the result will be the equivalent of doing first the transformation m1 and then m2.
Conceptually, the dependency from a debug instruction to its definition is in reverse direction: Only if its definition (the Arg) is alive, also the debug_value instruction is alive.
Conceptually, the dependency from a debug instruction to its definition is in reverse direction: Only if its definition is alive, also the debug_value instruction is alive.
Concrete witness thunk for a conformance:
Concrete witness thunks get a special mangling.
Concrete witness thunks use the context archetypes of the conformance.
Condition is the same if BB is reached over a pass through Pred.
Condition used by the current checked_cast_br instruction.
ConditionWaitHandle may finish before its children do.
Conditional bindings must have an initializer.
Conditional branch user.
Conditions are exactly the same, without any restrictions.
Conditions for showing this diagnostic: The object literal protocol's default type is unimplemented
Configuration for the caller block limit.
Configure a default target.
Configure all vars with attributes, 'static' and parent pattern.
Configure prof.thread_active_init before launching additional threads.
Configure the dominance resolver.
Configure the function passes.
Configure the implicit 'self' parameter of a function, setting its type, / pattern, etc.
Configure the module passes.
Configure thread.prof.active for the main thread.
Configures target-specific information for 32-bit arm platforms.
Configures target-specific information for 32-bit x86 platforms.
Configures target-specific information for arm64 platforms.
Configures target-specific information for powerpc64 platforms.
Configures target-specific information for x86-64 platforms.
ConflictGraph maintains lists of interfaces that conflict with each other due to being implemented by the same class.
Conformance cache should always be sufficiently initialized by this point.
Conformance info for a witness table that can be directly generated.
Conformance info for a witness table that is (or may be) dependent.
Conformance loaders for declarations that have them.
Conformance needs one default requirement to be filled in
Conformance of a metatype to an existential metatype is actually equivalent to a conformance relationship on the instance types.
Conformance provides all requirements, and we don't have an instantiator, so we can just return the pattern.
Conformance provides all requirements, but we have private storage and an initializer, so we must instantiate.
Conformance requirements.
Conformance to Equatable and Hashable is implied by being a "simple" no-payload enum.
Conformance to RawRepresentable is implied by having a raw type.
Conformances / cannot be generated until the function declaration is fully parsed so / that the function's generic signature can be consulted.
Conformances for generics and concrete subclasses of generics are represented by referencing the nominal type descriptor.
Conjure up a generic signature from the generic parameters and requirements.
Connect all case values to the result value.
Connect to a remote address
Connect to a remote host using an interruptible connect with optional timeout.
Connect to a socket using an interruptible connect with optional timeout.
Connection flags (connection_flags) are MONGO_CON_TYPE_READ and MONGO_CON_TYPE_WRITE.
Connection management
Consecutive T_INLINE_HTML tokens should be merged together to match Zend behaviour.
Consequently, checkSafeArrayElementUse must prove that no uses of the Array value, or projections of it can lead to mutation (element uses may only be retained/released).
Consequently, if the / given value is directly derived from a memory location, it cannot / alias.
Consequently, these must not be phi nodes (aka.
Conservative scan entire object.
Conservative scan everything
Conservative scan instances of the type with this type index.
Conservative whitelist for HHBC opcodes we know are safe to inline, even if the entire callee body required a AttrMayUseVV.
Conservatively assume classes need unique implementations.
Conservatively assume it's potentially live.
Conservatively assume that a concat with any non-scalar argument can invoke arbitrary side-effects.
Conservatively assume that an overflow can happen
Conservatively check that both checked_cast_br instructions are either exact or non-exact.
Conservatively do not allow any use of the box argument other than a strong_release or projection, since this is the pattern expected from SILGen.
Conservatively return that it might be inaccessible.
Conservatively say yes.
Consider 'self' first.
Consider CGetL obvious because if we knew the type of the local, we'll assert that right before the CGetL.
Consider a situation with a PHP function f() that calls another function g().
Consider add a materializeForSet accessor to the given storage / decl (which has accessors).
Consider adjusting the imported declaration name to remove the parameter.
Consider all alloc_box instructions in the function.
Consider all the associated type relationships we know about.
Consider alpha in the foreground color itself to be an upper bound on how opaque things get, when truecolor is available.
Consider disabling this when debugging the fast return path.
Consider each of the constraints related to this type variable.
Consider each of the origins in turn, breaking out if any of them yields a zero-length path.
Consider parameters to always have been read.
Consider paths starting at the given protocol.
Consider paths starting from a new origin protocol.
Consider static variable or MINIT in future.
Consider structs in the standard library module that wrap a builtin integer type to be integral types.
Consider the constructor decl reference expr 'implicit', but the constructor call expr itself has the apply's 'implicitness'.
Consider the graph fragment:  ...
Consider this simple example:
Consider whether we can share them.
Const cast is needed due to xdebug xml api.
Const variables should be imported as 'let'.
Const-cast to inject into ASTNode.
Constant and APC priming (always with compressed data).
Constant decls are captured by value.
Constant fold extraction of a constant element.
Constant fold extraction of a constant struct element.
Constant fold function calls.
Constant fold indexing insts of a 0 integer literal.
Constant fold switch enum.
Constant fold switch int.
Constant folding may lead this to be not a var anymore, so we should not be emitting *GetL in this case.
Constant propagation here can change when we invoke autoload, so it's considered HardConstProp.
Constants are captured by value.
Constants for MD5Transform routine.
Constants for curl_setopt()
Constants for seconds per minute, hour, day and week
Constants from interfaces implemented by superclasses can be overridden.
Constants never require reference-counting.
Constants not found in ICU library
Constrain over-approximates intersection of version ranges.
Constrain the 'self' object type.
Constrain the allowable registers for `ivl' by inspecting uses.
Constrain the guard on the Check instruction, but first relax the constraint based on what's known about `srcType'.
Constrain the sources of an Assert instruction.
Constrain the typeParam and sources of a Check instruction.
Constrained extensions cannot have inheritance clauses.
Constraint imposed on the Vreg at this use.
Constraints from which we can't do anything.
Construct SILDeclRef.
Construct SSA form, materializing a value that is live at the end of the / specified block.
Construct a ConstantFP from a FloatLiteralInst.
Construct a ConstantInt from an IntegerLiteralInst.
Construct a Job which produces the right CommandOutput.
Construct a LSLocation to represent the memory read by this instruction.
Construct a Location to represent the memory written by this instruction.
Construct a SILDeclRef from ListOfValues.
Construct a Scope for the function body so TypeAliasDecl can be added to the scope.
Construct a TuplePattern.
Construct a constraint system from this expression.
Construct a constraint system to compare the two declarations.
Construct a constraint system to use to solve the equality between the required type and the witness type.
Construct a mapping from type variables and constraints to their owning component.
Construct a new instruction by copying all the case entries.
Construct a parent map for the expr tree we're investigating.
Construct a proper inline scope pointing back to the call site.
Construct a representative function type.
Construct a specialized arg forwarder for a (locally) successful / dispatch.
Construct an AAWH from the array.
Construct an archetype call.
Construct an empty constraint system and solution.
Construct and register the constraint.
Construct effects for InterpOne, using the information in its extra data.
Construct initial attributes from options.
Construct left-hand side.
Construct right-hand side.
Construct the ASCII collation table.
Construct the SILFunctionType.
Construct the TypeRefBuilder
Construct the actual expected argument labels that our candidate expected.
Construct the exporter
Construct the extension.
Construct the folded instruction - a tuple of two literals, the result and overflow.
Construct the full alternate pattern.
Construct the full name
Construct the graph of Actions.
Construct the instance from the input arguments.
Construct the invocation arguments for the current target.
Construct the leaf index to leaf value map.
Construct the left-hand reference to self.
Construct the list of inputs.
Construct the original constant.
Construct the right-hand call to Builtin.zeroInitializer.
Construct the set of parameters from the list of members.
Construct the specialized rows.
Construct this object before any others.
Construction and destruction.
Constructor - intitialize member variables.
Constructor for the callee function.
Constructor for the caller function.
Constructor reference.
Constructor/Initializer
Constructors and destructors as contexts are always mangled using the non-(de)allocating variants.
Constructors and destructors don't have 'self' in parameter patterns.
Constructors and methods returning DynamicSelf return instancetype.
Constructors are not instance members.
Constructors cannot be called on a protocol metatype, because there is no metatype to witness it.
Constructors conceptually also have a dynamic Self return type, so they're okay.
Constructors need to be collected into the appropriate methods list.
Constructors with stub implementations cannot be called in Swift.
Constructs a fixed-size type info which asserts if you try to copy / or destroy it.
Constructs a scalar array with all the shape field names, this/self/parent, classes, type accesses, and type aliases resolved.
Constructs a type info which performs simple loads and stores of / the given IR type, given that it's a pointer to an aligned pointer / type.
Constructs a type info which performs simple loads and stores of / the given IR type.
Consts to be used on PHP and C++ side.
Consult API notes to determine whether this initializer is required.
Consult the blacklist of macros to suppress.
Consult the type lowering.
Consume a comma to continue.
Consume an extraneous '.' so we can recover the case name.
Consume bits from the input value.
Consume owned parameters at +1.
Consume self, and remember we did so.
Consume source elements off the queue.
Consume the ')', if it's there.
Consume the 'escaping'.
Consume the +1 argument.
Consume the base name.
Consume the code completion token, if there is one.
Consume the contextual keyword, if present.
Consume the first semicolon.
Consume the identifier.
Consume the second semicolon.
Consume the value being stored, not the thing it's being stored into
Consume tokens until we hit the corresponding ')'.
Consume tokens up to code completion token.
Consuming would be a no-op.
ContEnter pops a cell and pushes a yielded value.
Containing the value may require a side allocation, which we need to clean up.
Contains a map between LSLocation to their index in the LocationVault.
Contains a map between RC roots to their index in the RCRootVault.
Contains a map between location to their index in the LocationVault.
Contains all nodes of UnsortedChildren, but sorted by numTotalInsts.
Contains an entry for each checked_cast_br to be optimized.
Contains entries with a false property value, which must be propagated / to their dependencies.
Contains function calls in the loop, which only read from memory.
Contains the Callback Objects used to regulate callback-traffic from the webpage internal context.
Content of note is always 0
Contents is __FreeBSD_version, whose relation to OS versions is defined by a huge table in the Porter's Handbook.
Context could be either a this object or a class ptr
Context info used to emit FallthroughStmts.
Context is the DeclContext used / for the lookup.
Context sensitive keywords.
Context-sensitive keywords.
Contexts in which a guarded pattern can appears.
Contextual keyword get, set, ...
Continuation switch: no bounds checking needed
Continuations above that level are skipped as, if we see one, it means that the continuation that controls them - i.e, the lower-level continuation preceding them - failed to match.
Continuations at the current level are processed as, if we see one, there's no lower-level continuation that may have failed.
Continue at the caller.
Continue by emitting the extra inhabitant dispatch, if any.
Continue cannot be used to repeat switches, use fallthrough instead.
Continue checking the result type, below.
Continue if the value is present.
Continue if we are accessing the same field.
Continue in the caller.
Continue looking into the parent.
Continue on to diagnose any argument label renames.
Continue on to see if our reference decrement could potentially affect any other pointers via a use or a decrement.
Continue processing in case this increment could be a CanUse for a different pointer.
Continue simplifying any active constraints left in the system.
Continue this process until we take a full pass through the indexed type list without computing a different layout for all types.
Continue through the comma-separated list.
Continue trying below.
Continue up to the parent.
Continue with the fixed type.
Continue, pretending that the source value was an (optional) value.
ContinueAfterFailures
Continues a ripemd128 message-digest operation, processing another message block, and updating the context.
Continues a ripemd160 message-digest operation, processing another message block, and updating the context.
Continues a ripemd256 message-digest operation, processing another message block, and updating the context.
Continues a ripemd320 message-digest operation, processing another message block, and updating the context.
Continues an MD5 message-digest operation, processing another message block, and updating the context.
Continues an SHA1 message-digest operation, processing another message block, and updating the context.
Continues an SHA256 message-digest operation, processing another message block, and updating the context.
Continues an SHA384 message-digest operation, processing another message block, and updating the context.
Continues an SHA512 message-digest operation, processing another message block, and updating the context.
Continues create extra backedges, add them to the appropriate counters.
Contirbution information for a single pixel
Contract binding edges between type variables.
Contract the edges of the constraint graph.
Contrast this with the test in input().
Control flow insensitive vs.
Control flow instructions
Control flow splits and joins.
Convenience class for creating TransLocs and TransRecs for new translations.
Convenience initializers do not require special handling.
Convenience wrapper around a simple vcall to `helper', with a single `arg' and a return value in `d'.
Conveniently however, get/set properties are not allowed to have initializers, so we don't have an ambiguity, we just have to check for observing accessors.
Conveniently, it doesn't care about the actual types though, so we can just use 'void' for them.
Convention attribute.
Conventions based on C function declarations.
Conventions based on a C function type.
Converge the BBSetOut with iterative data flow.
Conversion instructions (and others of similar form).
Conversion instructions.
Conversion to Y,U,V buffer
Conversion to number failed.
Conversion to/from UnresolvedType.
Conversions to C function pointer type are limited.
Convert 4 bytes of input to 2 * 3 bytes of output
Convert DecRefs to DecRefNZ when we've proven the tmp must be used again.
Convert T_HASHBANG to T_INLINE_HTML for Zend compatibility
Convert UTF8 representation into UTF16.
Convert UnicodeString back to UTF-8.
Convert a '_' expression to an AnyPattern.
Convert a 16 bit signed value from file's native byte order
Convert a 16 bit unsigned value from file's native byte order
Convert a 32 bit signed value from file's native byte order
Convert a 32 bit unsigned value from file's native byte order
Convert a floating point number to a string formats 'f', 'e' or 'E'.
Convert a localId in a callee frame into an SP relative offset in the caller frame.
Convert a metatype 'self' argument to the ObjC Class pointer.
Convert a packed array to mixed, without moving the elements out of the old packed array.
Convert a paren expr to a pattern if it contains a pattern.
Convert a reinitialization of this address into a destroy, followed by an initialization.
Convert a semantic rvalue to a value of storage type.
Convert a string containing C character escapes.
Convert a subexpression to a pattern if possible, or wrap it in an ExprPattern.
Convert a weak storage type.
Convert all of the variadic arguments to the destination type.
Convert all tuples to patterns.
Convert an AsyncFunctionWaitHandle-relative offset to an offset relative to either its contained ActRec or AsioBlockable.
Convert an empty bitset to big-integer mode.
Convert an inout type.
Convert an l-value to a pointer type: unsafe, unsafe-mutable, or / autoreleasing-unsafe-mutable.
Convert any ranges to column ranges that only intersect the line of the location.
Convert arguments to a representation appropriate to the calling convention.
Convert back from internal Unicode to original character set
Convert call arguments, casting and adjusting for calling convention.
Convert cell coordinates to update box ID
Convert character code to glyph index
Convert each parameter to a Clang type.
Convert fragile tag index into resilient tag index.
Convert fragile tag index into resilient tag index. - -1 -- if we have a payload -  0 -- if there's no payload
Convert from a token range to a CharSourceRange, which points to the end of the token we want to remove.
Convert function takes refs to refs, address to addresses, and leaves other types alone.
Convert indirect to direct parameters/results.
Convert input string to internal Unicode
Convert internal image_type to mime type
Convert it to unowned.
Convert num to a base X number where X is a power of 2.
Convert num to its decimal format.
Convert offsets into PCs, and sync the PC.
Convert params to proper types.
Convert pattern (if specified) to UTF-16.
Convert resilient tag index into fragile tag index.
Convert s to wchar_t* and null-terminate for el_winsertstr.
Convert sampling interval to ticks
Convert source string from UTF-16 to UTF-8.
Convert source string from UTF-8 to UTF-16.
Convert strings in the specified array back to UTF-8.
Convert strings in the specified array from UTF-8 to UTF-16.
Convert the SIL result type to a Clang type.
Convert the Swift import path over to a Clang import path.
Convert the argument names.
Convert the argument to +1 if necessary.
Convert the argument to a string.
Convert the argument.
Convert the arguments.
Convert the array mutably if it's being passed inout.
Convert the base to an rvalue of the appropriate metatype.
Convert the base to the appropriate container type, turning it into an lvalue if required.
Convert the byte order of the data we are looking at While we're here, let's apply the mask operation (unless you have a better idea)
Convert the check into a Jmp.
Convert the condition to a logic value.
Convert the current character into hexadecimal digits.
Convert the destination pointer argument to a SIL address.
Convert the error to a bridged form.
Convert the image src to a grayscale image
Convert the indirect parameter to a direct parameter.
Convert the indirect result to a direct result.
Convert the initializer to the type of the pattern.
Convert the int to a string
Convert the inverted S-boxes into 4 arrays of 8 bits.
Convert the literal to the appropriate type.
Convert the literal to the non-builtin argument type via the builtin protocol, first.
Convert the metatype to objc representation.
Convert the metatype value to AnyObject.
Convert the pattern to a string we can print.
Convert the pointer argument to a SIL address.
Convert the relative index to absolute
Convert the result to a Builtin.i1.
Convert the resulting expression to the final literal type.
Convert the return and parameter types.
Convert the source args to unsigned here so that (1) the compare will be unsigned as it is in strncmp() and (2) so the ctype functions will work correctly without extra casting.
Convert the source to the simplified destination type.
Convert the subexpression.
Convert the substituted function type into a specialized function type based on the ReabstractionInfo.
Convert the target to an integer.
Convert the type arguments.
Convert the typical getopt input characters to the php_getopt struct array
Convert the unicode string to lowercase.
Convert the unicode string to uppercase.
Convert the value back to a +1 strong reference.
Convert the value to the expected result type of the function.
Convert thick metatype to Objective-C metatype.
Convert through optional types unless we're looking for a protocol that Optional itself conforms to.
Convert to UChar pivot encoding
Convert to a Clang function type.
Convert to a define call
Convert to a symbol name by replacing the USR prefix.
Convert to an Objective-C metatype representation, if needed.
Convert to an object reference.
Convert to bitset mode if needed, and use upper range.
Convert to final encoding
Convert to microsecs and trunc that first
Convert to milliseconds
Convert to mixed, reserving space for at least `neededSize' elems.
Convert to the appropriate address type and return.
Convert to the normal beginning of the year.
Convert ubuf to UTF-8 and try text soft magic
Convert whatever is on the right to a boolean and compare.
Convert zval to formattable according to message format type or (as a fallback) the zval type
Converters can re-enter the interpreter
Converting from modified utf8 to utf8 will always shrink, so this will always be sufficient
Converts UTF-8 into UTF-16 if required.
Converts YUV to RGB and writes into a 32 bit pixel in endian neutral fashion
Converts a packed array to mixed, leaving the packed array in an empty state.
Converts a user token ID to a token name
Converts an internal token ID to a user token ID
Converts call arguments.
Converts each generic function argument into a SILValue that can be passed / to the specialized call by emitting a cast followed by a load.
Converts from YUV (with color subsampling) such as produced by the WebPDecode routine into 32 bits per pixel RGBA data array.
Converts struct tm to time_t, assuming the data in tm is UTC rather than local timezone (as mktime assumes).
Convience function around the MD5 implementation
CookieJar is shared between multiple instances of NetworkAccessManager.
Cookies are preferred, because initially cookie and get variables will be available.
Copied from BridgeObjectTypeInfo.
Copied from upstream's libgd
Copied to BlockAnalysis::antLoc
Copied to BlockAnalysis::avlLoc
Copied to BlockAnalysis::delLoc
Copies and loads on edges (between blocks).
Copies code from the standard library into the user program to enable / optimizations.
Copies into the alloc_stack live range are safe.
Copies that are required at a given position or edge.
Copy / and destroy can just mask out the tag bits and pass the result to / retain and release entry points.
Copy BodyNodes and ParamFields into the MarkupContext.
Copy COUNT objects from FROM to TO.
Copy InitF into GetterF
Copy NewNodes onto the back of our Worklist now that we have finished this iteration.
Copy a numeric literal value into AST-owned memory, stripping underscores / so the semantic part of the value can be parsed by APInt/APFloat parsers.
Copy a string in Exif header to a character string and return length of allocated buffer if any.
Copy a string in Exif header to a character string returns length of allocated buffer if any.
Copy a string/buffer in Exif header to a character string and return length of allocated buffer if any.
Copy a value from one object to a new object, directly taking / responsibility for anything it might have.
Copy a value from one object to a new object.
Copy a value from one object to another based on the size in the / given type metadata.
Copy all of the containers (except the first) into a TypedValue array.
Copy all of the previous elements.
Copy an array to a new array of mixed kind, with a particular pre-reserved size.
Copy and record the substitutions.
Copy and spill points for resolving split lifetime intervals.
Copy any extra prefix bytes in from the superclass.
Copy argument into this temporary.
Copy as many bytes as will fit
Copy counted types correctly, especially RefData.
Copy down the parent's method entries.
Copy edges into captured edges Capturing edges first because after capturing nodes we nullify the header
Copy element name locations, if provided.
Copy element names, if provided.
Copy everything from `adIn' to `ad', including refcount, etc.
Copy everything including tombstones.
Copy flags over, adding HasEnumWitnesses flag
Copy generic signature from derived to the override type
Copy in all the use vars
Copy in interface constants.
Copy in the metadata template.
Copy initial values for properties to a new vector that can be used to complete initialization for non-scalar properties via the iterative 86pinit() calls below.
Copy instructions into GetterF
Copy into YYRESULT an error message about the unexpected token YYCHAR while in state YYSTATE.
Copy it if nontrivial.
Copy it off the cleanup stack in case the cleanup pushes a new cleanup and the backing storage is re-allocated.
Copy it to memory we can reference forever.
Copy must be an initialization.
Copy nodes into captured nodes
Copy of CheckedCastBrJumpThreading::FailurePreds.
Copy of CheckedCastBrJumpThreading::SuccessPreds.
Copy of the Vreg's def instruction.
Copy only the drive name
Copy only the share name
Copy ourself, and embed the repo as a section named "repo".
Copy over the existing bindings, dividing the constraints up into "favored" and non-favored lists.
Copy over the type variables in the live components and remap component numbers.
Copy parent's 86pinit() vector, so that the 86pinit() methods can be called in reverse order without any search/recursion during initialization.
Copy parent's constants.
Copy parent's declared property.
Copy pointers to the results.
Copy remaining data to buffer
Copy src to string dst of size siz.
Copy the active members into the entries list.
Copy the address-only value.
Copy the array load to the insert point.
Copy the array.props argument call.
Copy the attributes, since we're about to start hacking on them.
Copy the block so we have an independent heap object we can hand off.
Copy the body MaxTripCount-1 times.
Copy the call result to the destination register(s).
Copy the captures from the source to the destination.
Copy the closure's use variables from the closure object's properties onto the stack.
Copy the color bounds to the new box.
Copy the current value of ref count state into the result map.
Copy the edge values overwriting the edge at Idx.
Copy the element list into the ASTContext.
Copy the existing selector pieces into an array.
Copy the extra prefix from the superclass.
Copy the field offsets.
Copy the first part of user declarations.
Copy the flags from the original cursor and apply it to this one
Copy the function witnesses in, either from the proposed witnesses or from the standard table.
Copy the generic requirements.
Copy the given (default) value into a freeable string, so that assignments to the setting will consistently free the previous string.
Copy the indices into the callback storage.
Copy the initializer into the function Replace the access to a let property by the value computed by this initializer.
Copy the instance pointer.
Copy the key, shifting each character up by one bit and padding with zeros.
Copy the list of protocols.
Copy the locale into all categories
Copy the location information into permanent storage.
Copy the native data.
Copy the original arguments of the partial_apply into newly created temporaries and use these temporaries instead of the original arguments afterwards.
Copy the parent type.
Copy the payload, if we have it.
Copy the rest of the data from the derived class.
Copy the second part of user declarations.
Copy the source if we can't.
Copy the successors into a vector, dropping one entry for the liveblock.
Copy the temporary into Dest.
Copy the tile to the main buffer
Copy the two apply instructions into the two blocks.
Copy the type witnesses.
Copy the use vars to instance variables, and initialize any instance properties that are for static locals to KindOfUninit.
Copy the value out at +1.
Copy the value witnesses.
Copy this code point into the result.
Copy to YYRES the contents of YYSTR after stripping away unnecessary quotes and backslashes, so that it's suitable for yyerror.
Copy to the new explosion.
Copy tvRef to tvRef2.
Copy valid bytes found so far as one solid block.
Copy whatever the last rule matched to the standard output.
Copy-initialize with the new value.
CopyForwarding will be reapplied after the transparent function is inlined at which point global hoisting will be done.
CopyOnSuccess values should not have / attached cleanups.
Copying the block will create an independent reference.
Copyright (C) 1991-2, RSA Data Security, Inc.
Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura, Copyright (C) 2000 - 2003, Richard J.
Copyright (C) 2012 execjosh, http://execjosh.blogspot.com Copyright (C) 2012 James M.
Copyright (c) 1988, 1993 The Regents of the University of California.
Copyright (c) 1997-1998 Sun Microsystems, Inc.
Copyright (c) 1998 Todd C.
Copyright (c) 2003 Constantin S.
Copyright (c) 2005-2014 Rich Felker, et al.
Copyright (c) 2009 Keynetics Inc.
Copyright (c) 2012 Bryan Davis All rights reserved.
Copyright (c) 2014 - present Adobe Systems Incorporated.
Copyright (c) 2015-present, Facebook, Inc.
Copyright (c) 2016-present, Facebook, Inc.
Copyright (c) Christos Zoulas 2003.
Copyright 2010-present, Facebook, Inc.
Copyright 2013-present, Facebook, Inc.
Copyright 2015-present, Facebook, Inc.
Correct for over-counting in TC-stats.
Correctness checks are normally done before adding function to scope.
Could be a decimal now...
Could be an exponent now...
Could be one of the following: 1.
Could be some cert thing
Could call vm_user_func(bound, params) here which goes through a whole decode function process to get a Func*.
Could not find exact match, now try wildcard match
Could not find the record in the aggregate.
Could re-enter to run a destructor.
Couldn't actually import it as an error enum, fall back to enum
Couldn't convert, use raw path
Couldn't find a suitable operand, so bail.
Count how many levels deep we are.
Count of how many iterations we've had since any function was popped off the function worklist.
Count of matched subpatterns
Count the existing alloca sizes against the limit.
Count the fields we got from the superclass.
Count the number of SILParameterInfos that are needed in order to / pass the given argument.
Count the number of digits.
Count the number of entries up to and including the last null entry.
Count the number of possible case tags for a given enum type
Countable types correspond to the set of types in HHVM which are explicitly managed by the GC.
Counted as part sizeof(TypedValue)
Counter used by optimize pass to wait to visit Phis until after non-backedge predecessors.
Counters, just for debug printing.
Counts the number of words inside a string.
Crash when a deleted method is called by accident.
Crawl through our uses and look for a physical hint.
Create ".Some" patterns wrapping the isa pattern to balance out the optionals.
Create "of (extension in Swift).Swift"
Create AST statements which convert from an enum to an Int with a switch.
Create LLVM basic blocks for the other bbs.
Create OptTable class for parsing actual command line arguments
Create Vregs for all relevant SSATmps.
Create a "dest temp" to hold the reference after casting it.
Create a 'let' binding to stand in for the RHS value.
Create a / parameter list to represent the spelled argument or return null if none is / present.
Create a BB argument or 'unchecked_take_enum_data_addr' instruction to receive the enum case data if it has any.
Create a CFG edge from NewRetBB to MergedBB.
Create a CodeCompletionConsumer.
Create a DceAnalysis for each block, indexed by rpo id.
Create a FixIt for the keyword.
Create a Forward-declared type.
Create a LineTable from `srcLoc'.
Create a LocalVariableInitialization for the uninitialized var.
Create a PHInode for returning the return value from both apply instructions.
Create a PHP object given a typename and call the ctor, optionally passing up to 2 arguments
Create a PatternBindingDecl to bind the expression into the decl.
Create a ProtocolInfo object from the layout.
Create a SILArgument and store its value into the given Initialization, / if not null.
Create a SILBuilder with a tracking list for newly added instructions, which we will periodically move to our worklist.
Create a Swift compiler.
Create a TaskQueue for execution.
Create a TransRec for the translation, markEnd() should be called prior to calling rec().
Create a basic block destination for this case.
Create a basic block to jump to for the implicit 'self' return.
Create a basic block to jump to for the implicit destruction behavior of releasing the elements and calling the superclass destructor.
Create a binary and function.
Create a block for the body and emit code into it before processing any of the patterns, because none of the bound variables will be in scope in the 'body' context.
Create a block similar to another block (but with no bytecode in it yet).
Create a break target (at this level in the cleanup stack) in case it is needed.
Create a call of _bridgeToObjectiveC which converts an _ObjectiveCBridgeable / instance into a bridged ObjC type.
Create a call to Swift._unimplemented_initializer
Create a caller-side default argument, if we need one.
Create a clause matrix from the given pattern-row storage.
Create a compiler instance.
Create a compressed file.
Create a computed value variable
Create a concatenated string literal.
Create a conditional branch on the fast condition being true.
Create a connection to all of the servers in the seed list
Create a connection to every of the servers in the seed list
Create a constant with that integral type.
Create a constant with that struct type.
Create a continuation block.
Create a copy of the BB as a landing BB / for all FailurePreds.
Create a copy of the BB as a landing BB for all FailurePreds.
Create a copy of the BB as a landing BB.
Create a copy of the BB or reuse BB as / a landing basic block for all FailurePreds.
Create a copy of the BB or reuse BB as a landing basic block for all SuccessPreds.
Create a copy of this instruction in each one of our successors unless they are ignorable trap blocks.
Create a debug scope for the function using astNode as source location.
Create a defer-edge from the content to the stored value.
Create a defer-edge from the loaded to the stored value.
Create a diamond shaped control flow and a checked_cast_branch instruction that checks the exact type of the object.
Create a dummy Emitter, so it's possible to emit jump instructions
Create a dummy node to represent it until we see a real definition.
Create a factory for code completion callbacks that will feed the Consumer.
Create a flat list of loops in loop-tree postorder (bottom-up).
Create a forward declaration for that type.
Create a fresh archetype builder.
Create a gd-format image from the JPEG-format INFILE.
Create a generic parameter list with multiple generic parameters.
Create a getter function from the initializer function.
Create a getter so we don't break downstream invariants by having a setter without a getter.
Create a global variable into which we will store the hash of the module (used for incremental compilation).
Create a hard or symbolic link to a filename according to the type specified.
Create a hash so that we can check whether we already have a connection for this server definition.
Create a heap object to contain the self argument.
Create a lexer for the type sub-string.
Create a lexer that cannot go past the end state.
Create a list instead :)
Create a local variable to capture the generator.
Create a map from canonical check to aggregated type for all hoist groups.
Create a map from canonical check to hoist destination.
Create a map from region blocks to their corresponding initial IR blocks.
Create a map of the destination blocks for quicker lookup.
Create a member reference to the given constructor.
Create a method to witness the requirement.
Create a module for the current compile unit.
Create a name for the declaration from the field name.
Create a name of the specialization.
Create a nested array if there is more than one of the same header
Create a new "raw" WebPage object
Create a new Address corresponding to the given SIL address value.
Create a new Clang compiler invocation.
Create a new Explosion corresponding to the given SIL value.
Create a new Objective-C method corresponding to the given SIL value that / starts its search from the given search type.
Create a new Objective-C method corresponding to the given SIL value.
Create a new SID for the child process
Create a new StaticFunction corresponding to the given SIL value.
Create a new VarDecl with dummy type.
Create a new apply based on an old one, but with a different function being applied.
Create a new apply instruction that uses the concrete type instead of the existential type.
Create a new apply instructions that uses the concrete type instead / of the existential type.
Create a new archetype builder with the given signature.
Create a new argument which copies the original argument.
Create a new argument with the promoted type.
Create a new basic block and jump into it.
Create a new basic block in the edge, and insert it after the SrcBB.
Create a new basic block with the given name.
Create a new cond_fail using the merged condition.
Create a new context for the Then branch and traverse it in that new context.
Create a new context for the body and traverse it in the new context.
Create a new context for the fallthrough.
Create a new copy of this instruction, which retains all of the operands / and other information of this one.
Create a new empty function with the correct arguments and a unique name.
Create a new empty function with the optimized signature found by this / analysis.
Create a new empty function.
Create a new entry for the box.
Create a new entry for the cache.
Create a new explosion for potentially reabstracted parameters.
Create a new extension for this nominal type/Clang submodule pair.
Create a new function to contain our logic.
Create a new function.
Create a new linker flag entry.
Create a new member lookup table.
Create a new one here.
Create a new partial apply with the new arguments.
Create a new phi node.
Create a new preheader.
Create a new property, or overlay ancestor's property if one exists.
Create a new protocol composition type.
Create a new scope to reflect this.
Create a new select_enum instruction
Create a new solver scope in which we apply all of the partial solutions.
Create a new specialized function if possible, and cache it.
Create a new temporary at the beginning of a function.
Create a new virtual file for the region started by the #line marker.
Create a node for the pass id.
Create a node if the specialization is externally inlineable.
Create a non-parameter optional adjustment.
Create a normal return, but leaving the return value undefined.
Create a parameter pattern containing the anonymous variables.
Create a partial application of a dynamic method, applying bridging thunks if necessary.
Create a pattern binding to describe the variable.
Create a pattern binding to initialize the generator.
Create a phi in the continuation block and use the loaded value if we branched directly here.
Create a placeholder protocol record.
Create a potential archetype for this type parameter.
Create a re-abstraction thunk for a partial_apply.
Create a reabstraction thunk.
Create a record for this function.
Create a reference cast, forwarding the cleanup.
Create a reference to the old arg offset and increment arg offset so we can create the new arguments.
Create a reference to the witness.
Create a relative symlink to logs under linkname's directory
Create a release to balance it out.
Create a repl metavariable to capture the whole thing so we can reference it, then assign that into the pattern.
Create a set of arguments.
Create a set of type substitutions for all known associated type.
Create a shadow copy of inout parameters so they can be captured by closures.
Create a single CompileJobAction and a single BackendJobAction.
Create a single CompileJobAction for all of the driver's inputs.
Create a single aggregate alloca for explosions.
Create a single linked chain if From has multiple targets.
Create a single sequence expression, which we will modify for each operator, filling in the operator and dummy right-hand side.
Create a single stub function which calls swift_deletedMethodError().
Create a sorted list of nodes according to numTotalInsts.
Create a special arena to be used for allocating objects in low memory.
Create a specialized function with ReabstractionInfo for each attribute.
Create a specialized function.
Create a string buffer and append the directory name
Create a struct with the underlying type as a field.
Create a stub body that emits a fatal error message.
Create a substitution for the dependent type.
Create a target machine.
Create a temp server definition to create a new connection on-demand if we didn't have one already
Create a temporary address suitable for passing to the given inner / indirect result and add it as an inner indirect result.
Create a temporary base for relative references.
Create a temporary file to write the results into.
Create a temporary for the output optional.
Create a temporary if the result is indirect.
Create a temporary lexer that lexes from the body of the string.
Create a temporary within the closure to provide this address.
Create a tuple containing all of the segments.
Create a typealias for this CF typedef.
Create a typedpattern(namedpattern(decl))
Create a unified set of requirements.
Create a value for an ifd from an info_data pointer
Create a value for the condition of the terminator that flows along the edge / with 'EdgeIdx'.
Create a var member for this struct, along with its pattern binding, and add / it as a member
Create a variable to store the underlying value.
Create a vector of cluster arcs
Create a witness method, creating a witness table declaration if we don't / have a witness table for it.
Create a writeback scope for the access to the existential lvalue.
Create a zombie forward declaration.
Create all blocks and edges for one Func.
Create all of our visitors, register them with the visitor group, and run.
Create all the blocks up front, so we can set up our switch_enum.
Create allocations for this instruction.
Create an AvailableAttr that indicates specific availability / for all platforms.
Create an ErrorExpr to tell the type checker that this return statement had an expression argument in the source.
Create an Explosion containing the unmanaged LLVM values lowered from a / SIL value.
Create an IRGen instance.
Create an IRGenModule for each source file.
Create an Initialization for an uninitialized buffer.
Create an Initialization for an uninitialized temporary.
Create an Objective-C selector string literal.
Create an RValue by emitting destructured arguments into a basic block.
Create an access function for the type metadata of the given / non-generic nominal type.
Create an address value for an alloc_stack, consisting of a container and / a not yet allocated buffer.
Create an address value for an alloc_stack, consisting of a container and / the address of the allocated buffer.
Create an address value without a container (the usual case).
Create an allocation on the stack.
Create an almost-empty memory buffer.
Create an argument on the return-to BB representing the returned value.
Create an assignment into the storage or call to superclass setter.
Create an availability attribute for each observed platform and add to ToDecl.
Create an emission for a call of the given callee.
Create an empty body for the default constructor.
Create an empty body for the destructor.
Create an empty entry.
Create an empty hash object.
Create an empty parameter list to recover.
Create an empty response as notification that the service is restored.
Create an enum element by extracting the operand of a switch_enum.
Create an implicit 'self' decl for a method in the specified decl context.
Create an implicit AnyPattern to represent the default match.
Create an implicit TypeExpr, with location information even though it shouldn't have one.
Create an implicit accessor declaration.
Create an implicit availability attribute for the given platform / and with the inferred availability.
Create an implicit property given the imported name of one of / the accessors.
Create an implicitly-unwrapped optional of the object type, which subsumes both behaviors.
Create an initialization to initialize the element.
Create an initialization which will initialize it.
Create an inline scope for the cloned instruction.
Create an inliner pass that does not inline functions that are marked with / the global_init attribute or have an "availability" semantics attribute.
Create an integer literal for the value.
Create an object that, when deallocated, stores the given value to / the given pointer.
Create an optimized version of the current function.
Create an optional adjustment to a parameter.
Create an overload choice referencing this declaration and immediately resolve it.
Create an override of it.
Create an uncompressed file.
Create an unconditional branch that propagates the newly created BBArgs.
Create an uncounted array if we can.
Create an unreachable block for the default if the original SIL instruction had none.
Create an unreachable branch for unreachable switch defaults.
Create and initialize the instruction.
Create and insert the EnumCaseDecl containing all the elements.
Create and insert the new backedge block...
Create and open a tempfile, use the tempfile's name when dumping a heap profile, then open the resulting file.
Create and register 'BreakIterator' class.
Create and register 'CodePointBreakIterator' class.
Create and register 'IntlCalendar' class.
Create and register 'IntlGregorianCalendar' class.
Create and register 'IntlIterator' class.
Create and register 'IntlTimeZone' class.
Create and register 'RuleBasedBreakIterator' class.
Create arguments for the entry block
Create arguments for the entry block.
Create blocks for each entry point as well as ordinary control flow boundaries.
Create byte sequence P.
Create byte sequence S.
Create constructors to initialize that value from a value of the underlying type.
Create defer-edges from the block arguments to it's values in the predecessor's terminator instructions.
Create destination blocks for all the cases.
Create direct outer results for each of the elements.
Create edges for the instructions.
Create either a static or an uncounted string.
Create enum with OPT_xxx values for each option in Options.td.
Create epilogue when calling.
Create failed StaticWaitHandle object.
Create hash map key by concatenating pattern and flags.
Create intermediate result.
Create it in our current function.
Create it in the current function.
Create labeled initializers for unions that take one of the fields, which only initializes the data for that field.
Create location expression defined w.r.t DW_AT_frame_base
Create nSplit contiguous regions and store them in the appropriate freelist.
Create new metadata to cache.
Create new normal and error BBs only if: - re-using a BB would create a critical edge - or, the result of the new apply would be of different type than the argument of the original normal BB.
Create one interval I for each Vreg R that requires register allocation, by iterating blocks and instructions in reverse order, computing live registers as we go.
Create one node for every parsed block, including NativeData and ResumableFrame blocks.
Create options vector
Create or find the normal conformance.
Create or lookup the node builder for the parent and associate the newly created aggregate with this node.
Create plans for all the elements.
Create plans for all the sub-initializations.
Create prefix string literals used in Options.td.
Create projections for each one of them and the child node and projection to the worklist for processing.
Create prologue when calling
Create succeeded StaticWaitHandle object.
Create table mapping all options defined in Options.td.
Create takes care of copying local variables and iterators.
Create takes care of copying local variables and itertors.
Create the 'self' declaration and patterns.
Create the 'self' declaration.
Create the AsyncFunctionWaitHandle object.
Create the Cloned Name for the function.
Create the Generator object.
Create the HttpServer before any warmup requests to properly initialize the process
Create the IR emitter.
Create the LLVM function declaration for a thunk that acts like / an Objective-C method for a Swift method implementation.
Create the None block.
Create the REPL: it will launch itself, no need to store this variable.
Create the SILFunctionType for the callback.
Create the Some block, which recurses.
Create the VarDecl and the PatternBindingDecl for the captured expression.
Create the access function.
Create the actual constructor.
Create the aggregate for the current complete Node we are processing...
Create the allocation.
Create the allocations in reverse order.
Create the appropriate LLVM type.
Create the appropriate SIL function type for the given formal type / and conventions.
Create the appropriate bitcast based on the source and dest types.
Create the appropriate cast instruction based on result type.
Create the appropriate messenger function.
Create the appropriate pointer type.
Create the archetype builder.
Create the archetype for the implicit 'Self'.
Create the argc and argv arguments.
Create the args for the new apply by removing the closure argument...
Create the args for the thunk's apply, ignoring any dead arguments.
Create the argument list for the new apply, casting when needed in order to handle covariant indirect return types and contravariant argument types.
Create the array value.
Create the associated action.
Create the body type.
Create the branch to the header.
Create the cache directory if it doesn't exist.
Create the call to the destructor with the allocated object as self argument.
Create the checked_cast_branch instruction that checks at runtime if the class instance is identical to the SILType.
Create the class declaration and record it.
Create the class entry and associate it with an HPHP::Class if possible
Create the cloned start basic block.
Create the closure expression and enter its context.
Create the condition unit if a condition string was supplied
Create the constraint.
Create the constructor
Create the constructor.
Create the continuation block.
Create the control variable as the first instruction in the function (so that it is easy to destroy the stack location.
Create the correct substitution for calling the given function at / the given type.
Create the coverage data header.
Create the decl for the func and add it to the parent scope.
Create the default constructor.
Create the descriptor for the variable.
Create the descriptor.
Create the destructor function for a layout.
Create the disjunction constraint.
Create the disjunction of favored constraints.
Create the edge in this graph.
Create the end dest first so that the loop dest comes in-between.
Create the entry basic block with the function arguments.
Create the enum declaration and record it.
Create the error node
Create the evaluation string buffer and store the symbol name
Create the expression node.
Create the extension declaration and record it.
Create the false block if requested.
Create the filename then enable
Create the forwarding stub.
Create the frame node
Create the function body.
Create the getter function declaration.
Create the getter thunk.
Create the global constant.
Create the global mcg object
Create the global variable.
Create the hardware counter before reading options, so that the main thread never has inherit set in server mode
Create the has-member block.
Create the has-member branch.
Create the implicit memberwise constructor.
Create the indirect result parameters.
Create the inherited conformance entry.
Create the initial set of vasm blocks, numbered the same as the corresponding HHIR blocks.
Create the initializer declaration.
Create the initializer parameter patterns.
Create the instruction if we can.
Create the integer literal value.
Create the interface type of the method.
Create the invoke function.
Create the list of elements, and add the trailing closure to the end.
Create the logic for calling a throwing function.
Create the lookup table.
Create the mangled name of our witness table...
Create the message node
Create the meta-variable, let the typechecker name it.
Create the missing import decls and add to the collector.
Create the new address projection.
Create the new apply inst.
Create the new destination of the DefLabel at this block.
Create the new entry.
Create the new function type for the cloned function with some of the parameters promoted.
Create the new function type.
Create the new function.
Create the new generic parameter.
Create the new link object
Create the new optimized function type.
Create the new releases at each anchor point.
Create the new retain instructions.
Create the no-member block.
Create the no-member branch.
Create the on-disk hash table.
Create the opaque opened value.
Create the parameter list for the getter.
Create the parameter list for the setter.
Create the parameter list(s) for the getter.
Create the parameter list:
Create the parameter.
Create the pattern binding decl for the storage decl.
Create the pointer struct from the raw pointer.
Create the protected function.
Create the protocol declaration and record it.
Create the releaseN call right by the first retain.
Create the releaseN call right by the last release.
Create the rest of the type tree lazily based on uses.
Create the result plan.
Create the result value.
Create the retainN call right by the first retain.
Create the return statement.
Create the root node of the tree with our base type.
Create the selectors we'll be looking for.
Create the set of properties.
Create the setter thunk.
Create the shared destination at the first place that might have needed it.
Create the size function for a layout.
Create the specialized conformance entry.
Create the storage property as an optional of VD's type.
Create the stores that are alive due to partial dead stores.
Create the struct declaration and record it.
Create the struct type.
Create the substitution maps.
Create the swift_initStackObject function and all required types.
Create the target instance.
Create the thin function type for the cloned closure.
Create the throw destination at the end of the function.
Create the thunk and function value.
Create the true block if requested.
Create the tuple shuffle.
Create the type variables for the generic parameters.
Create their prototypes now.
Create tmp server definitions
Create type variables for all of the parameters in a generic function type.
Create unique temporary directory for these tests
Create values for the leaf types.
Create witness markers for all of the generic param types.
Create witnesses for requirements not already met.
Create: (assign (decl_ref_expr(VD)), decl_ref_expr(value)) or: (assign (member_ref_expr(decl_ref_expr(self), VD)), decl_ref_expr(value))
Create: (call_expr (dot_syntax_call_expr (decl_ref_expr(didSet)), (decl_ref_expr(self))), (decl_ref_expr(tmp))) or: (call_expr (decl_ref_expr(didSet)), (decl_ref_expr(tmp)))
Create: (call_expr (dot_syntax_call_expr (decl_ref_expr(willSet)), (decl_ref_expr(self))), (declrefexpr(value))) or: (call_expr (decl_ref_expr(willSet)), (declrefexpr(value)))
CreateAFWH takes care of copying local variables and iterators.
CreateCont takes care of copying local variables and iterators.
CreateMainWindow - creates the main install window.
CreateUserExperience - creates a new IBurnUserExperience object.
Creates a GET_MORE request  The following fields of cursor are used: - ns - recv.request_id - limit - cursor_id
Creates a JSON encoded string with all required fields escaped Works from http://www.ecma-internationl.org/publications/files/ECMA-ST/ECMA-262.pdf Section 15.12.3.
Creates a hash out of the password so that we can store it in the connection hash.
Creates a new CmdBreak instance, sets its breakpoints to the client's list, sends the command to the server and waits for a response.
Creates a proxy and threads needed to handle it.
Creates a query string in buf.
Creates a simple query header.
Creates a unique hash for a server def with some info from the server config, but also with the PID to make sure forking works
Creates an array with one element.
Creates the external declaration for swift_bufferAllocateOnStack.
Creates the external declaration for swift_bufferDeallocateFromStack.
Creating a `preExit' requires both: 1.
Creating a single-element mixed array with a integer key.
Creation and destruction.
Critical edges should be split for the unit before passing it to analyze.
Crucially, if two SSATmps belong to different must-alias-sets, they still /may/ point to the same object.
Ctor or dtor are for immediate class, not a derived class.
Ctx and PtrTo* may be statically unknown but always need just 1 register.
Curl Http Version constants (CURLOPT_HTTP_VERSION)
Curl NETRC constants (CURLOPT_NETRC)
Curl SSL Version constants (CURLOPT_SSLVERSION)
Curl TIMECOND constants (CURLOPT_TIMECONDITION)
Curl version constants
Current BB can be re-used instead as their target.
Current algorithm: by population for first half, then by volume.
Current algorithm: longest scaled axis.
Current algorithm: mean weighted by pixels (not colors)
Current algorithm: split at halfway point.
Current alias analysis we are using.
Current allocation frontier for the non-persistent region.
Current decl context is contained inside 'D', so generic parameters are visible.
Current function we are analyzing.
Current instruction is unreachable, thus the constraint on the stack depth will never be violated
Current match for a backref
Current post-order we are using.
Current rc-identity we are using.
Current token can be either one-character token we want to consume...
Current token encompasses our source location.
Currently IRGen wraps alloc/init methods into Swift constructors / with Swift conventions.
Currently NewElem and Elem InFoo effects don't need to do anything different from each other.
Currently ObjC enums always have integer raw values.
Currently a dynamic thunk looks just like a foreign-to-native thunk around an ObjC method.
Currently all witness tables have public conformances, thus witness tables should not reference SILFunctions without public/public_external linkage.
Currently available indexes in tracked.
Currently generic methods of generic types are the deepest we should be able to stack specializations.
Currently inferred information about a PHP function.
Currently it takes every allocation and chops them up into their smallest non-captured pieces.
Currently only AAWH utilizes this to handle failures.
Currently only EagerSyncVMRegs, CallBuiltin, and Call can be adjusted to use the parent frame.
Currently only fixed-layout types should be known bitwise-takable.
Currently only handle array.uninitialized
Currently only supports a very limited set of instructions to simplify the decision for when it's safe to clone/sink them: - No memory effects (read or write).
Currently protocol witness methods are called with an additional generic parameter bound to the Self type, and thus always require a thunk.
Currently the RequestBodyReadLimit is not supported by FastCGI so we don't ever pause ingress and POST data is always received during VM execution.
Currently the SIL verifier restricts it to single-refcounted-pointer types.
Currently the debugger has no action to take at such sites.
Currently the first request for context wins because we don't want to change context on-the-fly.
Currently the following things are done:  o Replace PureLoad instructions with new uses of an available value, if we know it would load that value.
Currently the only types in our typesystem that have infinitely growing chains of union_of are specialized arrays.
Currently there are no operator attributes for postfix operators.
Currently there are no operator attributes for prefix operators.
Currently these / are overflow builtins but may be extended to other instructions in the / future.
Currently this doens't bind to ini_get since it is hard to thread through an enum
Currently this is never dependent.
Currently this is only hooked up to SetL.
Currently this only works for caps within CapCode::Threshold.
Currently this results in spurious work in the debugger.
Currently tracked locations, indexed by their ids.
Currently unused except for debug printing:  Memory locations that we saw PureLoad instructions for in the loop.
Currently we add all stack sizes even if life ranges do not overlap.
Currently we believe that castValueToABICompatibleType can handle all cases, so this check should never fail.
Currently we don't allow the address+set combination either.
Currently we don't attempt any of this for FPushClsMethod because lookupImmutableMethod is only for situations that don't involve LSB.
Currently we don't do any sophisticated dataflow analysis, so we keep the memoryContent alive only for a single block.
Currently we have no curried known functions.
Currently we ignore this possibility.
Currently we only accept enums as result values.
Currently we only convert non-function-like macros.
Currently we only handle array semantics.
Currently we only use the first field's extra inhabitants.
Currently we represent large Indexes using a 64 bit integer, so we don't need to mess with anything.
Currently you can't write a getter/setter that takes a different type from the type of the variable.
Currently, Self is being migrated away from in favor of opened existential types, so we should remove the special case here for Self when that process is completed.
Currently, all our optimizations are only relevant on x64.
Currently, let's use the breadth-first strategy.
Currently, more than one sanitizer cannot be enabled at the same time.
Currently, the abstraction pattern corresponding to an optional object is always opaque.
Currently, there is no restriction on overloading.
Currently, we aggressively assume that / pointer-to-address is never used for type punning, which is not yet / clearly specified by our UnsafePointer API.
Currently, we treat NSUInteger as Int.
Currying and calling convention thunks have shared linkage.
Currying thunks always have freestanding CC.
Cursor helper function
Cursor related read/write functions
Custom GETCFN to reset completion state after typing.
Custom coercion rules for key types
Custom handling for statements.
Custom network access manager to allow traffic monitoring.
Custom request local globals
Custom scanner for base classes.
Custom scanner for entire object.
Custom scanner for particular field.
Custom type checking.
CustomInstance classes always go through IR:AllocObj and ObjectData::newInstance()
Cut edge points to fit in filter window in case of spill-off
Cygwin does not add "begin" and "end" objects.
Cygwin does not support uselocale(), but we can use the locale feature  in stringstream object.
Cygwin uses the default BFD linker, even on ARM.
D1 can be the same as B.
D1 can be the same as D2.
DC - This is the current DeclContext.
DC is the DeclContext where D was defined CurDC is the DeclContext where D was referenced
DCE instruction if trivially dead.
DCE replaces dead arg values with undef.
DCE+SimplifyCFG runs as a post-pass cleanup.
DEFAULT_FONTPATH and PATHSEPARATOR are host type dependent and are normally set by configure in config.h.
DI will make sure it is only assigned to once.
DISPOSE constants Dispose type constants
DITHERMETHOD constants
DV entry points must be in the primary function body
Danger is now that the data is dying.
Darwin uses Objective-C ARC.
Data beyond this point must be rescanned after resumption, so move it to the front of the buffer rather than discarding it.
Data beyond this point will be regenerated after resumption, so do not write it out when emptying the buffer externally.
Data consists of brief comment length and brief comment text,
Data flow has not stabilized, do not perform the DSE just yet.
Data flow may take too long to run.
Data is contained within "boxes".
Data measued on function entry and exit
Data must be provided
Data structures used to perform name lookup for local values.
Data structures used to perform name lookup of basic blocks.
Data that is kept per request and is only valid per request.
Data used by irGenRegion() and friends to pass information between retries.
DataType is actually mapped to uint64_t constants, for some reason, but if that changes we still want to test them as bytes here.
DataTypeGeneric is used because we're just passing the locals into the callee.
Database, username and hashed password
Dataflow needs multiple iteration to converge.
Datetime encode/decode
Dbgp Header for sent messages
DceFlags tracks the state of one instruction during dead code analysis.
Deactivate all the cleanups for the result values.
Deactivate all the element cleanups and activate the tuple cleanup.
Deactivate any cleanups we made when splitting the tuple.
Deactivate the cleanup.
Deactivate the element cleanups and activate the tuple cleanup.
Deactivate this special destination.
Dead function elimination nulls out entries for functions it removes.
Dead instructions should just be removed.
Dead-code, but needed to satisfy cond().
DeadFunctionElimination pass takes functions / reachable via vtables and witness_tables into account / when computing a function liveness information.
DeadFunctionElimination pass will check if the function is marked and preserve it if required.
Deal with any cycles we encountered
Deal with possible promotion to stdClass or array
Deal with the corner case of having more than 4 nested loops.
Deal with the escaped char
DeallocStackInst do not use reference counted values.
Deallocate a boxed existential container with uninitialized space to hold a / value of a given type.
Deallocate an uninitialized array.
Deallocate an uninitialized box.
Deallocate everything we allocated above.
Deallocate ours and return the winner.
Deallocate the buffer.
Deallocate the object.
Deallocate the source temporary if we needed one.
Deallocate the temporary.
DeallocateLocation initially empty.
Deallocation is also okay, as are DebugValueAddr.
Deallocation is also okay.
Deallocations and retain/release don't affect the value directly.
Deallocs are fine if we're not examining a function that the alloc_box was passed into.
Debug Hook Handling Helper that grabs the breakpoint ids for the given breakpoint type using the given breakpoint info.
Debug output for Explosions.
Debug parser for DWARF (using libdwarf)  DWARF is structured as a forest of DIEs (Debug Information Entry).
Debug values do not use referenced counted values in a manner we care about.
Debug-only run identifier.
DebugInfo doesn't appear to care about the generic context, so just throw it away before lowering.
Debugger (part of Eval)
Debugger clients are disconnected abnormally, or this sandbox is not being debugged.
Debugger::Stop() needs an execution context
DebuggerClient acquires global mutexes in its constructor, so we allocate debugger_client lazily to ensure that all of the global mutexes have been initialized before we enter the constructor.
DebuggerHook implementation
Debugging of the archetype builder and generic signature generation.
Dec ref the old value
DecRef of def is done unconditionally by the IR, since there's a good chance it will be paired with an IncRef and optimized away.
DecRef tvRef and tvRef2.
DecRef* are special: they're the only instructions that can reenter but not throw.
DecRefs on the main line must happen after the potentially-throwing exit above: if we throw during the RaiseWarning, those values must still be on the stack.
December 4, 1999  Ported to libgd by Pierre Joye.
Decide between the binary, prefix, and postfix cases.
Decide if we can evaluate this expression at +0 for the rest of the lvalue.
Decide whether some text looks like UTF-8 with BOM.
Decide whether some text looks like UTF-8.
Decide whether to show the desugared type or not.
Decide whether we need a temporary stack buffer to evaluate this 'let'.
Decide whether we should suppress default initialization.
Decide which macro to call depending on the number of arguments provided.
Decide which potential archetype is to be considered the representative.
Decimal point is allowed.
Declaration Parsing and AST Building
Declaration of the class F belongs to.
Declaration reference.
Declaration references terminate the search.
Declarations are added under their full and simple names.
Declarations are always accessible externally, so they are alive.
Declarations for Floyd-Steinberg dithering.
Declarations imported from Clang modules have shared linkage.
Declarations in SIL don't require definitions.
Declarations provided by a C module have a special context mangling.
Declarations that were derived on behalf of types in Clang modules get shared linkage.
Declare 'IntlCalendar' class constants
Declare 'IntlTimeZone' class constants
Declare 'IntlTimeZone' class properties
Declare a helper for escaping file names for use in Makefiles.
Declare cached declarations for each of the known declarations.
Declare constants that are defined in the C header
Declared extern "C" LLVM_LIBRARY_VISIBILITY above.
Declared in externals.h.
Decls captured by value don't escape.
Decode RATAs with a different function.
Decode Unicode identifiers.
Decode a base 8 number up to 3 characters long.
Decode and print each instruction
Decode but ignore the pointee.
Decode each instruction
Decode operator names.
Decode the 'function' parameter into this_, cls, name, pos, and nameContainsClass.
Decode the context data for lazily-loaded conformances.
Decode the default argument kind.
Decode the intrinsic's LLVM IR type, and map it to swift builtin types.
Decode the ordering argument, which is required.
Decode the record, pulling the version tuple information.
Decode the success- and failure-ordering arguments, which are required.
Decodes input (unsigned char) into output (uint32).
Decodes input (unsigned char) into output (uint32_t).
Decodes input (unsigned char) into output (uint64).
Decodes input (unsigned char) into output (unsigned int).
Decoding value of parameter
Decompose function types into parameters and result type.
Decompose parallel structure.
Decompose protocol compositions.
Decompose the application.
Decompose the call site.
Decompose the function's name into a builtin name and type list.
Decompose the initialization.
Decompose the input types into parameters.
Decompose the parameters for subscript declarations.
Decompose what user typed so far in 2 parts: what toInspect and what toComplete.
Deconstruct a parenthesized expression.
Deconstruct a tuple expression.
Deconstruct an existential object into witness tables and instance / pointer.
Deconstruct the call argument to find its elements, element names, and the locations of the left and right parentheses.
Decorate the window object in this frame (object ownership left to the creator/parent)
Decref the WaitHandle.
Decrement depth after query execution, in case an exception occurs during commit.
Decrement our iterator (carefully, to avoid going off the front) so it is valid after inlining is done.
Decrement ref count for each SILGlobalVariable with static initializers.
Decrement the usage count.
Deduce associated types from dependent member types in the witness.
DefInlineFP has some special treatment here.
DefLabel and BeginCatch may not appear anywhere in a block other than where specified in #1.
Default all non-newly added files to being rebuilt without cascading.
Default arg values are not currently allowed to depend on class context.
Default arguments still require a type.
Default case comes last
Default case, nothing extra needed
Default cases for cleaning up as we exit a node.
Default cases for whether we should verify within the given subtree.
Default declaration of generated scanner - a define so the user can easily add parameters.
Default dirty page purging threshold.
Default for members that don't require vtable entries.
Default implementation always returns true.
Default implementation is conservative: assume we use all of our inputs, and can't be removed even if our output is unused.
Default implementation: Assume the variant encapsulates a basic type.
Default implementation: Assume this is a variant encapsulating the basic type.
Default implementation: Get the value via sourcekitd_variant_array_get_value.
Default implementation: Get the value via sourcekitd_variant_dictionary_get_value.
Default implementation: Iterate over elements via a for-loop.
Default implementation: Linear search for the key/value pair via sourcekitd_variant_dictionary_apply.
Default implementation: Treat as empty container.
Default implementation: Use strlen.
Default implementations for when a method isn't overridden.
Default is conservative: we don't increment a weak use if it uses the frame (or stack), so they can't be eliminated.
Default number of rounds if not explicitly specified.
Default number of rounds.
Default permissions for files and directories that are created
Default to 1024 (used when n is "null")
Default to a module named "REPL" if we're in REPL mode.
Default to full alpha
Default to implicitly unwrapped optionals.
Default to public external linkage.
Default to public linkage.
Default to standard output.
Default to strict types in force_hh mode and when not using PHP 7 scalar types.
Default to the current year if year parameter is not given
Default to the representative, unless we find something better.
Default value for select_enum.
Default value with no additional nodes
Default variable settings
Default visibility should suffice for other object formats.
Default witness thunk or concrete implementation:
Default witness thunks are mangled as if they were the protocol requirement.
Default witness thunks just get the requirement type without substituting Self.
Default witness thunks use the context archetypes of the requirement.
Default-initialization always allowed for conversions.
Default-initialize optional types and weak values to 'nil'.
Defaults to EnableHHSyntax since, if you have that on, you are assumed to know what you're doing.
Defend against type variables from our constraint system leaking into recursive constraints systems formed when checking the body of the closure.
Defer enforcement of requirements until the creation of the class happens at runtime.
Defer the initialization of light processes until the log file handle is created, so that light processes can log to the right place.
Deferred constants such as SID
Deferred exception data
Deferred string init, see below
Deferred string result and metadata
Deferred string value and cas, see below
Define a global symbol referring to this implementation.
Define all of the diagnostic objects and initialize them with their  diagnostic IDs.
Define common set of rules for unwinding frames in the VM stack
Define macros that Swift bridging headers use.
Define our magic string to mark salt for SHA256 "encryption" replacement.
Define our magic string to mark salt for SHA512 "encryption" replacement.
Define some builtin opaque metadata.
Define structure for one recognized option (both single char and long name).
Define test functions for all of our abstract value kinds.
Define the add-functions for all passes.
Define the copy and dispose helpers.
Define the global variable for the conformance list.
Define the metadata for a type.
Define the storage for the packet accumulator
Define the substituted function type for partial_apply's purposes.
Defined at top level, in the same unit as the caller.
Defined here so IndexData is a complete type for the unique_ptr destructor.
Defined here so it can be inlined below.
Defined in crypt-sha256.c
Defined out of line to break circular dependency.
Defined property that is not accessible.
Defines a unique inline location.
Definitions of some builtin metadata objects.
Deinitializers are always called "dealloc".
Delay issuing the diagnostic until we parse the attribute.
Delay processing of platform until later, after we have parsed more of the attribute.
Delay the destruction of the proxy originally attached to the sandbox to avoid calling a DebuggerProxy destructor (which can sleep) while holding m_mutex.
Delay the retain-unowned optimization until we finished with all other optimizations in this block.
Delay type-checking on VarDecls until we see the corresponding PatternBindingDecl.
DelayedConformanceDiags callbacks contain pointers to the TypeChecker, so they must be removed when the TypeChecker goes away.
Delegate generators aren't currently supported in the IR, so just use the interpreter if we get into a situation where we need to use the delegate
Delegate the responsibility for freeing the buffer to the immutable copy, if it exists.
Delete all fix lifetime instructions.
Delete all parts those are not in the "parts" attribute
Delete all syntax map data from start line through end line
Delete all syntax map data from start line through end line.
Delete all the converted type infos.
Delete all the cookies for this URL
Delete all the cookies from the CookieJar
Delete all the values from a STL style associative container.
Delete all uses of the dead array and its storage address.
Delete cookie(s) from the ones visible to the given "url".
Delete dead code and drop the bodies of shared functions.
Delete dead instructions and everything that could become dead after their deletion.
Delete everything after the unreachable except for dealloc_stack which we move before the trap.
Delete redundant stores
Delete the argument label.
Delete the corresponding entry from m_watch2Node.
Delete the dead blocks.
Delete the dead stores.
Delete the debug info of the instruction that we are about to sink.
Delete the instruction and move on.
Delete the old apply instruction.
Delete the old argument.
Delete the unreachable default block if we didn't use it, or emit it if we did.
Delete these instruction and others that become dead after it's deleted.
Deleting this ensures that all attributes are covered by the visitor / below.
Deliberately leak the llvm::MemoryBuffer.
Deliberately reload `attrs' to check for dynamic properties.
Delimiter character to be quoted
Delta Memory (since the last begin frame)
Demangle the associated type chain.
Demangle the associated type name.
Demangle the base name.
Demangle the base type.
Demangle the basic type name.
Demangle the identifier
Demangle the parameters.
Demangle the result type.
Dependencies of the stdlib module (like SwiftShims module) are implementation details.
Dependencies which go in the reverse direction.
Dependency-marking is purely for SIL.
Dependent enum types need their own implementation if any element payload type might need its own implementation.
Dependent members can appear in lowered position inside SIL functions.
Dependent members can appear in lowered position inside tuples.
Dependent struct types need their own implementation if any field type might need its own implementation.
Dependent types have non-trivial representation in case they / instantiate to a class metatype.
Dependent types might be bound to classes.
Dependent types should be contextualized before visiting.
Depending on how we decide to resolve rdar://problem/14627460, we may want to use the regular getLoc instead and rather use the column info.
Depending on how we matched, produce tailored diagnostics.
Depending on number of request threads, current load, etc., this can easily result in excessive dirty page purging.
Depending on read preference type, run the correct algorithm
Depending on the RecordKind, we write the SILFunction table, the global / variable table, the table for SILVTable, or the table for SILWitnessTable.
Depending on whether we want a read or a write connection, run the correct algorithms
Deprecated IDE uses this, so keep it around for now.
Deprecated, but we will keep it for now
Depth-first search for connected components
Dereferencing the SuccIterator returns the predecessor's SILBasicBlock.
Derive SILType for InOutType from the object type.
Derive a 'hashValue' implementation for an enum.
Derive a concrete type of self and conformance from the init_existential / instruction.
Derive a pointer to the Objective-C class.
Derive its extra inhabitant index.
Derive name from SIL location.
Derive the ObjC selector family from an identifier.
Derive the callee function pointer.
Derive the connection graph of the apply from the known callees.
Derive the context argument if needed.
Derive the effects of the apply from the known callees.
Derive the name of the SIL file for debugging from the regular outputfile.
Derive the storage type from the initStorage method.
Derive the summary graph of the current function.
Derive the tuple type from the elements.
Derived classes even have to put all less visible methods of the base class into their vtables.
Derived types may conform to the protocol.
Derived-to-base casts in the AST might not be reflected as such in the SIL type system, for example, a cast from DynamicSelf directly to its own Self type.
Describe why the witness didn't satisfy the requirement.
Describes actions one could take to suppress a warning about a / nearly-matching witness for an optional requirement.
Describes an opened existential that has not yet been closed.
Describes an optional adjustment made to a witness.
Describes how the next member reference will be treated as we traverse / the AST.
Describes the kind of optional adjustment performed when / comparing two types.
Describes the kind of string literal we're importing.
Describes the relationship between the context types for two declarations.
Describes the relationship between the operands.
Describes the result of checking a type witness.
Description structure.
Descriptor for buffer area
Deserialize Conformance.
Deserialize a SILFunction if it is not already deserialized.
Deserialize all DefaultWitnessTables in all SILModules.
Deserialize all DefaultWitnessTables inside the module and add them to SILMod.
Deserialize all VTables in all SILModules.
Deserialize all VTables inside the module and add them to SILMod.
Deserialize all WitnessTables in all SILModules.
Deserialize all WitnessTables inside the module and add them to SILMod.
Deserialize the VTable mapped to C if it exists and all SIL the VTable / transitively references.
Deserialize the literal raw value, if any.
Deserialize the method and add it to the list.
Deserializes a CmdBreak from the given Thrift buffer.
Deserializing an array could give back a different ArrayKind than we need, so we have to go with the slow case of calling a collection constructor.
Despite spec, line and conditional are the same in php5 xdebug
Destination basic blocks for condfail traps.
Destination is palette based
Destination must be the allocation.
Destroy and dealloc are both fine.
Destroy is a no-op for trivial types.
Destroy only the unique entries.
Destroy overwritten value These are ignored.
Destroy palette based temporary image.
Destroy the alloca insertion point.
Destroy the captures.
Destroy the lookup table.
Destroy the main struct (reentrant only).
Destroy the object inside.
Destroy the old value.
Destroy the source value, since we avoided taking or destroying it above.
Destroy the stack itself.
Destroy the start condition stack.
Destroy the successor records to keep the CFG up to date.
Destroy the value if requested.
Destroy the value indirectly.
Destroy the value inside.
Destroy value of an enum with a trivial payload or no-payload is a no-op.
DestroyMainWindow - clean up all the window registration.
Destroying an array of trivial types is a no-op.
Destroys of loadable types can be rewritten as releases, so they are fine.
Destructively specialize the rows of this clause matrix.
Destructor - release member variables.
Destructor for an ErrorProtocol box.
Destructor has no non-self params.
Destructor of IntrusiveListHook will automatically unlink()
Destructors are a necessary part of class metadata, so can't be delayed.
Destructors are alive because they are called from swift_release
Destructors are technically instance members, although they can't actually be referenced as such.
Destructors need to be collected into the instance methods / list
Destructure original tuples.
Destructure the buffer into per-element buffers.
Destructure the existential and replace the "object" field with the right reference kind.
Destructure the input tuple type.
Destructure the result tuple type.
Destructure the value into its payload + tag bit components, each is optional.
Destructure tuple arguments.
Desugar for comparison.
Desugar the value type.
Detach from the old sandbox
Detaches the xdebug profiler from the current thread
Detaches the xdebug profiler if it's no longer needed
Detail about how an object conforms to a protocol.
Detailed memory effects of builtins are handled below by checking the memory behavior of the instruction.
Detect a terminal match.
Detect an edge from the loop pre-header's predecessor to the loop exit / block.
Detect self-recursive calls.
Detect suspicious headers.
Detect the case where the last selector is text(), simplexml always accesses the text() child by default, therefore we assign to the parent node.
Detect this and simplify the generated code if so.
Detect this pattern so we can consider / it a 'return' use of self.
Detect when the source and destination are both permit scalar conversions, but the source has a name and the destination does not have the same name.
Detect when the type arguments correspond to the unspecialized type, and clear them out.
DetectKanjiCode() derived from DetectCodeType() by Ken Lunde.
Detects multiple/malformed multiple newlines in mail headers.
Determine / whether all of the elements touched by the instruction are definitely / initialized at this point or not.
Determine a "mid" point and adjust to make sure the mid point is at the beginning of a case mapping triple.
Determine a "mid" point and adjust to make sure the mid point is at the beginning of a range pair.
Determine an appropriate path.
Determine default SSL configuration file
Determine how close an argument list is to an already decomposed argument / list.
Determine how many stack slots we're going to write that the caller hasn't already checked we have space for.
Determine how many tag bits we need.
Determine how many tags we need to accommodate the empty cases, if any.
Determine how much file is left.
Determine how we match up the input/result types.
Determine if an object is dead.
Determine if the given Objective-C instance method should also / be imported as a class method.
Determine if the given invocation should run as a subcommand.
Determine if the method is a property getter/setter.
Determine if the overloads all share a common return type.
Determine if the server needs us to keep the channel open after the request completes.
Determine if there exists a name mangling for the given type.
Determine if this basic block is part of an irreducible loop by looking at all blocks that are:
Determine if this is a copy *from* or *to* "Pointer".
Determine if this value_metatype instruction is part of a call to / self.init when delegating to a factory initializer.
Determine if we are doing code completion inside a static method.
Determine if we have leading decorations in this block comment.
Determine if we need to unregister the line
Determine required destination buffer size (pre-flighting).
Determine the CommandOutput for the job.
Determine the Objective-C name of the class.
Determine the Objective-C name of the declaration.
Determine the OpenMode
Determine the OutputInfo for the driver.
Determine the accessibility of this conformance.
Determine the actually nearest colors.
Determine the appropriate context for the element.
Determine the appropriate generic parameters at this level.
Determine the assignment semantics.
Determine the base name and whether this is an incomplete type or not from the DIE's attributes.
Determine the begin and end offsets of this type and set up a conservative scan for that range.
Determine the bits we're going to use for the tag.
Determine the callee.
Determine the calling convention.
Determine the class type to which the target value type is bridged.
Determine the constraint kind.
Determine the correct output filename.
Determine the declaration selected for this overloaded reference.
Determine the declaration selected for this subscript operation.
Determine the depth our parameter list is at.
Determine the derived thunk type by lowering the derived type against the abstraction pattern of the base.
Determine the desired abstraction pattern of the storage type in the requirement and the witness.
Determine the effective Clang context for this Swift nominal type.
Determine the element type of the generator.
Determine the failability of this initializer.
Determine the foreign error convention.
Determine the foreign representation of this type.
Determine the formal type of the 'self' parameter.
Determine the formal type of the storage.
Determine the frontend mode option.
Determine the generator type of the sequence.
Determine the implementation strategy.
Determine the initializer parameters.
Determine the input and result types of this function.
Determine the kind of checked cast to perform from the given type to / the given type.
Determine the kind of conformance.
Determine the kind of optional adjustment.
Determine the liveness state of the element that we care about.
Determine the liveness states of the elements that we care about.
Determine the liveness states of the memory object, including the super.init state.
Determine the maximum depth of the current generic type context's generic / parameters.
Determine the module and Swift declaration names.
Determine the module name from the Clang declaration.
Determine the name we would search for.
Determine the nominal type through which we found the declaration.
Determine the number of applications that need to occur before we can close this existential, and record it.
Determine the number of iterations the loop is at most executed.
Determine the number of parameters.
Determine the number of source-level Swift of a function or closure.
Determine the object type of 'self'.
Determine the opaque 'self' parameter type.
Determine the optionality of the given Clang parameter.
Determine the optionality of the given Objective-C method.
Determine the options associated with the given type.
Determine the outer most region that contains the exiting block that is not this subloop's region.
Determine the parameter bindings.
Determine the parameter index at which the error will go.
Determine the parameter type of the implicit constructor.
Determine the parameter type.
Determine the prefix to be stripped from the names of the enum constants / within the given enum.
Determine the relationship between the 'self' types and add the appropriate constraints.
Determine the relationship between the self types of the given declaration / contexts..
Determine the result convention.
Determine the score between two potentially-matching declarations.
Determine the score when trying to match two identifiers together.
Determine the selector of the counterpart.
Determine the selector of the overridden method.
Determine the self.init state.
Determine the semantics of a checked cast operation.
Determine the set of declarations that are shadowed by other declarations.
Determine the set of predecessors in case any predecessor has two edges to this block (e.g. a conditional branch where both sides reach this block).
Determine the set of protocols to which the given dependent type / must conform.
Determine the setter's element type and indices.
Determine the signature of this declaration.
Determine the size and alignment of an ErrorProtocol box containing the given / type.
Determine the substitutions.
Determine the superclass bound on the given dependent type.
Determine the time of the start of the period containing a given time.
Determine the type and generic args of the extension.
Determine the type of the container.
Determine the type of the generic function.
Determine the type of the method we referenced, by replacing the class type of the 'Self' parameter with Builtin.UnknownObject.
Determine the type of the value, opening up that type if necessary.
Determine the type that the requirement is expected to have.
Determine the type to which we'll bind the overload set's type.
Determine the type we're bridging to.
Determine we can suppress the warning about a potential witness nearly / matching an optional requirement by moving the declaration.
Determine what kind of diagnostic we're emitting.
Determine what state that goes to, based on the state we popped back to and the rule number reduced by.
Determine what the user has asked the frontend to do.
Determine where and how to perform name lookup for the generic parameter lists and where clause.
Determine where the explicit conformance actually lives.
Determine whether 'super' would have made sense as a base.
Determine whether a reference to the given method via its / enclosing class/protocol is ambiguous (and, therefore, needs to / be disambiguated with a coercion).
Determine whether an instruction may not have a SILDebugScope.
Determine whether any extensions were added that might require / us to compute conformances again.
Determine whether it's canonical.
Determine whether one declaration is more specialized than the other.
Determine whether one module takes precedence over another.
Determine whether one protocol extension is at least as specialized as / another.
Determine whether or not a given NominalTypeDecl has a failable / initializer member.
Determine whether or not we want to provide an optional chaining fixit or a force unwrap fixit.
Determine whether overriding the given declaration requires a keyword.
Determine whether the 'Self' type from the first protocol extension satisfies all of the requirements of the second protocol extension.
Determine whether the callee has any needless words in it.
Determine whether the entry is a global declaration that is being / mapped as a member of a particular type or extension thereof.
Determine whether the field we're touching is a let property.
Determine whether the frame pointer is outside the native stack, cleverly using a single unsigned comparison to do both halves of the bounds check.
Determine whether the given Clang entry is visible.
Determine whether the given Clang selector matches the given / selector pieces.
Determine whether the given Objective-C class, or any of its / superclasses, either has or inherits a swift_bridge attribute.
Determine whether the given Swift type is an integral type, i.e., / a type that wraps a builtin integer.
Determine whether the given class requires a separate instance / variable initialization method.
Determine whether the given conformance entry kind can be replaced.
Determine whether the given context is an extension to an Objective-C class / where the class is defined in the Objective-C module and the extension is / defined within its module.
Determine whether the given context is generic at any level.
Determine whether the given context nested inside a generic type context / with no local contexts in between.
Determine whether the given declaration has compatible argument / labels.
Determine whether the given declaration is favored.
Determine whether the given declaration requires a definition.
Determine whether the given declaration returns a non-optional object that / might actually be nil.
Determine whether the given dependent type is equal to a concrete type.
Determine whether the given destructor has an Objective-C / definition.
Determine whether the given enumerator is non-deprecated and has no specifically-provided name.
Determine whether the given expression returns a non-optional object that / might actually be nil.
Determine whether the given extension has a Clang node that / created it (vs.
Determine whether the given locator is for a witness or requirement.
Determine whether the given method potentially conflicts with the / setter for a property in the given protocol.
Determine whether the given parameter and argument type should be / "favored" because they match exactly.
Determine whether the given pattern binding declaration either has / an initializer expression, or is default initialized, without performing / any type checking on it.
Determine whether the given request has already been satisfied.
Determine whether the given requirement was left unsatisfied.
Determine whether the given text matches a property name.
Determine whether the given type is a value type to which we can bridge a / value of its corresponding class type, such as 'String' bridging from / NSString.
Determine whether the given type is an opened AnyObject.
Determine whether the given type is the 'Self' generic parameter / of a protocol.
Determine whether the given type refers to a non-final class (or / dynamic self of one).
Determine whether the given type variables occurs in the given type.
Determine whether the given word occurring after the given / preposition results in a conflict that suppresses preposition / splitting.
Determine whether the given word occurring before the given / preposition results in a conflict that suppresses preposition / splitting.
Determine whether the innermost context is generic.
Determine whether the method is dynamically dispatched.
Determine whether the new declarations matches an existing declaration.
Determine whether the parameter is of (possibly lvalue, possibly optional), non-autoclosure function type, which could receive a closure.
Determine whether the preposition in a split is "vacuous", and / should be removed.
Determine whether the rhs behaves normally, or abnormally.
Determine whether the set of bindings is non-empty.
Determine whether the should associate a conflict among the given / set of methods with the specified source file.
Determine whether the specified block is reachable from the entry of the / containing function's entrypoint.
Determine whether the type of the witness's context conforms to the protocol.
Determine whether the witness for the given requirement / is either the default definition or was otherwise deduced.
Determine whether the witness for this conformance is in fact our witness.
Determine whether the witness will be mutating or not.
Determine whether the word preceding the preposition is part of an / "extended" preposition, such as "compatible with".
Determine whether there are any extraneous default arguments to be zapped.
Determine whether there is a name conflict.
Determine whether there is a superclass constraint where the superclass conforms to this protocol.
Determine whether there is already a solution with the same bindings.
Determine whether this Objective-C class type is bridged to a Swift type.
Determine whether this debug scope belongs to an explicit closure.
Determine whether this declaration is suppressed in Swift.
Determine whether this entry is superseded by (or supersedes) some other entry.
Determine whether this generic Swift nominal type maps to a / generic Objective-C class.
Determine whether this is a "simple" type, from the type-simple / production.
Determine whether this is a parameter adjustment.
Determine whether this is a representable Objective-C object type.
Determine whether this is a variadic witness.
Determine whether this is an unparenthesized closure type.
Determine whether this is the name of a collection with a single / element type.
Determine whether this is the protocol 'Self' constraint we should skip.
Determine whether this location is some kind of closure.
Determine whether this nominal type is _ObjectiveCBridgeable.
Determine whether this nominal type is known to be representable in this foreign language.
Determine whether this subscript operation overrides another subscript operation.
Determine whether this type is a single value that is passed / indirectly at the given level.
Determine whether this type is bridged to Objective-C.
Determine whether this type is known to be POD.
Determine whether this type requires an indirect result.
Determine whether to escape the given keyword in the given context.
Determine whether type is 'NSString.
Determine whether we are (still) inheriting initializers.
Determine whether we are at the start of a parameter name when / parsing a parameter.
Determine whether we can derive a witness for this requirement.
Determine whether we have a default argument.
Determine whether we have a suitable return type.
Determine whether we have an imbalance in the number of optionals.
Determine whether we have the getter or setter.
Determine whether we know anything about this nominal type yet.
Determine whether we need to introduce a super.init call.
Determine whether we performed a coercion or downcast.
Determine whether we require in-class initializers.
Determine whether we should drop the preposition.
Determine whether we should lowercase the first word of the given value / name.
Determine whether we should strip the module prefix from a global-scope entity in the given module and with the given base name.
Determine whether we should warn about the given witness being a close / match for the given optional requirement.
Determine whether we'll need to use an allocating constructor (vs.
Determine whether we're dealing with a TVCoercionException or a php exception.
Determine whether we're handling a favored constraint in subsystem.
Determine whether we're searching from a protocol extension.
Determine which attribute it is, and diagnose it if unknown.
Determine which blocks the value can escape from.
Determine which colormap entries are close enough to be candidates for the nearest entry to some cell in the update box.
Determine which extensions should be treated as php source code.
Determine which instructions from this function we need to keep.
Determine which kind of array semantics call this is.
Determine which members, specifically are uninitialized.
Determine which method or subscript this method or subscript overrides / (if any).
Determine which of the candidates is viable.
Determine which of the successors is unreachable and create a new terminator that only branches to the reachable successor.
Determine which simple collection op to use for the given base and key types.
Determine which type we looked through to find this result.
Determines if a builtin type falls within the given category.
Determines the access semantics to use in a DeclRefExpr or / MemberRefExpr use of this value in the specified context.
Determines the kind of array bounds effect the instruction can have.
Determines whether the first type is nominally a superclass of the second / type, ignore generic arguments.
Determines whether the given type is bridged to an Objective-C class type.
Determines whether the optional adjustment is an error.
Determining this may be an O(N) operation.
Devirtualization of functions with covariant return types produces a result that is not an apply, but takes an apply as an argument.
Devirtualization of remaining cases is not possible, because more than one implementation of the method needs to be handled here.
Devirtualize apply instructions that call witness_method instructions:
Devirtualize indirect calls to functions, turning them into direct function references.
Devirtualize releases of array buffers.
Devirtualize releases of swift objects.
Devirtualize the apply instruction on the identical path.
Devirtualizes release instructions which are known to destruct the object.
Diagnose ".foo" expressions that lack context specifically.
Diagnose 'nil' without a contextual type.
Diagnose 'self.init' or 'super.init' nested in another expression.
Diagnose 'super.init', which can only appear inside another initializer, specially.
Diagnose C style for loops.
Diagnose a '_' that isn't on the immediate LHS of an assignment.
Diagnose a class that does not have any initializers.
Diagnose a declaration that doesn't match a previous pattern.
Diagnose a missing override of a required initializer.
Diagnose a missing required initializer.
Diagnose a potential witness.
Diagnose a previous declaration that is missing in this pattern.
Diagnose a reference to an unknown type.
Diagnose all the call sites within a single unhandled 'try' at the same time.
Diagnose an argument labeling issue, returning true if we successfully / diagnosed the issue.
Diagnose an optional injection that is probably not what the / user wanted, because it comes from a forced downcast.
Diagnose an override for potential availability.
Diagnose any conflicts attributed to this declaration context.
Diagnose assigning variable to itself.
Diagnose common failures due to applications of an argument list to an / ApplyExpr or SubscriptExpr.
Diagnose duplicated attributes.
Diagnose each conflict.
Diagnose each of the matches.
Diagnose empty collection literals that lack context specifically.
Diagnose expected diagnostics that didn't appear.
Diagnose for appropriate accessors, given the access context.
Diagnose for checks that are useless because the minimum deployment target ensures they will never be false.
Diagnose for deprecation
Diagnose for potential unavailability
Diagnose for the member declaration itself.
Diagnose if we have local captures and there were C pointers formed to this function before we computed captures.
Diagnose it with a generic error message now.
Diagnose metatype values that don't appear as part of a property, method, or constructor reference.
Diagnose non-type declarations.
Diagnose obvious assignments to literals.
Diagnose or defer a diagnostic, as appropriate.
Diagnose recursive use of properties within their own accessors
Diagnose requirements that can't be satisfied from the behavior decl.
Diagnose some simple and common errors.
Diagnose syntactic restrictions of expressions.
Diagnose the ambiguity.
Diagnose the bad case and return true so that the caller parses this as a trailing closure.
Diagnose the conflict.
Diagnose the duplicate value.
Diagnose the first associated type for which we could not determine a witness.
Diagnose the improper forward capture.
Diagnose the lack of initial value.
Diagnose the override.
Diagnose the unreachable code within the same block as the call to noreturn.
Diagnose this and create the getter decl now.
Diagnose this as a conversion failure.
Diagnose this problem, if asked to.
Diagnose this specifically.
Diagnose this, and recover as if they wrote that.
Diagnose user written unreachable code.
Diagnose uses of operators that found no matching candidates.
Diagnose uses of unavailable declarations.
Diagnose using accessibility in a local scope, which isn't meaningful.
Diagnose variables that were never used (other than their initialization).
Diagnosed at the call sites.
Diagnostic about the compiler arguments.
Diagnostic didn't exist.
Diagnostic printing of PatternKinds.
Dictionary downcasts are handled specially.
Did not find .mgc, restore q
Did not find a number
Did not find a retain in this block, try to go to its predecessors.
Did not find retain in this block.
Did this aggregate already create an aggregate and thus is "invalidated".
Did we see any copies into the alloc stack.
Didn't find a match based on SNI, fallback to default.
Didn't find a match, just return the raw function type
Didn't find an error parameter.
Didn't have a type, totally guess here
Die a horrible death.
Different addressor safety kinds still count as the same addressor.
Different enums cannot be cast to each other.
Different fields should not overlap.
Different from simplify(), this works even when `block' is unreachable.
Different from zend default but matches what we've been returning for years
Different implementation is used by a subclass.
Different line braces, so use RBrace's indentation.
Different payloads have different reference counting styles.
Different stags, with non-overlapping bits.
Different strategies could be used, E.g. breadth-first, depth-first, etc.
Different structs cannot be cast to each other.
Different, cleanup and ignore
Differing only in Optional vs.
Diffrence between static and uncounted is in the lifetime of the string.
Dig down to the type we care about.
Dig out some of the fields from the conformance.
Dig out the Objective-C class type through which the native type is bridged.
Dig out the Objective-C class.
Dig out the Objective-C superclass.
Dig out the Objective-C type.
Dig out the ObjectiveCBridgeable protocol.
Dig out the OtherConstructorRefExpr.
Dig out the StringInterpolationConvertible protocol.
Dig out the UnresolvedValueMember constraint for this expr node.
Dig out the argument tuple.
Dig out the argument.
Dig out the base type.
Dig out the class definition.
Dig out the conforming nominal type.
Dig out the constructor we're delegating to.
Dig out the context type.
Dig out the declaration of the Selector type.
Dig out the declaration of the class.
Dig out the effective Clang context for this nominal type.
Dig out the extended type.
Dig out the fixed type to which this type refers.
Dig out the initializer we're in (if we are).
Dig out the instance type and figure out what members of the instance type we are going to see.
Dig out the module that owns the class definition.
Dig out the nominal type being extended.
Dig out the nominal type we're bridging from.
Dig out the nominal type.
Dig out the owner of the default arguments.
Dig out the parameter for the value.
Dig out the parameter tuple for this constructor.
Dig out the protocol conformance.
Dig out the protocol.
Dig out the reference to a declaration.
Dig out the type of its pointer.
Dig out the type of the base, which will be the result type of this expression.
Dig out the type of the variable.
Dig out the type that we'll actually be looking into, and determine whether it is a nominal type.
Dig out the type witness.
Dig the open-existential expression out of the list.
Dig the original user's body of the defer out for AST fidelity.
Dig through all levels of calls.
Dig through each of the Swift lookup tables, creating extensions where needed.
Dig through the inherited entries to find a non-inherited one.
Dig through the optionals in the from/to types.
Dig through the type, looking for a typedef-name and stripping references along the way.
Direct conventions depends on the type.
Direct reference to a type.
Direct translation is relatively easy.
Directly call the peer constructor.
Directly capture storage if we're supposed to.
Directories are not executable
Dirty page purging thresholds for the per NUMA node arenas used by request threads.
Disable JIT for PPC64 - Port under development
Disable all llvm IR level optimizations.
Disable assertion configuration replacement when we build the standard library.
Disable buffering on stdout so that everything is printed before crashing.
Disable builtin wrapper if it exists
Disable its cleanup, forcing a copy if it was emitted +0.
Disable logging to files
Disable logging to suppress harmless errors about setrlimit.
Disable nested writeback scopes for any calls evaluated during the conversion intrinsic.
Disable semantic info in the editor for the given amount, to avoid repeated crashers.
Disable sending the 100 Expect header for POST requests
Disable signal polling during this time, since our protocol requires that only one thread talk to the client at a time.
Disable the API redefinition in sqlite3ext.h
Disable the cleanup for this value.
Disable the expression cleanup of the copy, since the let value initialization has a cleanup that lives for the entire scope of the let declaration.
Disable the rvalue expression cleanup, since the let value initialization has a cleanup that lives for the entire scope of the let declaration.
Disable the use of sret if we have a non-trivial direct result.
Disable the use of sret if we have multiple indirect results.
Disables the breakpoint at the given stack level.
Disallow direct ivar access (and avoid conflicts with property names).
Disallow infinite loops.
Disallow mutableAddress+set.
Disallow these chars outside option values
Disambiguate and diagnose invalid uses of trailing closures in a situation / where the parser requires an expr-basic (which does not allow them).
Disble function entry/exit events
Discard all PHP exceptions pending for this frame
Discard all buffered characters.
Discard all file_sections in ImageInfo
Discard all units that were created via create_function().
Discard any inout or lvalue qualifiers.
Discard data scanned by exif_read_file.
Discard numbers over the limit to avoid modulo bias
Discard stack temporaries
Discard the class, preserving the RHS value if it's there.
Discard the implicit _cmd argument.
Discard the shifted token.
Discard the value returned by the __toString() method and raise a recoverable error
Discard time, xflags and OS code:
Discarding an assignment is a no-op.
Discover which part we were last working on
Discriminated union case without argument.
Discussion: The guaranteed self call sequence is as follows:
Disjunction constraints are never solved here.
Dispatch down to a concrete override.
Dispatch in a struct/enum or to a final method is always direct.
Dispatch to each specialized function is implemented by inserting / call at the beginning of the original generic function guarded by a type / check.
Dispatch to the correct memcached_* function depending on initial_value, server_key, and isInc.
Dispatcher for the second argument for disjointDataFn.
Dispatching will consume it.
Display a warning if we encounter an unknown modifier.
Display diagnostics to stderr.
Display the common root of the found completions and beep unless we found a unique one.
Display the diagnostic.
Display the elevation shield if perMachine installation
Display the predecessors ids sorted to give a stable use order in the printer's output.
Display the user ids sorted to give a stable use order in the printer's output.
Displaying a spinning wait icon.
Distances for all scopes.
Ditto with command, XDebugServer is tracking the command before the break.
Div and mod might return boolean false.
Divide a fixed by a fixed
DllMain - Initialize and cleanup WiX custom action utils.
Do a PHP return to the caller---i.e., relative to the callee's frame.
Do a binary search with 5 steps
Do a cached lookup under yet another key, just so later lookups using the SILType will find the same TypeLowering object.
Do a depth first search exploring all of the uses of the object pointer, following through casts, pointer adjustments etc.
Do a derived-to-base conversion if necessary.
Do a double word increment.
Do a dynamic cast on the instance pointer.
Do a dynamic cast to the target class.
Do a fast path for ASCII characters that don't need escaping
Do a local lookup into the function, using the end loc to approximate being able to see all the local variables.
Do a lookup in this protocol.
Do a lot of sanity checking on the result.
Do a memoized witness-table layout for a protocol.
Do a prepass over the declarations to find and load the imported modules and map operator decls.
Do a primitive copy of the enum from one address to another.
Do a quick check at the beginning to make sure that our terminator is actually an unreachable.
Do a quick pass over the new arguments to see if any of them are dead.
Do a quick self-test.
Do a quick test before grabbing the write lease
Do a raw copy first, without worrying about counted types or refcount manipulation.
Do a raw copy without worrying about refcounts, and convert the values to uncounted later.
Do a rough check to allow any ObjC-representable struct or enum type on iOS.
Do a round of CFG simplification, followed by peepholes, then more CFG simplification.
Do a second pass over Builtins.def, ignoring all the cases for which we emitted something above.
Do a single mutation pass over the blocks.
Do a two-step look up
Do all of the users of the alloc stack allow us to perform optimizations.
Do all the stuff that we only have implemented when there is a single candidate.
Do an actual comparison of the contents.
Do an actual lookup for 'self' in case it shows up in a capture list.
Do an address range check to determine whether prop physically resides in propVec.
Do an adjustment if necessary.
Do an exact match if no archetypes are involved.
Do another pass and kill them off.
Do any post-sweep cleanup necessary for global variables
Do appropriate processing given the current state.
Do authentication if requested
Do dominator based simplification of terminator condition.
Do final permutation (inverse of IP).
Do formal evaluation of the base l-value.
Do formal evaluation of the underlying existential lvalue.
Do format conversion placing the output in buffer
Do initial permutation (IP).
Do it conservatively for now:
Do it first to move off the 'u' and leave us on the final hex digit as we move on by one later on
Do it here so we don't have to go through the rigormorale of binding if this is the case.
Do it last just in case
Do it now so the printDeclPre callback happens after the newline.
Do key permutation and split into two 28-bit subkeys.
Do linkage of the generator's AR.
Do lookup again just to make sure it wasn't created by another thread before we acquired the write lock.
Do make sure that it does not effect any other instructions.
Do not JIT this unit, we are using it exactly once.
Do not add a semi as it is wrong in most cases during migration
Do not allow a repair because that could put us in a perpetual restart loop.
Do not allow further breaks on the site of cmd, except during calls made from the current site.
Do not allow specification of keys even if the resulting array is packed.
Do not allow the entry block to be cloned again
Do not annotate references to unavailable decls.
Do not attempt a value-to-optional conversion when resolving the applicable overloads for an operator application with nil operands.
Do not attempt to inline an apply into its parent function.
Do not attempt to shorten the lifetime of this object beyond this point so we are conservative.
Do not capture frame for HPHP only functions.
Do not cause slowness on startup -- except for Facebook
Do not count referenced values after the first
Do not create any new specializations at Onone.
Do not encode output and input.
Do not form a path from an IndexAddrInst without otherwise distinguishing it from subelement addressing.
Do not get RC identical value here, could end up with a crash in replaceAllUsesWith as the type maybe different.
Do not handle unavailable decls.
Do not initialize JIT stubs for PPC64 - port under development
Do not inline wrappers, because this would result in a code size increase.
Do not inspect the body of types with unreferenced types such as bitfields and unions.
Do not iterate over this map's entries.
Do not prepend "hhvm." to these when accessing.
Do not process arithmetic overflow checks.
Do not re-process already known properties.
Do not reclaim the symbols of the rule which action triggered this YYABORT or YYACCEPT.
Do not reclaim the symbols of the rule which action triggered this YYERROR.
Do not recurse into other closures.
Do not remove bodies of any functions that are alive.
Do not remove functions from the white-list.
Do not remove the casts below.
Do not remove* any bits that are already on the closure though.
Do not remove/delete m_debuggerHook, it's a singleton, and code in another thread could be using it.
Do not replace the bbarg
Do not resolve volumes (for now).
Do not specialize apply insts that take in multiple closures.
Do not specialize functions that are available externally.
Do not specialize the signature of SILFunctions that are external declarations since there is no body to optimize.
Do not specialize the signature of always inline functions.
Do not translate functions from units marked as interpret-only.
Do not try to enumerate if we are not hoisting epilogue releases.
Do not try to fold it again if we had previously produced an error while folding it.
Do not try to optimize this function.
Do not use the 4 neighbors implementation with small images
Do not walk into function or type declarations.
Do nothing for non-trivial non-reference types.
Do nothing if no 'duplicates' were found.
Do nothing if the list is empty.
Do nothing if the read location NoAlias with the current location.
Do nothing if this is null
Do nothing with code completion expressions.
Do nothing with error expressions.
Do nothing with input, just skip it
Do post order walks from each DV entry with the same visited set (so we'll stop if they chain to the main entry, which is the normal case).
Do replica set name test
Do salting for crypt() and friends, and XOR with the permuted key.
Do sbox lookups (which shrink it back to 32 bits) and do the pbox permutation at the same time.
Do simplifications that require the dominator tree to be accurate.
Do so at +0 if we can.
Do so now, and cache the result.
Do some backup logic for foreign type declarations.
Do some special-case code completion for the start of the pattern.
Do some type checking / name binding for the parsed type.
Do the actual hoisting.
Do the actual replacement and put the result back into subject_value for further replacements.
Do the assignment as for a refcounted pointer.
Do the binary search.
Do the effects of array_set but without handling possibly emptiness of `arr'.
Do the first stack promotion on high-level SIL.
Do the first-time ping to record the latency of the connection
Do the following math as float intermediately, and round to ensure that Polygon and FilledPolygon for the same set of points have the same footprint.
Do the initialization as for a refcounted pointer.
Do the ping, if needed
Do the pre-order visitation.
Do the reassignment of the payload in-place.
Do the rest based on the opcode's dest type
Do the same as array_newelem_key, but ignoring possible emptiness of `arr'.
Do the same with the call graph.
Do the second stack promotion on low-level SIL.
Do the server-side work for this interrupt, which just notifies the client.
Do the simplest here thing here and just use ifdefs to control which implementation gets returned.
Do the simplification that requires both the dom and postdom tree.
Do the single call to the custom bases scanner if there is one.
Do the take/copy of the payload.
Do the tar test first, because if the first file in the tar archive starts with a dot, we can confuse it with an nroff file.
Do the transition now to avoid doing it in N places below.
Do the work of the debuggerRetHelper by setting some unwinder RDS info and resuming at the approprate catch trace.
Do these in a separate pass.
Do this after draining the worklist, as we want to prefer discovering things via non-conservative means.
Do this after the ini processing so we don't accidentally save the config when we change one of the options
Do this at the very end as syncing needs to allocate memory for the ELF file.
Do this before anything else has a chance to deadlock us.
Do this before checking the inheritance clause, since it may itself be dependent on one of these parameters.
Do this before setting up the timeout to avoid potential races.
Do this before we consume the 'sil' token so that all later tokens are properly handled.
Do this first so other methods can overwrite them
Do this here so we ensure the constants have been loaded correctly (e.g., error_reporting E_ALL, etc.)
Do this last so it can overwrite all the previous settings
Do type-lowering for a lowered type which is not already in the cache.
Do various optimizations based on the instruction we find.
Do we have a payload.
Do we have placeholders but no bound params
Do we know how to hoist the arguments of this call.
Do what a release would do before calling the deallocator: set the object in deallocating state, which means set the RC_DEALLOCATING_FLAG flag.
Do what the zend-collator code does
Doc says even find _could_ invalidate iterator, in pactice it should be very rare, so go with it now.
Document already exists, re-initialize it.
Documentation comments over the case are attached to the enum elements.
Does inline semantics-functions (except "availability"), but not global-init functions.
Does not attempt to reconnect nor throw any exceptions.
Does not do / any caching or drill down to implied protocols.
Does not have accessibility.
Does not inline functions with defined semantics.
Does not need m_valueCount, which is only useful with the unsupported types
Does not require an Operation.
Does not run any code.
Does not skip any whitespace before looking for the string.
Does not skip any whitespace.
Does this iteratively for all blacklist items
Does this iteratively for all connections
Does this value escape anywhere in the function.
Doesn't look like text at all
Doesn't look like this can happen, php_sockop_read overwrites the failure from recv() to return 0
Doing anything else is unsafe since by definition non-dead arguments will have SSA uses in the function.
Doing demangling just for this check is just wasteful.
Doing so means redundant work in the best case.
Doing this here safes us from doing it over the whole function in updateSSAAfterCloning because we have split all other critical edges earlier.
Dominance and post-dominance info for the current function
DominatingSuccBB: ...
Dominator information to be used.
Don't actually kill the exception's cleanup.
Don't actually poll if another thread is already in a command processing loop with the client.
Don't add implicit constructors for an invalid declaration
Don't add operands to worklist
Don't add redundant conformances here.
Don't add the EnumElementDecls unless the current context is allowed to have EnumElementDecls.
Don't add the super.init() call.
Don't add them again.
Don't add unreachable blocks to the region.
Don't allow a generic parameter to be equivalent to a concrete type, because then we don't actually have a parameter.
Don't allow cleanups to escape the conditional block.
Don't allow critical edges from PredBB to BB.
Don't allow two generic parameters to be equivalent, because then we don't actually have two parameters.
Don't analyze PHI nodes.
Don't append anything.
Don't apply module-shadowing rules to members of protocol types.
Don't apply this to single-expression-body closures.
Don't assume anything about globals which are imported from other modules.
Don't attempt recovery.
Don't attempt to determine function arguments in the PHP backtrace, as that might involve re-entering the VM.
Don't bind REPL metavariables to simple declrefs.
Don't bother adding external declarations to the function order.
Don't bother creating the line table here, because we can retrieve it from the repo later.
Don't bother if the declaration is invalid.
Don't bother if the replacement wouldn't make the string longer.
Don't bother projecting out the address-only element value only to ignore it.
Don't bother synthesizing the body if we've already finished type-checking.
Don't bother walking into this.
Don't bother with SetM on strings, because profile data shows it basically never happens.
Don't bother with string interpolations.
Don't bother with the CPU timeout if we're already handling a wall timeout.
Don't bother with the root directory
Don't cache type variable types.
Don't call wakeup when unserializing for the debugger, except for natively implemented classes.
Don't care about pointers to non-pointer followable types.
Don't cause a recursive type-check of the witness.
Don't change the type of a variable that we've been able to compute a type for.
Don't check for the existence of input files, since the user of the CompilerInvocation may wish to remap inputs to source buffers.
Don't close like the parent, 'cause that's what zend does
Don't compare methods vs.
Don't complain about a particular base class violating a forbidden template check.
Don't complain about accessors in protocols.
Don't complete optional operators on non-optional types.
Don't confuse Variant with uninit data
Don't consider comments to be this.
Don't consider this path if we reach a length that can't possibly be better than the best so far.
Don't consume 'throws', so we can emit a more useful diagnostic when parsing a function decl.
Don't consume cleanups on the base if this isn't final.
Don't continue looking through submodules of modules that have overlays.
Don't count costs in blocks which are dead after inlining.
Don't crash if the location is a DebugLoc.
Don't decent into control-dependent code.
Don't deduce IUO types.
Don't deduce autoclosure types or single-element, non-variadic tuples.
Don't descend into nested non-closure functions, or functions in the pseudo-main.
Don't diagnose this again.
Don't diagnose when we're injecting into
Don't do any work for the vastly most common case.
Don't do anything else if we don't have a parameter.
Don't do anything if an empty string is passed
Don't do anything if we are running the profiling function itself or if we haven't set up a profiler.
Don't do anything with I
Don't do it for two of the same in a row, though...
Don't do this for ARM, because it can lead to interpOne on the first SrcKey in a translation, which isn't allowed.
Don't emit a Fix-It here.
Don't emit a witness table if it is a declaration.
Don't emit a witness table that is available externally if we are emitting code for the JIT.
Don't emit anything yet, we emit it at the cleanup level of the switch statement.
Don't emit descriptors for properties without accessors.
Don't emit errors for unreachable code, or if we have already emitted a diagnostic.
Don't emit struct arrays for a collection initializers.
Don't emit the jump if it would be unreachable.
Don't emit the magic AnyObject conformance.
Don't emit the thunk if it already exists.
Don't emit the thunks if they already exist.
Don't emit type metadata records for types that can be found in the protocol conformance table as the runtime will search both tables when resolving a type by name.
Don't erase it in that case
Don't even try to load the bridging header if the Clang AST is in a bad state.
Don't even try to write if UTF-8 codec is unavailable
Don't expand type variables into the current namespace.
Don't expect to extract values once we've taken an address.
Don't expose objc properties for function types we can't bridge.
Don't externally emit systemlib because the external emitter can't handle that yet.
Don't finish a region with literal values or values that have a class related to the current context class.
Don't free malloc-ed allocations even if they're not reachable.
Don't free the iterator for the current loop however free any earlier pending iterators.
Don't free the iterator for the current loop.
Don't generate a descriptor for a property without any accessors.
Don't generate any code for the builtin.
Don't go beyond the definition.
Don't go overboard....
Don't handle any apply instructions that involve substitutions.
Don't handle captured AllocStacks.
Don't handle normal optional-related conversions here.
Don't hit more breakpoints while attempting to decide if we should stop at this breakpoint.
Don't hoist destroy_addr globally in transparent functions.
Don't implicitly turn non-optional results to optional if we're going to apply a foreign error convention that checks for nil results.
Don't include protocols, since they can't be initialized from the type name.
Don't inherit (non-convenience) factory initializers.
Don't inline from resumed functions.
Don't inline if we're retranslating due to a side-exit from an inlined call.
Don't inline into thunks, even transparent callees.
Don't inline the function, so it stays as a signal to the ARC passes.
Don't insert prefix operators in postfix position.
Don't introduce a default argument for setters with only a single parameter.
Don't introduce an empty options default arguments for setters.
Don't jump thread through a potential header - this can produce irreducible control flow.
Don't jumpthread function calls.
Don't jumpthread the same edge twice.
Don't keep external functions from stdlib and other modules.
Don't keep looking if the user didn't indicate it's an override.
Don't keep looking if this is already a simple name, or if there are no arguments.
Don't know how to duplicate these properly yet.
Don't know which values should be passed if there is more than one basic block argument.
Don't leave anything around in vm they could use.
Don't let any functions have linkage names if the object type doesn't have external linkage.
Don't let any members have linkage names if the object type doesn't have external linkage.
Don't let execution of the try body, or the previous catch body, fall into here.
Don't log "self" in a constructor
Don't log attributes of "self" in a constructor
Don't mark Swift decls as imported.
Don't mask "always true" warnings if NSError is cast to ErrorProtocol itself.
Don't match anything in a protocol.
Don't merge if the caller's density is significantly better than the density resulting from the merge.
Don't merge if the probability of getting to the callee from the caller is too low.
Don't move instructions that are sensitive to their location.
Don't need a module for SIMD types in C.
Don't need to check for overflows if ret is of primitive type because the depth does not change.
Don't need to dynamically calculate this offset.
Don't need to handle function arguments.
Don't need to recurse
Don't optimize callees that should not be optimized.
Don't optimize function that are marked as 'no.optimize'.
Don't optimize functions that are marked with the opt.never attribute.
Don't outdent if we weren't at the start of the line.
Don't override an existing method if this class provided an implementation
Don't override the linkage of a default witness table with an existing declaration.
Don't override the linkage of a witness table with an existing declaration.
Don't override the transparency or linkage of a function with an existing declaration.
Don't parse any function bodies except those that are transparent.
Don't pass a gid *and* a gname to this.
Don't pass a uid *and* a name to this.
Don't perform early attribute validation more than once.
Don't perform on-demand loading of root certificates on Linux
Don't pop the args yet---if the builtin throws at compile time (because it would raise a warning or something at runtime) we're going to leave the call alone.
Don't print a redundant 'final' if we are printing a 'static' decl.
Don't print empty curly braces while printing the module interface.
Don't print parentheses: they break the correspondence with the way we print the expression.
Don't print qualifiers for imported types.
Don't print qualifiers for types from the standard library.
Don't print submodules.
Don't print unsafe_unretained twice.
Don't proceed if free memory is too limited, no matter how big the cache is.
Don't produce any results in an enum element.
Don't produce these diagnostics for implicitly generated code.
Don't profile 86ctor, since its an implementation detail, and we dont guarantee to call it
Don't propagate the code completion bit from members: we cannot help code completion inside a member decl, and our callers cannot do anything about it either.
Don't prune redundant type information from the base name if there is a corresponding property (either singular or plural).
Don't put DefLabel in a block with a BeginCatch.
Don't put MAGIC constant - it likely points to a file within MSys tree
Don't put the cleanup in a state we can't restore it from.
Don't rebridge if the source is already some kind of NSError.
Don't record multiple dealloc instructions.
Don't record the fix until we successfully simplify the constraint.
Don't recur into child closures.
Don't recurse because there shouldn't be anything interesting in the children.
Don't recurse into default-value expressions.
Don't recurse into the base expression.
Don't recursively delete the pointer we're getting in.
Don't rename functions.
Don't repeatedly diagnose the same thing.
Don't replace markers that are still valid.
Don't reprocess the phi.
Don't resolve further absolute paths.
Don't resolve generic parameters.
Don't resolve the nested type if the parent is equal to the decl context we are looking in.
Don't search for a containing declaration if we don't have a source range.
Don't send onComplete() more than once (required because of the eom flag on sendImpl).
Don't set the time here because it will throw if it is bad
Don't show generic type parameters.
Don't show the "omitted" suffix.
Don't show the window if there is a splash screen (it will be made visible when the splash screen is hidden)
Don't signal an error since we recovered.
Don't skip it twice if there's an empty tuple.
Don't sleep too frequently.
Don't specialize Apply instructions that return the Self type.
Don't spend too much time with constant evaluation.
Don't split a method that looks like an action (with a "sender" of type AnyObject).
Don't split anything that starts with "set".
Don't stack promote any allocation inside a code region which ends up in a no-return block.
Don't start profiling new functions if the size of either main or prof is already above Eval.JitAMaxUsage.
Don't step into generated or builtin functions, keep looking.
Don't step out to generated or builtin functions, keep looking.
Don't stop emitting messages if we ever can't load a module.
Don't strip just "Error".
Don't strip type info off OtherConstructorDeclRefExpr, because CSGen doesn't know how to reconstruct it.
Don't support indexing within an interior address.
Don't synthesize attributes if there is already an availability annotation.
Don't throw here because GD might need to do its own cleanup.
Don't touch generated or invalid code.
Don't trace through too many jumps, unless we're inlining.
Don't truncate if we've decided we want to truncate the entire block.
Don't try this at home.
Don't try to check the behavior if we already encountered an error.
Don't try to convert +/- infinity
Don't try to do anything with an invalid location.
Don't try to fill the buffer, so this is an EOF.
Don't try to find their meta-metatype.
Don't try to load all members re-entrant-ly.
Don't try to load conformances re-entrant-ly.
Don't try to optimize incomplete aggregates.
Don't try to optimize the code in this case, and just let dead code elimination take care of it later.
Don't try to print invalid expressions, module exprs, or void expressions.
Don't try to serialize a CPP extension class which doesn't support serialization.
Don't try/catch - We want the exception to be passed along
Don't update f's m_cls if it doesn't have AttrClone set: we're cloning it so that we get a distinct set of static locals and a separate translation, not a different context class.
Don't use 'tvRef2' here so that we don't reuse the temp.
Don't use a method representation if we modified self.
Don't use any AST types in 'swift::sma'.
Don't use any immediates that don't fit in a byte.
Don't use handle zero
Don't use importFullName() here, we want to ignore the swift_name and swift_private attributes.
Don't use inode because it can easily change when you update the repository even though the file is supposed to be the same (same size/time).
Don't use knownValue if it's from a different block and we're currently in a catch trace, to avoid extending lifetimes too much.
Don't use memcpy because its probably one of the functions thats been mapped out.
Don't use usleep() here since it causes the CPU to halt which will generate meaningless results.
Don't visit CoerceExpr with an empty sub expression.
Don't visit types twice.
Don't walk into closures.
Don't walk into it though, it may not even be type checked yet.
Don't walk into nested decls.
Don't walk into non-single expression closure bodies, because ExprTypeSaver and TypeNullifier skip them too.
Don't walk into statements.
Don't walk into subscript expressions - to do so would risk factoring the index expression into edge contraction.
Don't walk into the LHS of the assignment, only the RHS.
Don't walk into the type if the decl is implicit, or if the type is implicit.
Don't walk the children for this node, it leads to multiple diagnostics because of how sema injects this node into the type checker.
Don't warn here, let the caller decide what to do if the func is nullptr.
Don't warn if the potential witness has been explicitly given less visibility than the conformance.
Don't warn if we're in UNSET state (ie between queries, etc)
Don't worry about commands that finished or weren't going to run.
Don't write anything if there are no generic params.
Done after the current pattern has been matched and before the corresponding action - sets up yytext.
Done by our system library
Done by the system library
Done, break out of for loop
Done, don't do redundant work on destruction.
DosQueryAppType will return FAPPTYP_DOS on a file ending with ".com" (other than an OS/2 exe or Win exe with this name).
Dot terminates it because of POSIX form  where dot precedes the codepage except for variant
Double check the prologue array now that we have the write lease in case another thread snuck in and set the prologue already.
Double quoted '"' string ends
Double quoted '"' string start
Double to fixed point
Doubles always stay doubles
Doug Claar: watch out for NaN in atan2 (2.0.5)
Drill down on a single stage of component.
Drill down on the operand until it's non-optional.
Drill down to make an i16*.
Drill down to make an i8*.
Drill down to the appropriate address in the base, then convert that to an integer.
Drill down to the concrete type on the right hand side.
Drill down to the member storage.
Drill down to the raw pointer using intrinsic knowledge of those types.
Drill down to the root normal conformance.
Drill in on the actual source value.
Drill into the object pointer.
Drill into the result type.
Drill through tuple shuffles, ignoring non-default-argument inouts.
Drop "With" if present after the "init".
Drop 'noreturn' and 'throws'.
Drop N parameters off of ParamInfos.
Drop a single newline character from the buffer.
Drop all connections.
Drop any pending signal since we're about to start processing interrupts again anyway.
Drop debug_value_addr of uninitialized void values.
Drop duplicates, except CC
Drop everything functions in this module reference.
Drop generic parameters and requirements from the method's context.
Drop one layer of parentheses.
Drop our references to anything we've deserialized.
Drop padding arguments.
Drop references to other blocks.
Drop requirements for parameters that have been constrained away to concrete types.
Drop requirements rooted in the applied generic parameters.
Drop the Self argument clause from the type.
Drop the argument labels.
Drop the arguments from the branch instructions by creating a new branch instruction and deleting the old one.
Drop the cleanup if we have one.
Drop the double quotes.
Drop the high bits indicating the # bytes of the result.
Drop the initial buffer/value parameter in accessors that have one.
Drop the initial weak retain of the object.
Drop the optionality of the result type of the given function type.
Drop the original self clause.
Drop the parameters from basic blocks and replace all uses with the passed in arguments.
Drop the reference count of functions referenced by this table.
Drop the reference count of witness functions referenced by this table.
Drop the reference to the current AFWH twice: - it is no longer being executed - it is no longer referenced by the parent
Drop the requirement and continue, but log an error so that we don't actually try to generate code.
Drop the value and don't bother with precise effects.
Drop top-level module name.
Drop trailing newline.
Drops all open connections
Drops the specified word, and returns the number of times it was dropped.
Duck out early if we have nothing to register.
Due to NaN only equality comparisons with doubles can be negated.
Due to complications associated with ArrayAccess, it is possible to acquire a reference as a side effect of vector operation processing.
Due to the matching pairs being in different basic blocks, the ARC Optimizer (which is currently local to one basic block does not handle it).
Due to the way the enum is layed out, we can model this by just adding 2.
Dummy class to get some code to run before main().
Dummy handler to log unimplemented nodes.
DummyTaskQueue implementation
Dump a reference to the given declaration.
Dump contents of Node
Dump human-readable bytecode.
Dump large annotations to disk.
Dump source and reset any / colorization before dying.
Dump the func guard in the TC before anything else.
Dump the generic signature into an ArchetypeBuilder that will figure out the minimal set of requirements.
Dumps the alias relations between all instructions of a function.
Dumps the escape information of all functions in the module.
Dumps the expansions of SILType accessed in the function.
Dumps the expansions of memory locations accessed in the function.
Dumps the memory behavior of instructions in a function.
Dumps the reductions of set of memory locations.
Dumps the side-effect information of all functions in the module.
Dup pushes a cell that is guaranteed to be not the last reference.
Duplicate method names override parent methods, unless the parent method is final and the class is not a __MockClass, in which case this class definitely would fatal if ever defined.
Duplicate subject string for repeated replacement
Duplicate the destination block into this one, rewriting uses of the BBArgs to use the branch arguments as we go.
Duplicating the testb/jcc from B4 into these allows branch fusion to greatly simplify everything, eliminating the phi and saving a test and jump.
Duplication is necessary due to xml api
During analysis of retains/releases within the loop body, the users in this set are assumed to cover all possible mutating operations on the array.
During analysis, information about functions or classes will be requested from the Index, which initially won't really know much, but will record a dependency.
During the cleanup phase, we can either use a landing pad to perform cleanup (with _Unwind_SetIP and _URC_INSTALL_CONTEXT), or we can do it here.
During the optimize pass, we may add phis for the values known to be in memory locations at particular control-flow-joins.
During the search, any other instruction that has a status flag result will reset the pattern matcher.
During this analysis pass, we have to assume everything could be live out, so we set allLive here.
During this first analysis pass, we need to pretend none of the stores is anticipated (because we don't yet know).
During this process, the blocks that are deleted get "merged" with their equivalent ones in the `region'.
During this re-entry anything can happen (e.g. a surprise flag check could cause a php signal handler to run arbitrary code).
During this traversal, each instruction that pops when going forward instead "pushes" information about whether that input will be required.
During type-checking, we may try to mapTypeInContext before AllArchetypes has been built, so fall back to the generic params.
Dyld will invoke this on our behalf for all images that have already been loaded.
Dynamic 'Self' in the result type of a function body.
Dynamic 'Self' is only permitted on methods.
Dynamic Self is equivalent to 'instancetype', which is treated as 'id' within the Objective-C type system.
Dynamic cast the object to the resulting class type.
Dynamic cast the source object to the class type to which the target value type is bridged.
Dynamic check for the enabling conditions of different kinds of / packing into a fixed-size buffer, and perform an operation at each / of them.
Dynamic dispatch to the initializer.
Dynamic is inherited.
Dynamic lookup can find functions, variables, and subscripts.
Dynamic lookup can only find class and protocol members, or extensions of classes.
Dynamic lookup cannot find results within a non-protocol generic context, because there is no sensible way to infer the generic arguments.
Dynamic member reference.
DynamicSelf has the same representation as its superclass type.
DynamicSelfType is actually local.
DynamicSelfType is also sugar as far as debug info is concerned.
DynamicSelfType preserves variance.
Dynamically cast a class instance to a Swift class type.
Dynamically cast a class metatype to a Swift class metatype.
Dynamically cast a class object to a Swift class type.
E.g. a Str might contain "" and be falsey, or an array or collection could be empty.
E.g. ordered equal FCMP_OEQ(Nan, Nan) is not true.
EAM   - It's worse than that.
EAM DEBUG - Newer versions of libfree2 make it easier by defining encodings
ELF executables have multiple section headers in arbitrary file locations and thus file(1) cannot determine it from easily.
ELF-based platforms).
END Facebook: json_utf8_loose
END WebServerResponse
EOF during the string throws.
EOS after separators only
ER is given a non-local successor edge that points at the successor index in L that points at S.
EUI-64 format: Four hexadecimal digits separated by dots.
Each ClassInfo has a table of public static properties with these entries.
Each DIE has a tag, which describes what kind of DIE it is, and a list of attributes.
Each Litstr entry becomes a static string.
Each SSATmp starts out as the canonical name for itself.
Each SrcKey in m_typePredictions, m_preConditions, m_byRefs, m_refPreds, and m_knownFuncs is within the bounds of the block.
Each Variable represents a Vreg in the Vunit we're performing register allocation on---including lifetime ranges, uses, def information, etc.
Each attribute has a type, which identifies what it is, and a value (the type of the value is implied by the attribute type).
Each block starts with an extra position number that corresponds to an imaginary "label" instruction that is not physically in the vasm IR.
Each block that has a use of the owning pointer has the value live-in unless it is the block with the alloc_box.
Each block that has a use of the value has the value live-in unless it is the block with the value.
Each block's rpo_id is the reverse-postorder number (entry starts at 0, and so-on).
Each chained call gets its own writeback scope.
Each const cast is necessary due to xml api
Each core filter has its own radius
Each corresponds / in order to a "hole" (a null value) in Args.
Each document has a SwiftDocumentSemanticInfo pointer so use that for the token.
Each double-round is a series of 2 rounds.
Each dst must not be previously defined.
Each entry is a pair of SILDeclRef and SILFunction.
Each entry is three values long, one value for each color component.
Each entry point for a DV funclet is the start of a basic block.
Each incoming value should be either from a block dominated by DomBB or it should be the value used in condition in DomBB
Each interval consists of a sorted list of disjoint, live ranges covering the positions where R must be in a physical register or spill slot.
Each invocation of the match method returns the next type to check, returning nullptr if there's no more types to check.
Each label is space-terminated.
Each label source source has an Offset where the jmp should be patched up is, and an Offset from which the jump delta should be computed.
Each local id referred to in the type prediction list is valid.
Each match in an ApplyExpr is evaluated for how close of a match it is.
Each month is divided into three decades (instead of weeks) of 10 days each.
Each object can only have one of these.
Each of the non-load instructions will each be checked to make sure that they are live-in or a full element store.
Each of the segments is passed as an argument to init(stringInterpolationSegment:).
Each of the type variables in the same equivalence class as this type should have this type variable as their representative.
Each of these loops can trigger the others to execute again, so repeat until /all/ of the pending lists are empty.
Each of these tests, if it succeeds, will leave the text converted into one-unichar-per-character Unicode in ubuf, and the number of characters converted in ulen.
Each pred has a forward link to the phi.
Each predecessor of a reachable block must be reachable (deleted blocks must not have out-edges to reachable blocks).
Each protocol gets a witness table.
Each protocol is a substitution / candidate.
Each quarter-round modifies 4 words.
Each real token shifted decrements this.
Each region is translated separately.
Each round is a set of 4 parallel quarter-rounds.
Each rule can delay the start of the year by one day, and since rule #1 can combine with one of the other rules, it can be delayed as much as two days.
Each rule has a diagram explaining the graph transformation it makes, the changes it makes to the underlying IR, the preconditions for the rule applying, and where it tries to reprocess.
Each runtime function definition in RuntimeFunctions.def should indicate if it requires a global referencing it.
Each semaphore actually consists of three semaphores allocated as a unit under the same key.
Each src must be defined by some other instruction, and each dst must be defined by the current instruction.
Each src must be defined earlier in the same block or in a dominator.
Each stack pointer address is followed by the size of the data in use in that stack, in bytes.
Each subexpression is a (key, value) tuple.
Each swift_once should synchronize on the token.
Each table contains data for 128-255 symbols from ASCII table.
Each time a stateIn for a block changes, we re-insert the block's rpo ID in incompleteQ.
Each tracked location has both a ValueInfo and a separately-tracked type.
Each type constant other than the last one in the chain must refer to a class or an interface.
Each value in the list is represented with 2 IDs: ValueID and ValueResultNumber.
Each value in the list is represented with 4 IDs: ValueID, ValueResultNumber, TypeID, TypeCategory.
Each will handle 12 bits of the S-box input.
Each witness marker starts a new substitution.
Eager execution in non-resumed mode is supported only by async functions.
Eagerly chop a skipped parameter off either end.
Eagerly coalesce adjacent conservative ranges.
Eagerly loading here could cause an unnecessary load+materialize in some cases, but it's not really important.
Eagerly mark us as not needing ratchets.
Eagerly pull records for nondependent witnesses into our cache.
Eagerly save VM regs and realign the native stack.
Earlier match kinds are better.
Early check to avoid scanning unrelated instructions.
Early exit if the mask has no effect.
Early exit if we're given the same two strings.
Early return if either sil block or sil index block does not exist.
Easter as the number of days after 21st March
Easy case -- no payload
Easy case: all pointer arguments are non-null.
Easy case: the types match.
Easy case: we want to pass exactly this value.
Easy checks: # of elements, trailing closures, element names.
Eat all of the catch clauses, so we don't trip over them in error recovery.
Eat an invalid token in an expression context.
Eat any UTF-8 BOM we find in the first 3 bytes
Eat attributes, if present.
Eat invalid tokens instead of allowing them to produce downstream errors.
Eat leading and trailing double quotes
Eat leading and trailing single quotes
Eat leading whitespace
Eat the code completion token because we handled it.
Eat trailing whitespace
Eberhard Mattes remarks Tue, 6 Apr 93: Moreover, it reports the type of the (new and very bug ridden) Win Emacs as "OS/2 executable".
Edge forward in the string...
Edge from inner to outer loop.
Edge from outer to inner loop.
Edit over the 'foo' decl.
Edit over the 'foo' reference.
EditLine wrapper that implements the user interface behavior for reading / user input to the REPL.
Effectively, we use array for Set initialization only when it is a static array for now.
Effects on locally allocated storage.
Either BEmpty or more than one bit set in rep.
Either a Metadata* or a NominalTypeDescriptor*.
Either add the breakpoint or store it as unmatched.
Either both must be 'static' or neither.
Either both types should be functions or neither should be.
Either both types should be metatypes or neither should be.
Either both types should be tuples or neither should be.
Either grab the passed filename or get the current one
Either node may be an NT::Phi, but the new node may not be a Phi.
Either null, or populated by initialization of ThreadInfo as an approximation of the highest address of the current thread's stack.
Either read annotation from file or print inline.
Either release the callee (which the apply would have done) or remove a retain that happens to be the immediately preceding instruction.
Either simplification didn't do anything, or we're using some other instruction's dst instead of our own.
Either the Swift declaration was from stdlib, or we imported the underlying decl of the typedef, or we imported the decl itself.
Either the storage itself was imported from Clang...
Either this platform has no support for parsing debug information, or the preprocessor symbol to enable actually building scanner isn't enabled.
Either this was a mutation that's going to fatal (property doesn't exist), or it's a private static or a protected static.
Either way the stack depth is below the calleeAR by numArgs, because we haven't run func prologue duties yet.
Either way we skip over it.
Either way, delete the instruction and move on.
Either way, it's helpful to know the situation that led us here, so this dumps the buffer up to this point to stdout and returns.
Either way, just bail out.
Either way, we have a live PHP return value in the return registers, which we need to put on the top of the evaluation stack.
Either way, we want to have the potential of successfully matching the type.
Either we did a decref, or the value was static.
Either we didn't have to wait, or we waited but no sleeper timed us out, so just handle the ETEs.
Elem dims with MOpFlags::Unset can change a base from a static array into a reference counted array.
Elements are always stored at offset 0.
Elements in the local cache must not be KindOfRef.
Elements of a noncounted array are uncounted
Elements outside of the range specified may not be / computed correctly.
Elements without payloads are numbered after the payload elts.
Elements without payloads are trivial.
Eliminate bodies of external functions which are not alive.
Eliminate local copies of either address-only or reference types.
Eliminate this AssertType if the src type won't relax.
Eliminate this AssertTypeOp if the source value is another assert that's good enough.
Eliminate trailing newline from ctime_r.
Eliminating the address-only copies eliminates a very expensive call to getGenericMetadata.
Eliminating the reference copies, avoids artificially bumping the refcount which could save a copy of all elements in a COW container.
Eliminating the trampoline can expose opportunities to improve the new block we branch to.
Else keep trying to find a space.
Else will try to reuse lookahead token after shifting the error token.
Else: calling non-static method
Elsewhere, we assume it's a type.
Embed command-line options.
Embed the bitcode for the llvm module.
Emission of l-value expressions and basic operations on them.
Emission of materializeForSet.
Emit 'self', then mark it uninitialized.
Emit Builtin.initialize by evaluating the operand directly into / the address.
Emit Fix-Its to correct the names.
Emit IR for the body of the instruction.
Emit Objective-C method descriptors for the property accessors of the given / property.
Emit SIL functions for all the members of the extension.
Emit SIL functions for all the members of the type.
Emit a "sentinel" location.
Emit a 'deallocateBuffer' operation.
Emit a 'destroyBuffer' operation.
Emit a 'get' into a temporary.
Emit a 'get' into the temporary.
Emit a 'projectBuffer' operation.
Emit a 'raw' allocation, which has no heap pointer and is / not guaranteed to be zero-initialized.
Emit a 'raw' deallocation, which has no heap pointer and is not / guaranteed to be zero-initialized.
Emit a ConcatN if we hit the limit, or if we hit the final Concat.
Emit a Protocol* value referencing an ObjC protocol.
Emit a boolean comparison against two constants.
Emit a branch to the return block and set the insert point there.
Emit a byte of padding.
Emit a call into the runtime to get the current enum payload tag.
Emit a call to a function with a loadWeak-like signature.
Emit a call to a function with a storeWeak-like signature.
Emit a call to a getter.
Emit a call to an addressor.
Emit a call to do a 'deallocateBuffer' operation.
Emit a call to do a 'destroy' operation.
Emit a call to do a 'destroyArray' operation.
Emit a call to do a 'destroyBuffer' operation.
Emit a call to do a 'projectBuffer' operation.
Emit a call to do an 'allocateBuffer' operation.
Emit a call to do an 'assignWithCopy' operation.
Emit a call to do an 'assignWithTake' operation.
Emit a call to do an 'initializeArrayWithCopy' operation.
Emit a call to do an 'initializeArrayWithTakeBackToFront' operation.
Emit a call to do an 'initializeArrayWithTakeFrontToBack' operation.
Emit a call to do an 'initializeBufferWithCopyOfBuffer' operation.
Emit a call to do an 'initializeBufferWithTakeOfBuffer' operation.
Emit a call to do an 'initializeWithCopy' operation.
Emit a call to do an 'initializeWithTake' operation.
Emit a call to swift_retain.
Emit a call to the 'destructiveInjectEnumTag' operation.
Emit a call to the 'destructiveProjectEnumData' operation.
Emit a call to the 'getEnumTag' operation.
Emit a call to the 'getExtraInhabitantIndex' operation.
Emit a call to the 'storeExtraInhabitant' operation.
Emit a call to the type metadata accessor for the given function.
Emit a cascading sequence of type checks blocks.
Emit a check for whether a non-native function call produced an / error.
Emit a check for whether the given object is a collection.
Emit a check that returns 1 if the running OS version is in / the specified version range and 0 otherwise.
Emit a check to verify the result before returning the optimistic result.
Emit a checked cast of a metatype.
Emit a checked cast of a scalar value.
Emit a checked cast to a protocol or protocol composition.
Emit a checked cast, starting with a value in memory.
Emit a checked unconditional downcast of a class value.
Emit a class existential container from a class instance value / as an explosion.
Emit a class of diagnostics that we only know how to generate when there is / exactly one candidate we know about.
Emit a collection check first.
Emit a collection downcast expression.
Emit a commuted version of the specified operation.
Emit a comparison against an object and string.
Emit a concrete implementation of materializeForSet.
Emit a conditional cast.
Emit a conformance error through conformsToProtocol.
Emit a copy of this value with independent ownership.
Emit a copy-like call to perform a ref-counting operation.
Emit a default witness table for a resilient protocol definition.
Emit a destroy on each CFG edge leading to a dead-in block.
Emit a destroy value for each captured closure argument.
Emit a destroy_addr in the taken block.
Emit a diagnostic and return true if this is an error condition we can / handle uniformly.
Emit a diagnostic for references to declarations that have been / marked as unavailable, either through "unavailable" or "obsoleted:".
Emit a diagnostic with a fixit hint for an invalid binary operator, showing / how to split it according to splitCandidate.
Emit a diagnostic, if necessary for a potentially unavailable accessor.
Emit a direct parameter that was passed under a C-based CC.
Emit a field l-value by applying the given offset to the given base.
Emit a fixit hint to rewrite to the correct do/catch construct.
Emit a function now, if it's externally usable or has been referenced in / the current TU, or remember how to emit it later if not.
Emit a global declaration.
Emit a global list, i.e. a global constant array holding all of a / list of values.
Emit a global variable storing an offset into the field offset vector within the class metadata.
Emit a global variable storing the constant field offset.
Emit a global variable.
Emit a heap allocation.
Emit a helper function for swift_once that performs in-place / initialization of the given nominal type.
Emit a instruction with invalid opcode 0x0
Emit a jump to the actual code.
Emit a load from the given metadata at a constant index.
Emit a load from the given metadata at a constant index. / / The load is marked invariant.
Emit a load of a selector.
Emit a materializeForSet callback that stores the value from the / result buffer back into the l-value.
Emit a materializeForSet callback to clean up after an addressor / with an owner result.
Emit a materializeForSet operation that calls a mutable addressor.
Emit a materializeForSet operation that projects storage, assuming / that no cleanups or callbacks are required.
Emit a materializeForSet operation that simply loads the l-value / into the result buffer.
Emit a member initialization for the members described in the / given pattern from the given source value.
Emit a metatype value for a known type.
Emit a new block that jumps to the specified location and runs necessary / cleanups based on its level.
Emit a note specifying where this came from, if we can find it.
Emit a partial application thunk for a function pointer applied to a partial / set of argument values.
Emit a polymorphic parameters clause, binding all the metadata necessary.
Emit a projection from an existential container to its concrete value / buffer with the type metadata for the contained value.
Emit a projection from an existential container to its concrete value / buffer.
Emit a protocol witness table for a conformance.
Emit a raw apply operation, performing no additional lowering of / either the arguments or the result.
Emit a reassignment sequence from an enum at one address to another.
Emit a reference to an ObjC class.
Emit a reference to the Swift metadata for an Objective-C class.
Emit a reference to the function to execute.
Emit a reference to the global token.
Emit a reference to the heap metadata for the target type.
Emit a reference to the metadata and figure out what cast function to use.
Emit a reference to the type metadata for a foreign type.
Emit a release of a live value with the given refcounting implementation.
Emit a release of a live value.
Emit a release_value instruction at the current location, attempting to / fold it locally into another nearby retain_value instruction.
Emit a retain of the loaded value, since we return it +1.
Emit a sequence of catch clauses.
Emit a service request stub of type `sr' at `start' in `cb'.
Emit a single protocol witness table reference.
Emit a smashable call that initially calls a recyclable service request stub.
Emit a specific diagnostic.
Emit a store of a live value to the given retaining variable.
Emit a store of a native error to the foreign-error slot.
Emit a string encoding the labels in the given tuple type.
Emit a struct_element_addr to get to the field, and then load the element as an rvalue.
Emit a temporary at the given address.
Emit a trap in the event a type does not match expected layout constraints.
Emit a type check and dispatch to each specialized function.
Emit a type metadata reference without using an accessor function.
Emit a unary call to perform a ref-counting operation.
Emit a value of a certain integer-like type.
Emit a value semantics operation for each nontrivial case of the enum.
Emit a value witness table for a fixed-layout generic type, or a null / placeholder if the value witness table is dependent on generic parameters.
Emit a value-witness table for the given type, which is assumed to / be non-dependent.
Emit a witness table for a protocol conformance.
Emit abbreviation for RECORD_CATEGORY.
Emit abbreviation for RECORD_DIAG.
Emit abbreviation for RECORD_SOURCE_RANGE.
Emit all intermediate operations, leaving the final operation up to our caller.
Emit all of the queue'd up errors.
Emit all of the trailing bytes.
Emit all the catch clauses, branching to the end destination if we fall out of one.
Emit all the shared case statements.
Emit an 'allocateBuffer' operation.
Emit an 'initializeBufferWithCopyOfBuffer' operation.
Emit an 'initializeBufferWithTakeOfBuffer' operation.
Emit an ExitPlaceholder at the beginning of the block if any of the optimizations that can benefit from it are enabled, and only if we're not inlining.
Emit an Objective-C method descriptor for the given method.
Emit an allocation of a class.
Emit an ambiguity diagnostic about the specified expression.
Emit an argument as an expanded tuple.
Emit an error message about an unbound generic parameter existing, and / emit notes referring to the target of a diagnostic, e.g., the function / or parameter being used.
Emit an error, but do not discard the attribute.
Emit an existential container initialization operation for a concrete type.
Emit an existential metatype container from a metatype value / as an explosion.
Emit an explosion of phi node(s) to receive the value.
Emit an expression in a forced context.
Emit an initialization sequence, initializing an enum at one address / with another at a different address.
Emit an initialize of a live value to the given retaining variable.
Emit an invocation of the specialized function.
Emit an lvalue that refers to the given property.
Emit an open-coded protocol-witness thunk for materializeForSet if / delegating to the standard implementation isn't good enough.
Emit an optional-to-optional transformation.
Emit an unconditional scalar cast that's known to succeed.
Emit any default argument generators.
Emit any default argument getter functions.
Emit any delayed definitions that were forced.
Emit any delayed diagnostics and return.
Emit any diagnostics that have been delayed.
Emit any lazy ObjC protocol definitions we require.
Emit any lazy definitions (of globals or functions or whatever / else) that we require.
Emit any lazy function definitions we require.
Emit any lazy type metadata we require.
Emit any rethrow with no cleanup since all args have been forwarded and nothing has been locally allocated or copied.
Emit any shared case blocks we generated.
Emit attributes (if any).
Emit byte codes to implement methods.
Emit call to _stdlib_isOSVersionAtLeast(major, minor, patch)
Emit code stashing the current return value in the "ret" unnamed local
Emit code to instantiate the new anonymous class, with the use variables as arguments.
Emit code to release/destroy temporaries.
Emit conditional checks for all successors in this region, in descending order of hotness.
Emit constants for the checked version range.
Emit dealloc_stack for all temporaries.
Emit debug info for a function argument or a local variable.
Emit debug info for the metadata.
Emit debug information for the argument.
Emit diagnostic with the Fix-It.
Emit diagnostics that say "no arguments".
Emit diagnostics, if necessary, for accesses to storage where / the accessor for the AccessContext is not available.
Emit early stack overflow check if necessary.
Emit either an 'apply' or a 'try_apply', with the error branch of / the 'try_apply' simply branching out of all cleanups and throwing.
Emit entry point arguments for a SILFunction with the Swift calling / convention.
Emit entry point arguments for the parameters of a C function, or the / method parameters of an ObjC method.
Emit external definitions used by this module.
Emit individual fail blocks so that we can map the failure back to a source line.
Emit initializers for static variables.
Emit into that address.
Emit into the buffer that 'let's produce for address-only values if we have it.
Emit into the buffer.
Emit into the context initialization if it's present and possible to split.
Emit it as global variable of the current module.
Emit lazy definitions that have to be emitted in this specific / IRGenModule.
Emit locationless intrinsic for variables that were optimized away.
Emit logic to print the specified expression value with the given / description of the pattern involved.
Emit matching release for owned self if we are moving the original call.
Emit nonlazily realized class references in a second magic section to make sure they are realized by the Objective-C runtime before any instances are allocated.
Emit notes for each uninitialized stored property in a designated / initializer.
Emit only declarations if it is a module with pre-specializations.
Emit other attributes.
Emit protocol conformances into a section we can recognize at runtime.
Emit protocol witness table pointers for the given protocol conformances, / passing each emitted witness table index into the given function body.
Emit raise-warnings for any missing arguments.
Emit records for the protocol requirements on the type.
Emit reffiness predictions.
Emit service request to smash address of SrcKey into 'addr'.
Emit signal that is catched by the PhantomJS callback, then wait until response.close() was called from the PhantomJS script.
Emit space for the dependent metaclass.
Emit static initializers.
Emit suggested Fix-Its for a reference with to an unavailable symbol / requiting the given OS version range.
Emit symbols for eliminated dead methods, which can still be referenced / from other modules.
Emit symbols for eliminated dead methods.
Emit testb when possible to enable more optimizations later on.
Emit the 'iterator' variable that we'll be using for iteration.
Emit the 'self'/'super' and '_cmd' arguments for an ObjC method dispatch.
Emit the C function pointer
Emit the ObjC class symbol to make the class visible to ObjC.
Emit the ObjC-compatible class symbol for a class.
Emit the Objective-C -dealloc entry point if it has something to do beyond messaging the superclass's -dealloc.
Emit the RECORD_DIAG record.
Emit the abbreviation for RECORD_DIAG_FLAG.
Emit the abbreviation for RECORD_FILENAME.
Emit the abbreviation for RECORD_FIXIT.
Emit the access function for this witness table.
Emit the ambiguity diagnostic.
Emit the application of 'self'.
Emit the appropriate call instruction sequence.
Emit the argument variables in calling convention order.
Emit the artificial error result argument.
Emit the base location operation.
Emit the base operand.
Emit the basic block that 'return' should branch to and insert it into / the current function.
Emit the bindjmp for the function body.
Emit the block copy helper for a block.
Emit the block header into a block storage slot.
Emit the block name if present.
Emit the body of a case statement at the current insertion point.
Emit the body of a lazy cache accessor.
Emit the body of a metadata accessor function for the given type.
Emit the body of the field type accessor later.
Emit the body, which is always evaluated the first time around.
Emit the boolean test and/or pattern bindings indicated by the specified / stmt condition.
Emit the call and produce the return value.
Emit the call target into the instruction stream.
Emit the call to super.init() right before exiting from the initializer.
Emit the capture argument variables.
Emit the case body into the predecessor's block.
Emit the catch clauses, but only if the body of the function actually throws.
Emit the class metadata.
Emit the closure body.
Emit the closure for the defer, along with its binding.
Emit the components of an Objective-C method descriptor for a / property getter method.
Emit the components of an Objective-C method descriptor for a / subscript getter method.
Emit the components of an Objective-C method descriptor: its selector, / type encoding, and IMP pointer.
Emit the condition bindings, branching to the bodyBB if they fail.
Emit the condition, along with the "then" part of the if properly guarded by the condition and a jump to ContBB.
Emit the conformance constraints.
Emit the constructor body.
Emit the continuation block and generate a PHI to produce the value.
Emit the continuation block.
Emit the create function for the template.
Emit the deallocating destructor.
Emit the debug info for the variable if any.
Emit the decision tree for a row containing only non-specializing / patterns.
Emit the default block if we needed one.
Emit the definition for the given SIL constant.
Emit the dependent rodata.
Emit the destroying destructor.
Emit the destructor body.
Emit the diagnostic on the unreachable block and emit the note on the branch responsible for the unreachable code.
Emit the diagnostic to bitcode.
Emit the direct path.
Emit the elements of a dependent value witness table template into a / vector.
Emit the elementwise arguments.
Emit the enum directly into the context if possible
Emit the epilog and post-matter.
Emit the epilog into its former predecessor.
Emit the epilog into the epilog bb.
Emit the epilogue for the function.
Emit the error block.
Emit the error destination.
Emit the existential value.
Emit the exploded constructor argument.
Emit the fail BB if we have one.
Emit the failure block.
Emit the failure destination, but only if actually used.
Emit the first level of call.
Emit the fixes computed as part of the solution, returning true if we were / able to emit an error message, or false if none of the fixits worked out.
Emit the forwarding stub function for a partial application.
Emit the fully-formed call.
Emit the function body for the type metadata accessor of a nominal type / that might require in-place initialization.
Emit the given expression as an r-value, then (if it is a tuple), combine / it together into a single ManagedValue.
Emit the guard branch, if it exists.
Emit the immediate into the instruction stream.
Emit the implicit 'self' argument.
Emit the implicit import of the swift standard library.
Emit the indirect path.
Emit the indirect result arguments, if any.
Emit the indirect return and arguments.
Emit the indirect return argument, if any.
Emit the indirect return slot.
Emit the initial value into the initialization.
Emit the initialization code into a function.
Emit the initialization for the pattern.
Emit the initialization sequence.
Emit the initialization.
Emit the initializers.
Emit the inner expression.
Emit the ivar destroyer, if needed.
Emit the ivar initializer, if needed.
Emit the jmp target into the instruction stream.
Emit the l-value, but don't perform an access.
Emit the layout values.
Emit the lazy initialization token for the initialization expression.
Emit the member initializers.
Emit the metadata for an ObjC category.
Emit the metadata for an ObjC protocol.
Emit the metatype argument.
Emit the metatype for the associated type.
Emit the module contents.
Emit the native deallocating destructor for -dealloc.
Emit the new method that handles the memoization
Emit the non-error destination.
Emit the operand into the temporary.
Emit the operation at a concrete packing kind.
Emit the other arguments, taking ownership of arguments if necessary.
Emit the polymorphic arguments.
Emit the private data (RO-data) associated with a class.
Emit the prolog for the non-self arguments.
Emit the prologue for the function.
Emit the protocol conformance list and return it.
Emit the protocol conformance to the behavior.
Emit the protocols the archetypes conform to.
Emit the raw application.
Emit the real definition.
Emit the record for the type itself.
Emit the recursive cases.
Emit the release immediately.
Emit the respondsToSelector: call.
Emit the result explosion.
Emit the result expression into the initialization.
Emit the result of this call to an explosion.
Emit the result of this call to memory.
Emit the retain and release that keeps the argument life across the callee using the closure.
Emit the retain that matches the captured argument by the partial_apply in the callee that is consumed by the partial_apply.
Emit the rethrow block.
Emit the rethrow logic.
Emit the runtime "once" call.
Emit the rvalue for self, allowing for guaranteed plus zero if we have a func.
Emit the same diagnostic, but include a fixit to move the attribute.
Emit the sequence that an assign instruction lowers to once we know / if it is an initialization or an assignment.
Emit the signal only if the encoding actually was changed
Emit the source metadata if we haven't yet.
Emit the specific class test.
Emit the specified declaration as an address if possible, / otherwise return null.
Emit the statement here.
Emit the sub-expression into the tuple initialization we just built.
Emit the sub-expression tuple and destructure it into elements.
Emit the subexpression.
Emit the subject value.
Emit the subtree in its own scope.
Emit the success block.
Emit the switch_value
Emit the throw destination.
Emit the thunk if we haven't yet.
Emit the trap instruction.
Emit the type and reffiness predictions for this region block.
Emit the type encoding for the property.
Emit the type layout by projecting it from a value witness table to / which we have linkage.
Emit the type layout by projecting it from dynamic type metadata.
Emit the type metadata or metadata template for a class.
Emit the type metadata or metadata template for a struct.
Emit the uncurried call.
Emit the unpin immediately.
Emit the unreachable block, if any.
Emit the unsubstituted result of this call into the given explosion.
Emit the unsubstituted result of this call to the given address.
Emit the value into the payload area.
Emit the value we're casting from.
Emit the witness table for the base conformance if it is shared.
Emit the witness table pointers.
Emit the witness table references required for the given type / substitution.
Emit the witness table right now if we used it.
Emit the witness thunk and add it to the table.
Emit them as constant 0.
Emit them here, since they won't appear anywhere else.
Emit them if present.
Emit this instruction into the prolog of the function so we can memoize/CSE it in VarLocs.
Emit top-level cleanups into the epilog block.
Emit type and reffiness prediction guards.
Emit type guards/preconditions.
Emit type metadata for the fields into the vector.
Emit type metadata for types that might not have explicit protocol conformances.
Emit type predictions.
Emit types and other global decls.
Emit unique side-effecting inline asm calls in order to eliminate the possibility that an LLVM optimization or code generation pass will merge these blocks back together again.
Emit warning message.
Emit witness tables for conformances of concrete types.
Emit witness tables for protocol conformances introduced by the extension.
Emits SIL instructions to create an enum value.
Emits a Make-style dependencies file.
Emits a Swift-style dependencies file.
Emits a call to a throwing function as defined by FuncRef, and passes the / specified Args.
Emits a type check in the current block.
Emits an error with a fixit for the case of unnecessary cast over a / OptionSet value.
Emits an invocation of / the specialized function.
Emits code to invoke the specified nonpolymorphic CalleeFunc using the / provided SILBuilder.
Emits the basic block for the "true" case and / returns the unemitted basic block for the "false" case.
Emits the test(s) that determine whether the enum contains a payload / or an empty case.
Emits the test(s) that determine whether the fixed-size enum contains a / payload or an empty case.
Emitting RATAs isn't supported here right now.
Emitting these may in turn force more definitions, so we have to take care to keep pumping the queues.
Empirical results indicate that a value in the 2-10 range is reasonable.
Empirically and surprisingly (20Jan2015): server mode: the contents of system map are     destructed on SIGTERM CLI    mode: the contents of system map are NOT destructed on SIGTERM
Empirically the best subbox size seems to be about 1/512th of the histogram (1/8th in each direction).
Empty cases of enums do not have a type
Empty entries also get their parent directories added.
Empty entries are basically AnyPatterns.
Empty is represented in bitset mode.
Empty nodes are useful for building graphs, since not every node type can have control flow edges, but it has no meaning later.
Empty option name or value
Empty payload addresses can be left undefined.
Empty result, don't add it.
Empty selector piece.
Empty store gives an empty sample.
Empty the output buffer --- called whenever buffer fills up.
Empty tuple queries return a completely "unknown" vector, since they don't care about any of the elements.
Empty values don't matter.
Empty whitespace-only input.
Empty/null string is meaningless
Emulate a ret to enterTCExit without actually doing one to avoid unbalancing the return stack buffer.
Enable address top-byte ignored in the ARM64 backend.
Enable backtracing through PHP frames (t9814472).
Enable checks for parsed files
Enable debugging if requested.
Enable disable controls per-page.
Enable implicit module maps (this option is implied by "-fmodules").
Enable jemalloc thread-local heap dumps.
Enable or disable ObjC interop appropriately for the platform
Enable profiling and tracing if we need to
Enables the breakpoint at the given stack level.
Enables the hotfixing of a bug that occurred with D1797805 where per request user settings (like upload_max_filesize) were not able to be accessed on a server request any longer.
Enabling the token table.
Enabling verbose error messages.
Encode Unicode string as UTF-8, returning pointer to character after end of string, or NULL if an invalid character is found.
Encode Y,U,V and write data to file
Encode the context data for lazily-loaded conformances.
Encode the filenames first.
Encode the fixity as a filter on the func decls, to distinguish prefix and postfix operators.
Encode two replacement characters, so the expected output length lines up.
Encode type qualifier, 'in', 'inout', etc.
Encodes input (uint32_t) into output (unsigned char).
Encodes input (uint64) into output (unsigned char).
Encodes input (unsigned int) into output (unsigned char).
Encoding -- determine the character encoding of a text file.
Encoding is 0x110aaaaa 10bbbbbb
Encoding is 0x1110aaaa 10bbbbbb 10cccccc
Encoding is 0x11110aaa 10bbbbbb 10cccccc 10dddddd
Encoding to be used for the concatenated string literal.
Encoding/Decoding of WebP still image compression format.
Encountered a finally block, jump and free any pending iterators
Encountered a try block, need to run finally.
Encountered another try block, jump to its finally and free iterators on the way.
Encountering * completes/commits a component
Encrypt one block, BF_N is hardcoded here.
Encrypt the key with itself.
End HHVM internal memory buckets
End Of Image (end of datastream)
End anonymous namespace.
End llvm namespace / Check to see if AvailableVals has an entry for the specified BB and if so, / return it.
End of a slash-star comment, so whitespace.
End of option value (if EOF is reached before EOL)
End of replacement string
End of section or an option offset
End of source string or the source string contains an ill-formed subsequence at the end.
End of the input string
End of the last delimiter match + 1
End of unrolling passes.
End recursion if we dont need deeper levels or we dont have any deeper levels
End recursion if we found a concrete associated type.
End script execution: delete the phantom singleton and set execution return value
End the initial writeback scope.
End top of the stack.
End with xdebug_stop_trace()
EndBlock means the end of this SILFunction.
EndBlock means the end of this VTable.
EndBlock means the end of this WitnessTable.
Ended on non-(space/NUL)
Ends a ripemd128 message-digest operation, writing the message digest and zeroizing the context.
Ends a ripemd160 message-digest operation, writing the message digest and zeroizing the context.
Ends a ripemd256 message-digest operation, writing the message digest and zeroizing the context.
Ends a ripemd320 message-digest operation, writing the message digest and zeroizing the context.
Ends an MD4 message-digest operation, writing the the message digest and zeroizing the context.
Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context.
Ends an SHA1 message-digest operation, writing the the message digest and zeroizing the context.
Ends an SHA256 message-digest operation, writing the the message digest and zeroizing the context.
Ends an SHA384 message-digest operation, writing the the message digest and zeroizing the context.
Engine exception classes
Ennumerators and lookups
Enqueue additional tasks if we have additional tasks, we aren't already at the parallel limit, and no earlier subtasks have failed.
Enregister the memoryRef so it can be used with an offset by the cmp instruction
Ensure consistency between filenames
Ensure consistent state for vmfp
Ensure consistent state for vmfp and vmpc
Ensure every number was visited.
Ensure no one calls into the function
Ensure path ends with '/'.
Ensure that Objective-C does layout starting from the right offset.
Ensure that all of the requirements of the protocol have been satisfied.
Ensure that graph invariance 4) is kept.
Ensure that it has the full / complement of accessors.
Ensure that none of the signals that indicate a fatal CPU exception are blocked.
Ensure that profiling is enabled in jemalloc.
Ensure that the VM stack is completely empty (vmfp() should be null) and that we're not in a nested VM (reentrancy)
Ensure that the anchor translation is a known size so that it can be reclaimed when the function is freed
Ensure that the entry isn't better than the fulfillment.
Ensure that the frame is still dead for the purposes of memory-effects
Ensure that the function is visible for debugging.
Ensure that the result cannot change in future.
Ensure that the type of our TypeLoc is fully resolved.
Ensure that this marker is SIZ (as is mandated by the standard)
Ensure that vmfp() is valid
Ensure that vmfp() points to the only frame on the call stack.
Ensure that void return types original from a tuple instruction.
Ensure that we don't get tok::code_complete here.
Ensure that we don't have multiple threads racing to do this.
Ensure that we restore the parser state at exit.
Ensure that weak captures are in a separate scope.
Ensure the entry is acceptable.
Ensure the flow filter is fresh
Ensure the forced restart package variable is null when it is an empty string.
Ensure the location for the history file exists
Ensure the output expression is up to date.
Ensure the replacement dominates the original call site.
Ensure the result is null-terminated after the strcpy
Ensure the variable is at least forward-declared.
Ensure there are no other uses of alloc_box than the project_box and retains, releases.
Ensure this command is valid in the given server status
Ensure we don't convert an array to a void pointer this way.
Ensure we have at least head and body.
Ensure we have no residuals left over from the HDF run.
Ensure we interpret all code at the given offsets.
Ensure we interpret an entire function when the debugger is attached.
Ensure we're actually connected.
Ensures that both string literals to be concatenated use the same / UTF encoding.
Enter VM by calling action(), which invokes a function or resumes an async function.
Enter a break/continue scope.
Enter a cleanup for the +1 result.
Enter a cleanup to deallocate the callback storage.
Enter a cleanup to deallocate the given location.
Enter a cleanup to delete all the IGMs and their associated LLVMContexts that have been associated with the IRGenerator.
Enter a cleanup to destroy the value there.
Enter a cleanup to emit a DeinitExistentialAddr or DeinitExistentialBox / of the specified value.
Enter a cleanups scope.
Enter a fresh default-argument context with a meaningless parent.
Enter a new generic context if this type is generic.
Enter a new scope for the type witnesses hash table.
Enter a scope for any bound pattern variables.
Enter a start condition.
Enter an initializer context if necessary.
Enter offset lookup state
Enter section data lookup state
Enter the arguments for the function into a new function-body scope.
Enter the block for a non-note diagnostic immediately, rather than waiting for beginDiagnostic, in case associated notes are emitted before we get there.
Enter the context of the closure when type-checking the body.
Enter the continuation block and add the PHI if required.
Enter the continuation block.
Enter the line into the line history.
Enter the normal path.
Entering a recursive interpolated expression
Entering an exception handler may take us someplace we weren't expecting.
Entries can be added or removed from either list during sweeping.
Entries in the ClassInfo method table need to track some additional information.
Entries will be sorted by instruction index, area then machine code pc.
Entry block can't have predecessors.
Entry block starts with DefFP.
Entry point for dead store elimination.
Entry point to redundant load elimination.
Entry points using a standard C calling convention or not using the new calling convention do not need to have global symbols referring to their implementations.
Entry points using the new calling convention require global symbols referring to their implementations.
Enum case constructor call.
Enum case constructor references are open-coded.
Enum constants that are not imported as members should be considered private if the parent enum is marked private.
Enum constructors are essentially the same as thunks, they are emitted by need and have shared linkage.
Enum element constructors are always emitted by need, so don't need delayed emission.
Enum elements are printed as part of the EnumCaseDecl, unless they were imported without source info.
Enum elements require names.
Enum global wrappers which are not disabled
Enum payloads are always stored at the abstraction level of the unsubstituted payload type.
Enum request local wrappers
Enum type lowering needs to derive implementations of the above for an enum type.
Enum values that while merging we found conflicting values for.
Enumerate all locations accessed by the loads or stores.
Enumerate conformance requirements.
Enumerate each immediate child expression of this node, invoking the / specific functor on it.
Enumerate members of archetype's requirements.
Enumerate the conformance requirements.
Enumerate the supertypes of each of the types we tried.
Enumerates actions that should be taken by the enterVM loop after unwinding an exception.
Enumerates the optimization kinds that we do in SIL.
Enumeration constants may have common prefixes stripped.
Enumerations with a raw type conform to RawRepresentable.
Enumerators are always stored within the enumeration, despite having the translation unit as their redeclaration context.
Enumerators can end up within their enclosing enum or in the global scope, depending how their enclosing enumeration is imported.
Enums are mapped to Swift enums, Options to Swift option sets, both of which attempt prefix-stripping.
Enums are mapped to Swift enums, Options to Swift option sets.
Enums can only have computed properties.
Enums depend on their enumerators.
Enums do not alias non-enums.
Enums with raw types can implicitly derive their RawRepresentable conformance.
Enums without associated values can implicitly derive Equatable and Hashable conformance.
Env vars defined in the hdf file go in first
Environment for the whole optimization pass.
Environment variable that can be used for certain settings
Environment variables the idekey is grabbed from
Equality and subtyping have fairly strict requirements on tuple matching, requiring element names to either match up or be disjoint.
Equate it to the other type in the constraint.
Equivalent to Plan 9 chartorune().
Equivalent types are always ABI-compatible.
Erase a function from the module.
Erase a global SIL variable from the module.
Erase all of the reference counting instructions (in reverse order to have no dangling uses).
Erase an expression tree's open existentials after a re-typecheck operation.
Erase any invalid or stub declarations.
Erase any overridden declarations
Erase any solutions with more value witnesses in protocol extensions than the best.
Erase meta-data about these regions of the TC
Erase our cached TypeLowering objects and associated mappings for dependent types.
Erase the 'live-range'
Erase the end of various lists.
Erase the instruction that stores into the box and the release that releases the box, and finally, release the box.
Erase the instructions recursively, this way, we get rid of pass dependence on DCE.
Erase the local conflicts from the list of conflicts.
Erase the local unsatisfied requirements from the list.
Erase the member type entry from the
Erase the rethrow block.
Erase the uses, we can have instructions that become dead because of the removal of these instructions, leave to DCE to cleanup.
Erase this parameter from the list of unfulfilled named parameters, so we don't try to fulfill it again.
Erase those submodules that are not missing.
Erasure to a Swift protocol always captures the type metadata from its subexpression.
Erasure to an ObjC existential or between metatypes doesn't require type metadata.
Err on the side of caution and don't automatically add bang, which may lead to crashes.
Error already populated
Error case: erroneous extension.
Error for values that don't make sense if there's a clear definition of the possible values (as there is for _runtime).
Error is less than half an ulp -- check for special case of mantissa a power of two.
Error result types must have pointer-like representation.
Error results are last.
Error tokens are diagnosed by the lexer, so there is no reason to emit another diagnostic.
Error, because the label is crossing a finally
Error, try to be as helpful as possible: (a range ending/starting with '.' won't be captured here)
Error-temporary emission may need writeback.
ErrorProtocol always has a single-ObjC-refcounted representation.
ErrorProtocol has a special runtime representation.
ErrorProtocol uses its own RC entry points.
ErrorStruct is currently opaque to the compiler.
Errors and Logging Configuration Options
Errors are propagated via 'nil' returns.
Escape analysis can eliminate this copy if it's unneeded during optimization.
Escape analysis uses the connection graph to check if the pointers may point to the same content.
Escape double quoted string contents
Essentially the same as what QSslSocket::setCiphers(QString) does.
Essentially what we now have is a set of tokens each consisting of a hexadecimal number followed by a separator character.
Essentially, an entry a is less than an entry b iff:  - a starts before b - a starts at the same place, but encloses b entirely - a has the same extents as b, but is a parent of b
Establish a default generic type resolver.
Establish the cleanup.
Establish the new context.
Estimate the metonic cycle number.
Estimation of page cache that are readily evictable without causing big memory pressure.
Estimation of the memory needed till the next check point.
Eval PHP code to get default value.
Eval stack depth should be the same at merge points.
Eval stack use information.
Eval stack:  During backward traversal of a block, we maintain a "backwards" stack, indicating which eval stack slots are going to be required in the future or not.
Evaled units have a footprint in the TC and translation metadata.
Evaluate a Boolean literal.
Evaluate a ParenExpr.
Evaluate a guard expression and, if it returns false, branch to / the given destination.
Evaluate a named reference expression.
Evaluate a subset of expression types suitable for build configuration conditional expressions.
Evaluate a target config call expression.
Evaluate and discard the side effect if present.
Evaluate arguments and begin any inout formal accesses.
Evaluate it directly into the enum.
Evaluate literal integers.
Evaluate number, be it int, rational, or float from directory.
Evaluate script with JSC
Evaluate the AsyncIterator object and store it into unnamed local.
Evaluate the condition as an i1 value (guaranteed by Sema).
Evaluate the condition with the false edge leading directly to the continuation block.
Evaluate the condition, the body, and a branch back to LoopBB when the condition is true.
Evaluate the condition, to validate it.
Evaluate the condition.
Evaluate the expression as an lvalue or rvalue, discarding the result.
Evaluate the getter into the result buffer.
Evaluate the reference into memory.
Evaluate the subject every time.
Evaluate the subject once and stash it in a local
Evaluates the breakpoint's conditional clause if present.
Evaluates the given unit at the given depth and returns the result or throws and error on failure.
Even builtin swift types usually come boxed in a struct.
Even for object types with different keys, if the underlying object type is the "same" (according to the linkage rules), the same Object representation will be returned.
Even if SIL has a direct return, the IR-level calling convention may require an indirect return.
Even if a func has AttrNoOverride, if it has static locals it is cloned into subclasses (to give them different copies of the static locals), so we need to skip this.
Even if any illegal encoding is detected the result may contain a list of parsed encodings.
Even if at runtime this option will be off, it's fine to compile as if it were on: we just won't fold the calls that could've raised this error.
Even if it does, the miscompile might only occur on the production build, but not on a testing build (such as because of different optimization settings).
Even if the alloc_ref did not allocate the object on the stack, we don't have to deallocate it, because it is deallocated in the final release.
Even if the array is empty, for PHP5 conformity we need call compact() because it has side-effects that are important
Even if the call has the destroys_locals flag this is the case---after it destroys the locals the new value will have a fully synchronized reference count.
Even if the complete graph of the function did change, it does not mean that the summary graph will change.
Even if the func contains NativeImpl we may have broken the trace before we hit it.
Even if the instruction does not write memory it could e.g. return the address of global memory.
Even if the instruction does not write memory we conservatively set all operands to escaping, because they may "escape" to the result value in an unspecified way.
Even if the pre-specialization exists already, try to preserve it if it is whitelisted.
Even if the type does not really need a register (e.g., InitNull), a Vreg is still allocated in assignRegs(), so the following assertion holds.
Even if the whole file is valid UTF-8 sequences, still reject it if it uses weird control characters.
Even if there were no source files, we should still record known protocols.
Even if they are apply_inst, it is safe to do so, because they can only be applies of functions annotated as string.utf16 or string.utf16.
Even if we aren't inlining this can happen, because before doing the CallBuiltin we set the marker stack offset to only include the passed-through-stack args.
Even if we couldn't find a value property, still make up a stub getter and setter, so that subsequent diagnostics make sense for a computed-ish property.
Even if we diagnose, we go ahead and form an identifier token, in part to ensure that the basic behavior of the lexer is independent of language mode.
Even if we don't have a 'self', if we have an error result, we should have a placeholder argument here.
Even if we have alias rules, if we're in repo mode, they will be applied during the trait flattening step, and we won't populate traitAliases() on the Class.
Even if we're processing the top-level module like any other, we may still want to include non-exported modules.
Even if you're manually creating catches we require this just to make sure you're not doing it on accident.
Even that has never been tested according to DB.
Even then, only find complete object initializers.
Even though at the SIL level we have "one" return function, we can have multiple exits provided by no-return functions.
Even though connections may be open for reading, they will not be executed in the VM
Even though there are no sessions, memory is allocated to perform INI setting bindings when the thread is initialized.
Even though we always return false in ValidMArrayIter, this function may still be called because MArrayIters are constructed in an invalid position, and then advanced to the first element.
Even though we didn't emit the function now, update the lastEmittedFunction so that we preserve the original ordering that the symbols would have been emitted in.
Even though, LSLocations are canonicalized, we still need to consult alias analysis to determine whether 2 LSLocations are disjointed.
Even when newIds.isAny(), we still know it won't alias locals in other frames, so keep the specialization tag.
Even when they're annotations.
Events are duplicated so we can use the non-generic perf events.
Eventually / they will all be removed after all the new ones are generated.
Eventually the all the projection tree nodes will be freed when the BPA allocator is free.
Eventually this block can be removed.
Eventually this should have additional capabilities like stripping globals, vtables, etc.
Eventually we might be able to use SILLocation (when it contains info about inlined call chains).
Eventually we might have an attribute here or something based on the deployment target.
Eventually we'd like to emit an inline cache, which should be faster than calling out of line.
Eventually we'll allow optionals to carry abstraction.
Eventually, this will have its own helper routine.
Every AttrUnique non-trait class has a unique ClassInfo object, or no ClassInfo object in the case that instantiating it would've fataled.
Every FPI region must be contained within one section, either the primary body or one fault funclet
Every FuncFamily is non-empty and contain functions with the same name.
Every SSATmp that may have a reference counted type is assigned to a must-alias-set.
Every back edge must be a retreating edge, which means we must've already visited its target when iterating in RPO.
Every bound generic type we care about gets mapped to a particular construct in Objective-C we care about.
Every case after this point requires knowing things about knownCls.
Every closure should have a unique allocation site, but we may see it multiple times in a given round of analyzing this function.
Every declaration should come from a module, so we should not see the TranslationUnit DeclContext here.
Every indexed type is associated a layout (hence a scanner), but a given type can be part of multiple indexed types.
Every indexed type receives a unique type-index and will have a scanner generated for it.
Every instruction must have a catch block attached to it if and only if it has the MayRaiseError flag.
Every instruction's BCMarker must point to a valid bytecode instruction.
Every piece of data in the dependent data appears to be related to Objective-C information.
Every reachable use of a particular inlined fp in the unit.
Every return site should call through here.
Every time the BBSetIn of a basic block changes, the optimization is rerun on its predecessors.
Every time the BBSetOut of a basic block changes, the optimization is rerun on its successors.
Every time the BBWriteSetIn of a basic block changes, the optimization is rerun on its predecessors.
Every time the ForwardSetOut of a basic block changes, the optimization is rerun on its successors.
Every use position must be inside one of the ranges, or exactly at the end of the last range.
Everything before is assumed to be the command string
Everything contains AEmpty, but AEmpty can't be anything.
Everything else cares about the (rvalue) argument.
Everything else gets accessors.
Everything else goes into its redeclaration context.
Everything else is a method.
Everything else is just a pure type-system boxing operation.
Everything else is just an entity.
Everything else is non-exhaustive.
Everything else is opaque.
Everything else is trivial.
Everything else requires a definition.
Everything else requires a shared accessor function.
Everything else requires accessors.
Everything else returns ().
Everything else should be unreachable here.
Everything else should use the l-value logic.
Everything else stays the same.
Everything else we see here ought to be a translation of a builtin.
Everything externally visible is considered used in Swift.
Everything from here on is some kind of pointer type.
Everything is a subclass of AUnknown and intersects AUnknown.
Everything is a subtype of Top, couldBe Top, and the union of Top with anything is Top.
Everything is defined in the naming environment here.
Everything is handled by the dependencies.
Everything that needs to be on the stack gets spilled now.
Everything uses the new instruction now.
Everything will get a conservative scanner by default if someone actually tries to use the scanners at runtime.
Exact equality is fine.
Exact match is always okay.
Exact matches are even better.
Exact prefix matches are the best.
Examine the log file name specifier for strftime conversion specifiers and determine the period between log files.
Except for the above case, we should not be making a value less optional.
Except in specific whitelisted cases for Foundation/Swift standard library compatibility, an _ObjectiveCBridgeable conformance must appear in the same module as the definition of the conforming type.
Except it's not really an invariant, because argument emission likes to lie sometimes.
Except see the bug regarding a race condition php_sysvsem_get().
Exception breakpoints just add the type
Exception for 'failure' which should be a callable.
Exception handling and the other opcodes (ex. BoxR) already do the right thing.
Exception::getMessage method name.
Exceptions thrown by g++-generated code will have the class "GNUCC++" packed into a 64-bit int.
Exceptions will be thrown for any non-object.
Exclude "main", because it should naturally be used, and because adding it to llvm.used leaves a dangling use when the REPL attempts to discard intermediate mains.
Exclude address types.
Exclude rarely-used stuff from Windows headers
ExcludeNodeAtLocation, / Pass all nodes up to and including the location.
Excluding AllocStackInst (which is handled above).
Execute JS code in the context of the document
Execute each operation.
Execute the fill ops.
Execute the interactive command loop for the debugger client.
Execute the regular expression.
Execute the subcommand.
Execute this source line.
Executed by m_mainThread to run the command-line debugger.
Execution has been interrupted, so go ahead and give the user the prompt back.
Execution will resume at this function later after the opcode.
ExecutionContext and the TC may retain references to Class'es, so it is possible for Class'es to outlive their Unit.
ExecutionContext::handleError is dirty-reg safe, but evaluate other functions that you might need here.
Exif Attribute Information
Existential Metatypes
Existential metatypes always use metatype representation.
Existential metatypes are trivial.
Existential metatypes do not contain type parameters.
Existential types don't need to conform, i.e., they only need to contain the protocol.
Existential types handled below.
Existing connections, so find the last one
Existing step outs should be cleaned up before making new ones.
Exists purely to mirror PHP5's invalid arg logic for this function
Exit blocks are all associated with FPs that are defined on the main trace as part of a DefInlineFP/InlineReturn pair (mainFPs)
Exit heads are non-main-blocks with at least one main-block predecessor.
Exit is a very special snowflake.
Exit the scope introduced for the generic parameters.
Exit to interpreter if resume address is not known.
Exit-blocks from the lifetime region.
ExitException is fine, no need to show a warning.
ExnNode ids are contiguous.
Expand R to 48 bits (simulate the E-box).
Expand a zlib stream into a String  Starts with an optimistically sized output string of input size or maxlen, whichever is less.
Expand all of the direct and indirect result types.
Expand and collect the newly created forwardable values.
Expand certain kinds of type within the entity context.
Expand if the pattern was a tuple.
Expand inherited conformances so we have the complete set of conformances.
Expand inherited conformances.
Expand replacement range for trailing closure.
Expand the abstract parameters of a SIL function type into the / physical parameters of an LLVM function type.
Expand the direct result.
Expand the given LSLocation and Val into individual fields and process them as separate reads.
Expand the given Mem into individual fields and add them to the locationvault.
Expand the given Mem into individual fields and process them as separate reads.
Expand the given Mem into individual fields and process them as separate writes.
Expand the given location and val into individual fields and process them as separate writes.
Expand the indirect results.
Expand the nassign buffer.
Expand the packed bits to the destination type.
Expand the requirements of the given abstract calling convention / into a "physical" calling convention.
Expand the result and parameter types of a SIL function into the / physical parameter types of an LLVM function and return the result / type.
Expand the result and parameter types to the appropriate LLVM IR / types for C and Objective-C signatures.
Expand this node into an llvm::coverage::Counter.
Expanded data destination object for stdio output
Expanded data source object for gdIOCtx input
Expect `c' after possible whitespace/comments.
Expect a " " separator to follow
Expect a check_subscript call or the empty dependence.
Expect an alloc_stack initialization.
Expect intrinsics are 'free' instructions.
Expect the attribute terminator.
Expect the option value's first character to follow.
Expect to display as their stringified classname.
ExpectMultipleResults
Expected types of the code completion expression.
Expensive, but the only way that produces an acceptable result: mix down to a palette based temporary image.
Expiration Date, if provided, giving priority to "expires" over "expiry"
Explicit cases that have explicit pointer name
Explicit closures are exempt from this rule.
Explicit closures start their own sequence.
Explicit port param overrides the implicit one from host.
Explicitly add Transfer-Encoding: chunked here.
Explicitly disabled inlining.
Explicitly ignored field types.
Explicitly listing these constants is an unfortunate compromise for making the database file much more compact.
Explicitly pass the target to the linker
Explicitly set the linker target to "androideabi", as opposed to the llvm::Triple representation of "armv7-none-linux-android".
Explode a copy_addr instruction of a loadable type into lower level / operations like loads, stores, retains, releases, retain_value, etc.
Explode a managed tuple into a bunch of managed elements.
Explode as an r-value.
Explode out multi-index subscripts to find the best match.
Explode the direct results.
Explode the inner direct results.
Explode the tuple into individual managed values.
Export for the admin server.
Export getMap() so we can workaround constructing ReadableNativeMap
Expose TypeChecker's handling of GenericParamList to SIL parsing.
Exposed API, mainly static wrapper methods.
ExprCleanser - This class is used by typeCheckExpression to ensure that in / no situation will an expr node be left with a dangling type variable stuck / to it.
Express the relationship with a new constraint.
Expression Parsing and AST Building
Expression type checking listener for conditions.
Expressions are always-refutable wildcards.
Expressions can't begin with a closure literal at statement position.
Expressions cannot affect a function's signature.
Expressions that wrap lvalues
Expressions, patterns and decls cannot contain fallthrough statements, so there is no reason to walk into them.
Extend current path to include next, then loop.
Extend the back of the range to the location of the default argument, or the typeloc if they are valid.
Extend the lifetime of 'Arg' to the lifetime of the closure.
Extend the lifetime of a captured argument to cover the callee.
Extend the logical size if we seek beyond EOF.
Extend the stack our own way.
Extend to include the extra tag bits, which are always significant.
Extend word sign Lowering for cmpqi removed, since movl was emitted, then the empty will always return false
Extended Linear Scan register allocator over vasm virtual registers (Vregs).
Extended grapheme cluster segmentation algorithm as described in Unicode Standard Annex #29.
Extended result values.
Extension methods don't get vtable entries.
Extension shutdown could have re-initialized some request locals
Extensions always exist in the same group with the nominal.
Extensions are self-registering, so we bring in the SO then throw away its handle.
Extensions could have shutdown handlers
Extensions of generic ObjC functions can't use generic parameters from their context.
Extents of the inner elements.
External aggregate statistics
External code references continue to point to the same address as before relocation.
ExternalFunctionDefinitionsElimination pass does not take functions / reachable via vtables and witness_tables into account when computing / a function liveness information.
Extra characters at the end will be / tolerated (and included as a Suffix node as a child of the / Global).
Extra inhabitant information can be obtained at runtime through the value witness table, so there are no layout differences between a generic enum type and a substituted type.
Extra inhabitants of the various scalar existential containers.
Extra verbose when with __TEST
Extract 'self' if it needs to be passed as the context parameter.
Extract LSLocations from LoadInst.
Extract LSLocations from StoreInst.
Extract a Bool from the resulting expression.
Extract a member from a struct/tuple/enum.
Extract and switch on the tag bits.
Extract application argument.
Extract application function.
Extract byte convert testbi to testqi or ldimmq + testq by testqi's lowering
Extract elements, cast each of them, create a new tuple.
Extract from the same struct as the first extract_inst.
Extract locations from SIL DebugValueAddrInst.
Extract locations from SIL LoadInst.
Extract locations from SIL StoreInst.
Extract locations from unknown memory / inst.
Extract out the first operator.
Extract out the scalar results.
Extract port number from a host in case it's inlined.
Extract struct elements from fully referenceable structs.
Extract struct elements.
Extract subexpression in parentheses.
Extract the PGO function name.
Extract the argument used to initialize this parameter.
Extract the arguments.
Extract the arithmetic operation from the Branch.
Extract the arithmetic operation from the condfail.
Extract the base NormalProtocolConformance.
Extract the box and value address from the result.
Extract the class instance pointer.
Extract the false values.
Extract the i1 from the Bool struct.
Extract the instance pointer from a class existential value.
Extract the invocation pointer for blocks.
Extract the last SILLocation used in BB.
Extract the lazy resolver.
Extract the linker flags from the objects.
Extract the metatype pointer from a class existential value.
Extract the next path component and adjust `left' and its length.
Extract the parameter.
Extract the parameters.
Extract the paths from the builder.
Extract the payload-discriminating tag from a payload and optional / extra tag value.
Extract the program name.
Extract the protocol conformance.
Extract the return value if necessary.
Extract the self types from the declarations, if they have them.
Extract the signal number.
Extract the size and alignment.
Extract the size of the conformances block from the head of the section
Extract the true values.
Extract the value witness used to deduce this associated type, if any.
Extract tuple element.
Extract tuple elements.
Extract word convert testli to testqi or ldimmq + testq by testqi's lowering
Extracting from a zero class returns a zero.
Extracts autolink flags from object files so they can be passed to the linker directly.
F and G are optimized compared to their RFC 1321 definitions for architectures that lack an AND-NOT instruction, just like in Colin Plumb's implementation.
F if in -GH and not B--GH, D--GH, -H--GH, -H---GH else dropped if -GNED, -GN, else dropped if -DGE-, -DGI- or -DGY- (handled in D) else J if in -GE-, -GI, -GY and not GG else K
F, G, H and I are basic MD5 functions.
F, G, H and I are basic SHA1 functions.
FACEBOOK Bogus values for non-facebook libmysqlclients.
FB json_decode() options intentionally higher so when PHP adds more options we're fine
FCall, NewPackedArray, and some final member operations specify how many values are popped in their first immediate
FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
FIXME -- offer a fixit to explicitly specify the type
FIXME VarDecl LetDecl
FIXME conformance for concrete type
FIXME emit the name somewhere.
FIXME(thread-safety): lock the whole AST context.
FIXME(thread-safety): the walker is mutating the AST.
FIXME: 'deinit' is being used as a dummy identifier here.
FIXME: (LLVM branch) This should probably be a DW_TAG_interface_type.
FIXME: A clang module's Directory is supposed to be the directory containing the module map, but ClangImporter sets it to the module cache directory.
FIXME: A generic SILFunctionType should not contain any nondependent archetypes.
FIXME: A renamed match might be useful to retain for the failure case.
FIXME: ASTWalker walks enum elements as members of the enum decl, not as members of the enum case decl.
FIXME: Actually diagnose something here.
FIXME: Actually do the lookup in these contexts, because if we find something, we don't need to continue outward.
FIXME: Add a Fix-It, when the caller provides us with enough information.
FIXME: Add proper location.
FIXME: Add something for this record or remove it.
FIXME: Add static witness tables for type conformances.
FIXME: Add user-defined swift modules
FIXME: All single-retainable-pointer types should eventually have extra inhabitants.
FIXME: All the code following could be made significantly more aggressive by saying that aggregates of the same type that do not contain each other cannot alias.
FIXME: Allow an SDK overlay to add a required initializer to a class defined in Objective-C
FIXME: Allow class requirements here.
FIXME: Allow indirect field access of anonymous structs.
FIXME: Along with the FIXME below, this is a hack to work around problems with restating requirements in protocols.
FIXME: Also allow types bridged through Objective-C classes.
FIXME: Also exclude the type alias that has already been specified.
FIXME: Ambiguity detection and resolution.
FIXME: Ambiguity resolution.
FIXME: And re-doing SILGen, SIL-linking, SIL diagnostics, and IRGen is expensive, because it's not properly being limited to new things right now.
FIXME: And there are more compact ways to encode a 16-byte value.
FIXME: Any error anywhere in the SourceFile will switch off SIL diagnostics.
FIXME: AnyObject should go away
FIXME: Array types will need to be mapped differently depending on context.
FIXME: ArrayElementType is a total hack here.
FIXME: As a bit of a hack, do lookup by the simple name, then filter compound decls, to avoid having to completely redo how modules are serialized.
FIXME: Ask Clang to try to parse and evaluate the expansion as a constant expression instead of doing these special-case pattern matches.
FIXME: Assert that there is a native entry point available.
FIXME: Assert that this is never queried.
FIXME: Assert this token is after the last one
FIXME: Assume (probably safely) that the hasMethodBB has only us as a predecessor, and cannibalize its bb argument so we can represent is as an ObjCMethod lowered value.
FIXME: Assumes the payload is word-chunked.
FIXME: Audit all call sites and make them create the function debug scope.
FIXME: Audit uses of this function and figure out how to migrate them to per-file names.
FIXME: Avoid a behavior change while guaranteed self is disabled by default.
FIXME: Avoid string comparison by caching this identifier.
FIXME: Avoid the possibility of an infinite loop by fixing the root /        cause instead (incomplete circularity detection).
FIXME: Bad dependency
FIXME: Banned for operator parameters, like user conversions are.
FIXME: Basically the same as SerializedModuleLoader.
FIXME: Better ambiguity handling.
FIXME: Better location info for both diagnostics.
FIXME: Better recovery.
FIXME: BinaryFileName below should instead be ld-style names for object files in archives, e.g. "foo.a(bar.o)".
FIXME: Bogus location info.
FIXME: BridgesTypes.def is almost sufficient for this.
FIXME: Build a superclass conformance if the superclass conforms.
FIXME: Builtin and qualified types in LLVM have no parent scope.
FIXME: Cache a bit indicating when qualified lookup is possible.
FIXME: Cache name lookup.
FIXME: Cache the name.
FIXME: Call classifier should identify the object for us.
FIXME: Caller checks that this type conforms to all of the inherited protocols.
FIXME: Can also weaken to the set of protocol constraints, but only if there are any protocols that the type conforms to but the superclass does not.
FIXME: Can weaken input type, but we really don't want to get in the business of strengthening the result type.
FIXME: Canonical equivalence.
FIXME: Case-insensitivity in non-ASCII characters.
FIXME: Change to iterator later
FIXME: CharSourceRange is a half-open character-based range, while SourceRange is a closed token-based range, so this conversion omits the last token in the range.
FIXME: Check all the variadic elements.
FIXME: Check base/member types through substitutions.
FIXME: Check class requirement.
FIXME: Check container/member types through substitutions.
FIXME: Check inputs and outputs.
FIXME: Check that this declaration is at least as available as the one it overrides.
FIXME: Check whether this function conversion requires us to build a thunk.
FIXME: Check whether this has already failed.
FIXME: Clang defines max_align_t in stddef.h since 3.6.
FIXME: Clang does this by using non-ad-hoc types for ObjC runtime structures.
FIXME: Clang module config macros are not handled here.
FIXME: Clang submodules are not handled here.
FIXME: Clear unnamed_addr if the global will be relative referenced to work around an ld64 bug.
FIXME: Collapse this check into the second check.
FIXME: Compatibility equivalence.
FIXME: Complain about literals Check if we have a call to a function marked warn_unused_result.
FIXME: Compound name locations.
FIXME: Compound names.
FIXME: Conformances in InitExistentialRefInst is currently not included in SIL.rst.
FIXME: Consider lazily encoding the string when needed.
FIXME: Context params should be independent of the function type.
FIXME: Continue accepting the old path for simulator libraries for now.
FIXME: Copied from TypeCheckProtocol.cpp.
FIXME: Could allow a subclass here, but the rest of the compiler isn't prepared for that yet.
FIXME: Could be an assert if we fix non-single-frontend mode to link together serialized SIL emitted by each translation unit.
FIXME: Could collect these from the conformance requirements, above.
FIXME: Could emit a Fix-It here.
FIXME: Could handle inherited conformances here.
FIXME: Could recover better if we "know" it's a compound name.
FIXME: Could try to apply generic arguments first, and see whether that resolves things.
FIXME: Crawling all loaded modules is a hack.
FIXME: Crummy source-location information.
FIXME: Crummy way to get idempotency.
FIXME: Currently skipping generic classes.
FIXME: Currently we only implement spare bits for single-element primitive integer types.
FIXME: Customize diagnostic to mention types and compound names.
FIXME: Customize message to the kind of thing.
FIXME: Deal with broken recursion
FIXME: Deal with broken recursion.
FIXME: Deal with from/to base types that haven't been solved down to type variables yet.
FIXME: Deal with these.
FIXME: Deal with unsatisfied dependencies.
FIXME: Decide what to do about ().
FIXME: Declaration validation is overkill.
FIXME: Default argument expression, if available.
FIXME: Default implementations in protocols.
FIXME: Defensive check that shouldn't be needed, but prevents a huge number of crashes on ill-formed code.
FIXME: Dependencies should be de-duplicated at serialization time, not now.
FIXME: Depth won't match when a generic signature applies to a method in generic type context.
FIXME: Derive spare bits from element layout.
FIXME: Destructors don't have the '()' pattern in their signature, so paste it here.
FIXME: Detect edits that don't affect other files, e.g. whitespace, comments, inside a function body, etc.
FIXME: Determine which associated types matter, and only print those.
FIXME: Deterministic ordering.
FIXME: Diagnose ambiguity.
FIXME: Diagnose existentials properly.
FIXME: Diagnose this failure here, rather than over in type-checking.
FIXME: Dig into the pattern.
FIXME: Dig out the property DeclNameLoc.
FIXME: Disable checks that the protocol witness carries debug info.
FIXME: Disable memberwise initializer if a property uses a behavior.
FIXME: Distinguish errors from "file removed", which is benign.
FIXME: Do not report if we are within a template instantiation.
FIXME: Do something more clever based on the decl's mangled name.
FIXME: Do the print-completions-below-the-prompt thing bash does.
FIXME: Does not respect visibility of the module.
FIXME: Doesn't handle scoped testable imports correctly.
FIXME: Doesn't work properly for generics.
FIXME: Don't need to serialize private and internal default witness tables.
FIXME: Drop this protocol.
FIXME: Dropping requirements among different associated types of the same name.
FIXME: Dropping substitutions here.
FIXME: Duplicated from CompilerInvocation, but in theory the runtime library link path and the standard library module import path don't need to be the same.
FIXME: Duplicated from ToolChains.cpp.
FIXME: Egregious hack to avoid failing when there are no declared types.
FIXME: Egregious hack to set an 'override' attribute.
FIXME: Either emit a descriptor for this or create a metadata kind that indicates its trivial layout.
FIXME: Eliminate the less-correct path.
FIXME: Eliminate this once we can handle finding protocol members in resolveTypeInContext.
FIXME: Emit a warning of some kind.
FIXME: Emit candidate set....
FIXME: Enable this assertion.
FIXME: Errors could cascade here, because name lookup for this operator won't find this declaration.
FIXME: Establish that we need a type witness.
FIXME: Even implicit Stmts should have proper ranges that include any non-implicit Stmts (fix Stmts created for lazy vars).
FIXME: Eventually it shouldn't be.
FIXME: Eventually we might get C++-like support for strong pointers in structs, at which point we should really be checking the lifetime qualifiers.
FIXME: Eventually, deal with multiple overrides.
FIXME: Eventually, this should itself be a verification failure.
FIXME: Eventually, we may want to throw.
FIXME: Eventually, we want to enforce that we have either argTuple or argParen here.
FIXME: Everything here brazenly assumes little-endian-ness.
FIXME: Except for optionals, which get bit-packed into an integer.
FIXME: Explosion level
FIXME: Extract useful related declarations, overloaded functions, if VD is an initializer, we should extract other initializers etc.
FIXME: Factory methods cannot have dummy parameters added for historical reasons.
FIXME: Failing here should not take down the whole process.
FIXME: Feels like a total hack.
FIXME: Feels too early to perform this check.
FIXME: Figure out how to deal with incomplete protocols, since that notion doesn't exist in Swift.
FIXME: Figure out how to deal with incomplete types, since that notion doesn't exist in Swift.
FIXME: Figure out if this can be migrated to LLVM.
FIXME: Figure out what to do with superclasses in C++.
FIXME: Find a way to have this continue to happen after.
FIXME: For SizeInBits, clang uses the actual size of the type on the target machine instead of the storage size that is alloca'd in the LLVM IR.
FIXME: For mapTypeInContext
FIXME: For now, conservatively assume that unknown functions can be called from any witness_method call site.
FIXME: For now, substitute in the bound type for literal collection exprs that would otherwise result in a simple conversion constraint being placed between two type variables.
FIXME: For protocol argument types, could add specific error similar to could_not_use_member_on_existential.
FIXME: Form a new initializer by performing the appropriate substitutions of subclass types into the superclass types, so that we get the right generic parameters.
FIXME: Fully use the ASTPrinter.
FIXME: GSSAPI isn't implemented yet
FIXME: Generalize this.
FIXME: Generic local functions can add type parameters to arbitrary depth.
FIXME: Generic subscript operator could add another layer of substitutions.
FIXME: Get expansion from SILDeclRef
FIXME: Get expansion from SILFunction
FIXME: Get the actual diagnostic.
FIXME: Get the generic parameters from the function type.
FIXME: Give the thunk a real name.
FIXME: Guarding the rest of these things together with early attribute validation is a hack.
FIXME: Hack to deal with recursion elsewhere.
FIXME: Handle "private(set)" requirements.
FIXME: Handle 'self' along with the other arguments.
FIXME: Handle 'self' along with the other body patterns.
FIXME: Handle 'self' like any other argument here.
FIXME: Handle IBOutletCollection.
FIXME: Handle NonFixedTypeInfo here or assert that we won't encounter one.
FIXME: Handle _Bool and DarwinBoolean.
FIXME: Handle all attributes.
FIXME: Handle errors better.
FIXME: Handle generalized parameters.
FIXME: Handle generic initializers as well.
FIXME: Handle hierarchical names better.
FIXME: Handle multibyte characters.
FIXME: Handle re-exported decls.
FIXME: Handle self along with the other body patterns.
FIXME: Handling of generic parameters in SIL type lowering is in flux.
FIXME: Hard-coded list should move into the module map language.
FIXME: Having to deal with private imports as a superset of public imports is inefficient.
FIXME: Heavy WIP here.
FIXME: Highlight the offending node/constraint/adjacency/etc.
FIXME: Hold off on registering extra inhabitants for dynamic enums until initializeMetadata handles them.
FIXME: Horrible hack.
FIXME: Horrible, horrible hackaround.
FIXME: I am not sure if this is possible, if it is not change this to an assert.
FIXME: I just made this up
FIXME: Ideally we would handle decl modifiers as a special kind of attribute, but for now it's simpler to treat them as a keyword in the printer.
FIXME: If ModuleToPrint is a submodule, get its top-level module, which will be the DeclContext for all of its Decls since we don't have first- class submodules.
FIXME: If one or both types are dependent, we can't accurately assess whether they're ABI-compatible without a generic context.
FIXME: If only we had the notion of a "searchable" declaration context...
FIXME: If the base type is a type variable, constrain it to a metatype of a bound generic type.
FIXME: If the decl is in error, we get no information from this.
FIXME: If the root class specifies its own runtime ObjC base class, assume that that base class ultimately inherits NSObject.
FIXME: If the unsubstituted payload type is empty, but not resilient, we treat the case as a no-payload case.
FIXME: If there is a name, actually perform qualified lookup into this DeclContext.
FIXME: If there is no module, infer one.
FIXME: If this is a submodule, get its top-level module, which will be the DeclContext for all of its Decls since we don't have first-class submodules.
FIXME: If we already looked at this for this generation, skip.
FIXME: If we already set the inherited protocols, bail out.
FIXME: If we do this late enough, there will be no failure.
FIXME: If we ever allow argument reordering, this is incorrect.
FIXME: If we ever have first-class polymorphic values, we'll need to revisit this.
FIXME: If we ever split all critical edges, this should be relooked at.
FIXME: If we had some basic sanity checking of Self, we might be able to use these.
FIXME: If we had the actual parameters and knew the body names, those matches would be best.
FIXME: If we have fewer arguments than we need, that might be okay, if we're allowed to deduce the remaining arguments from context.
FIXME: If we inferred different types for literals (for example), could diagnose ambiguity that way as well.
FIXME: If we reach this point, the program we're being handed is likely very broken, but it's still conceivable that this may happen due to invalid shadowed declarations.
FIXME: If we spilled extra tag bits, we could offer spare bits from the tag.
FIXME: If we used Clang as a linker instead of going straight to ld, we wouldn't have to replicate Clang's logic here.
FIXME: If we want keyword arguments for closures, add them here.
FIXME: If we were able to actually fix things along the way, we may have to hunt for the best solution.
FIXME: If we were walking TypeLocs, we could actually get parameter names.
FIXME: If we're not planning to run SILGen, this is wasted effort.
FIXME: Ignore submodules, which are empty for now.
FIXME: Implement bitcast typechecking.
FIXME: Implement cancelling.
FIXME: Implement once Complex is in the library.
FIXME: Implement once Swift has namespaces.
FIXME: Implement once we can pretty-print expressions.
FIXME: Implement remaining enum layout strategies
FIXME: Implement request handle.
FIXME: Implement using AvailableAttr::getMinVersionAvailability().
FIXME: Implementation.
FIXME: Import C++ member functions as methods.
FIXME: Import anonymous union fields and support field access when it is nested in a struct.
FIXME: ImportDecl should store a DeclNameLoc.
FIXME: Importing the type will can recursively revisit this same EnumConstantDecl.
FIXME: Importing the type will recursively revisit this same EnumConstantDecl.
FIXME: In a function argument context, arrays should import as pointers.
FIXME: Include proper source location.
FIXME: Infer body indentation from the source rather than hard-coding 4 spaces.
FIXME: Initializer expressions (like array literals) are not contained within the global variables nodes.
FIXME: InterruptedConnectionHandler will go away.
FIXME: Introduce a bit indicating when everything in the TypeRepr has been name-bound, which indicates that we can always compute a structural type.
FIXME: It also must not carry witness tables.
FIXME: It doesn't necessarily make sense to pass all types using their explosion schema.
FIXME: It seems like this should be easier to detect.
FIXME: It would be nice to point out where we found the named type declaration, if any.
FIXME: It would be nice to say what part of the requirements actually end up being problematic.
FIXME: It would be nicer if we could build the ASTs properly in the first shot.
FIXME: It would be really nice to emit a follow-up note showing where we got the other type information from, e.g., the parameter we're initializing.
FIXME: It'd be nice if the result of the accessor was natively an address.
FIXME: It'd be nice not to have to call through the runtime here.
FIXME: It'd be nice not to need a runtime call here.
FIXME: It'd be nice to be able to return a SIL address directly.
FIXME: It's wrong to use the uncurried types here for methods.
FIXME: Iterating over LoadedModules is not a good way to do this.
FIXME: Jump through hoops to maintain syntactic sugar.
FIXME: LLVM's YAML support does incremental parsing in such a way that for-range loops break.
FIXME: Lame to rely on archetypes in the substitution below.
FIXME: Largely copied from SILGenFunction::emitOptionalToOptional.
FIXME: Layering violation to use the ClangImporter's define.
FIXME: Linear search is not great for large enum decls.
FIXME: Locator when anchored on a declaration.
FIXME: Long-term, we clearly need a specialized runtime entry point.
FIXME: Long-term, we'd like clients to deal with the trailing where clause explicitly, but for now it's far more direct to represent the trailing where clause as part of the requirements.
FIXME: Look through the superclass.
FIXME: Look up things other than types.
FIXME: Loses potentially better alignment info we might have.
FIXME: Losing ".0" sugar here.
FIXME: Lots of other cases to handle.
FIXME: MC breaks when emitting alias references on some platforms (rdar://problem/22450593 ).
FIXME: Make an exception for serialized extensions, which don't currently have the correct archetypes.
FIXME: Make sure this table is complete, somehow.
FIXME: Make sure this thing is global.
FIXME: Make this an assertion.
FIXME: Make this useful.
FIXME: Map into archetype context.
FIXME: Map over source ranges in the diagnostic.
FIXME: Map source locations over.
FIXME: Map to a real fixed-size Swift array type when we have those.
FIXME: Member constraint is still weird here.
FIXME: Member function pointers can be mapped to curried functions, but only when we can express the notion of a function that does not capture anything from its enclosing context.
FIXME: Memory corruption issues arise when enabling this for mixed Swift/ObjC enums.
FIXME: Merge this with diagAvailability in MiscDiagnostics.cpp.
FIXME: Might want to warn about this in debug builds, so we can find a way to eliminate the redundancy in the search space.
FIXME: Module imports inside that header.
FIXME: MongoDB doesn't support "connection promotion" to SSL at the moment, so we can't support this option properly
FIXME: Move to an LLVM API.
FIXME: Much of this was copied from visitOptionalEvaluationExpr.
FIXME: Multi-file compilation may cause group id collision.
FIXME: Name won't match demangled context generic signatures correctly.
FIXME: Need a better locator for a pattern as a base.
FIXME: Need a more complete/robust lookup mechanism that can handle declarations in sub-stmts, etc.
FIXME: Need a sugar-preserving getExtendedInterfaceType for extensions
FIXME: Need an AST to represent this properly.
FIXME: Need error-checking.
FIXME: No "safe" variant.
FIXME: No generic substitutions.
FIXME: No way to express this in Objective-C.
FIXME: Nonsense, but we shouldn't need this code anyway.
FIXME: Not a total order.
FIXME: Not knowing what went wrong is pretty bad.
FIXME: Not really true.
FIXME: Not the best interface.
FIXME: Note this as invalid, in case we don't find a solution, so we don't let errors cascade further.
FIXME: Notion of depth is reversed from that for archetypes.
FIXME: Occurs when the nested type is a concrete type, in which case it's quite silly to create a type variable at all.
FIXME: Once we separate the notion of ref counts from reading/writing memory this will be unnecessary.
FIXME: Once we support private conformances, update this.
FIXME: One should only jump to this label in the case where we want to cut off other potential conversions because we know none of them apply.
FIXME: Only because we're synthesizing conformances for deserialized protocols.
FIXME: Only functions can be overloaded.
FIXME: Only when experimental patterns are enabled for now.
FIXME: Optimize for known switch values.
FIXME: Other decl types too.
FIXME: Overriding the default to context "None" is a hack so that they won't overwhelm other results that also match the filter text.
FIXME: PHP calls stat() here if the wrapper has a non-null stat handler, in order to skip the open of a missing file, thus suppressing warnings.
FIXME: Parser diagnostics should be filtered out of the semantic ones, Then just merge the semantic ones with the current parse ones.
FIXME: Pass this down instead of getting it from the ASTContext.
FIXME: Pattern initializers at top-level scope end up here.
FIXME: PatternBindingDecls don't have attributes themselves, so just assume the variables all have the same attributes.
FIXME: Per the comment on DelayedExtensionDecls, this is insane.
FIXME: Platform compatibility.
FIXME: Poor location info.
FIXME: Poor location information.
FIXME: Poor source-location information.
FIXME: Possibly should extend to more availability checking.
FIXME: Pretty print #if decls
FIXME: Print element expr.
FIXME: Print location info if available.
FIXME: PrintNameContext::GenericParameter
FIXME: Probably should be more general, as mentioned above.
FIXME: Prohibits some user-defined conversions for tuples.
FIXME: Properly handle deployment targets.
FIXME: Property encoding differs in slight ways that aren't publicly exposed from Clang.
FIXME: Protect against broken standard library.
FIXME: ProtocolConformanceRef should have an "error" representation
FIXME: Provide a mask to only match the bits in the payload whose extra inhabitants differ.
FIXME: Provide a more meaningful debug type.
FIXME: Provide type annotation.
FIXME: Put the error message in the crash report.
FIXME: Re-visit this to always do the check.
FIXME: Reabstract the result value as substituted.
FIXME: Read file names and sort them to prevent non-determinism.
FIXME: Really these should be marked as artificial, but LLVM currently has no support for flags to be put on global variables.
FIXME: Really this should look at availability instead.
FIXME: Record (via type sugar) that this was referenced via baseTy.
FIXME: Record failure.
FIXME: Record that we did this.
FIXME: Record that we're checking substitutions, so we can't end up with infinite recursion.
FIXME: Recovery here is awful.
FIXME: Rectify these the same way we do for element types.
FIXME: Recurse into these constraints to see whether this type variable is fully bound by any of them.
FIXME: Recursion into existing type checker.
FIXME: Recursion into old type checker.
FIXME: Recursion into the old type checker.
FIXME: Refactor this into its own function.
FIXME: Relational constraints for which we could perhaps do better than the default.
FIXME: Relative references to aliases break MC on 32-bit Mach-O platforms (rdar://problem/22450593 ), so substitute an alias with its aliasee to work around that.
FIXME: Remap the parsed context types to interface types.
FIXME: Remove altogether rather than injecting a NULL value.
FIXME: Remove dummy argument.
FIXME: Remove even the null value per rdar://problem/18801263
FIXME: Remove null data altogether rdar://problem/18801263
FIXME: Remove this to save metadata space.
FIXME: Removing this triggers a linker bug
FIXME: Replace pre-specialization's "keep as public" hack with something more principled
FIXME: Report it as failed request.
FIXME: Report the diagnostic.
FIXME: Report the memory cost of the overall CompilerInstance.
FIXME: Requirement declarations.
FIXME: Resilience: could write out vtable for fragile classes.
FIXME: Resolve through name lookup.
FIXME: Respect the access path.
FIXME: Restore defer after Tokens.def.
FIXME: Retrying a failed import works around recursion bugs in the Clang importer.
FIXME: Revisit this restriction.
FIXME: Right now this works only with access paths of length 1.
FIXME: SDK overlay semantics
FIXME: SILFunction::ContextGenericParams needs to be a GenericSignature instead.
FIXME: Search imported modules to resolve the context.
FIXME: See the comment for SelfTypeVar for information about this hack.
FIXME: Setup dependencies on the included headers.
FIXME: Short-circuit if any of the constraints fails.
FIXME: Should also be able to do this for forced class methods.
FIXME: Should be able to handle this earlier
FIXME: Should be able to move a value from an extension in a derived module to the original definition in a base module.
FIXME: Should be able to pick the best locator, e.g., based on some depth-first numbering of expressions.
FIXME: Should be fixed to allow inheriting from a nested type some day
FIXME: Should be represented in SIL.
FIXME: Should be the interface type of the extension.
FIXME: Should check for protocol in Sema
FIXME: Should look up the type witness.
FIXME: Should pass the main module for the interface but currently it's not necessary.
FIXME: Should probably cache this.
FIXME: Should restrict this to the source file we care about.
FIXME: Should suggest overload set, but we're not ready for that until it points to candidates and identifies the self type in the diagnostic.
FIXME: Since we don't represent Clang submodules as Swift modules, we're getting everything.
FIXME: Skip Microsoft __interfaces.
FIXME: Some clients probably care about them.
FIXME: Some opaque types do have manglings, but we don't have enough info to figure them out.
FIXME: Somewhat duplicated from Implementation::importAttributes.
FIXME: Spare bits between struct members.
FIXME: Spare bits between tuple elements.
FIXME: Specialize for implicitly-generated constructors.
FIXME: Specialize the match failure kind
FIXME: Splice the block to the end of the function so they come out in the right order.
FIXME: Standardize all callers to always provide all argument names, rather than hack around this.
FIXME: Submodules don't get sorted properly here.
FIXME: Subscript trailing closures
FIXME: Support REPL on non-Apple platforms.
FIXME: Support recursive definitions in immediate modes by making type checking even lazier.
FIXME: Swift diagnostics currently have no category.
FIXME: Swift diagnostics currently have no flags.
FIXME: Swift does not have static variables in structs/classes yet.
FIXME: Switch to a format other than YAML.
FIXME: Technically should be "consume", but that introduces barriers in the current LLVM ARM backend.
FIXME: Technically, we only need very basic name binding.
FIXME: That's not correct if the user /just/ passed -emit-header and not -emit-module.
FIXME: The "hasClangNode" check here is a complete hack.
FIXME: The AST should do this for us.
FIXME: The archetype builder should be doing this and mapping down to a concrete type.
FIXME: The code-completion kind is also used for semantic annotations.
FIXME: The current source file needs to be handled specially, because of private extensions.
FIXME: The diagnostics here should be improved.
FIXME: The diagnostics here should be improved...
FIXME: The following should run in the synchronous dispatch queue of the connection.
FIXME: The latter could be avoided if we had already substituted all of those other type variables through.
FIXME: The name of this module could end up as a key in the ASTContext, but that's not correct for submodules.
FIXME: The naming and documentation here isn't ideal.
FIXME: The only way this should happen realistically is if there are casts in between two projection instructions.
FIXME: The outer parentheses may be superfluous too.
FIXME: The parent module isn't exactly a private import, but it is needed for link dependencies.
FIXME: The pedantically correct way to find the type is to resolve the Swift.StringLiteralType type.
FIXME: The problem may not be the OS version.
FIXME: The proper way to do this depends on the decls used.
FIXME: The rest of the hack for restating requirements.
FIXME: The second argument indicates whether the given operator is visible outside the current file.
FIXME: The short-circuit here is lame.
FIXME: The source location here is completely bogus.
FIXME: The way we do this is really ugly...
FIXME: There are type variables and overloads not common to both solutions that haven't been considered.
FIXME: There are unfortunate inconsistencies in the treatment of generic param decls.
FIXME: There exists a small window where the module file may have been modified after compilation finished and before we get its stamp.
FIXME: There is a way more general property here, where we can drop one label from the tuple, maintaining the rest.
FIXME: There is undoubtedly a good dynamic-programming algorithm to find the best assignment here.
FIXME: There might be a better way to do this.
FIXME: There might be better ways to do this.
FIXME: These APIs allocate memory on the ASTContext, meaning it may not be freed for a long time.
FIXME: These are going to come out in nondeterministic order.
FIXME: These can't be controlled from the command line.
FIXME: These could be further propagatable now, we might want to move this to CCP and trigger another round of copy propagation.
FIXME: These decls are not being parsed correctly since (a) some of the callbacks are still being added, and (b) the logic to parse them has changed.
FIXME: These expressions merely adjust the result type for DynamicSelf in an unchecked, ABI-compatible manner.
FIXME: These values are hardcoded from their previous IDL values Grab their correct values from the system as appropriate
FIXME: These will be the same for most source files, but we copy them over and over again.
FIXME: They never should have been in the type anyway.
FIXME: This admits varargs tuples, which should only be handled as part of argument emission.
FIXME: This algorithm falls out from the way the "all archetypes" lists are structured.
FIXME: This algorithm has quadratic memory usage.
FIXME: This arguably should be getMemberForBaseType's responsibility.
FIXME: This assumes that smashable calls and regular calls look the same, which is probably not true on non-x64 platforms.
FIXME: This assumes that, e.g., the default literal int/float/char/string types are never generic.
FIXME: This case is hit when code completion occurs in a function parameter list.
FIXME: This check is unneeded if the type is known to be pure Swift.
FIXME: This check was tautological before the removal of AutoreleaseReturnInst, and it turns out that we're violating it.
FIXME: This constant should be vended by LLVM somewhere.
FIXME: This could be lazier.
FIXME: This could likely be implemented directly.
FIXME: This depends on the buffer IDs chosen by llvm::SourceMgr.
FIXME: This doesn't belong on IGF.
FIXME: This doesn't cope with bzip2
FIXME: This doesn't handle a non-debugger REPL, which should also treat this as a non-fatal error.
FIXME: This doesn't handle implicit properties.
FIXME: This doesn't work if the type has default values because they fail to canonicalize.
FIXME: This feels like a hack, but we don't have the right predicate anywhere.
FIXME: This feels painfully inefficient.
FIXME: This feels very, very wrong.
FIXME: This forces the creation of wrapper modules for all imports as well, and may do unnecessary work.
FIXME: This forces us to re-use archetypes from outer scopes as concrete types, which is currently important for the layout of the "all archetypes" list.
FIXME: This hack is only necessary to work around some problems we have for inferring the type of an unresolved member reference expression in an optional context.
FIXME: This hack is required because the inclusion check below doesn't compares the *start* of the ranges, not the end of the ranges.
FIXME: This hack tells us to prefer members of subprotocols over those of the protocols they inherit, if all else fails.
FIXME: This has to be cleaned up on the Clang side before we can improve things here.
FIXME: This has to be dynamically looked up for classes, and dynamically instantiated for generics.
FIXME: This heuristic isn't great, but it helped somewhat for overload sets.
FIXME: This implementation does a global lock, which is much worse than what we have on other platforms.
FIXME: This implementation is pretty horrible and should be rewritten when ReflectionProperty is ported.
FIXME: This implementation is woefully inefficient.
FIXME: This is a band-aid used to work around the fact that the above code can introduce null elements into the vector.
FIXME: This is a bit of a hack.
FIXME: This is a bug in the SIL deserialization.
FIXME: This is a current limitation, not inherent.
FIXME: This is a fallback.
FIXME: This is a general property of the type system.
FIXME: This is a hack because DI is not understanding SILGen's stack values that have multiple init and destroy lifetime cycles with one allocation.
FIXME: This is a hack to ensure that inherited conformances are always "single step", which is bad for resilience but is assumed elsewhere in the compiler.
FIXME: This is a hack to work around our inability to handle multiple levels of substitution through inherited conformances elsewhere in the compiler.
FIXME: This is a hack.
FIXME: This is a language change -- for now, keep the old behavior
FIXME: This is a note pointing to a synthesized declaration buffer for a declaration coming from a module.
FIXME: This is actually a general problem: any "fatal" error could mess up the CompilerInvocation.
FIXME: This is also computed when the constraint system is set up.
FIXME: This is an awful hack to handle Clang submodules.
FIXME: This is an awful hack.
FIXME: This is an awful way to get the current OS.
FIXME: This is an error path.
FIXME: This is awful.
FIXME: This is brittle.
FIXME: This is cheesy when the destination BB has only the switch as a predecessor.
FIXME: This is completely unnecessary.
FIXME: This is explicitly checking for attributes in some cases because it can be called before accessibility is computed.
FIXME: This is gross.
FIXME: This is horrible.
FIXME: This is inefficient.
FIXME: This is missing implicit includes.
FIXME: This is not an aggressive implementation.
FIXME: This is not at all thread-safe.
FIXME: This is not quite right: we want to handle AppExtensions properly.
FIXME: This is not working well for decl parents.
FIXME: This is only because forceExternalDeclMembers() might do something interesting.
FIXME: This is only needed because binops don't respect contextual types.
FIXME: This is only really needed for debugging.
FIXME: This is really crappy special case of computing a reasonable result based on the given constraints.
FIXME: This is really dubious.
FIXME: This is really unfortunate.
FIXME: This is really weird: 1) For generic functions, generic methods and generic local functions, we return the function's generic parameter list twice.
FIXME: This is ridiculous, this all needs to be sucked into the declparsing goop.
FIXME: This is silly.
FIXME: This is still a lousy approximation of whether the module file will be externally consumed.
FIXME: This is supposed to be a short-term hack.
FIXME: This is the wrong diagnostic for if someone manually declares a variable named 'self' using backticks.
FIXME: This is unsound, since type checking will turn other more complicated patterns into non-refutable forms.
FIXME: This is wrong for observed properties.
FIXME: This is wrong for type declarations, which we're skipping entirely.
FIXME: This isn't a total ordering
FIXME: This isn't a total ordering.
FIXME: This isn't actually used for anything at the moment.
FIXME: This location info is bogus.
FIXME: This logic has been duplicated from CompilerInvocation::setMainExecutablePath.
FIXME: This looks completely wrong for varargs within a parameter list.
FIXME: This might need to be changed to STR_EMPTY_ALLOC().
FIXME: This needs to be a linker-local symbol in order for Darwin ld to resolve relocations relative to it.
FIXME: This representation is actually quite awful
FIXME: This requires a traversal of the whole file to compute.
FIXME: This seems like a hack, there must be a better way..
FIXME: This seems like an odd restriction.
FIXME: This should all just be a matter of getting the type of the sub-expression, but this doesn't work well when typeCheckChildIndependently is over-conservative w.r.t.
FIXME: This should apply to blocks as well, but Unmanaged is constrained to AnyObject.
FIXME: This should be a function transform that pushes cloned functions on the pass manager worklist.
FIXME: This should be an API on clang::Module.
FIXME: This should be more general.
FIXME: This should be target-specific.
FIXME: This should be using std::min(protocol's access, type's access).
FIXME: This should go into llvm/ADT/StringExtras.h.
FIXME: This should happen before we attempt shadowing checks.
FIXME: This should not be needed, but seems to help when stdout is being redirected to a file.
FIXME: This should not be rewritten.
FIXME: This should not take down the entire process.
FIXME: This should really be the linkage of the parent function.
FIXME: This should track whether this should result in a private or non-private dependency.
FIXME: This should use ExprWalker to print children.
FIXME: This should use the generic signature, not walk the members.
FIXME: This should work without an output file map.
FIXME: This shouldn't be needed.
FIXME: This shouldn't ever appear in protocol requirement signatures.
FIXME: This stack operation is painfully inefficient.
FIXME: This terrible hack is in place to support equality comparisons of non- equatable option types to 'nil'.
FIXME: This ties ASTs to every argument and the exact order that they were provided, preventing much sharing of ASTs.
FIXME: This use of getSwiftType() is extremely suspect.
FIXME: This will do the wrong thing if there's any adjustment to do besides optionality.
FIXME: This will end up taking linear time.
FIXME: This will prevent hard error in cases the error is coming from ObjC interoperability code.
FIXME: Thread a branch through the cleanups if there are any active cleanups and we have a valid insertion point.
FIXME: ThreadSafeRefCntPtr is racy.
FIXME: Tighten up checking for conversions to protocol types.
FIXME: Today, the subclasses of LoadedFile happen to return StringRefs that are backed by null-terminated strings, but that's certainly not guaranteed in the future.
FIXME: Totally bogus fallthrough.
FIXME: Try uppercasing for non-types.
FIXME: Tuple-to-Any conversions
FIXME: TupleExpr doesn't preserve location of keyword name or colon.
FIXME: Turn this into an assertion instead.
FIXME: TypeChecker::resolveType() is mostly non-ad-hoc-recursive when given an UnsatisfiedDependency.
FIXME: Types that can be mapped, but aren't yet.
FIXME: Ugly hack: remove the .Builtin from the element type.
FIXME: Unfortunate that we can't really capture the generic parameters here.
FIXME: Unfortunately, right now, in an unlikely race another thread could create another translation with the same type specialization that we just created in this case.
FIXME: Until we link everything in up front we need to ensure that we link after devirtualizing in order to pull in everything we reference from the stdlib.
FIXME: Upcasts between existential metatypes are not handled yet.
FIXME: Use a consistent constant/enum rather than repeating hard-coded values
FIXME: Use a longer hash string to minimize possibility for conflicts.
FIXME: Use llvm::CountPopulation_64 when that's declared constexpr.
FIXME: Use mongo_methods here
FIXME: Use of the platformString here is non-awesome for application extensions.
FIXME: Use target-independent linker option.
FIXME: Use the SIL basic block's name.
FIXME: Use the allArchetypes vector instead of the generic param if available because of cross-module archetype serialization woes.
FIXME: Use the same type-substitution approach as lookupMemberType.
FIXME: Verify that these aren't circular and infinite size.
FIXME: We actually do have things to enforce for versioned API.
FIXME: We allow trivially-representable cases that also conform to _ObjectiveCBridgeable.
FIXME: We also need to consider if the enum is resilient, in which case we're never guaranteed to be exhaustive.
FIXME: We aren't const-correct.
FIXME: We can have interesting ordering dependencies among the various extensions, so we'll need to be smarter here.
FIXME: We can provide better diagnostics here.
FIXME: We can't actually get here because we reject setting this option to prefer in mcon/parse.c.
FIXME: We can't handle subpatterns here.
FIXME: We can't reasonably lifetime-extend an inner-pointer result through a thunk.
FIXME: We can't statically emit a global variable for generic properties.
FIXME: We can't use visitConformances() because there are no conformances for protocols to protocols right now.
FIXME: We could also make extra inhabitants using spare bits, but we probably don't need to.
FIXME: We could avoid imploding and reexploding tuples here.
FIXME: We could be significantly smarter here by using the protocol hierarchy.
FIXME: We could do something crazy, like try to fix up the witness.
FIXME: We could gather the requirements on these as well.
FIXME: We could generate the code to dynamically report the overflow if the third argument is true.
FIXME: We could get spare bits out of the metadata and/or witness pointers.
FIXME: We could handle generic thunks if it's worthwhile.
FIXME: We could import specializations, but perhaps only as unnamed structural types.
FIXME: We could insert an IsPattern if a checked cast can do the conversion.
FIXME: We could lower select_enum directly to LLVM select in a lot of cases.
FIXME: We could probably optimize this case too
FIXME: We could produce the greatest common supertype of the two types.
FIXME: We could recover by looking at later components.
FIXME: We could support explicit function specialization.
FIXME: We don't handle remarks yet.
FIXME: We don't have enough semantic understanding of extra inhabitant sets to be able to reason about how many spare bits from the payload type we can forward.
FIXME: We either have an associated type here or a member of some member of the superclass bound (or its superclasses), which should allow us to skip much of the work in resolveDependentMemberType.
FIXME: We eventually want to loosen this constraint, to allow us to find operator functions both in classes and in protocols to which a class conforms (if there's a default implementation).
FIXME: We have to dig through a ridiculous number of nodes to get to the Protocol node here.
FIXME: We hit this building Foundation, with a call on the type encoding path.
FIXME: We intentionally call SILClonerWithScopes here to ensure the debug scopes are set correctly for cloned functions.
FIXME: We may need to do something here if subscripts contain any symbols exposed with linkage names.
FIXME: We may want to merge this scope with the scope introduced by the stmt-brace, as in C++.
FIXME: We might need to go through ObjC dispatch for references to constructors imported from Clang (which won't have a direct entry point) or to delegate to a designated initializer.
FIXME: We need a better way to show headers, since they usually /are/ re-exported.
FIXME: We need an accessibility value to check against, so we pull one out of some random VarDecl in the pattern.
FIXME: We need the Swift equivalent of Clang's FileEntry.
FIXME: We need the enclosing CallExpr to rewrite the argument labels.
FIXME: We need to add implicit initializers and dtors when a decl is touched, because it affects vtable layout.
FIXME: We need to be passing the buffers from the open documents.
FIXME: We need to check whether anything is specialized, because the innermost extended type might itself be a non-generic type within a generic type.
FIXME: We need to convert this back to an ObjC class for an ObjC metatype representation.
FIXME: We need to undef 'defer' when including Tokens.def.
FIXME: We ought to be able to get to the generic signature from a dependent type, but can't yet.
FIXME: We ought to prefer operators elsewhere in this module before we check imports.
FIXME: We probably shouldn't be adding an rpath here unless we know ahead of time the standard library won't be copied.
FIXME: We should be able to tell if this is a private lookup.
FIXME: We should build a sidetable cache in the module.
FIXME: We should call a fast deallocator for heap objects with known size.
FIXME: We should have generated an overload set from this, in which case we can emit a typo-correction error here but recover well.
FIXME: We should integrate this into the LinkEntity cache more cleanly.
FIXME: We should mirror properties of the root class onto the metatype.
FIXME: We should not be relying on the global LLVM context.
FIXME: We should persist this information between lookups.
FIXME: We should probably be a bit more clever here about which lines we put into the history and when we put them in.
FIXME: We should probably diagnose this, but this is not a place where we can emit diagnostics.
FIXME: We should really go through the conformance above to extract the element type, rather than just looking for the element type.
FIXME: We should support returning "Self.Type" for a root class instance method mirrored as a class method, but it currently causes problems for the type checker.
FIXME: We shouldn't allow this.
FIXME: We shouldn't even get here if the function isn't locally generic to begin with, but fixing that requires a lot of reengineering for local definitions in generic contexts.
FIXME: We shouldn't need this.
FIXME: We shouldn't need to do this, the target should be immutable once created.
FIXME: We shouldn't need to do this.
FIXME: We shouldn't need to encode this for /all/ private decls.
FIXME: We shouldn't need to use the global context here, but something is persisting across calls to performIRGeneration.
FIXME: We want the locator that indicates where the binding came from.
FIXME: We want this issue to disappear completely when single-element labelled tuples go away.
FIXME: We'd like to drop just the problematic protocols, not everything.
FIXME: We'd like to only use this in SIL mode, but unfortunately we use it for our fake overlays as well.
FIXME: We'd prefer to keep what the user wrote here.
FIXME: We're implicitly depending on the fact that lookupConformance is global, ignoring the module we provide for it.
FIXME: We're just using CompilerInstance::createOutputFile.
FIXME: We're not recovering (in the AST), so the Fix-It should move.
FIXME: We're not tracking the colon locations in the AST.
FIXME: We're seeding typeVars with TypeVariables so that the connected-components algorithm only considers those type variables within our component.
FIXME: Weak, Unowned references have different extra inhabitants
FIXME: Weird that we're producing an archetype for protocol Self, but the declared type of the context in non-protocol cases.
FIXME: When default implementations come along, we can try to match these when they're default implementations coming from another (unrelated) protocol.
FIXME: When destructors get moved into vtables, update this to use the vtable for the class.
FIXME: When generic parameters can map down to specific types, do so here.
FIXME: When request cancellation is implemented and Xcode adopts it, / don't use 'OncePerASTToken'.
FIXME: When we can import C++, use Clang's mangler all the time.
FIXME: When we can import C++, use Clang's mangler.
FIXME: When we start dealing with C++, we can map over some operator names.
FIXME: With some changes to their callers, all of the below functions could be re-worked to use emitInjectEnum().
FIXME: Work around an apparent reentrancy problem with the REPL.
FIXME: Workaround for strange anchor on ConstructorMember locators.
FIXME: Working with filenames is fragile, maybe use the real path or have some kind of FileManager.
FIXME: Would be better to walk the requirements of the protocol of which the associated type is a member.
FIXME: Would like to abstract the dtor slot (#0) out from this to somewhere unified.
FIXME: Would like to customize the diagnostic emitted in conformsToProtocol().
FIXME: Xcode can't currently handle multiple targets in a single dependency line.
FIXME: a bit of a hack.
FIXME: actually check imports.
FIXME: actually object to an invalid setting.
FIXME: add -x support (or equivalent)
FIXME: add a UID for operators
FIXME: add handling of the case#b above
FIXME: add ref_element_addr check here.
FIXME: also include user-defined attribute keywords
FIXME: any place we have to do this that actually requires uniqueness is buggy.
FIXME: author apparently had no idea what this function was meant to do ce is meant to point to uninitialised memory, which this function is meant to fill, so you can't just triple-dereference it
FIXME: avoid this duplication of the behavior of isLoadable.
FIXME: because other-module results are cached, they will not be given a type-relation of invalid.
FIXME: better explosion kind, map as static.
FIXME: better recovery
FIXME: bind the extension.
FIXME: blocks should be Direct_Guaranteed.
FIXME: cache the physical field index in the VarDecl.
FIXME: callWitness() may end up re-doing some work we already did to convert the array literal elements to the element type.
FIXME: callWitness() may end up re-doing some work we already did to convert the dictionary literal elements to the (key, value) tuple.
FIXME: can we 'log' SwiftDemangleNodeKindToCString(node_kind))
FIXME: check for matching types.
FIXME: clang source location
FIXME: clang::IdentifierInfo /nearly/ has the API we need to do this in a more principled way, but not quite.
FIXME: collect attributes in the CallEmission.
FIXME: compress bitfield
FIXME: consider whether CCOpts has changed since the 'open'.
FIXME: const-ness on the clang API.
FIXME: don't need to check hasStorage, already done above
FIXME: drop "Mutable"...
FIXME: drop mutable...
FIXME: duplicated from NameBinder::getModule
FIXME: duplicated from computeDefaultAccessibility in TypeCheckDecl.cpp.
FIXME: dyn_cast_null does not work with IntrusiveRefCntPtr.
FIXME: each parameter info should be HNI with a handle to the Func::ParamInfo
FIXME: even though we don't apply the solution, the type checker may modify the original expression.
FIXME: file type bonus if we're checking a file path.
FIXME: generalize this.
FIXME: generic parameters
FIXME: generic signature dumping needs improvement
FIXME: get the parameter from the init, and plug it in here.
FIXME: get this from the proper header.
FIXME: getting attributes here without setting them does nothing.
FIXME: handle code completion in Arguments.
FIXME: handle multiple direct results here
FIXME: handle pointers and fields of atomic type
FIXME: handle variable amounts of space.
FIXME: hang the converter object somewhere so that it is persistent between requests to this AST.
FIXME: hide individual custom completions
FIXME: how to pass method name if style is SOAP_DOCUMENT
FIXME: hphpd can be initialized this way as well
FIXME: if it's ErrorType but we've already typechecked we shouldn't typecheck again.
FIXME: if we're missing 'override', but have the decl introducer we should delete it and re-add both in the correct order.
FIXME: implement fallback code completion.
FIXME: in a protocol extension, we really want the extension, not the protocol.
FIXME: individual custom completions
FIXME: instead of resetColor(), we can look into capturing the current active color and restoring it.
FIXME: interface type should be passed in.
FIXME: ld64 crashes resolving relative references to coalesceable symbols.
FIXME: macros FIXME: imported header module
FIXME: make thread-safe
FIXME: mangling 'self' in destructors crashes in mangler.
FIXME: matched ranges output.
FIXME: maybe don't have a default case
FIXME: merge requiresForeignEntryPoint() into getMethodDispatch() and add / an ObjectiveC case to the MethodDispatch enum.
FIXME: more robust way to determine the option type.
FIXME: more specific diagnostics here, handle this case gracefully below.
FIXME: need to know if this is a NativeObject or UnknownObject
FIXME: non-first character matches are all the same.
FIXME: non-fixed offsets
FIXME: non-matches are the same as non-first-character matches.
FIXME: only if the class itself is not marked final
FIXME: only show module part of RawAccessPath
FIXME: only the private imports from the current source file.
FIXME: optional of Any (ugh...)
FIXME: partial application of properties
FIXME: path separators would be handled here, jumping straight to the last component if the pattern doesn't contain a separator.
FIXME: peek into capture lists of nested functions.
FIXME: popular/unpopular API.
FIXME: possibly it could be worth recovering and attempting other inlines within this same recursive call rather than simply propagating the failure.
FIXME: print closures somehow.
FIXME: print condition
FIXME: print container
FIXME: print expression.
FIXME: print guard expr
FIXME: print guard expression
FIXME: print increment
FIXME: print initializer
FIXME: pull out the magic constants.
FIXME: put the attributes into forward source order so we don't need to iterate through them.
FIXME: rdar://14883575 Libcompiler_rt omits muloti4
FIXME: rdar://16320042 - For properties, we don't have a useful location for the 'var' token.
FIXME: rdar://17671977 the initializer for a lazy property has already been moved into its implicit getter.
FIXME: really it would be much better if Sema had stricter phase separation.
FIXME: recursion-breaking hack
FIXME: refactor the frontend to provide an easy way to figure out the correct filename here.
FIXME: register property metadata in addition to the methods.
FIXME: rename from RemoveCondFails to RemoveRuntimeAsserts.
FIXME: rename generatorType to iteratorType due to the protocol renaming
FIXME: repack if not bit-identical
FIXME: replace this condition with something more sane.
FIXME: replace with std::optional, when we have it.
FIXME: replace with std::string and StringRef as appropriate to each case.
FIXME: restructure to use a "switch".
FIXME: revisit this once we get default definitions in protocol bodies.
FIXME: revisit this once we get default implementations in protocol bodies.
FIXME: set ObjCClassFlags::Hidden when appropriate
FIXME: setting buffer_length will cause the destructor to free memory owned by the string
FIXME: should have a semantic context for groups.
FIXME: should warn about unexpected keyword kind.
FIXME: show deduced types, etc, etc.
FIXME: some locale free implementation is really required here,,,
FIXME: some of this work needs to be delayed until runtime to properly account for archetypes dynamically being optional types.
FIXME: some types are provably too big (or aligned) to be allocated inline.
FIXME: source location...
FIXME: specialize diagnostic when there were closure parameters.
FIXME: std::map is lame.
FIXME: substitution means this type should be explicit to improve performance.
FIXME: suggestPotentialOverloads should do this.
FIXME: support 'inout', etc.
FIXME: swiftcall / func printType(forMetadata: Any.Type)
FIXME: swiftcall / func printTypeMemberOffset(forType: Any.Type, memberName: StaticString)
FIXME: swiftcall / func printTypeMetadataMemberOffset(forType: Any.Type, /                                    memberName: StaticString)
FIXME: synthesizeMaterializeForSet() wants to statically dispatch to a known subscript here.
FIXME: take best contained result.
FIXME: that doesn't mean we should physically pass it indirectly at this resilience expansion.
FIXME: that should be Direct_Guaranteed
FIXME: the callee should have a lowered SIL function type, and PartialApplyInst should derive the type of its result by partially applying the callee's type.
FIXME: the canonical type makes a poor signature, because we don't canonicalize away default arguments and don't canonicalize polymorphic types well.
FIXME: the fact that this could resolve in the local scope is dumb.
FIXME: the generic parameter types list should never be empty.
FIXME: the optionality of outputType and the presence of trustInputTypes are hacks for cases where coming up with those types is complicated, i.e., when dealing with generic bridging functions.
FIXME: the pedantically correct way is to resolve Swift.*LiteralType.
FIXME: the rest of body is ignored
FIXME: there might be some interesting cases where this is suboptimal for enums.
FIXME: these checks should apply to the LHS of the operator, not the immediately left expression.
FIXME: these should all be modeled with a DynamicSelfType.
FIXME: this always chooses the first operator with the given name.
FIXME: this assertion is absolutely correct, but it's currently fouled up by the presence of archetypes in substitutions.
FIXME: this assumes that there's never meaningful reabstraction of self arguments.
FIXME: this code is largely duplicated with the previous block.
FIXME: this creates duplicate results.
FIXME: this does not include types that conform to an expected protocol.
FIXME: this has a super-inefficient extraneous simplifyType() in it.
FIXME: this is inefficient.
FIXME: this is not sufficient to establish a total order for overloaded decls.
FIXME: this is wrong, we should try to sub-group.
FIXME: this needs to be target-specific.
FIXME: this should be a placement new but that adds a null check
FIXME: this should be the scope of the type's declaration.
FIXME: this should distinguish between key and value.
FIXME: this should not require variant hops
FIXME: this will assert
FIXME: this works around the fact we're producing invalid completion strings for our inner "." result.
FIXME: try each submodule chain starting from the most specific.
FIXME: uncomment these checks.
FIXME: update output ranges, if necessary
FIXME: update this to be a function pass.
FIXME: use posix_memalign if alignMask is larger than the system guarantee.
FIXME: using the range up to a dot is silly when candidate isn't a file.
FIXME: we can do transforms between two abstraction patterns now Translate to the fully-substituted formal type...
FIXME: we can't use the exclamation mark chunk kind, or it isn't included in the completion name.
FIXME: we cannot resolve members appear later in the body of the nominal.
FIXME: we could try to continue to parse.
FIXME: we could write the results to disk in the background, since they're immutable at this point.
FIXME: we currently emit _CocoaArrayType: _CocoaArrayType.
FIXME: we may not wish to put this in a destructor.
FIXME: we might want to just introduce a separate instruction kind, instead of keeping this invariant.
FIXME: we need a more uniform way to handle operator completions.
FIXME: we need to resolve the set of protocol conformances to do unqualified lookup.
FIXME: we should detect if offset is required but not set.
FIXME: we should fix that, since it also affects struct members, etc.
FIXME: we should get the semantic context of the function, not the operator decl.
FIXME: we should have a callback that would tell us whether it's kosher to print a module name or not
FIXME: we shouldn't double typecheck, but it looks like code completion may do so in some circumstances.
FIXME: we will need to pass additional parameters if the target conformance is conditional.
FIXME: willBeRelativelyAddressed is only needed to work around an ld64 bug resolving relative references to coalesceable symbols.
FIXME: work this into the constraint system
FNV-1 hash each octet in the buffer
FNV-1 hash each octet of the buffer
FPI is within whole func, but we also need to check within the section
FPassM final operations have paramId as imm 0 and stackCount as imm1
FPassV is a no-op when the callee expects by ref.
FPushCuf when the callee is not known at compile time.
FPushFunc consumes method name from stack
FPushFuncD doesn't support class-method pair strings yet.
Facebook specific optimization which depends on versions of MySQL which allow access to the grotty internals of libmysqlclient
Factor the case index into payload and extra tag parts.
Factor the extra tag value from the payload value.
Factor the index into the part that goes in the occupied bits and the part that goes in the spare bits.
Factor the non-fixed-size field's alignment into the total alignment.
Factor the spare and occupied bit values from the index.
Factory for String atoms that are required to match another captured String opcode.
Factory initializers are effectively "allocating" initializers with no corresponding initializing entry point.
Factory methods cannot be overridden.
Facts about a Func's current frame at various program points
Facts about a specific block.
Fail early to avoid further execution of PHP code.
Fail hard if the block isn't code.hot.
Fail if the Elm is a tombstone.
Fail if the Elm key type doesn't match.
Fail if the Elm key value doesn't match.
Fail if the cases are too sparse.
Fail if the input element is named and we're trying to match it with something with a different label.
Fail if this isn't a copy-initialization.
Fail if this isn't a load from a stack slot.
Fail if this isn't a store to a stack slot.
Fail if this isn't an assignment.
Fail if we jitted more than 25kb of code.
Fail if we spent more than 0.5ms in the JIT.
Fail silently, continue running the request.
Fail statements are only permitted in initializers.
Fail the async generator and let the C++ exception propagate.
Fail to open empty path
Failable enum initializer produce a CFG for the return that looks like this, / where the load is the use of 'self'.
Failed to find a type we can extend
Failed to prove anything.
Failed to write file to disk
Failing casts with take_always can release.
Failing inits create critical edges, where all 'return nil's end up.
Failing that, check for subtyping.
Failing that, try to diagnose any type witness that failed a requirement.
Failure already diagnosed, above, as part of applying the solution.
Failure block: branch out to the continuation block.
Failure may not release because no store occurred.
Failure to compile the eval string doesn't count as an assertion failure.
Failure to read the file, just use filename to recover.
Failure to read the file.
Fall back to Swift lowering for the enum's representation as a struct.
Fall back to Swift lowering for the underlying type's representation as a struct member.
Fall back to a generic array get.
Fall back to an unknown, indirect callee.
Fall back to just using the immediate LHS.
Fall back to locale codec
Fall back to old-style constructor: same as class name.
Fall back to our current directory
Fall back to savedFP in that case.
Fall back to the 'Unknown' path.
Fall back to the normal deterministic ordering.
Fall back to the r-value case.
Fall back to unknown entry points if the Objective-C runtime is available.
Fall into the next code completion handler.
Fall out into the normal path.
Fall out to the case below, clearing the name so that createVariable doesn't detect a collision.
Fall though from the currently active block into the given block.
Fall though to the call to PARSE_ERROR() below
Fall through to build the member reference.
Fall through to mangle the name.
Fall through to merge it with following T_INLINE_HTML tokens
Fall through to produce diagnostics.
Fall through to record the raw type.
Fall through to record the superclass.
Fall through to the check below, since this could be a type alias to an enum type
Fall through to the fully-generic JmpSwitchDest at the end if nothing matches.
Fall through to the trivial-implementation case.
Fall through, as to match Zend, the warning below should also be raised
Fall-through to the default case, since we still need to print the character.
Fallback default implementation.
Fallback implementation of curl_multi_select()  This allows the OSS build to work with older package versions of libcurl, but will fail with file descriptors over 1024.
Fallback to TypeRepr.
Fallback to pointer kind
Fallback to showing the default type.
Fallback, callers will handle this as an error
Fallthrough and use default collator
Fallthrough from here on is side-exiting due to an InvalidSetMException.
Fallthrough should signal a normal exit by returning 0.
Fallthrough transfers control to the next case block.
False if constant propagation could do the same job inside the callee without inlining it.
False means the machine is running and we need to wait for another interrupt.
FalseBB has already been inserted somewhere unless there's a continuation block.
Family of relative op functions.
Fast case sensitive comparison, unrolled to do 8 bytes at a time.
Fast case: copy from a known address in the Class
Fast path -- if both functions were unwrapped from a CanSILFunctionType, we might have pointer equality here.
Fast path changes that don't change the type.
Fast path for bridging types in a function type without uncurrying.
Fast path for classes with no declared properties
Fast path for files that exist
Fast path for zero-argument selectors.
Fast path the common case that elems is mixed.
Fast path: The requested capacity is greater than the current capacity.
Fast path: There are no tombstones and the requested capacity is less than or equal to the current capacity.
Fast path: avoid an unnecessary temporary explosion.
Fast path: check the invasive cache.
Fast path: element 0 is always at offset 0.
Fast path: if the results of the original type are not type-dependent, we can just copy them over.
Fast path: if the types match exactly, no abstraction difference is possible and we can just materialize as normal.
Fast path: if the unsubstituted type from the variable equals the substituted type from the l-value, there's nothing to do.
Fast path: if this isn't a subscript, just use whatever we have.
Fast path: no re-abstraction required.
Fast path: no uncurrying required.
Fast path: this associated type declaration declares the desired conformance.
Fast path: we don't have a tuple.
Fast-path a really common case.
Fast-path check for equality.
Fast-path the empty tuple type.
Fast-path the empty tuple.
Fast-path, if the needles just not there, or if it is and the haystack is ascii (meaning the needle must have been as well) Then we can skip the ICU overhead and return
FastCGITransport doesn't run in the same event base.
Fatal if any arguments are pass by reference
Fatal if any arguments are variadic
Fatal if protected/private or if the staticness is wrong
Fatal if the number of arguments is wrong
Fault and catch protected region starts in order.
Fault entries have a few things to assert.
Fault funclets can have protected regions which may point to handlers that are also listed in parents of the EH-region that targets the funclet.
Fault funclets don't actually fall in the EHEnt region for all of their parent handlers in HHBC.
Favor an UnsafeMutablePointer-to-UnsafeMutablePointer conversion.
Favor binary operator constraints where we have exact matches / for the operands and contextual type.
Favor certain overloads in a call based on some basic analysis / of the overload set and call arguments.
Favor types, as appropriate.
Favor unary operator constraints where we have exact matches / for the operand and contextual type.
Feature name is required
Feed the cast result into the nonnull branch.
Feed the corresponding result into the phi nodes.
Feed the object pointer to object_getClass.
Feed this result into the outter hash
Fetch a global reference to a reference to the given Objective-C class.
Fetch a global reference to the given Objective-C class.
Fetch a global reference to the given Objective-C metaclass.
Fetch all the options from the options array
Fetch from PreClass as: - the order is important - we want type profiling info and neither of these are in the Class...
Fetch the cache for a generic witness-table structure.
Fetch the class in the inheritance tree which first declared the property
Fetch the ctx hash value
Fetch the declaration of a metaclass object.
Fetch the declaration of the ivar initializer for the given class.
Fetch the declaration of the metaclass stub for the given class type.
Fetch the declaration of the metadata (or metadata template) for a / type.
Fetch the error result slot received from the caller.
Fetch the error result slot.
Fetch the lazy access function for the given conformance of the / given type.
Fetch the lazy witness table access function for a protocol conformance.
Fetch the metadata as a tuple type.
Fetch the metadata cache for a generic metadata structure, / in a context where it must have already been initialized.
Fetch the metadata cache for a generic metadata structure.
Fetch the metadata for that class.
Fetch the next record.
Fetch the object (without resetting its last error code ).
Fetch the right item from the history
Fetch the serialized module bitstreams from the Mach-O files and register them with the module loader.
Fetch the type metadata access function for a non-generic type.
Fetch the type metadata access function for the given generic type.
Fetch the value separately.
Fetch the witness table access function for a protocol conformance.
Fetch value of varName only, so that we can recover nicely when its value is too large to serialize.
Fetching non-WSDL mode options
Few of the cell counts will overflow, and clamping those that do overflow to the maximum value will give close- enough results.
Field reading functionality
Fields are imported as variables.
Figure out /which/ dependencies are missing.
Figure out for each predecessor which branch of the dominating checked_cast_br is used to reach it.
Figure out how many extraneous, missing, and wrong labels are in the call.
Figure out if a declaration should be exported to Objective-C.
Figure out if the value of this variable is statically known.
Figure out if we need the value to be in a temporary.
Figure out locations the call may cause stores to, then remove any memory support on those locations.
Figure out previous argument names from the parameter bindings.
Figure out the (non-builtin) argument type if there is one.
Figure out the actual base type, and whether we have an instance of that type or its metatype.
Figure out the class in which this method occurs.
Figure out the class in which this subscript occurs.
Figure out the context we're substituting into.
Figure out the curried 'self' type for the interface type.
Figure out the declaration context to use when opening this type.
Figure out the declaration context we're importing into.
Figure out the declaration context where we'll get the generic parameters.
Figure out the declaration of the existing conformance.
Figure out the exact bound type of the function to be called by applying all substitutions.
Figure out the first parameter name.
Figure out the index and result types.
Figure out the initializing sequence for each of the properties.
Figure out the instance type used for the base.
Figure out the interface type of the parent.
Figure out the name for this argument, which comes from the method name.
Figure out the name for this parameter.
Figure out the non-fixed offsets.
Figure out the offset to the first element, which is necessary to be able to polymorphically project as a generic box.
Figure out the parameter type, accounting for the implicit 'self' if necessary.
Figure out the parameter type.
Figure out the protocol, requirement, and potential witness.
Figure out the representative for this type variable.
Figure out the source location to emit the diagnostic to.
Figure out the source location.
Figure out the string type we're converting to.
Figure out the tag and payload for the empty case.
Figure out the type of the container.
Figure out the type of the declaration that we're using for comparisons.
Figure out the type of the indices.
Figure out the type that's explicitly conforming to this protocol.
Figure out the type we're converting to.
Figure out what import to suggest.
Figure out what kind of constructor this will be.
Figure out what kind of optional it is.
Figure out what stream we are supposed to write to...
Figure out what they are.
Figure out what type the constraints decided on.
Figure out what types the constraints decided on.
Figure out what we're actually required to pass:
Figure out what we're actually still required to pass
Figure out where this requirement came from.
Figure out where to finish removing this element.
Figure out where to look for the counterpart.
Figure out where to start removing this argument.
Figure out whether there will be a default argument for this parameter.
Figure out whether we need an explicit 'class' in the inheritance.
Figure out which arena this conformance should go into.
Figure out which basic blocks contain back-edges to the loop header.
Figure out which buffer contains this location.
Figure out which class this can affect.
Figure out which declaration to print.
Figure out which field we're walking into.
Figure out which one we have here by inspecting the next byte.
Figure out which parameter it is.
File is a reparse point.
File is not in the PWD.
File may not exist, continue and recover as if it was empty.
File upload stopped by extension
File upload successful
File written with different format.
FileScope's flags are from parser, but VariableTable has more flags coming from type inference phase.
Filesystem and Streams Configuration Options
Fill depths with BFS over module imports.
Fill in dynamic args (3..6) as needed
Fill in in reverse order, since they may come from popC's (depending on what loadParam wants to do).
Fill in offsets for the first non-zero case and default
Fill in the Elements array.
Fill in the `self` space.
Fill in the context pointer if necessary.
Fill in the metaclass pointer.
Fill in the pointer from the metadata to the VWT.
Fill in the provided part of the requirements from the pattern.
Fill in the rodata reference in the class.
Fill in the rodata reference in the metaclass.
Fill in the special destinations array.
Fill in the substitution and conformance maps.
Fill in the type and value.
Fill out an array with the field type layout records.
Fill out an array with the field type metadata records.
Fill the entire 16-byte space for a TypedValue with trash.
Fill the first block predictions with the live types.
Fill the input buffer --- called whenever buffer is emptied.
Fill the inverse-colormap entries in the update box that contains
Fill this special destination with a value.
Filled in by the runtime.
Filled in during parsing.
Filter any whole-module imports, and skip specific-decl imports if the import path doesn't match exactly.
Filter by private-discriminator, or filter out private decls if there isn't one...unless we're already in a private context, in which case everything is private and a discriminator is unnecessary.
Filter out "fileNames" that don't actually exist
Filter out all servers that don't have the replicaset name the same as what we have in the server definition struct.
Filter out any subclasses that do not inherit from this specific bound class.
Filter out anything that couldn't satisfy one of the requirements or was used to satisfy a different requirement.
Filter out bits and pieces that no longer exist due to other components going to Bottom, starting with bits.
Filter out declarations from other modules.
Filter out designated initializers, if requested.
Filter out duplicated inferred types as well as inferred types that don't meet the requirements placed on the associated type.
Filter out duplicates.
Filter out global variables.
Filter out inappropriate overloads.
Filter out lexer errors for placeholders.
Filter out redundant requirements.
Filter out redundant results early.
Filter out the duplicates.
Filter out those results that have been removed from the found-declarations set.
Filter the candidate list based on the argument we may or may not have.
Filter window size (of affecting source pixels)
Filtered Image Rescaling Based on Gems III - Schumacher general filtered image rescaling (pp.
Final case is the default, and must have a litstr id of -1.
Final elem ops This is a helper for final defining Elem operations that need to handle array chains and frame effects, but don't yet do anything better than supplying a single type.
Final functions never require ObjC dispatch.
Final methods can be statically referenced.
Final new elem ops This is a helper for final defining Elem operations that need to handle array chains and frame effects, but don't yet do anything better than supplying a single type.
Final properties can always be direct, even in classes.
Final stats, per-function per-callsite, with a count of how many times the function was called from that callsite.
Finalize the DIBuilder.
Finalize the generic requirements.
Finalize the given generic parameter list, assigning archetypes to / the generic parameters.
Finalize the imported declaration.
Finalize the lookup table, which may fail.
Finalize this solution.
Finally add the parent to the worklist.
Finally apply defaults from config file
Finally delete the closure.
Finally dump the output.
Finally ensure that we have no users of this operand preceding the release_value in this BB.
Finally generate calls to all custom functions.
Finally just use the default value
Finally materialize and return the forwarding SILValue.
Finally swap the number of arguments that we have.
Finally we can erase the epilog BB.
Finally we try to sink retain instructions from this BB to the next BB.
Finally, a file is considered to be international text from some other character code if its characters are all either ISO-8859 (according to the above definition) or characters in the range 0x80 ...
Finally, any removed frame pointers in BCMarkers must be rewritten to point to the outer frame of that frame.
Finally, call the setter.
Finally, collect all the values for the SILArgument, materialize it using the SSAUpdater.
Finally, compute the proper type for the closure.
Finally, decref the old value
Finally, delete the dead stores and create the live stores.
Finally, emit the continue block and keep emitting the rest of the condition.
Finally, emit the epilog and post-matter.
Finally, evaluate into the buffer.
Finally, generate new retains and remove the old retains.
Finally, if there's a suffix layout, and the suffix begins at offset 0, than the suffix layout can completely subsume the original layout.
Finally, instantiate object and call constructor
Finally, load the submodule and make it visible.
Finally, make sure any volatile locals are set to Gen, even if they are parameters.
Finally, now that we know the value is uninitialized on all paths, it is safe to do an unconditional initialization.
Finally, perform the redundant load replacements.
Finally, print out the result, by referring to the repl temp.
Finally, print the variable's value.
Finally, record various metadata about the translation and add it to the SrcRec.
Finally, set the body.
Finally, sort and reassign slots so the most frequently used slots come first.
Finally, update m_instanceBits on every Class that currently exists.
Finally, update m_used and return
Finally, use the results of all these iterations to perform optimization.
Finally, we pad on the right.
Find 'key' in concurrent_unordered_map 'map'.
Find Id for the given name.
Find MemberRefExprs that have an implicit "self" base.
Find Self references within the given requirement.
Find a / value that is trivially RC-identical to V and dominates the argument's / block.
Find a Store whose destination is taken from an init_enum_data_addr whose address is same allocation as our inject_enum_addr.
Find a bridged type, which may be different
Find a case corresponding to this value
Find a default initializer in the superclass.
Find a dominating checked_cast_br, which performs the same check.
Find a function marked with the LLDBDebuggerFunction attribute instead.
Find a location that dominates all users.
Find a new position for an ApplyInst's FuncRef so that it dominates its / use.
Find a path from the given set of origins to the destination / protocol.
Find a potential best.
Find a reasonable color
Find a set of get_element calls that can be replace by the initialization / value of the array allocation call.
Find a set of uses that the given copy can / forward to and replace them with the copy's source.
Find a solution that's at least as good as the solutions that follow it.
Find a standin declaration to place the diagnostic at for the given accessor kind.
Find a strong iterator slot that is empty.
Find a witness to the fact that a type is a value type.
Find all IncRefs in the unit.
Find all blocks reachable from the entry block.
Find all dealloc instructions for AI and then chop them up.
Find all functions which are alive from the beginning.
Find all methods to be imported.
Find all non-back-edge predecessors.
Find all of the declarations with this name in the Swift module.
Find all of the declarations with this name in the appropriate module.
Find all of the members that aren't used to satisfy requirements, and check whether they are close to an unsatisfied or defaulted requirement.
Find all of the named, unclaimed arguments.
Find all of the named, unfulfilled parameters.
Find all of the unfulfilled parameters, and match them up semi-positionally.
Find all the RC roots in the function.
Find all the epilogue releases for this argument.
Find all the predecessors before the SSA update.
Find all the return blocks in the function, inserting a dealloc_stack before the return.
Find an arc with max weight and merge its nodes
Find an enum element in an enum type.
Find an exiting block.
Find an extension in the requested module that has the correct generic signature.
Find an unqualified enum element.
Find anchors in vtables and witness tables, if required.
Find and dump the epilogue release instructions for the arguments.
Find and set the parent loop for each loop, if it exists.
Find any entries that are superseded by other entries.
Find array object lifetime.
Find back edges in the CFG.
Find based on selector within the current type.
Find beginning of salt string.
Find best predecessor.
Find blocks associated with exception handlers.
Find canonical induction variables.
Find compiled pattern matcher in hash map or add it.
Find entries for this base name.
Find everything which may not be eliminated, e.g. because it is accessed externally.
Find functions in cold blocks which are forced to be inlined.
Find instruction boundaries and branch instructions.
Find last attribute in node
Find library intrinsic function.
Find max message size
Find msg and whether it contains "isdbgrid"
Find number of covering value and concrete values for the locations expanded from the given location.
Find or create a translation for `args'.
Find or create the best match
Find or insert 'key' into concurrent_unordered_map 'map'.
Find other potential definitions.
Find our first letter
Find out how many processes are using this semaphore.
Find out if the apply instruction contains any substitutions for a method itself, not for the class where it is declared.
Find out if we are dealing with Builtin.staticReport().
Find out if we have any available values.
Find out where the next varargs element is coming from.
Find out whether this sandbox is being debugged.
Find out which linkage it has.
Find pattern binding declarations that have initializers.
Find read preferences tags
Find safe array bounds check in a loop.
Find some Decl that contains the reference range.
Find starting text node
Find that offset into the metadata.
Find the "best" constructor with this signature.
Find the "best" method that has this selector, so we can report that.
Find the "primary" potential archetypes, from which we'll collect all of the requirements.
Find the (unspecialized) conformance.
Find the / lifetime endpoints reached by each store of a refcounted object into the / object.
Find the ARC Users and the final retain, release.
Find the AST node for the defining module.
Find the Clang module unit that stores the class.
Find the EHEnt for the fault funclet that off is inside of.
Find the Md5 for this path, and then the unit for this Md5.
Find the Nth argument passed to BB.
Find the SILFunction for the ivar initializer or destroyer.
Find the Swift class being extended.
Find the ValueDecl given a type and a member name.
Find the _BridgedToObjectiveC protocol.
Find the _ObjectiveCBridgeable protocol.
Find the _bridgeToObjectiveC requirement.
Find the _unconditionallyBridgeFromObjectiveC requirement.
Find the actual type of the source.
Find the adjacency information.
Find the appropriate function type.
Find the appropriate injection function.
Find the appropriate object literal protocol.
Find the archetype information.
Find the argument type.
Find the argument types.
Find the beginning of the field offset vector in a struct's metadata.
Find the best default witness for the requirement.
Find the best dominating 'open' for each open existential.
Find the best witness for the requirement.
Find the bit count, if any.
Find the bucket for the metadata entry.
Find the builtin "once" call.
Find the builtin argument type we'll use.
Find the builtin in the Builtin module
Find the builtin method.
Find the canonical protocols.
Find the chain for the key.
Find the check_subscript call.
Find the close bracket so we can overallocate the set.
Find the closest colormap entry for each cell in the update box, given the list of candidate colors prepared by find_nearby_colors.
Find the closest matching unfulfilled named parameter.
Find the closing ')'.
Find the code that performs the initialization first.
Find the code-completion expression and operator again.
Find the conformance and dig out the type witness.
Find the conformance for the protocol we're interested in.
Find the conformance information for a protocol.
Find the conformance of the origin to the associated type's protocol.
Find the conformance of the value type to _BridgedToObjectiveC.
Find the conformance record.
Find the conformance to _ObjectiveCBridgeable.
Find the corresponding lookup table.
Find the corresponding named element.
Find the corresponding string match and substitute it in instead of the backref
Find the counterpart.
Find the database and username
Find the decl for the protocol name.
Find the declaration that derives the protocol conformance.
Find the depth of the 'Self' parameter.
Find the depth of the function's own generic parameters.
Find the destructor name via SILDeclRef.
Find the destructor of the type.
Find the digit sequence.
Find the disjunction of fallback constraints.
Find the elements we need to touch.
Find the end of the year.
Find the entry point for a SIL function.
Find the entry point.
Find the exit condition.
Find the extended class.
Find the extraneous type variable.
Find the final releases of the alloc_box along any given path.
Find the final tailcnt chars of str, accounting for UTF-8.
Find the first colon.
Find the first compilation unit which at least partially lies within the range given by the begin parameter.
Find the first identifier bound by the given binding.
Find the first non invalidated node.
Find the first predecessor, the first terminator and the Nth argument.
Find the first retain of the pointer.
Find the first space in the command.
Find the first unreachable block in the switch so that we could use it for better diagnostics.
Find the foreign error convention and 'self' parameter index.
Find the foreign error convention if we have one.
Find the function that's actually got an entry in the metadata.
Find the generic implementation declaration for the named syntactic-sugar / type.
Find the generic parameters.
Find the generic type that implements this syntactic sugar type.
Find the getter indices and make sure they match.
Find the global variable.
Find the globalinit_func by analyzing the body of the addressor.
Find the immediate dominator of each block using Cooper, Harvey, and Kennedy's "A Simple, Fast Dominance Algorithm", returned as a vector of Block*, indexed by block.
Find the implementation for the given "intrinsic" library function.
Find the implementation of the member which should be invoked.
Find the implementation of the named type in the given module.
Find the indentation used on the indentation line.
Find the index of the argument corresponding to our partial apply.
Find the initial set of blocks where the value is live, because it is used in those blocks.
Find the initial set of instructions in this function that appear to be live in the sense that they are not trivially something we can delete by examining only that instruction.
Find the initialization function.
Find the initialization point of the / copy's source and replace the initializer's address with the copy's dest.
Find the initializer and the SILGlobalVariable.
Find the initializer we chose.
Find the innermost enclosing declaration with an availability range annotation and ensure that this attribute's available version range is fully contained within that declaration's range.
Find the innermost generic context and stash it in DeclCtx.
Find the interface, if we can.
Find the last * in pat and count chars needed after it
Find the last child DIE which does not start with the begin/end range.
Find the last component of the given lvalue and derive a base / location for it.
Find the last element with a known offset.
Find the last instance of the first word in the name within the words in the type name.
Find the last preposition in the given word.
Find the last preposition.
Find the layout metadata pointers for these elements.
Find the least common ancestor of the two paths, then modify the active list by popping and then pushing nodes to set it to the new block's path.
Find the library intrinsic.
Find the list of entries for this base name.
Find the local history of this macro directive.
Find the location at which we should insert the new initializer.
Find the location of optionality, below.
Find the locations that this basic block defines and the locations which we do not have a concrete value in the current basic block.
Find the locators which have the largest numbers of distinct overloads.
Find the lookup table entry for this base name.
Find the lookup table.
Find the lowest Slot that doesn't conflict with anything in the conflict set for iface.
Find the mapped instruction.
Find the matching ID.
Find the maximum compressed chunk size.
Find the maximum-sized builtin float type.
Find the maximum-sized builtin integer type.
Find the member used to satisfy the named requirement.
Find the metadata pointer for this element.
Find the microseconds that need to be truncated
Find the module the extension is declared in.
Find the molad of Tishri closest to this date.
Find the name directly bound by this pattern.
Find the named requirement.
Find the nearest containing function or nominal decl.
Find the nearest post-dominator that has useful instructions.
Find the next combination.
Find the node for this type variable.
Find the nominal type decl related to VD.
Find the nominal type declaration and its parent type.
Find the origin's type metadata.
Find the original declaration, from which we can determine the owning module.
Find the original method/property declaration and retrieve the name from there.
Find the other accessor, if it exists.
Find the overload choice used for this declaration reference.
Find the overload for Int.
Find the owner of this method and determine whether it is the class we're looking for.
Find the perpendicular distance from point C (px, py) to the line segment AB that is being drawn.
Find the placeholder.
Find the point at which the depth changes.
Find the potential archetypes.
Find the predecessor TransIDs along each non-back-edge predecessor of the loop header.
Find the property names.
Find the protocol decl.
Find the protocol layout.
Find the pure Objective-C superclass.
Find the real name of path, by removing all ".", ".." and symlink components.
Find the release to match with the unsafeGuaranteedValue.
Find the relevant insertion points for the loop region R in its successors.
Find the replica set name
Find the representative.
Find the representatives for the member type variables.
Find the return BB of F.
Find the sanitizer kind.
Find the selected member.
Find the self index for the getter.
Find the self index for the setter.
Find the set of enum elements for the type so we can verify exhaustiveness.
Find the set of loop headers.
Find the set of property names.
Find the shared object embedded within a custom section.
Find the single ivar.
Find the smallest number of value witnesses found in protocol extensions.
Find the source range covering the full name.
Find the source ranges of extraneous default arguments within a / call to the given function.
Find the splittable box with the largest (scaled) volume
Find the splittable box with the largest color population
Find the standard type of exceptions.
Find the start of the given line.
Find the start of the year.
Find the start value.
Find the store instruction
Find the store instruction and turn it into return.
Find the string interpolation protocol we need.
Find the substituted storage type.
Find the substitution info for the witness type.
Find the superclass type that matches where the conformance was declared.
Find the superclass type with the context matching that of the member.
Find the tag associated with our BB and set the state of the enum we switch on to that value.
Find the target JumpDest based on the target that sema filled into the stmt.
Find the tentative type witness for this associated type.
Find the top-level ValueDecl or Module given a name.
Find the type checked version of the LiteralExpr used for the raw value.
Find the type variable associated with the function, if any.
Find the type variables and overload locators common to all of the solutions.
Find the type we bridge to.
Find the typealias given a builtin type.
Find the underlying condition value of the cond_fail.
Find the unique declaration that has the right kind.
Find the unsatisfied requirements with the nearest-matching names.
Find the values that this basic block defines and the locations which we do not have a concrete value in the current basic block.
Find the vtable entry.
Find the witness table.
Find the witness we need to use.
Find the witness we're interested in.
Find this symbols recurse level
Find top-level declarations with the given name.
Find trait methods to be imported.
Find translations that belong to the selectedFuncId Also returns the max prof count among them
Find two types that conflict.
Find where the field offsets begin.
Find which one, then add edges to reachable catches and the enclosing fault funclet, if any.
Finding an element not in the map would therefore never terminate.
Finding the date and time of the new moon (or molad) is the first step.
Finding the first day of the year is the most difficult part.
Finds the enclosing CallExpr, and indicates whether it should be further / considered a candidate for application of trailing closure.
Finds the expansion factor, i.e. the square root of the factor by which the affine transform affects area.
Finds the preceding check_subscript, make_mutable call or returns nil.
Finds the specified class.
Finds the specified field of the specified class.
Finds the specified method of the specified class.
Finds the unvisited blocks in the CFG by doing a reverse DFS starting at `block', and adds them to `blocks'.
Fine to have unbound generic types.
Finish all the component tuples.
Finish building an optional Some in the given address.
Finish emitting guards, and emit profiling counters.
Finish off any diagnostic we were in the process of emitting.
Finish off the epilog by returning.
Finish the "true part" by cleaning up any temporaries and jumping to the continuation block.
Finish the check for one value being a non-escaping local object.
Finish the first scheduled task.
Finish the given protocol conformance (for an imported type) / by filling in any missing witnesses.
Finish the mangling of the symbol and return the mangled name.
Finish the result type.
Finish the type name.
Finish up at the end of each pass.
Finish whatever is left over.
Finished copying the file, now load it.
Finished iterating---we need to free the array.
First 256 symbols are for conversion from koi8-r to corresponding charset, second 256 symbols are for reverse conversion, from charset to koi8-r.
First 32 bits are reserved for ICU-specific flags.
First add the blocks that QueryNode is directly control-dependent on.
First add to NewParameterInfoList all of the SILParameterInfo in the original function except for the closure.
First allocation is just for 2 elements, since we don't know if this scanner will even need a stack.
First arg is pointer to storage for that return value
First argument is inout but no lvalue present.
First attempt to get the BB where this value resides.
First attempt to lookup the Object in our internal maps.
First attempt to lookup the origin for our class method.
First attempt to see if we can narrow it down to a single function based on the conformance.
First char of hostname must be alphanumeric
First check for a self-move.
First check for an existing connect, and reuse that.
First check if it is possible to convert all arguments.
First check if the module contains a required specialization already.
First check if there are escape paths which we don't explicitly see in the graph.
First check if we have a function.
First check that std::is_constructible counts explicit conversion operators.
First child is number.
First comparison already proves they are different
First consider if we've got internal breakpoints setup.
First demangle any specialization prefixes.
First directory starts at offset 8.
First dive into the inner loops.
First do 50 LIFO, then 50 FIFO.
First do a basic check, mainly based on the type of instruction.
First drop all references so that we don't get problems with non-zero reference counts of dead functions.
First fill the request local method cache for this call.
First find the first non-payloaded enum.
First fix up some of the indexed types so that they're in a consistent state.
First forward any copies that implicitly destroy CurrentDef.
First generate calls to the scanner to record all the pointers.
First get the path to a state where we don't have ..
First grab the NonPayloadedEnumBB and RCIdentityBB.
First handle allocations.
First handle options.
First handle the tuple case.
First if one instruction is a gep and the other is not, canonicalize our inputs so that V1 always is the instruction containing the GEP.
First if our UADCI has not users, bail.
First in stack is the top-level "key.entities" container.
First include all other files in the module.
First increment the byte count.
First initialize the descriptor Notice that if no length is given, we initialize buf_end to the highest possible address.
First instruction is always either li or lis, both are D-form
First is character offset, second is its token offset.
First iterate over every DIE, finding all object types and computing their names (and linkage).
First look at the origin of V and see if we have any instruction that is a typed oracle.
First look for a type with the same name in the same compilation unit.
First look for an exact match
First make sure that IncomingEdgeBB dominates NonPayloadedEnumBB.
First make sure that both of our base types are the same.
First make sure that the prefix matches.
First make sure that we are actually a function argument.
First make the inst's next block, so we can save state to it in finishBlock.
First map the callee parameters to the caller arguments.
First merge memory support information.
First move last chars to start of buffer.
First new DefInlineFP instructions are inserted at exit heads and all exit blocks are updated to use these new frame pointers, inserting phi nodes where necessary.
First of all, if we have zero or one columns, this is trivial to decide.
First order types according to what category of type they are, using the below arbitrary ranking.
First pass of IRBuilder optimizations try to replace an instruction based on tracked state before we do anything else.
First pass, identify the easy(common) case of modules with no dependencies and put that at the front of the list defer all other for slower resolution
First phase: analysis.
First populate a worklist of predecessors.
First read in the parameter counts at each depth.
First record added should be for bytecode offset zero.
First remove any block not reachable from the entry.
First resume is always next() which pushes null.
First rewrite predecessors of the loop header to point at the loop.
First scan the whole function and add relevant instructions as use-points.
First see if native getter is implemented.
First see if native setter is implemented.
First see if we find it in the registered memory buffers.
First set ArgValue to a used albeit invalid, empty ArgumentSource.
First simplify instructions generating branch operands since that can expose CFG simplifications.
First sort the types.
First specialize user-code.
First split the entry BB, moving all instructions to the FailedTypeCheckBB.
First step: collect all the functions we want to inline.
First step: compute the length of the blocks.
First step: find blocks which end up in a no-return block (terminated by an unreachable instruction).
First step: replicate the points-to edges and the content nodes of the source graph in this graph.
First strip off RC identity preserving casts.
First strip off any RC identity preserving instructions.
First synchronize registers.
First task, set up the value argument list.
First test a case that we can represent.
First the ApplyInst args.
First thing to do: find the current buffer containing the specified location to pull out the source line.
First thing: canonicalize swift_retain and similar calls so that nothing uses their result.
First time that it crashed.
First to limit compile time, second to make sure that the loop terminates.
First try and grab the single predecessor of our parent BB.
First try gdRealloc().
First try to create a Projection for User.
First try to decide what to do without reference to lookahead token.
First try to detect BOM: ZERO WIDTH NOBREAK SPACE (FEFF 16) since we have no encoding support for the BOM yet we skip that.
First try to find exact match, afterwards try wildcard matches
First try to load the ini setting
First try to look up R from the lookup table.
First try unwrapping optionals.
First update uses of the value.
First value is a string (our number value)
First we check for the global (connection string) default
First we check whether the link already has database/username/password set.
First we create a hash for the password to store (md5(pid,password,username))
First we create an empty function (i.e. no BB) whose function signature has had its arity modified.
First we determine the argument type.
First we grab the session name from the ini settings, then the id from the cookies
First we have the histogram data structure and routines for creating it.
First we pad on the left.
First we prefer primary over secondary, and if the field type is the same, we sort on ping_ms again.
First we prefer secondary over primary, and if the field type is the same, we sort on ping_ms again.
First we set PCRE_NOTEMPTY and try the match again at the same point.
First we try "w", and if that is not found we check for "safe"
First we'll rewrite any partial applies that we can to remove the box container pointer from the operands.
First, 510 dates from a table in "Jewish Calendar Mystery Dispelled" were calculated and compared to the table.
First, analyze all direct subclasses.
First, bail out if there are no local captures at all.
First, bind type metadata for Self.
First, build the metaclass object.
First, call the failure callback for 'class' if we didn't do so above
First, check for an accessor.
First, check for attributes that denote the classification
First, check for characters for which JSON has custom escape sequences.
First, check for the static local singleton pattern...
First, check if there is a Phi value in the current block.
First, check if there is a function with a required name in the current module.
First, check if we already had a superclass.
First, claim all the indirect results.
First, close any protected EH regions that are past-the-end at this offset.
First, collect all the properties we'll need to match on.
First, collect current available locations and their corresponding values into a map.
First, construct an abstraction pattern and parameter sequence which we can use to emit the inner tuple.
First, find proper list of substitutions for the concrete method to be called.
First, find the corresponding protocol.
First, gather the sorted list of base names.
First, get a function type for the constant.
First, get a mangled name for the declaration.
First, grab a write lock on s_instanceCounts and grab the current set of counts as quickly as possible to minimize blocking other threads still trying to profile instance checks.
First, handle the effects of the store on memory support.
First, if the base type is an int and we have a string containing an int, do the coercion first.
First, if we're reading from stdin and we don't have a directory, output to stdout.
First, indirect results.
First, lower at the AST level by uncurrying and substituting bridged types.
First, lower the method type.
First, make sure that parent classes have their traits imported.
First, make sure the used trait is flattened.
First, mark every (non-interface, non-special) method as AttrNoOverride.
First, pick the region starting at the lowest bytecode offset.
First, pre-check the expression, validating any types that occur in the expression and folding sequence expressions.
First, satisfy any associated type requirements.
First, see if the field type vector has already been populated.
First, see if this is a predefined type.
First, set the depth of each generic parameter, and add them to the archetype builder.
First, the effects of PureStores on memory support.
First, the formal parameters.
First, the terminals, then, starting at YYNTOKENS, nonterminals.
First, try to get user-specific magic file
First, try to use the stated explicit conformances to determine where the conformance should go.
First, type check the nominal decl that contains the function.
First, type check the parent DeclContext.
First, we deal with  platform-specific or compiler-specific issues.
First, we try to find the map from cache.
First, when we are code completing "x.
First, write out the metadata.
First-letter-case insensitive.
Fix "XDebug" turning into "x_debug".
Fix PHIs (incoming arguments).
Fix all predecessors.
Fix build on Windows/old versions of ICU
Fix didn't work, let diagnoseFailureForExpr handle this.
Fix in 1.3: count a vertex only once
Fix predecessor sets for the successors.
Fix successor sets for the predecessors.
Fix the AST and determine the insertion text.
Fix the argument label.
Fix the argument names that need fixing.
Fix the argument names.
Fix the intrinsic call here by pointing it to the correct GV.
Fix the lifetime of a live value.
Fix the name of the function itself.
Fix the name of the witness, if we can.
Fix the name, if needed.
Fix the types when we've imported into a protocol.
Fix this by replacing 'Self' with the nominal type name.
Fix up any forward jumps that reference to this Label
Fix up argv to have the right type.
Fix up the EmitterVisitor's table of jump targets
Fix up the string parameters to have the right type.
Fixed by Mao Morimoto 2.0.16
Fixed point to double
Fixed point to integer
Fixed-layout global variables don't get accessors.
Fixed-size enums don't need dynamic metadata initialization.
Fixed-size enums don't need dynamic witness table initialization.
Fixed-size loadable enums are represented as explosions of values, the address-only lowering uses more general operations.
Fixed-size optimizations can be applied if all payload types are fixed-size from this resilience scope.
Fixup SSA form for loop values used outside the loop.
Fixup local ids, in case we removed any.
Fixup the exit blocks.
Flag it as error (or warning, if in playground mode) for the rest of the compiler pipeline and lex it as an identifier.
Flag that this translation has been retranslated, so that it's not retranslated again along with the function body.
Flag which is used to allow yywrap()'s to do buffer switches instead of setting up a fresh yyin.
Flags about the existence of various magic methods, or whether any derived classes may have those methods.
Flags liveness optimization.
Flags that can be used to control name lookup.
Flat out, if we need more space than the buffer provides, we always have to allocate.
Flatten parameter packs as if they were just a normally provided parameter list.
Flatten the parameters from innerExtents into innerParams, and fill out varargsAddrs if necessary.
Flattened inner parameter sequence.
Flattens one level of optional from a nested optional value.
Flip args and do the above.
Floating literals must have '.', 'e', or 'E' after digits.
Floating point operations
Flow control cmds do their work in onSetup() and onBeginInterrupt(), so there is no real work to do in here.
Flow control commands only belong to sticky thread
Flush any pending writes and close, calling close() will immediately call readEOF and prevent any further attempts to write data.
Flush out information for old buffer.
Flush the cache if the size of the cache is too large.
Flush the current conformances.
Flush the final conformances.
Flush the packet to disk, and reset the accumulator
Flush whatever access logs are still pending
Fold 'T.Type' or 'T.Protocol' into a metatype when T is a TypeExpr.
Fold (T) into a type T with parens around it.
Fold LHS and RHS together and declare completion.
Fold a tuple expr like (T1,T2) into a tuple type (T1,T2).
Fold archetypes to unique exemplars.
Fold comparison predicates.
Fold constant division operations and report div by zero.
Fold for integer constant arguments.
Fold sequence expressions.
Fold the dependent member types within this type.
Fold the result into the optional evaluation or try.
Folding JmpZero and JmpNZero.
Follow derived types until we reach a type that reports back a size.
Follow gcc/clang behavior and use stdout for --version and stderr for -v.
Follow links unless 'follow' is false and this is the last path component.
Follow the chain of projections and check if it ends up with a load.
Follow the superclass chain.
Follow this metadata path.
Following code is based on apache_multipart_buffer.c from libapreq-0.33 package.
Following if block primarily used for inserting nodes created via createElementNS
Following the path automatically caches at every point along it, including the end.
Following this call, BreakPointInfo::breakable will return false until a subsequent call to BreakPointInfo::setBreakable with a lower or equal stack level.
Following this call, BreakPointInfo::breakable will return true until a subsequent call to BreakPointInfo::unsetBreakable with the same or higher stack level.
Fonts can be used across multiple images
FooSomeEnumeration belongs inside "Foo", but we haven't actually seen "Foo" yet.
For "self" and "parent", knownConstraint should always be non-null at this point
For 'let' bindings, we emit a release_value or destroy_addr, depending on whether we have an address or not.
For / Swift-defined types, this is equivalent to the metatype for the / class, but for Objective-C-defined types, this is the class / object.
For / example, an opaque function that uses the array's address could store a / new array onto it.
For AllocStacks that are only used within a single basic blocks, use the linear sweep to remove the AllocStack.
For ArrayObject::offsetExists, we need to check the value at `offset`.
For C functions, create empty argument names.
For DCE analysis it is ok to assume the transfer function is the identity on unreachable blocks (i.e. gen and kill sets are empty).
For HHBBC to invoke builtins.
For HTTP/1.0 conforming clients
For HTTP/1.1 conforming clients and the rest (MSIE 5)
For InterpOne we don't bother to keep track of specialized types or inner-ref types.
For MixedArray, postSort() handles rebuilding the hash.
For NSError**, take ownership from the qualifier.
For NameAlias types, the DeclContext for the aliasED type is in the decl of the alias type.
For ObjC or mixed classes, we need to use object_getClass.
For ObjMethod calls, a private method declared by ctx trumps any other method we may have found.
For Objective-C BOOL properties, use the name of the getter which, conventionally, has an "is" prefix.
For Objective-C classes we need to arrange for a msgSend to happen when the method is called.
For Objective-C initializers, we only have an initializing initializer.
For Objective-C protocols, check whether we have a class that conforms to the given protocol.
For Optimize translations, the entry block's profCount is adjusted later in translateRegion.
For OutputArgs, if the param is not a KindOfRef, we give it a nullptr
For PHP 7 support, in certain scenarios, we throw a deprecation warning and then for PHP 8+ support we will not support them at all.
For PPC64 there are no instructions to perform operations with only part of a register, differently of x86_64.
For PopV and PopR currently we never know if can't run a destructor.
For QoI, in future should emit a fixit to update the existing attribute.
For RPCRequestHandler threads, the ExecutionContext can stay alive across requests, but its always ok to kill it between requests, so do so now
For RepoAuthoritative mode, if tc is a type alias we can optimize in some cases
For SCI you encode the S, then have to remember to skip the C.
For Self types, recur on the underlying type.
For Swift classes, get the method implementation from the vtable.
For Swift, we map the redefinition types back to the equivalent of the built-in types.
For a Clang declaration, trust Clang.
For a SIMPLE arg, after the name part, there should be an ARG_TYPE part whose string value tells us what to do
For a bounded call, the static type that provides the lower bound for / the search.
For a build without mutexes, no-op the mutex calls.
For a class that's really implemented in Objective-C, this is obviously right.
For a class with a superclass, automatically define overrides for all of the superclass's designated initializers.
For a class with no superclass, automatically define a default constructor.
For a class, check whether the superclass (if it exists) is default-initializable.
For a class, we don't need to visit the protocol members of the superclass: that's already handled.
For a computed variable, we want the getter.
For a concrete conformance, use the conforming type as the base type of the requirement and witness lookup.
For a concrete conformance, we record the type variable for 'Self' without doing anything else.
For a conditional dynamic cast, use conditionallyBridgeFromObjectiveC.
For a constructor, enum element, static method, static property, or an instance method referenced through an instance, we've consumed the curried 'self' already.
For a constructor, we only care about the parameter types.
For a convenience initializer or an initializer synthesized for an Objective-C class, allocate using the metatype.
For a declaration, check whether the declaration is hidden.
For a deep equality constraint, only perform equality.
For a default witness, use the requirement's context archetype.
For a default-value expression, do nothing.
For a designated initializer, we know that the static type being allocated is the type of the class that defines the designated initializer.
For a dynamic result referring to an instance function through an object of metatype type, replace the 'Self' parameter with a AnyObject member.
For a few special cases, (object-string and string-int), we have special IR opcodes because the required semantics cannot be easily represented via type conversions.
For a fixed-size enum, this does a primitive load / of the representation and calls down to testFixedEnumContainsPayload.
For a forced cast, force the required optionals.
For a free function witness, discard the 'self' parameter of the requirement.
For a function, bind the output and convert the argument to the input.
For a function, use the result type.
For a generic type, use a slot we saved in the generic metadata pattern immediately after the metadata object itself, which should be instantiated with every generic metadata instance.
For a getter or setter, go through the variable or subscript decl.
For a given constraint kind, decide if we should attempt to eliminate its / edge in the graph.
For a given expression, given information that is global to the / expression, attempt to derive a favored type for it.
For a given layout, output the matching C++ code to implement the scanner.
For a given phi node F, the first of the two hints we return is derived from only those phijmps and phijccs targeting F (if F is a phidef), or from the phidefs F targets (if F is a phijmp or phijcc).
For a heap variable, the box is responsible for the value.
For a major decl, we print an empty line before it.
For a member, "self" indicates the self parameter.
For a metatype, perform a construction.
For a much better antialiased result, the affine function is recommended.
For a named pattern without a type, create a new type variable and use it as the type of the variable.
For a non-generic method that returns dynamic Self, we need to provide an interface type where the 'self' argument is the nominal type.
For a non-member vardecl or one / which is not an override of a base class property, it performs a direct / storage load.
For a non-subscript declaration found via dynamic lookup, strip off the lvalue-ness (FIXME: as a temporary hack.
For a parameter, map back to its parameter to get the TypeLoc.
For a pattern of unknown type, create a new type variable.
For a payload case, store the tag after the payload area.
For a precise union, we need to make sure the returned class is not any bigger than it should be.
For a protocol extension, build the generic parameter list.
For a protocol or extension thereof, the type is 'Self'.
For a protocol type, use its Self parameter.
For a protocol, substitute the base object directly.
For a protocol, the type of 'self' is the parameter type 'Self', not the protocol itself.
For a reference to an overloaded declaration, we create a type variable that will be bound to different types depending on which overload is selected.
For a reference to an overloaded declaration, we create a type variable that will be equal to different types depending on which overload is selected.
For a single potential conversion, directly recurse, so that we don't allocate a new constraint or constraint locator.
For a struct with memberwise initialized properties, we add a memberwise init.
For a subl instruction (l means 32bits), the result must be placed in the lower 32bits (X means the result value): "0x44582C2XXXXXXXX" and the higher 32bits should not be touched.
For a subscript declaration, only look at the input type (i.e., the indices).
For a subscript, use the element type.
For a tuple with a single element, just use the witnesses for the element type.
For a type with dependent conformance, just return the requirement from the protocol.
For a type, strip off the 'self' we artificially added.
For a typed pattern, simply return the opened type of the pattern.
For a variable declaration (without accessors) we use the range of the containing pattern binding declaration to make sure that we include any type annotation in the type refinement context range.
For a witness call, add the Self argument metadata arguments last.
For abstract caches, we need to follow a path.
For abstract methods, simply return if method already declared.
For added safety, we only leave -_.
For additional tags, we use discriminator bit(s) to inhabit the full bit size of the payload.
For address-only sequences, the base is in memory.
For after seeing a T_INLINE_HTML, see below
For all basic blocks in the function, initialize a BB state.
For all entries we visited that did not have this control target in m_gotoTargets, add this control target to these entries' m_gotoTargets fields as appropriate.
For all entries we visited that did not have this control target in m_returnTargets, add this control target to these entries' m_returnTargets fields as appropriate.
For all instructions in the block.
For all loop types, throws one of a variety of exceptions for various errors, and throws DebuggerClientExitException when the event loop is terminated due to the client stopping.
For all lowerings except ResilientEnumImplStrategy, the primary enum operations are open-coded at usage sites.
For all of the entries that did not have this control target in m_breakTargets, add this control target to these entries' m_breakTargets fields as appropriate.
For all of the entries that did not have this control target in m_continueTargets, add this control target to these entries' m_continueTargets fields as appropriate.
For all other (reference counted value, ref count state) we are tracking...
For all other async functions, we leave m_retTypeConstraint empty.
For all other entities, prepend "__" to the base name.
For all practical usage we should be fine with 20 bytes.
For all successors of the node:
For all users of the AllocStack instruction.
For all users of the AllocStack:
For allocating constructors, 'self' is a metatype, not the 'self' value formally present in the constructor body.
For an Objective-C class, import all of the visible categories.
For an addressed property, consider the appropriate addressor.
For an archetype, retrieve the nested type with the appropriate name.
For an archetype, we substitute the base object for the base.
For an empty case, factor out the parts that go in the payload and tag areas.
For an example, see "hphp/test/slow/hhbbc/return-type-opt-bug.php".
For an expression being type checked with a CTP_CalleeResult contextual / type, try to diagnose a problem.
For an implicit declaration, our argument type will be in terms of archetypes rather than dependent types.
For an implicitly generated super.init() call, make sure there's only one designated initializer.
For an inherited conformance, the conforming nominal type will be different from the nominal type.
For an integer subscript expression on an array slice type, instead of introducing a new type variable we can easily obtain the element type.
For an optional requirement, record an empty witness: we'll end up querying this at runtime.
For an override of a base member property, it chains up to / super.
For an unbound instance method reference, replace the 'Self' parameter with the base type.
For an unconditional dynamic cast, use forceBridgeFromObjectiveC.
For any literal type that has been covered, remove the default literal type.
For any nominal type reference, look at the type declaration.
For any of the type variables that has no associated fixed type, assign a fresh generic type parameters.
For anything else, if we completely failed to import the type abstractly, give up now.
For anything else, the object is always greater.
For anything with a Clang node, lazily check conformances.
For array types, convert the element type and treat this an as array.
For arrays, this will return an array of values.
For arrays, we fall back on the Variant machinery
For astronomical as well as ceremonial reasons, the start of a new year may be delayed until a day or two after the new moon causing years to vary in length.
For async functions stepping over an await, we land on the next statement.
For autoreleased results, the reclaim is implicit, so the value is effectively +1.
For backward jumps, we simply call recordJumpTarget
For better error recovery, parse but reject #available in an expr context.
For better recovery, we just accept a label on any statement.
For bool results, a zero value is an error.
For boxed captures, we need to mark the contained variables as having escaped for DI diagnostics.
For branches we store information so that we / can reconstruct the use after the branch has been modified.
For c_Map, postSort() handles rebuilding the hash.
For calls only those calls which are known to not access the caller frame can be modified in this manner.
For calls, we try to figure out the destination symbol name.
For capture lists, we typecheck the decls they contain.
For cases where m_size is zero or the buffer's refcount is greater than 1, call resizeHelper().
For cases where the buffer's refcount is greater than 1, call resizeHelper()
For cases where the buffer's refcount is greater than 1, call resizeHelper().
For catch handlers, add an edge to each handler entry point.
For certain actions it can immediately be known that its associated object will always be interesting.
For certain special typedefs, we don't want to use the imported type.
For chunk encodings, we way receive an EOM with no data, such that hasMorePostData returns true (because client is not yet complete), client sends EOM, getMorePostData should return 0/nullptr
For class initializers, the assign into the self box may be captured as SelfInit or SuperInit elsewhere.
For class, archetype, and protocol types, look up the dynamic metatype.
For class-at-a-time analysis, closures that are associated with a class context are analyzed as part of that context.
For classes with non-scalar initializers, the 86pinit and 86sinit methods are guaranteed to run before any other method, and are never called afterwards.
For classes, check the superclass.
For classes, expand implied conformances of the superclass, because an implied conformance in the superclass is considered "fixed" in the subclass.
For classes, this is the initializing constructor, to which we will dynamically dispatch.
For classes, we need the superclass (if any) to support qualified lookup.
For closures containing only a single expression, the body participates in type checking.
For closures use variables will be the first properties of the closure object, in declaration order
For closures, type-check the patterns and result type as written, but do not walk into the body.
For closures, update the parameter types and check the body.
For closures, use the parent name.
For codegen passes, only passes that do IR to IR transformation are supported.
For command line programs, we need this exception to exit from the infinite execution loop.
For common ancestors to exist they must be on both sides of the baseList at the same positions
For compatibility with php, throwing through a constant lookup has different behavior inside a property initializer (86pinit/86sinit).
For concrete caches, this is easy.
For concrete metadata, declare the alias to its address point.
For concrete metadata, we want to use the initializer on the / "full metadata", and define the "direct" address point as an alias.
For conditions of distribution and use, see the accompanying README file.
For consistency with the interpreter, decref the rhs before we decref the stack inputs, and decref the ratchet storage after the stack inputs.
For consistency with the interpreter, we need to decref things in a different order depending on whether we are unwinding, or planning to side exit.
For constant values only.
For constructors, we make sure that the body ends with a "return" stmt, which we either implicitly synthesize, or the user can write.
For convenience, these vars (plus the bison vars far below) are macros in the reentrant scanner.
For critical arcs, we currently just approximate it as half of the smallest weight of its incident blocks.
For curried functions, 'throws' and 'noreturn' only applies to the innermost function.
For data profiling, we need to find the actual class that a Func belongs to so we put such Funcs into this map.
For debug builds, set m_pos to 0 as well to make the asserts in checkInvariants() happy.
For debugging purposes.
For debugging, count how many times basic blocks get interpreted.
For debugging, print the final input states for each block.
For debugging, print the final state of the class analysis.
For debugging, still output to stdout
For default implementations, Self is the protocol archetype.
For dependent member types, we may need to look up the member if the base is resolved to a non-dependent type.
For details see the comments for the SIL StackPromoter.
For details, see ClassScope::importUsedTraits in the compiler.
For dynamic multi-payload enums, it would be expensive to recalculate the payload area size from all of the cases, so cache it in the metadata.
For each "subrecord" of agg in the worklist...
For each BB in our post order...
For each BB in our reverse post order...
For each BB in the destructor...
For each Block with a new Phi argument:
For each Leaf we have as input...
For each Objective-C method declared in this file, check whether it overrides something in one of its superclasses.
For each RegionID in our reverse post order...
For each basic block BB in Caller...
For each basic block BB in Fn...
For each block in a Reverse Post Order scan:
For each block in the body, traverse from the innermost to outermost exception handler that includes the block.
For each block with multiple successors in the same chain, only keep the successor that first appears in the chain.
For each block, create a list of the direct predecessors that the block is control-dependent on.
For each block, if it has 2 successors with the same SrcKey, then merge the successors' chains into one.
For each captured argument of PAI, decrement the ref count of the captured / argument as appropriate at each of the post dominated release locations / found by Tracker.
For each class declaration in our V-table list:
For each color in colormap, find: 1.
For each color selected by find_nearby_colors, compute its distance to the center of each cell in the box.
For each component C, we should subtract C_rhs from C_lhs iff every other component of lhs that can intersect with C is subsumed by the corresponding component of rhs.
For each declaration whose context is not something we've already visited above, add it to the list of declarations.
For each element index of the tuple...
For each eliminated method symbol create an alias to the stub.
For each entry in the regex array, get the entry
For each entry in the witness table...
For each exiting block: / / 1.
For each fault handler block ending in Unwind, find the EH entry for the funclet, then traverse outwards starting from the next outermost.
For each function, find any inout arguments and try to optimize each of them.
For each increment in our list of new increments, attempt to match them up with decrements and gather the insertion points of the decrements.
For each increment in our list of new increments.
For each index i until min path size...
For each instruction I in BB...
For each instruction II in BB...
For each instruction in BB...
For each instruction, add it to the set if it must be the start of a block.
For each instruction:
For each key in the map, we copy the key to the set if the corresponding value is equal to pos exactly (which means it was present in all of the containers).
For each matching starting delimiter, we increment nesting level, and decrement it for each matching ending delimiter.
For each nested simulator (corresponding to nested VM invocations), look at its PC to find a potential fixup key.
For each new apply, attempt to link in function bodies if we do not already have them, then notify the pass manager of the new functions.
For each node in the post-dominator tree we will compute: -- A level number.
For each of the archetypes, compute the substitution.
For each of the constraint restrictions, record it with simplified, canonical types.
For each of the fixes, record it as an operation on the affected expression.
For each of the overload sets, get its overload choice.
For each of the partial solutions, subtract off the current score.
For each of the primary potential archetypes, add the nested requirements.
For each of the primary potential archetypes, add the requirements.
For each of the type variables, get its fixed type.
For each overload locator for which we have an overload choice in all of the previous solutions.
For each parameter in the old function...
For each platform version spec in the spec list, create an implicit AvailableAttr for the platform with the introduced version from the spec.
For each possible dest type, determine if its type might relax.
For each predecessor of the header of the loop: / / 1.
For each predecessor with argument type...
For each request, make sure we start with the default error code.
For each state that we are currently tracking, apply our summarized instructions to it.
For each store location, insert releases.
For each subject entry, convert it to string, then perform replacement and add the result to the return_value array.
For each subpattern, insert it into the appropriate array.
For each subpattern, insert it into the subpatterns array.
For each substitution Sub in AI...
For each successor of BB...
For each successor region S of ER...
For each terminator instruction I in BB visited in reverse...
For each type variable bound in all of the previous solutions, check whether we have a binding for this type variable in this solution.
For each use of a specific result value of the instruction.
For each user U of the alloc_existential_box...
For each user U of the take_enum_data_addr...
For each user U of the unchecked_addr_cast...
For each user of V...
For each variable in the pattern, make sure its type is identical to what it was in the first label item's pattern.
For effects on locals, we perform the type effects of each operation on base.type, and then allow moveBase() to make the updates to the local when we know what its final type will be.
For efficiency of lookup below, compute a mapping of the local ivars in the class to their element number.
For empty names, there is nothing to do.
For empty types, we don't really need to allocate anything.
For enum values we are only interested in switch_enum and select_enum users.
For error recovery purposes, keep track of the disposition of the last pattern binding we saw ('let' vs 'var') in multiple PBD cases.
For error recovery, also parse "for in ..." as foreach.
For error-recovery, we mark them as invalid.
For every block with retain, we need to check the transitive closure of its successors are retain-free.
For every block, add edges to reachable fault and catch handlers.
For every character in the password add the entire password.
For every indexed type, we generate its layout.
For every instruction in trace representing a tracelet guard, call func with its location and type, and whether or not it's an inner hint.
For every other use case a failed generator was identical to one that finished executing, but `getReturn` wants to throw an exception if the generator threw an exception.
For every requirement, add a constraint.
For every type which has its linkage changed, update its dependents (templates where the type is used as a parameter, or nested classes) with the new linkage, and mark as being changed as well.
For everything else if we fail to start the return block it means the return was unreachable, and we cannot inline such regions.
For everything else which we didn't handle above: we set the property of the instruction value to false.
For everything else, convert to a double.
For everything else, convert to an int.
For everything else, just get it from the generic parameter.
For everything, store in the appropriate getObject() maps, which will allow us to do getObject() lookups afterwards.
For exact casts, we are interested only in the fact that the source operand is the same for both instructions.
For example a break point that get's triggered when the server starts to process a page request.
For example aliasing information is not taken into account.
For example consider bit-casting a pointer to an int.
For example we could have an IterPos and an IterBoth.
For example, Britain converted in 1752, The USSR in 1918 and Greece in 1923.
For example, PredictableMemOps can no longer remove some alloc_stack cases after global destroy hoisting.
For example, We could give some path information where the use was uninitialized, like the static analyzer.
For example, _swift_isDeallocating is required by Instruments.
For example, a concrete type is always a subtype of any protocol it conforms to.
For example, all entries using the RegisterPreservingCC calling convention need a global, because they are currently always invoked indirectly using a client-side wrapper.
For example, assuming that a child expression is literally a TupleExpr may only be a reasonable assumption in an unchecked parse tree.
For example, getAssignExistentialsFunction relies on being uniqued for different layout kinds.
For example, if a unit defines multiple persistent functions, it's possible another thread may call one of them before we've finished defining the other ones.
For example, if this is a VarDecl for "x", the pattern may be / "(x, y)" and the initializer on the PatternBindingDecl may be "(1,2)" or / "foo()".
For example, if we matched "ViewController" in "dismissViewControllerAnimated", stitch together "dismissAnimated".
For example, init_enum_data_addr and struct_element_addr / may be part of a decoupled initialization sequence.
For example, it could be a resilient struct or / something of unknown size.
For example, it could be a resilient struct or something of / unknown size.
For example, it may have generic / arguments substituted in.
For example, it will return false for / enumerators, because those are naturally nested within the / enumeration declaration.
For example, on the OSXApplicationExtension platform we want to chose the OS X spec unless there is an explicit OSXApplicationExtension spec.
For example, storing to a local on a frame is weak because if no other uses of the frame are keeping it alive (for example a load of that same local), we can just remove the store.
For example, this allows:
For example, this may directly cast a single-payload enum to a NativeObject reference.
For example, type SomeTy.SomeMember can look up static functions, and can even look up non-static functions as well (thus getting the address of the member).
For example, we emit an error for / #available(OSX 10.10, OSX 10.11, *)
For example: Consider d register with the value "0x44582C24A50CAD2".
For example: case ...: case body is implicitly wrapped in a brace statement
For example: switch ...
For examples, see hphp/tests/vm/asm_*.
For existential-to-existential coercions, open the source existential.
For exprs of a structural type that are not modeling argument lists, avoid merging the type variables.
For fatal errors and unknown exceptions, we raise a warning.
For fault handlers, add an edge to the fault handler and stop.
For filtering assertions, some opcodes are considered to have no use for a stack input assertion.
For fixed-layout cases this isn't necessary (except for reflection, but it's OK if reflection is a little slow).
For fixed-size enums, the currently inhabited case is a function of both the payload tag and the payload value.
For fixed-sized types, we can emit concrete box metadata.
For flow control only at this time.
For forward jumps, we store information about the
For funcIsMagic prologues, this is just a possible prologue.
For function application, convert the argument to the input type of the function.
For function that requires just 1 iteration of the data flow to converge we set the initial state of BBWriteSetIn to 0.
For function that requires more than 1 iteration of / the data flow this is populated when the first time the functions is / walked, i.e. when the we generate the genset and killset.
For functions, close the existential once the function has been fully applied.
For functions, we need to form a complete name.
For future reference: Set errno on error, since we are called by hphplex_init()
For future reference: Set errno on error, since we are called by yylex_init()
For generic and resilient types, nondependent conformances are keyed by the nominal type descriptor rather than the metadata, so try that.
For generic functions, build a new generic function...
For generic literal types, check whether we already have a specialization of this generic within our list.
For generic parameters, we want name lookup to look at just the signature of the enclosing entity.
For generic types, this uses the unbound type.
For globals we currently do not support available_externally.
For hoisting bounds checks the block must dominate the exit block.
For image rotations, the optimized versions have a lazy antialiasing for the edges of the images.
For imported classes, use the ObjC class symbol.
For in-tree builds this is the directory name, which is typically the same as the extension name converted to lower case.
For indirect arguments, we just need to pass a pointer.
For initializers, compute the first argument name.
For initializers, prepend "__" to the first argument name.
For inlined functions, we need to rewrite the inlined call site.
For instance, a PopC will call the destructor of the top-of-stack object if it was the last reference alive, and this counts as an example of 'UsedIfLastRef'.
For instance, if the archetype is class-constrained, and the binding is not a class, it can never be bound.
For instance, routines that use stripUpcasts() do not want to strip off a downcast that results from checked_cast_br.
For instructions with vector immediates, we have to scan the contents of the vector immediate to determine how many values are popped
For internal use only.
For it to be a valid split, the start and end section must be valid operators, splitting a unicode code point isn't kosher.
For ivar destroyers, the decl is the class itself.
For keys of SILFunction and SILLoop.
For keys that could be strings, we have to assume they could be strictly-integer strings.
For kills, locations on the eval stack below the re-entry depth should all be added.
For known conditional jumps we have to consume the const value on the top of the stack and figure out which branch to go to.
For known strings that are strictly integers, we'll set both the known integer and string keys, so generally the int case should be checked first below.
For l-value types, reset to the object type.
For large arrays, do a naive pre-check for OOM.
For layout purposes, we consider a singleton tuple to be isomorphic to its element type.
For legacy purposes, SetL expects its immediate argument to be present on the symbolic stack.
For level 0, this is the current file/line, for all other frames this is the stored file/line #
For library-style parsing, we need to make two passes over the global scope.
For literal we disregard RuntimeOption::AlwaysPopulateRawPostData
For literal-convertible types, form the corresponding literal.
For local DCE, we have to assume all variables are in the live-out set for the block.
For local decls, use the address we allocated or the value if we have it.
For locations which we do not have concrete values for in this basic block, try to reduce it to the minimum # of locations possible, this will help us to generate as few SILArguments as possible.
For long strings it falls back to the non-inlined slow path.
For lookups within the generic signature, look at the generic parameters (only), then move up to the enclosing context.
For member functions, the args are serialized and kept along with the 'this' pointer, and used to look for constant returns given the same args.
For member variables, this access is done w.r.t.
For members of a synthesized extension, we should append the USR of the synthesize target to the original USR.
For metadata patterns, we're done.
For metadata purposes, we consider a singleton tuple to be isomorphic to its element type.
For methods, we defer setting the full name until m_cls is initialized
For migration purposes, distinct Map types should compare equal
For more details, see the help for CmdThread.
For more information on the IJG JPEG software (and JPEG documentation, etc.), see ftp://ftp.uu.net/graphics/jpeg/.
For more information on the level of compatibility, please refer to the comments in BF_set_key() below and to the crypt(3) man page included in the crypt_blowfish tarball.
For more information, see rdar://problem/18499385
For most instructions, we know how many values are popped based solely on the opcode
For most of our types, where m_data represents an exact constant value, this just means the types only overlap if there is no data.
For most types, we can just emit the usual metadata.
For multi-line calls, this instruction is associated with the subsequent line which results in an off-by-n.
For multipart messages, the final newline belongs to the boundary.
For mutable value type methods, we need to dig through inout types.
For namespaced collections, returns an "alternate" name, which is a collection name with or without the namespace qualifier, depending on what's passed.
For native calls we don't use a return block
For negative start or length, calculate start and length values based on total code points.
For nested loops it returns the command that completed the loop, which will match the expectedCmd passed in.
For nice-looking dumps, we want to remember curMarker between blocks.
For non Ambiguous pointers, try to drill down and resolve the edge name
For non consumed parameters (e.g. guaranteed), we also need to insert releases after each apply instruction that we create.
For non-JIT'd code, the linker will do it for us.
For non-ObjC closures, assume the type metadata is always used.
For non-Objective-C initializers, we have an allocating initializer to call.
For non-address-only structs, we emit a struct_extract sequence.
For non-argument tuples, we can do the same conversion but not to a tuple with varargs.
For non-closure classes, a property of type KindOfUninit means that it has non-scalar initializer which will be set by a 86pinit method.
For non-error cases, the caller handles this.
For non-failable initializers, store to the return address directly.
For non-functions, just use the base name.
For non-interface classes, each method in a php class has an entry in its ClassInfo method table, and if it's not special, AttrNoOverride, or private, an entry in the family table.
For non-parameter adjustments, use the result type or whole type, as appropriate.
For non-repo mode, where they are added at Class-creation time.
For non-subscript getters, this degenerates down to "()".
For non-trivial types, insert destroys for each final release-like instruction we found that isn't an explicit dealloc_box.
For nonblocking mode, temporary out of data.
For nontrivial payloads, we need to copy/take the payload using its value semantics.
For now -Oplayground is equivalent to -Onone.
For now I'm just making use of copyMixed to do it for me before GrowPacked happens.
For now I'm just making use of copyPacked to do it for me before GrowPacked happens.
For now all ref counting insts have 1 operand.
For now consider any references inside requirements as a possibility to infer the generic type.
For now directly reference the class object, which is totally wrong for ObjC interop.
For now for simplicity, we put all new arguments on the end and delete the old one.
For now ignore functions with indirect results.
For now ignore generic functions to keep things simple...
For now instead of ignoring it, pick up the declaration name from the buffer identifier and append it to the diagnostic message.
For now just always dump assembly.
For now just be conservative.
For now just check for a single copy_addr that destroys its source.
For now just don't handle loops containing such exits.
For now just include it in the description only in the new code path.
For now just look at the previous instruction if it exists.
For now just look for guaranteed self.
For now just throw that away.
For now just use a generic schema.
For now only describing the data.
For now this is restricted to opcodes that do literally nothing.
For now this just gives up if the context and the callee class could be related and the context defines a private of the same name.
For now this only supports alloc_ref of classes so any alloc_ref with a reference type that is not a class this will return false for.
For now this utility is only used to split critical edges involving cond_br.
For now we add all the edges, although we might be able to be less pessimistic later.
For now we are not going to be smart about this to enable avoiding any issues with visiting the open_existential_addr/witness_method before the init_existential_inst.
For now we are not going to be smart about this to enable avoiding any issues with visiting the protocol_method before the init_existential_inst.
For now we encode collections keys in m_refs using a null pointer.
For now we just return Unrelated since I can not remember why I had the special check in the hasNonEmptySymmetricDifference code.
For now we just toss in the function name and id, as well as the pseudo-frames for context breaks at explicit joins.
For now we keep the one with a smaller `rep' value, instead of discarding both.
For now we leave this disabled in HipHop syntax mode to deal with incompatibilities in existing code-bases.
For now we only interop with Int8 pointers using UTF8 encoding.
For now we only need dependencies for function return types.
For now we shouldn't be seeing exceptions from any other runtimes but this may change in the future.
For now we skip these so we don't get odd behaviour in default arguments and the like, but in the future we should consider creating appropriate regions for those expressions.
For now we use UnqualifiedLookup to fetch other declarations with the same base name.
For now we're ignoring the type information, and only using offset.
For now we're leaving that alone, which gives the invariant that every FuncFamily we create here is non-empty.
For now, / for this to succeed portably, both need to be globals defined in the / current translation unit.
For now, IR-gen makes the actual thunk.
For now, add it if it wasn't set by the caller.
For now, all control flow instructions are essential.
For now, all type metadata is directly stored.
For now, all we have is swift_allocObject.
For now, all we have is swift_slowAlloc.
For now, all we have is swift_slowDealloc.
For now, assume anything else is an hdf file TODO(#5151773): Have a non-invasive warning if HDF file does not end .hdf
For now, assume that an associated type is cheap enough to access that it doesn't need a new cache entry.
For now, assume that finding an abstract conformance is always fast enough that it's not worth caching.
For now, assume that we never have any interest in dynamically changing the value witnesses for something that's fixed-layout.
For now, check only that the copy_addr is the first use within the same block.
For now, don't inline when we'd need to adjust ObjectData pointers.
For now, don't try to re-use destination blocks for multiple failure sites.
For now, expose no extra inhabitants.
For now, generic function types cannot be dependent (in fact, they erase dependence) or contain type variables, and they're always materializable.
For now, if present, this will only be the empty range, indicating that the branch is dead.
For now, if the type does not have a fixed layout in all resilience domains, we will treat it as address-only in SIL.
For now, if you're binding output columns, it's better to use LAZY or BOUND fetches if you want to shave off those cycles
For now, ignore witness-table fulfillments when they're not for archetypes.
For now, it's separate as this was pulled originally from xdebug
For now, just check that a SIL function type came from some AST function type.
For now, just emit a switch and phi nodes, like a chump.
For now, just focus on cases where there is a single use.
For now, just generate a generic error.
For now, just handle the case where all predecessors are unconditional branches.
For now, just report cases where we would need a reabstraction as unsupported.
For now, just send a naked RST.
For now, just skip anything that's an interface.
For now, just use a generic word-chunked schema.
For now, just use extra inhabitants from the first element.
For now, just use extra inhabitants from the first field.
For now, native weak references are just a pointer.
For now, never promise atomicity.
For now, only do anything if there's a single direct result.
For now, return false is the address argument is an address-only type, since we currently handle loadable types only.
For now, that's just simply scalar values.
For now, the fact that a declaration was not implemented in Swift is enough to conclusively force us into a slower path.
For now, this is fine -- but if we ever synthesize #available(), this will be a real problem.
For now, trailing where clauses are only permitted on protocol extensions.
For now, treat all archetypes independently.
For now, use the same condition as requiresIndirectSchema.
For now, we assume that relocation is only required when the parent class has prefix matter we didn't know about.
For now, we conservative only specialize if doing so can eliminate dynamic / dispatch.
For now, we don't allow stored properties to be potentially unavailable.
For now, we don't care.
For now, we don't need either an AccessKind or an AccessSemantics, because addressors are always directly dispatched.
For now, we don't support the observing accessors on subscripts.
For now, we just pick a random server from the set
For now, we mark the cell popped with a Use::UsedIfLastRef.
For now, we never try to emit specialized versions of the metadata statically, so compute the field layout using the originally-declared type.
For now, we require the extensions to use their own thread local memory for user-changeable settings.
For now, we'll consider only the simplest induction variables: - Exactly one element in the cycle must be a SILArgument.
For object typehints there is no possible coercion in the failure case, but HNI builtins currently only guard on kind not class so the following wil generate false positives for objects.
For objects, we fall back on the Variant machinery
For operands the treatment is analogous, only the lower 32bits are considered to perform the operation.
For operators, sort the results so that non-generic operations come first.
For optimize, we don't need to bother doing anything to these---another pass is responsible for removing completely unreachable blocks.
For optional reference results, a nil value is normally an error.
For optional types, use 'nil'.
For other closures, type-check the body once we've finished with the expression.
For other functions, the initial state of BBWriteSetIn should be all 1's.
For other nominal types, print the generic parameters.
For our purposes 'dynamic' means that the method call cannot invoke a method in a subclass.
For owned results, the value is already retained.
For owning addressors, we can just let the owner get released at an appropriate point.
For parameter adjustments, dig out the pattern.
For parens and vars, just set the type annotation and propagate inwards.
For parity with C, several places in the grammar accept multiple comma-separated expressions and then bind them together as an implicit tuple.
For parity with the enum_is_tag combiner pass, handle integer literals for now.
For partial_apply, if we've been asked to examine the body, the uses of the argument are okay there, and the partial_apply itself cannot escape, then everything is fine.
For payload or extra inhabitant cases, zero-initialize the extra tag bits, if any.
For peek/poke instructions or InsertMid instructions, this function returns 0.
For peek/poke instructions, this function returns 0.
For perfect rounding, must get sin(a + pi/4) and sin(a - pi/4).
For phi uses, however, we want to consider the whole phi group's allocations first.
For phis, union all incoming values, taking care to not recurse infinitely in the presence of loops.
For pinning addressors, we have to push a writeback.
For places where it is not supposed to include simple_counter.h.
For platforms with incomplete ANSI defines.
For pointers to members, the type referring to the object the member belongs to.
For polymorphic functions, bail if the number of substitutions is not the same as the number of expected generic parameters.
For possible future extension.
For primitive return types (int, bool, double), and returnByValue, the return value is already in dstReg/dstType
For profiling translations, grab the postconditions to be used for region selection whenever we decide to retranslate.
For prologues with corresponding DV funclets, their corresponding DV funclet will be regenerated right after them.
For properties that do not require deep initialization, promote strings and arrays that came from 86pinit to static.
For properties that require "deep" initialization, we have to do a little more work at object creation time.
For protocol default implementations, we also use the allocating constructor, because that's the only thing that's witnessed.
For purposes of Type equivalence, NaNs are equal.
For purposes of argument type matching, existential types don't need to conform -- they only need to contain the protocol, so check that separately.
For quality and type, -1 means that the argument does not exist
For reachable basic blocks, the initial state of ForwardSetOut should be all 1's.
For really long matches, we'll give a high score.
For recovery parse one if present.
For recovery purposes, accept an oper_binary here.
For recovery, again make sure the user didn't try to spell a switch case label: 'case Identifier:' or 'case Identifier where ...:'
For recovery, see if the user typed something resembling a switch "case" label.
For recovery, skip elements that didn't have a name attached.
For recovery, we still form the pattern even if one or more elements are missing keywords.
For reference, the total malloced memory usage could be calculated as such, if delta0 were recorded in resetStatsImpl():
For relational constraints, match up the types.
For remaining path pieces, filter or drill down into the results we have.
For replicaset in return
For repo mode, where trait methods are flattened at compile-time.
For request-local allocation, we make a fast path to handle cases where no CapCode encoding is needed and the corresponding size class is fully utilized.
For resolved archetypes
For resources, we fall back on the Variant machinery
For return by reference (String, Object, Array, Variant), the builtin writes the return value into MInstrState::tvBuiltinReturn TV, from where it has to be tested and copied.
For returns from generators, we follow the execution stack for now, and end up at the caller of ASIO or send().
For setter accessors, we need the base's setter to be accessible from the overriding context, or it's not an override.
For short-term ease of initial implementation, we always go through the expr parser for ambiguous productions.
For simplicity, assume a single preheader
For simplicity, for now we return `false' if the sets of guarded locations are different.
For sinit, the context class is always the same as the late-bound class, so we can just use curClass().
For smashable jmps and calls in ARM, we emit the target address straight into the instruction stream, and then do a pc-relative load to read it.
For some discussion on how we know whether the SSATmp* is usable (i.e. its definition dominates code that might want to reuse it), see the bottom of this file.
For some invalid decls it might be impossible to compute the signature, for example, if the types could not be resolved.
For some operations that are conceptually a socket operation (eg fopen('http://...)) we actually complete it and store the result in a memfile.
For some purposes, a truncated host name is good enough.
For some reason -Ounchecked can accept a higher base benefit without increasing the code size too much.
For some reason I am running into compile issues when I try it now.
For some reason gcc won't capture MinPrintLevel without this
For some reason, subscripts and properties don't include their self type.
For sorts that use builtin comparators, the types of values are also observed during this first pass.
For static members, determine how that member's address can be determined.
For static methods, give handler the name of called class
For static variables, emit a reference to the global variable backing them.
For static/class members, drop the metatype argument.
For step-conts, we ignore handlers at the original level if we're not in the original resumable.
For storage, close the existential either when it's accessed (if it's an rvalue only) or when it is loaded or stored (if it's an lvalue).
For str_getcsv() support
For structs and enums, this is the allocating constructor (because there is no initializing constructor).
For structs, external extensions may initialize let properties.
For stubs, just add line 0
For sub-decls, all extensions should be printed.
For subtyping constraints, just make sure that this name isn't used at some other position.
For symmetry with overload resolution, penalize conversions to empty existentials.
For the 'V' serialization format, we don't print out keys for Serialize, APCSerialize, DebuggerSerialize
For the DWARF output we want to mangle the type alias + context, unless the type alias references a builtin type.
For the OuterHandle case, we just delegate to APCArray below (which will do the full DataWalker pass).
For the Self and Parent cases, we must always have a resolved class for the constraint
For the case of join points which were halted on one side, optimize_graph will not process through the join because the visit_counter will never be high enough.
For the current scheme we just add the local to gen even if we're doing a removable push, which is correct but could definitely fail to eliminate some earlier stores.
For the first selector piece, attach either the first parameter or "AndReturnError" to the base name, if appropriate.
For the llvm's GraphWriter we copy the connection graph into CGForDotView.
For the moment this is fine -- but future syntax might violate this assumption.
For the moment, this source module just uses the default resync method provided by the JPEG library.
For the moment, we perform a linear search here, but we can and should do something more efficient.
For the most part this should never happen, the emitter assigns our delegate to a non-null value in ContAssignDelegate.
For the moves set, we have no way to track where the pointers may be moved to, so we need to account for it, conservatively, as if it were a decref right now.
For the nested cases, the caller has sent a cmd to the server and is expecting a specific response.
For the next steps we need our parentDC to be a type context
For the nodes corresponding to each type variable...
For the protected method case: if the context class must be derived from the class that first defined the protected method we know it is accessible.
For the purpose of naming (having entered the the function body), a variadic capture param acts as any other variable.
For the purpose of this function, 'word' is defined as a locale dependent string containing alphabetic characters, which also may contain, but not start with "'" and "-" characters.
For the purposes of finding a fixed point, consider the function to be rethrowing-only within its body.
For the purposes of handling and try-coverage diagnostics, being rethrowing-only still makes this a throw site.
For the purposes of later type checker consumption, model this as returning an lvalue.
For the rest, just generator chunks one at a time.
For the same reason we care about DW_TAG_variables, we examine DW_TAG_subprogram as well.
For the same reason, we need s_impl to be destructed after all other statically created objects may reference it in their destructor.
For the setter, first check that we have the right number of parameters.
For the sign of the final result to be set, only one of Left or Right should be true.
For there to be a superclass relationship, the potential subtype must be a class or superclass-bounded archetype.
For there to be a superclass relationship, we must be a superclass, and the potential subtype must be a class or superclass-bounded archetype.
For these classes, we want the initial type of the property to be the type set by the 86pinit method, so we set the type to TBottom.
For these declarations (enum / cases and variable declarations) a Fix-It for an added availability / attribute should be suggested for the appropriate concrete location.
For these definded in php fopen but C stream have different modes
For these machines you must define RIGHT_SHIFT_IS_UNSIGNED.
For this frame, record the tracelet address as starting from this callToExit-1, so gdb does not barf.
For this implementation we'll use the highest depth encountered.
For this inlined region to be a viable target for this optimization the InlineReturn should be the only use of DefInlineFP within these blocks.
For this purpose, the lunar cycle is assumed to be 29 days 12 hours and 793 halakim.
For this reason, many of the operations are structured as for-each style iteration.
For this we use a cubic function on the number of caller blocks.
For this, we'll need special destinations.
For those functions, m_dvFuncletDB keeps the TransID for their first translation.
For tiled fill, the use of a flag buffer is mandatory.
For timer mode, when start is invoked, it adds a new timer to the existing handler for SIGVTALRM.
For trivial payloads (including no-payload cases), we can just primitive-copy to the destination.
For type constants, we have to use the value from the PreClass of the declaring class, because the parent class or interface we got it from may have replaced it with a resolved value.
For type-sugar reasons, prefer the spelling of the default literal type.
For types and properties, build member references.
For types that might be static, it generates a compare of the m_count field against 1, followed by two conditional branches on the same flags.
For types which have external linkage, this lets us use whatever naming scheme the compiler has chosen for unnamed types.
For uncommon layouts, use value witnesses that work with an arbitrary size and alignment.
For unconditional jumps, just set env.sk to the dest.
For unsafe addressors, that's all we've got.
For unsafe addressors, we have no owner pointer to manage.
For updating code we need to go through all the files and pick up changes, even if they have compiler errors.
For use with loading xml
For use with the HackStrictOption settings.
For user exceptions, invoke the user exception handler
For value members, look at their type signatures.
For values stored out-of-line, initializeBufferWithTakeOfBuffer is always a memcpy.
For verbose output, print out each command as it begins execution.
For vinvoke, `inst' is no longer valid after this point.
For visibility checks
For weak and unowned types, convert the reference to the right pointer, producing a +1.
For weak and unowned types, convert the reference to the right pointer.
For wildcard and name patterns, set the type.
For yields, we want to land on the next statement when driven from a C++ iterator like ASIO.
Forbid redefining constants from interfaces, but not superclasses.
Force a ManagedValue to be stored into a temporary initialization / if it wasn't emitted that way directly.
Force a public metadata access function into existence if necessary / for the given type.
Force all archetypes referenced by the type to be bound by this point.
Force any delayed members added to the nominal type declaration.
Force dominator recomputation since we modified the cfg.
Force fmt to a valid value since we don't return anything.
Force immediate writeback to the error temporary.
Force it as "Used", if it conforms
Force jemalloc to update stats cached for use by mallctl().
Force load adapter modules for all imported modules.
Force next pass to zero the color index table
Force null-termination at MAX
Force recheck of the arg expression because we allowed unresolved types before, and that turned out not to help, and now we want any diagnoses from disallowing them.
Force request thread to run in the interpreter, and hit XDebugHook::onOpcode().
Force send to drop a field
Force send to drop a field.
Force standard library to be loaded immediately.
Force the creation of any delayed members, to ensure proper member lookup.
Force the debug info for the function to be emitted, even if it is external or has been inlined.
Force the declaration's context to be the current module, not the original module associated with this module file.
Force the driver into batch mode by specifying "swiftc" as the name.
Force the existing dst type to match that of `res.dst'.
Force the given result into the given initialization.
Force the import to occur.
Force the initializer to be materializable.
Force the r-value into its context if necessary.
Force the resolution of the nested types.
Force the result into the temporary if it's not already there.
Force the right-hand side to be an rvalue.
Force the value into the temporary if necessary.
Force the value we will test.
Force type lowering to lower the type, so that we have a chance to check for infinite value types even if there are no other references to this type.
ForceCompression exists only to support cases when proxy removes Accept-Encoding header but browser can read compressed data.
Forced bridged casts can be still simplified here.
Forcefully always compile this unit with debug enabled, to permit mixing and matching of optimized and unoptimized binaries.
Forcibly define USE_TRACE, so we get the debug trace.h interface included here.
Forcing IUOs always requires a thunk.
Foreign classes cannot conform to objc protocols.
Foreign entry points shouldn't appear in vtables.
Foreign functions are only available at very specific uncurry levels.
Foreign metadata has an additional header that
Foreign overrides currently don't need reabstraction.
Foreign-to-native, native-to-foreign thunks for declarations and function values are implemented in SILGenBridging.cpp.
Forget any information about stack values in memory.
Forget the decl being invalidated
Forget the previous decl.
Fork off the parent process
Form a constraint system where we've opened up all of the requirements of the second protocol extension.
Form a full tuple expression.
Form a humble camel by appending the two strings and adjusting case as needed.
Form a humble camel name from a string.
Form a mapping from associated type declarations to failed type witnesses.
Form a new set of substitutions where Self is replaced by a concrete type.
Form a normal subscript.
Form a reference to the builtin method.
Form a reference to the destroying destructor.
Form a reference to the function.
Form a reference to the superclass -dealloc.
Form a reference to the witness itself.
Form a reference to this member.
Form a set of case_tag:result pairs for select_enum
Form a string describing the associated type deductions.
Form a trace of the async stack starting with the currently running generator, if any.
Form an LLVM constant for the relative distance between a reference / (appearing at gep (0, indices) of `base`) and `target`.
Form an LLVM constant for the relative distance between a reference / (appearing at gep (0, indices...) of `base`) and `target`.
Form an abstraction pattern for bridging purposes.
Form an expression pattern with this match.
Form and return the aggregate.
Form constraints with the greater type on the right (which will be the concrete type, if one).
Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
Form the (favored, fallback) disjunction.
Form the Fix-It text.
Form the argument lists.
Form the argument patterns.
Form the argument tuple.
Form the block on the stack.
Form the body of a chaining designated initializer.
Form the bound generic type.
Form the call and type-check it.
Form the call argument.
Form the call, which will be emitted on any path that needs to run the code.
Form the conformance.
Form the dependent type that refers to this archetype.
Form the dictionary type.
Form the error convention.
Form the function type by building the curried function type from the back to the front, "prepending" each of the parameter patterns.
Form the function type.
Form the generic subscript expression.
Form the inherited conformance.
Form the initial difference increments
Form the lvalue referencing this member.
Form the mapping from base names to entities with their context.
Form the match result.
Form the method_t instance.
Form the open-existential expression.
Form the optional using address operations if the type is address-only or if we already have an address to use.
Form the overload set.
Form the parameter list.
Form the parameter tuple.
Form the replacement #selector expression.
Form the result and return.
Form the selector string.
Form the set of canonical protocol types from the protocol declarations, and use that to build the canonical composition type.
Form the set of generic substitutions required
Form the source value.
Form the specialized type.
Form the subcommand name.
Form the subscript expression.
Form the substitution.
Form the target for the optional object.
Form the textual path illustrating the cycle.
Form the type of the getter.
Form the type of the setter.
Form type parameter substitutions.
Format the text in each of the new page's controls (if they have any text).
Format: / Attr, SILDeclRef (DeclID, Kind, uncurryLevel, IsObjC), and an operand.
Format: Name and type.
Format: a list of typed values.
Format: a type followed by a list of typed values.
Format: a type followed by a list of values.
Format: a type, an operand and a SILDeclRef.
Format: a type, an operand and a decl ID.
Format: a typed value, a SILDeclRef, a BasicBlock ID for method, a BasicBlock ID for no method.
Format: attributes such as transparent and number of substitutions, the callee's substituted and unsubstituted types, a value for the callee and a list of values for the arguments.
Format: attributes such as transparent, the callee's type, a value for the callee and a list of values for the arguments.
Format: condition, a list of cases (EnumElementDecl + Basic Block ID), default basic block ID.
Format: condition, a list of cases (EnumElementDecl + Value ID), default value ID.
Format: condition, a list of cases (Value ID + Basic Block ID), default basic block ID.
Format: condition, a list of cases (Value ID + Value ID), default value ID.
Format: condition, a list of cases (ValueID + Value ID), default value ID.
Format: condition, true basic block ID, a list of arguments, false basic block ID, a list of arguments.
Format: destination basic block ID, a list of arguments.
Format: number of substitutions, the builtin name, result type, and a list of values for the arguments.
Format: the cast kind, a typed value, a BasicBlock ID for success, a BasicBlock ID for failure.
Format: the cast kind, two typed values, a BasicBlock ID for success, a BasicBlock ID for failure.
Forms a list of all threads which are currently blocked within this proxy.
Fortunately this doesn't actually matter in practice.
Fortunately too, there is general agreement that codes 0x00 through 0x3F represent control characters, 0x41 a nonbreaking space, and the remainder printing characters.
Fortunately, SEEK_SET is defined to be zero by the standard.
Fortunately, our TC personality routine skips all the way back to native frames before resuming the unwinder, so its brokenness goes unnoticed.
Fortunately, the cases where that happens are exactly the situations where our entire superclass hierarchy is defined in Swift.
Fortunately, the execution context has a stack of simulators, which we consult instead.
Fortunately, this code is very x86 specific anyway...
Fortunately, though, all versions of EBCDIC, including this one, agree on most of the printing characters that also appear in (7-bit) ASCII.
Forward a value down into a branch of the decision tree that may / fail and lead back to other branch(es).
Forward a value down into an irrefutable branch of the decision tree.
Forward all arguments.
Forward all of the split element cleanups, assuming we made any.
Forward any field extracts to the new allocation.
Forward archetypes and specialize if the function is generic.
Forward arguments according to a function type's ownership conventions.
Forward captures of functions are OK, if the function doesn't transitively capture variables ahead of the original function.
Forward decl for prespecialization support.
Forward declaration for the MD5 algorithm
Forward declarations.
Forward declare this first because types may be recursive.
Forward implicit closure context arguments.
Forward into a single value, then install a cleanup on the resulting imploded value.
Forward it along and register a cleanup.
Forward iteration count.
Forward just the specialized argument right now.
Forward local substitutions to a non-generic local function.
Forward or assign into the box depending on whether we actually consumed 'self'.
Forward propagation failed.
Forward references are not allowed at the top level.
Forward references only live here if they have a single result.
Forward results to the SourceKit consumer.
Forward substitutions from the outer scope.
Forward substitutions.
Forward the address of indirect value params.
Forward the arguments.
Forward the captured owning box.
Forward the captured value address.
Forward the cleanup on the saved indices.
Forward the constructor arguments.
Forward the context as is.
Forward the curried formal arguments.
Forward the existing return argument to a new BBArg.
Forward the incoming arg from a single predecessor.
Forward the indirect return values.
Forward this value, deactivating the cleanup and returning the / underlying value.
Forward-declare this, but define it after swift_release.
Forwarding implementations.
Forwards declarations
Found a different operand, now check to see if its type is something cheap enough to sink.
Found a replacement for this init call.
Found a use of an aggregate containing the given element.
Found a use of an element.
Found a use of the struct at the given access path.
Found an apply that initializes the enum.
Found an unsafe or unknown user.
Found another designated initializer in the superclass.
Found at least one nonempty block.
Found the AAWH we need to remove
Found the next unfinished child.
Found the store to this enum payload.
Fragile functions can reference 'static inline' functions imported from C.
Frame pointer (CFA) for previous frame is in RBP + 16
Frame pointers and stack depth must match.
Frame-based 'canonicalized' stack locations.
FramePtr/StkPtr-typed tmps may live across calls.
FrameState for the same function must always have the same number of locals.
Free ActRec and store the return value.
Free ProfTransRecs for Profile translations.
Free ProfTransRecs for Proflogue translations.
Free TC-space associated with func
Free all transformations.
Free allocated memory
Free and maybe quarantine unmarked objects.
Free any values that may be on the eval stack.
Free function witnesses have an implicit uncurry layer imposed on them by the inserted metatype argument.
Free functions are always statically dispatched...
Free is skipped above.
Free iterator for the current loop whether or not this is the last loop that we jump out of.
Free locals, but don't trigger the EventHook for FunctionReturn since the generator has already been exited.
Free memory allocated for DNS records.
Free memory allocated for image_info
Free resources created by the system
Free the already existing one
Free the authdb too as it defaulted to 'admin' when no db was passed as the connection string
Free the locals and VarEnv if there is one
Free the memory allocated to an longopt array.
Free the out-of-line if we allocated one.
Free the pending iterators on the way.
Free the response node.
Free the self value in convenience initializers, otherwise there's nothing to do.
Free the variable metadata.
Free this cursor/link pair
FreeSec: libcrypt for NetBSD  Copyright (c) 1994 David Burren All rights reserved.
Freetype 2.1 or better
Freetype 2.1.3 or better
Freeze epilogue release or not.
Freshly thrown faults either were never previously seen by the unwinder OR were propagated from the previous frame.
From GDB: (gdb) call HPHP::Trace::dumpRingBuffer()
From REQ_BIND_CALL, we're running "between" basic blocks, with all VM registers sync'ed.
From date/time (3, 5 or 6 arguments)
From gdb: (gdb) set language c++ (gdb) call HPHP::Trace::dumpRingBuffer(100)
From here on out, we're creating a new class to hold the closure.
From here on we're on the side-exit path, due to a failure to coerce.
From here on, we only handle members of classes.
From here on, we'll be working with scratch space.
From here we have an intersection that may have data, and we know that neither type completely contains the other.
From http://devzone.zend.com/303/ "hello" was renamed to "dso_test".
From this assumption only DefInlineFP's associated with an InlineReturn are considered, and terminal blocks are associated with the most deeply nested DefInlineFP that is paired with an InlineReturn.
From this the length of the year can be determined and thus the length of each month.
From timezone and locale (0 to 2 arguments)
Frontier and base of the persistent region.
Frontier for the "local" part of the persistent region (data not shared between threads, but not zero'd)---downward-growing.
Fudge the offset values to achieve this, unless we're already at the end of the string.
Fully dead store - stores to all the components are dead, therefore this instruction is dead.
Fully qualified names aren't represented explicitly in DWARF.
Fully set up the call frame for the stub.
Func guards on x64 come in regular and short versions---the latter are used for Func*'s which fit into a signed 32-bit immediate.
FuncCache Set of FuncCache handles for dynamic function callsites, used for invalidation when a function is renamed.
FuncEntry    caller ...
FuncTable maps function name to an ID.
Funcs and PreClasses.
Funcs can be recorded out of order when loading them from the repo currently.
Function argument handling.
Function argument symbolic flavor
Function arguments are safe.
Function arguments can't alias with things that are known to be unambiguously identified at the function level.
Function arguments need to have a decl.
Function attributes require a syntactic function type.
Function casts succeed on exact matches, or if the target type is throwier than the source type.
Function currently processing.
Function has WSDL description
Function hasn't WSDL description
Function id is added to the breakpoint once matched
Function is not definition.
Function names are already hashed, and the hash bits are random enough That allows us to do a faster combination of hashes using a known implementation (boost::hash_combine)
Function object that replaces all occurrences of archetypes and / dependent types with type variables.
Function object that retrieves a type variable corresponding to the / given dependent type.
Function object that returns all constraints placed into buckets back to the list of constraints.
Function on same line, insert with semi-colon.
Function parameters are ABI compatible if their differences are trivial.
Function parameters are contravariant: we want to switch the direction of transformation on them by flipping inputOrigType and outputOrigType.
Function parameters are siblings.
Function preserve variance in the result type, and flip variance in the parameter type.
Function referenced by partial_apply.
Function return value
Function takes no arguments and returns refType
Function that adds a new key/value pair.
Function that allows php code to access request local data that has been gathered via surprise flags.
Function that calls loopCallee N times.
Function that inits the scan of the memory and count of class pointers
Function that traverses objects and counts metrics per strings
Function types are interchangeable if they're also ABI-compatible.
Function types do not satisfy allowsOwnership.
Function types must be parenthesized.
Function used to construct the left string literal.
Function used to construct the right string literal.
Function-like declarations do, but they should have / polymorphic type and therefore don't need specific binding.
Function-to-function.
Function: gdAffineConcat Concat (Multiply) two affine transformation matrices.
Function: gdAffineEqual Determines whether two affine transformations are equal.
Function: gdAffineFlip Flip an affine transformation horizontally or vertically.
Function: gdAffineIdentity Set up the identity matrix.
Function: gdAffineInvert Find the inverse of an affine transformation.
Function: gdAffineRectilinear Determines whether the affine transformation is axis aligned.
Function: gdAffineRotate Set up a rotation affine transform.
Function: gdAffineScale Set up a scaling matrix.
Function: gdAffineShearVertical Set up a vertical shearing matrix, columns are untouched.
Function: gdAffineTranslate Set up a translation matrix.
Function: gdImageThresholdCrop Crop an image using a given color.
Function: gdTransformAffineCopy Applies an affine transformation to a region and copy the result in a destination to the given position.
Function: gdTransformAffineGetImage Applies an affine transformation to a region and return an image containing the complete transformation.
Function: getPixelInterpolated Returns the interpolated color value using the default interpolation method.
FunctionSignatureSpecializationParams Specializations are just prepended to already-mangled names.
FunctionSuspend will decref the newly allocated waitHandle if it throws.
FunctionType::get - Return a uniqued function type with the specified / input and result.
Functions are special because they might be operators.
Functions called from the callee are assumed to have DefaultApplyLength.
Functions can have _silgen_name, semantics, and NSManaged attributes.
Functions can't be rethrowing-only unless they're defined within the rethrows context.
Functions have component types.
Functions have reference semantics, but are not class references.
Functions in the libswiftDemangle library, which provides external access to Swift's demangler.
Functions need some special handling when printing, since the syntax for function and pointer to function is slightly different.
Functions that are already represented as blocks or C function pointers don't need bridging.
Functions that return non-optional reference type and were imported from Objective-C.
Functions that throw C++ exceptions TODO(T6618159) Take a stack dump here to save context if it results in a crash when propagated
Functions that use ICU to do unicode normalization and collation.
Functions that we've emitted a reference to.
Functions to manipulate the write set.
Functions use statics within themselves.
Functions which return the same data every time, but not the same instance, are candidates.
Functions with captures have an extra uncurry level for the capture context.
Functions with inout parameters cannot be partially applied.
Functions, especially artificial thunks and closures, are often generated on-the-fly while we are in the middle of another function.
Functions, initializers, and de-initializers include their interface types in their signatures as well as whether they are instance members.
FurcHash -- a consistent hash function using a binary decision tree.
Further indent, and include the line to the right child if there is one.
Further, we won't diagnose for useless #available() conditions where * matched on this platform -- presumably those conditions are needed for some other platform.
Furthermore, a DIE can have other DIEs as children.
Furthermore, all of the builtin types are pre-built in the clang ASTContext.
Furthermore, any unreachable blocks appearing before the first reachable block are moved to the end of workQ.
Furthermore, if the subexpr type is already known to be an array type, then we must have an attempt at an array to pointer conversion.
Furthermore, if the superclass is a generic context, we have to assume that its layout depends on its generic parameters.
Future considerations for this: - If we have the structural type lying around in some cheap fashion, maybe we *should* just pass it.
Future options: - Collect the data cross-request to find APC opportunities.
Future-proofing: make sure we validate the control block before we try to read any other blocks.
GC will ignore pointers to freed memory gracefully in prod mode.
GCC 4.8 has some real problems with all the inlining in this file, so don't go overboard with that version.
GD 2.0 supports 8 bits of color resolution per channel and 7 bits of alpha channel resolution.
GD 2.0 supports RGBA truecolor and will read and write truecolor PNGs.
GD2 image format types
GD_SUCCESS on success or GD_FAILURE
GEP to the appropriate element and store.
GEP to the appropriate index, avoiding spurious IR in the trivial case.
GEP to the appropriate slot.
GET request means to extend the url, but not for redirects obviously
GIF Image compression - modified 'compress'  Based on: compress.c - File compression ala IEEE Computer, June 1984.
GIF Specific routines
GIF(sm) is a Service Mark property of CompuServe Incorporated.
GIFCOMPR.C       - GIF Image compression routines  Lempel-Ziv compression based on 'compress'.
GIFENCODE.C    - GIF Image compression interface  GIFEncode( FName, GHeight, GWidth, GInterlace, Background, Transparent, BitsPerPixel, Red, Green, Blue, gdImagePtr )
GLOSSARY  dehiyyot         The set of 4 rules that determine when the new year starts relative to the molad.
GMPData class methods
GNU Unix Standard tar archive
GNU libc++ versions 3.3 and 3.4 obey the environment variables GLIBCPP_FORCE_NEW and GLIBCXX_FORCE_NEW respectively.
GOVERNMENT USE: If you are acquiring this software on behalf of the U.S.
GP regs are now full, bring tmp back to fill the initial stack
GPC elements holds Variants that are acting as smart pointers to RefDatas that we've created in the process of a multi-dim key.
Gaining control of these threads is the intention...
Gamma is ignored, and there is no support for text annotations.
Gather a list of CopyDest users in this block.
Gather all of the protocols.
Gather all of the substitutions for all levels of generic arguments.
Gather any diagnostics we've produced.
Gather generic arguments from a bound generic type.
Gather instruction counts if we are asked to do so.
Gather protocol records for all of the explicitly-specified Objective-C / protocol conformances.
Gather protocol references for all of the explicitly-specified Objective-C protocol conformances.
Gather spare bits into the low bits of a smaller integer value.
Gather the arguments.
Gather the conformances for the type witness.
Gather the constraints affected by a change to this type variable.
Gather the constraints associated with this type variable.
Gather the generic parameter types at all levels.
Gather the occupied bits.
Gather the set of protocol declarations to which this archetype conforms.
Gather the spare bits.
Gather the substitutions from dependent types to concrete types.
Gather the substitutions we need to map the generic conformance to the specialized conformance.
Gather the type arguments.
Gather the value witnesses for the given requirement.
Gather the values we will switch over for this payload chunk.
Gather the witnesses from the Iterator protocol conformance, which we'll use to drive the loop.
Gather type variables from this constraint.
Gather up all Values in Fn.
Gather up units created by the worker threads and commit them in batches.
Gen and InitGen don't add any useful information, so leave them out entirely.
GenSet and KillSet initially empty.
General case: concatenate all of the generic argument lists together.
Generalize if necessary.
Generally called when the reference count on an array drops to zero.
Generally hasExtra() should be checked first.
Generally it will report a list of pointers to other potentially interesting types, as well as address ranges that should be conservatively scanned.
Generally these lists are for various LLVM / metadata or runtime purposes.
Generally this will crash the VM.
Generally you want a TInitGen.
Generally, we set the "InStructSubElement" flag and recursively process the uses so that we know that we're looking at something within the current element.
Generate ConstantStruct for StructInst.
Generate HHBC of the structure:
Generate IR for each bytecode instruction in this block.
Generate IR for the SIL Function.
Generate RGBA row from an YUV row (with width upsampling of chrome data) Input: 1, 2, 3.
Generate a Jmp and return the src.
Generate a bunch of operands of a given type.
Generate a call to the 'swift_willThrow' runtime function to allow the debugger to catch the throw event.
Generate a category if the extension either introduces a conformance to an ObjC protocol or introduces a method that requires an Objective-C entry point.
Generate a code to invoke the bridging function.
Generate a forward declaration of the runtime entry implementation.
Generate a getter from InitF which returns the value of the global.
Generate a getter from the global init function without side-effects.
Generate a getter only if there are any loads from this variable.
Generate a load for the source argument.
Generate a module, but treat it as an intermediate output.
Generate a new apply of a function_ref to replace an apply of a / witness_method when we've determined the actual function we'll end / up calling.
Generate a new parameter list with deleted parameters removed.
Generate a private stub function for the LLVM ARC optimizer to recognize.
Generate accessor functions for all of the declared variables, which Builtin.once the lazy global initializer we just generated then return the address of the individual variable.
Generate an exit for the rare case that r is zero.
Generate code to emit a thunk with native conventions that calls a / function with foreign conventions.
Generate code to invoke _bridgeToObjectiveC
Generate code to the optional is present, and if not abort with a message (provided by the stdlib).
Generate diagnostic info.
Generate diagnostics.
Generate function info for this signature.
Generate getter from the initialization code whose / result is stored by a given store instruction.
Generate global symbols which are function pointers to the actual implementations of runtime entry points.
Generate ilim digits, then fix them up.
Generate layouts for all indexed types.
Generate lowered explosions for each explicit argument.
Generate more specific messages in some cases.
Generate or use a private key
Generate order numbers for the functions in the SIL module that correspond to definitions in the LLVM module.
Generate specific error messages for unary operators.
Generate the arguments from this row's pattern in the case block's expected order, and keep those arguments from being cleaned up, as we're passing the +1 along to the shared case block dest.
Generate the closure function, if we haven't already.
Generate the closure value (if any) for the closure expr's function reference.
Generate the compare of the indices.
Generate the conversion from the enums to integer indices.
Generate the entire C++ file.
Generate the genset and killset for each basic block.
Generate the genset and killset for every basic block.
Generate the local function body.
Generate the new layout for this type, including any suffix.
Generate the search class object reference.
Generate the select_value right before the first cond_br of the pattern.
Generate the thunk name.
Generated code should never use a StaticString on the left-hand side of assignment.
Generates LLVM IR, runs the LLVM passes and produces the output file.
Generates LLVM IR, runs the LLVM passes and produces the output files.
Generates Y, U, V data (with color subsampling) from 32 bits per pixel RGBA data buffer.
Generating the inlined call failed, bailout
Generator instructions
Generator support helpers
Generators A and B both do `yield from` on a shared delegate generator, C.
Generators don't support returning by references
Generators pass return values both through the eval stack and through the return registers, so we need to get it in both places.
Generators pass return values through both the eval stack and the registers, so the memory location already contains the same value.
Generic Parameters are visible in the function body.
Generic Parsing and AST Building
Generic and dynamic static properties require lazy initialization, which isn't implemented yet.
Generic functions aren't first-class values and shouldn't end up lowered through this interface.
Generic integer switch
Generic translation: convert both to strings, and then concatenate them.
Generic tuple value witness for 'allocateBuffer'
Generic tuple value witness for 'assignWithCopy'.
Generic tuple value witness for 'assignWithTake'.
Generic tuple value witness for 'deallocateBuffer'.
Generic tuple value witness for 'destroy'.
Generic tuple value witness for 'destroyArray'.
Generic tuple value witness for 'destroyBuffer'.
Generic tuple value witness for 'initializeArrayWithCopy'.
Generic tuple value witness for 'initializeArrayWithTakeBackToFront'.
Generic tuple value witness for 'initializeArrayWithTakeFrontToBack'.
Generic tuple value witness for 'initializeBufferWithCopy'.
Generic tuple value witness for 'initializeBufferWithCopyOfBuffer'.
Generic tuple value witness for 'initializeBufferWithTake'.
Generic tuple value witness for 'initializeBufferWithTakeOfBuffer'.
Generic tuple value witness for 'initializeWithCopy'.
Generic tuple value witness for 'initializeWithTake'.
Generic tuple value witness for 'projectBuffer'.
Generic type parameters can inherit a class.
Generic type parameters.
Generic type params are siblings to align.
Generic types are trickier, because they can require conformances.
GenericFunctionTypes shouldn't nest.
GenericSpecializationParams Specializations are just prepended to already-mangled names.
Genset and Killset are initially empty.
Get 16 bits motorola order (always) for jpeg header stuff.
Get ProtocolConformance for a replacement type.
Get SIL-linkage for something that's not required to be visible / and doesn't actually need to be uniqued.
Get a StringMapEntry for the function.
Get a StringMapEntry for the variable.
Get a bit vector indicating which arguments are non-null for a / given function or method.
Get a compatible Class, and add it to the list of defined classes.
Get a destination that runs all of the cleanups needed when existing on the failure path.
Get a list of SerializedModules from ASTContext.
Get a map from basic blocks or the original loop to the cloned loop.
Get a map of expressions to their depths and post-order traversal indices.
Get a new slab, then allocate nbytes from it and install it in our slab list.
Get a pointer to the storage type for the given type.
Get a stack slot, looking through mark_uninitialized if necessary.
Get additional server params from the transport if it has any.
Get algorithmic types
Get all declared properties first, bottom-to-top in the inheritance hierarchy, in declaration order.
Get all interesting uses of the object (e.g. release instructions).
Get all non-failure exit BBs in the Apply Callee if our partial apply is guaranteed.
Get all of the analyses that we need.
Get an appropriately cast function pointer.
Get an appropriately-cast function pointer.
Get an estimate of the number of aliased functions.
Get analysis results that let us build the rc flowgraphs.
Get and validate the ordering argument, which is required.
Get and validate the ordering arguments, which are both required.
Get and validate the suboperation name, which is required.
Get appropriate arguments.
Get arguments and do error checking
Get astronomical twilight
Get at least the name of the module.
Get best match possible.
Get constant option value
Get current dominating block.
Get current options, unsetting the NO_TLSv1_* bits.
Get declaration of the superclass.
Get direct subclasses
Get disassembled instruction in codeStr
Get either the specialized emitter for a known function, or the function value for a normal callee.
Get everything else as option/offset value
Get field specification
Get function parameters and do error checking
Get function parameters and do error-checking.
Get getCacheDir() from the context
Get headername for tag_num or nullptr if not defined
Get index of expression in tuple.
Get information about a potential select_value case (or default).
Get it from /proc/cpuinfo if we can.
Get location metadata for the inputs of `ni'.
Get lowered formal types for callback parameters.
Get memory for full buffer, including space for trailing EOB's.
Get metadata for the dynamic Self type if we have it.
Get nautical twilight
Get next piece if no limit or limit not yet reached and something matched
Get number of code points assuming we substitute invalid sequences.
Get number of septets
Get number option value as string
Get of new value in array
Get offset range for the pc only.
Get offset ranges for the whole line.
Get operands of a binary bitop builtin where one operand is an integer / literal.
Get or create SILGlobalVariable for a given global VarDecl.
Get or create a "GOT equivalent" llvm::GlobalVariable, if applicable.
Get or create a global Objective-C method name.
Get or create a global UTF-16 string constant.
Get or create a global string constant.
Get or create a helper function with the given name and type, lazily / using the given generation function to fill in its body.
Get or create a type metadata cache variable.
Get or create a witness table cache variable.
Get or create an LLVM function with these linkage rules.
Get or create an LLVM global variable with these linkage rules.
Get or create an ObjC protocol record.
Get or create an ObjC protocol reference.
Get or create an Objective-C selector reference.
Get or create an accessor function to the given generic type.
Get or create an accessor function to the given non-dependent type.
Get or create an llvm::GlobalVariable.
Get or create buffers for the arguments.
Get out of here if we are something else like an array.
Get parent's equivalent property, if one exists.
Get potential bindings.
Get properties from the actual object unless we're serializing for var_dump()/print_r() and the object exports a __debugInfo() magic method.
Get ready to actually load the members.
Get rest as section/offset value
Get rid of all the Cookies that have expired
Get rid of apparently dead functions as soon as possible so that we do not spend time optimizing them.
Get rid of definitions for all global functions that are not marked as alive.
Get rid of the completely unreachable blocks, now that any arcs to/from them are gone.
Get source type and bit width.
Get substitutions, if source is a bound generic type.
Get sun up/down and transit
Get the 'self' decl and type.
Get the (GuaranteedValue, Token) tuple from a call to "unsafeGuaranteed" / if the tuple elements are identified by a single tuple_extract use.
Get the (sub)module to generate.
Get the (sub)module to print.
Get the Address of a SIL value of address type, which must have been / lowered.
Get the Application Context object
Get the Class* part of the cache line.
Get the DV blocks, without the rest of the primary function body, and then add them to the end of sorted.
Get the Encoding used by the Terminal at this point in time
Get the LoweredValue corresponding to the given SIL value, which must / have been lowered.
Get the NewAggregateBuilder associated with Node or if none is created, / create one for Node.
Get the NewAggregateBuilder associated with Node.
Get the ObjC instance or class object to check for these conformances.
Get the ObjC metadata for the class.
Get the ObjC metadata for the type we're checking.
Get the ObjC selector family a SILDeclRef implicitly belongs to.
Get the PIPE_BUF from pathconf
Get the Phantom singleton
Get the REPLInput object owned by the REPL instance.
Get the SIL metatype of this type.
Get the SIL subtypes of the returned tuple type.
Get the SILArgument's incoming values.
Get the Swift identifier.
Get the Swift metadata for the type we're checking.
Get the Swift type metadata for the type.
Get the URL string before calling the superclass.
Get the accessor function.
Get the actual class object.
Get the address at which the field type vector reference should be cached.
Get the address of the global variable the protocol reference gets indirected through.
Get the address to which to store the result.
Get the aggregate member based on the top of the projection stack.
Get the allocation alignment of this box.
Get the allocation size of this box.
Get the arg if we haven't already.
Get the arg, which should be in a paren expression.
Get the arguments and check for errors
Get the arguments in the proper registers.
Get the associated type reference from a child archetype.
Get the best known type information about the destination type.
Get the bit representing the LSLocation in the LocationVault.
Get the bit representing the LSValue in the LSValueVault.
Get the bit representing the location in the LocationVault.
Get the bytes behind the string literal, dropping the double quotes.
Get the cached witness table, if successful.
Get the callee value at the needed uncurry level, uncurrying as much as possible.
Get the callee value.
Get the camel-case words in the name and type name.
Get the captured native function value out of the block.
Get the class name as a string using NSStringFromClass.
Get the class pointer.
Get the conformance and record it.
Get the contents of the original source file.
Get the context as a Decl, or nullptr.
Get the context as a PrintStructureKind, or None.
Get the context generic parameters for an entity.
Get the correct stack frame
Get the corresponding context type.
Get the current column number.
Get the current line number.
Get the current token.
Get the current type to process.
Get the current used size of the three stacks, in elements.
Get the declared type.
Get the default value for journalling
Get the delimiter and display a warning if it is alphanumeric or a backslash.
Get the destination block.
Get the destination payload type
Get the dominance node of the header.
Get the dominator tree.
Get the edge values from the terminator to the destination basic block.
Get the element of Aggregate corresponding to the one extracted by Extract.
Get the end of the line.
Get the enum element and the destination block of the block we jump thread.
Get the exit blocks of the original loop.
Get the expected type of a dynamic method reference.
Get the expression result of type checking the arguments to the call independently, so we have some idea of what we're working with.
Get the expression's simplified type.
Get the extra tag bits, if any.
Get the field offset vector from the struct metadata.
Get the field offset vector.
Get the file-name to group map if parsing correctly.
Get the filename in which execution will proceed when execution resumes.
Get the first induction value.
Get the first level projection for the struct or tuple type.
Get the first level projection of the current type.
Get the fp and pc of the top frame (possibly skipping one frame).
Get the fragile type information for the given type, which is known / to have undergone SIL type lowering (or be one of the types for / which that lowering is the identity function).
Get the fragile type information for the given type, which may not / have yet undergone SIL type lowering.
Get the fragile type information for the given type.
Get the function generic params, including outer params.
Get the function to reference from the vtable.
Get the function value.
Get the generation number under which this lookup failed.
Get the generic signature from the surrounding context.
Get the getter and setter extended encodings, if needed.
Get the global variable.
Get the guard page's size, because the stack address returned above starts at the guard page, so the thread's stack limit is stackaddr + guardsize.
Get the heap metadata for the box.
Get the identifier for the base name.
Get the index of the first non-reserved bit.
Get the index of the first range or use that is not strictly lower than `pos' (i.e., which contains/is at `pos' or is strictly higher than `pos').
Get the ini (-d) and hdf (-v) strings, which may override some of options that were set from config files.
Get the innermost enclosing declaration for a declaration.
Get the input stream.
Get the inputs without 'self'.
Get the instance size and alignment mask for the given class / instance.
Get the integer constant.
Get the interface type of the result.
Get the interface types of all of the captured values, mapped out of the / context of the callee we're partially applying.
Get the intrinsic function.
Get the last induction value.
Get the least common ancestor across both states.
Get the length of the current token.
Get the length of the given full name, counting up the base name and all / argument labels.
Get the line and indent position for this context.
Get the line number on which execution will proceed when execution resumes.
Get the linkage for SILGlobalVariable.
Get the list of existential constraints.
Get the loop exit condition.
Get the lowered AST types: - the original type
Get the lowered optional payload types.
Get the lowering for the address type.
Get the lvalue address as a raw pointer.
Get the main source file's private discriminator and attach it to the compile unit's flags.
Get the maximum possible capacity without reallocation.
Get the message property from the Exception if we can.
Get the messenger function.
Get the metaclass pointer as an intptr_t.
Get the metatype metadata from the runtime.
Get the metatype of this type.
Get the method dispatch mechanism for a method.
Get the most optimal resilience expansion for the body of this function.
Get the name of the class or protocol to mangle into the ObjC symbol / name.
Get the natural IR type in the body of the function that makes the call.
Get the next argument and use it as the 'self' type metadata.
Get the next argument as a pointer to the given storage type.
Get the next character.
Get the next client and their address (as a string)
Get the next execution offset
Get the next level projections based on current projection's type.
Get the next state from the transition table.
Get the nominal type.
Get the non-self parameter from the Clang type.
Get the number of expected generic parameters, which is a sum of the number of explicit generic parameters and the number of their recursive member types exposed through protocol requirements.
Get the openend existential value if the archetype is an opened existential type.
Get the operator, if appropriate to this pass.
Get the original lvalue.
Get the original pointer value, abstracted to the converter function's expected level.
Get the original type of the witness from the conformance.
Get the original value.
Get the output stream.
Get the pair of array and index. Because we want to disambiguate between the two types of check bounds checks merge in the type into the lower bit of one of the addresse index.
Get the parent module because currently we don't represent submodules with ClangModule.
Get the parent module because currently we don't represent submodules with ClangModuleUnit.
Get the path through a tuple, if relevant.
Get the payload and extra tag (if any) parts of the discriminator for a no-data case.
Get the payload argument.
Get the phi group for r's def, optionally allocating a new phi group if necessary.
Get the protocol being conformed to.
Get the protocol reference.
Get the reference storage type of the builtin object whose value witness we can borrow.
Get the reference to the existential box.
Get the referenced base expression from the failed constraint, along with the SourceRange for the member ref.
Get the referenced expression from the failed constraint.
Get the requested handler
Get the requirement and witness attributes.
Get the requirements that aren't rooted in the applied 'self' parameter.
Get the return value.
Get the runtime library link path for static linking, / which is platform-specific and found relative to the compiler.
Get the runtime library link path, which is platform-specific and found / relative to the compiler.
Get the self argument.
Get the server status
Get the set of let properties defined by this struct.
Get the signedness of the destination.
Get the simplified type of each element and rebuild the aggregate.
Get the single byte that remains after the file type indentification
Get the single stack slot we can deshadow, or null if no such slot was / found.
Get the size of the various sections.
Get the spare bits from this part.
Get the special protocol kind for an uncomposed protocol existential.
Get the squares of the lengths of the segemnts AC and BC.
Get the static metadata.
Get the storage type for the given type.
Get the stored value for a load.
Get the sub expression argument as a managed value
Get the sub-initializations.
Get the subcommand name and remove it from the program arguments.
Get the sugared type directly from the tuple expression, if there is one.
Get the superclass constraint.
Get the superclass of current one
Get the superclass type.
Get the tag bits from spare bits, if any.
Get the transitive set of top-level imports.
Get the type information for the given type, which may not / have yet undergone SIL type lowering.
Get the type information for the given type, which may not have / yet undergone SIL type lowering.
Get the type metadata for the instance.
Get the type metadata from the ObjC class, which may be a wrapper.
Get the type metadata.
Get the type name by chopping off "Builtin.".
Get the type of a destructor function.
Get the type of a global variable getter function.
Get the type of a reference to the first declaration, swapping in archetypes for the dependent types.
Get the type of a reference to the second declaration.
Get the type of the function for substitution purposes.
Get the type of the witness.
Get the type that exists at runtime to represent a compile-time type.
Get the type used to initialize the existential.
Get the type without the first uncurry level with 'self'.
Get the unapplied params.
Get the unbound generic type F belongs to.
Get the underlying array pointer.
Get the unlowered formal type of the constant, stripping off the first level of function application, which applies captures.
Get the unsubstituted capture types for a closure context.
Get the user-defined data for this scanner.
Get the value out of the optional, and wrap it up with a cleanup so that any exits out of this scope properly clean it up.
Get the value we're testing, which is a function.
Get the value we're testing, which may be a function, an address or an instance pointer.
Get the value witness table for an existential type, first trying to use a / shared specialized table for common cases.
Get the value witness table for the element.
Get the variable name as a cell, for the LHS
Get the version of this compiler and pass it to C/Objective-C declarations.
Get the witness tables.
Get time delta in microseconds.
Get to the last dot part and get its value, if it exists
Get transitive closure of value captured by this function, and any captured functions.
Get value of parameter
Get values for all the properties.
Get weight of this magic entry, for sorting purposes.
Get-only properties are (readonly).
Get/Create intermediate arrays for multidimensional arrays
Get/create the semaphore.
Gets input and stuffs it into "buf".
Gets its class name from 1st column
Gets or creates the MethodInfo for a vtable or witness table method.
Gets the base implementation of a method.
Gets the entry for a SIL value, e.g. an array-value or a tuple containing / an array.
Gets the entry for a struct or class field.
Gets the entry for a value at an address, e.g. a struct/class field or / an alloc_stack.
Gets the estimated definition of a value if it is in the caller.
Gets the estimated definition of a value.
Gets the estimated integer constant of a value.
Gets the estimated integer constant result of a builtin.
Gets the parameter in the caller for a function argument.
Gets the producing instruction of a cond_fail condition.
Gets the underlying address of a load.
Getter has none, setter has one arg
Getter selectors can belong to families if their name begins with the wrong thing.
Getters and Setters are anonymous functions, so we forge a name using its parent declaration.
Getters return the value type.
Getting a nontrivial metatype requires forcing any conformances necessary to instantiate the type.
Getting more aggresive
Getting name, advancing i
Getting the dynamic type of a class doesn't require type metadata.
Getting the interface from a swift source file differs from getting interfaces / from headers or modules for its performing asynchronously.
Getting this wrong will cause subtle breakage -- in particular, it probably will not show up in CLI mode, since everything there tends to be single theaded.
Getting type, advancing i
Give a cond_br or switch_enum instruction and one successor block return / true if we can infer the value of the condition/enum along the edge to this / successor blocks.
Give a tailored error message for this case.
Give back the default-argument context if we didn't need it.
Give each SILBasicBlock a unique ID.
Give each parameter in a ClosureExpr a fresh type variable if parameter / types were not specified, and return the eventual function type.
Give each parameter in a ClosureExpr a fresh type variable if parameter types were not specified, and return the eventual function type.
Give it a module number
Give reconnect a shot, it could help...
Give the cmd a bad type and send it over.
Give the context the list of search paths to use for modules.
Give the debugger a chance to do extra logging if there are any attached debugger clients.
Give the enum element the appropriate type.
Give the function an empty body.
Give the prologue a TransID if we have profiling data.
Give up and call the interpreter
Give up if it's not a string.
Give up if the array semantic function might change the uniqueness state of an array value in the loop.
Give user a chance to reallocate the stack.
Given "NSMagicArmor" and "NSMagicArmory", only / "NSMagic" is returned.
Given N extra inhabitants, we represent the first N tags using those inhabitants.
Given SSA, there's a faster sparse version of this algorithm that marks useful instructions in one pass, then transitively marks pure instructions that define inputs to useful instructions.
Given a C parameter declaration whose type is passed directly, / deduce the convention for it.
Given a C parameter declaration whose type is passed indirectly, / deduce the convention for it.
Given a Clang-expanded (according to ABIArgInfo::Expand) parameter / in 'in', produce a Swift value explosion in 'out'.
Given a DIE representing an arbitrary type, return its equivalent Type.
Given a DIE, and the current scope, recursively generate the names/linkages for all the object types in this DIE and children.
Given a DIE, walk the specification chain and return the offset of the actual type declaration.
Given a LSLocation, try to collect all the LSValues for this LSLocation / in the given basic block.
Given a SILType which is a ReferenceStorageType, return the type / info for the underlying reference type.
Given a Swift type, attempt to return an appropriate Clang / CanQualType for the purpose of generating correct code for the / ABI.
Given a Swift value explosion in 'in', produce a Clang expansion / (according to ABIArgInfo::Expand) in 'out'.
Given a TrackedStore s1 in blk, and s2 in succ, figure out the new TrackedStore to replace s2.
Given a ValueMember, UnresolvedValueMember, or TypeMember constraint, / perform a lookup into the specified base type to find a candidate list.
Given a VarDecl with a willSet: and/or didSet: specifier, synthesize the / (trivial) getter and the setter, which calls these.
Given a call to a helper function that produces a result / into its first argument, set attributes appropriately.
Given a call to a helper function, set attributes appropriately.
Given a candidate list, this computes the narrowest closeness to the match / we're looking for and filters out any worse matches.
Given a class existential container, returns a witness table / pointer out of the container, and the type metadata pointer for the / value.
Given a class metatype, produce the necessary heap metadata / reference.
Given a collection of "linked" expressions, analyzes them for / commonalities regarding their types.
Given a current token of 'unowned', check to see if it is followed by a / "(safe)" or "(unsafe)" specifier.
Given a day number, find the molad of Tishri (the new moon at the start of a year) which is closest to that day number.
Given a declaration that allows availability attributes in the abstract / syntax tree, return the declaration upon which the declaration would / appear in concrete syntax.
Given a declaration upon which an availability attribute would appear in / concrete syntax, return a declaration to which the parser / actually attaches the attribute in the abstract syntax tree.
Given a default SSL config, SSL_CTX, and certificate path, load certs.
Given a filename, finds the corresponding unit if it exists.
Given a full struct explosion, project out a single field.
Given a full tuple explosion, project out a single element.
Given a function candidate with an uncurry level, return the parameter / type at the specified uncurry level.
Given a generic signature, add the argument types required in order to call it.
Given a list of a specific marker object type, apply the given callable f to it (which should extract the marked type out of it), sort and uniquify the resultant list, and return it.
Given a list of direct results, form the direct result value.
Given a load with multiple struct_extracts/tuple_extracts and no other uses, canonicalize the load into several (struct_element_addr (load)) pairs.
Given a loaded type like CInt, look through the name alias sugar that the stdlib uses to show the underlying type.
Given a lowered SIL type, apply a substitution to it to produce another / lowered SIL type which uses the same abstraction conventions.
Given a lowered SIL type, load a value witness table that represents its / layout.
Given a metatype pointer, produce the value-witness table for it.
Given a metatype value for the type, allocate an Objective-C / object (with alloc_ref_dynamic) of that type.
Given a metonic cycle number, calculate the date and time of the molad (new moon) that starts that cycle.
Given a name like "autoclosure", return the type attribute ID that / corresponds to it.
Given a name like "inline", return the decl attribute ID that corresponds / to it.
Given a node, you can walk the parents towards roots to find out why the node is reachable.
Given a non-tagged object pointer, load a pointer to its class object.
Given a pair of instructions that are already known to have the same kind, / type, and operands check any special state in the two instructions that / could disrupt equality.
Given a partial_apply instruction, create a specialized callee by removing / all constant arguments and adding constant literals to the specialized / function body.
Given a pattern stored in a clause matrix, check to see whether it / can be specialized the same way as the first one.
Given a pointer to a heap object (i.e. definitely not a tagged / pointer), load its heap metadata pointer.
Given a possibly-existential value, deallocate any buffer in its storage.
Given a possibly-existential value, find its dynamic type and the / address of its storage.
Given a reference range and a declaration context containing the range, / attempt to find a declaration containing the reference.
Given a reference to class metadata of the given type, / derive a reference to the field offset for a stored property.
Given a reference to class metadata of the given type, / load the fragile instance size and alignment of the class.
Given a reference to nominal type metadata of the given type, / derive a reference to a protocol witness table for the nth / argument metadata.
Given a reference to nominal type metadata of the given type, / derive a reference to the nth argument metadata.
Given a reference to some metadata, derive a reference to the / type's parent type.
Given a result of name lookup that had no viable results, diagnose the / unviable ones.
Given a scalar value, materialize it into memory with the / exact same level of cleanup it had before.
Given a serial day number (SDN), find the corresponding year, month and day in the Jewish calendar.
Given a set of parameter lists from an overload group, and a list of / arguments, emit a diagnostic indicating any partially matching / overloads.
Given a set of parameter lists from an overload group, and a list of / arguments, emit a diagnostic indicating any partially matching overloads.
Given a specific expression and the remnants of the failed constraint / system, produce a specific diagnostic.
Given a subpath of an old locator, compute its summary flags.
Given a substituted explosion, re-emit it as an unsubstituted one.
Given a symbol name and a depth, returns the symbol's value.
Given a symbolic element number, return the type of the element.
Given a tuple shuffle and an original parameter type, construct / the type of the source of the tuple shuffle preserving as much / information as possible from the original parameter type.
Given a tuple_element_addr or struct_element_addr, compute the new / BaseEltNo implicit in the selected member, and recursively add uses of / the instruction.
Given a type and a declaration context, return a type with a curried 'self' type as input if the declaration context describes a type.
Given a type metadata pointer, load its value witness table.
Given a type metadata pointer, load one of the value witnesses from its / value witness table.
Given a type, check if this is an object type with any template parameters being a pointer followable type.
Given a type, determine how many bytes an instance of that type occupies.
Given a type, determine if it is non-interesting, IE, its generated layout is empty.
Given a type, determine if it is pointer followable.
Given a type, fill the given layout (starting at the specified offset) appropriate for that type.
Given a use that has at least one uninitialized element in it, produce a / nice symbolic name for the element being accessed.
Given a value with the abstraction patterns of the original formal / type, give it the abstraction patterns of the substituted formal type.
Given a value with the abstraction patterns of the substituted / formal type, give it the abstraction patterns of the original / formal type.
Given a value witness table, load one of the value witnesses.
Given a variant, coerce it into a EVP_PKEY object.
Given a year, find the number of the first day of that year and the date and time of the starting molad.
Given a year, month and day in the Jewish calendar, find the corresponding serial day number (SDN).
Given an AST type, load its value witness table.
Given an RValue of aggregate type, compute the values of the elements by / emitting a series of tuple_element instructions.
Given an abstract type --- a type possibly expressed in terms of / unbound generic types --- return the formal type within the type's / primary defining context.
Given an aggregate value and an access path, extract the value indicated by / the path.
Given an apply or partial_apply, return the direct callee or / nullptr if this is not a direct call.
Given an array of polymorphic arguments as might be set up by / GenericArguments, bind the polymorphic parameters.
Given an array value, recursively check that uses of elements within the / array are safe.
Given an existential object, find the witness table / corresponding to the given protocol.
Given an existential object, returns the payload value.
Given an exploded enum payload consisting of consecutive word-sized chunks, cast them to their underlying component types.
Given an explosion with multiple pointer elements in them, pack them / into an enum payload explosion.
Given an expression that has a non-lvalue type, dig into it until we find / the part of the expression that prevents the entire subexpression from being / mutable.
Given an incompatible argument being passed to a parameter, decide whether / it is a "near" miss or not.
Given an inject_enum_addr of a concrete type without payload, promote it to a store of an enum.
Given an instruction which is considered live, propagate that liveness back to the instructions that produce values it consumes.
Given an integer argument, see if it is ultimately matching whether / a given enum is of a given tag.
Given an interesting instruction, incorporate it into the set of results, and filter down the list of demanded subelements that we still need.
Given an object type representation, fill the given Layout (starting at specified offset) with the appropriate layout for that object type.
Given an object type, check if any template parameters are a pointer followable type.
Given an object type, determine if it is non-interesting, IE, its generated layout is empty.
Given an object type, examine it to infer all the needed actions for that type.
Given an object type, return the matching Object representation.
Given an operand of a direct apply or partial_apply of a function, / return the index of the parameter used in the body of the function / to represent this operand.
Given an operand of a direct apply or partial_apply of a function, / return the parameter used in the body of the function to represent / this operand.
Given an unhandled case, we have an illegal use for our optimization / purposes.
Given an unresolved T_shape TypeStructure, returns the __fields__ portion of the array with all the field names resolved to string literals.
Given any guaranteed arguments that are not being passed at +0, insert the decrement here instead of at the end of scope.
Given nothing but a formal C parameter type that's passed / directly, deduce the convention for it.
Given nothing but a formal C parameter type that's passed / indirectly, deduce the convention for it.
Given part of the witness's interface type, produce its / substitution according to the witness substitutions.
Given that a cast operation is complete, maybe deallocate an / opaque existential value.
Given that a method returns a CF type, infer its method / family.
Given that a tuple value is being passed indirectly in the / input, explode it and translate the elements.
Given that a tuple value is being passed indirectly in the / output, translate the elements and implode it.
Given that the type-of-rvalue differs from the type-of-storage, / and given that the type-of-rvalue is loadable, produce a +1 scalar / of the type-of-rvalue.
Given that the type-of-rvalue differs from the type-of-storage, / store a +1 value (possibly not a scalar) of the type-of-rvalue / into the given address.
Given that type1 is known to be a subtype of type2, check if the two / types have the same calling convention representation.
Given that we are currently at the beginning of the / continuation block, complete the operation.
Given that we are returning a normal value, convert it to a / bridged representation and set up a return value according to the / given foreign-error convention.
Given that we are throwing a native error, turn it into a bridged / error, dispose of it in the correct way, and create the appropriate / normal return value for the given foreign-error convention.
Given that we have a source for a witness table that the given type / conforms to the given protocol, check to see if it fulfills anything.
Given that we have a source for metadata of the given type, check / to see if it fulfills anything.
Given that we have an imported Clang declaration, deduce the / ownership conventions for calling it and build the SILFunctionType.
Given that we're going to define a global value but already have a / forward-declaration of it, update its linkage.
Given that we've applied some sort of trivial transform to the / value of the given ManagedValue, enter a cleanup for the result if / the original had a cleanup.
Given that we've broken down a source value into this subobject, / and that we were supposed to use the given consumption rules on / it, construct an appropriate managed value.
Given the DIE representing an object type, its name, and its key, return the detailed specification of the object.
Given the address of a class existential container, returns / the address of a witness table pointer.
Given the address of a class existential container, returns / the address of its instance pointer.
Given the address of a tuple, project out the address of a / single element.
Given the address of an existential object, destroy it.
Given the address of an existential object, drill down to the / metadata field.
Given the address of an existential object, drill down to the / witness-table field.
Given the address of an existential object, find the witness / table corresponding to the given protocol.
Given the address of an existential object, find the witness / table of a directly-stored witness table.
Given the address of an existential object, load its metadata / object.
Given the address of an existential object, load its witness table.
Given the address of an optional value, unsafely project out the / address of the value.
Given the base of a vector object, pass it to a helper which is responsible for triggering COW.
Given the bit, get the LSLocation from the LocationVault.
Given the bit, get the LSValue from the LSValueVault.
Given the current lattice state, if we have seen a use, advance the / lattice state.
Given the proflogueTransId for a TransProflogue translation, regenerate the prologue (as a TransPrologue).
Given the range of a reference to an unavailable symbol and the / declaration context containing the reference, make a best effort find up to / three locations for potential fixits.
Given the type of a function, classify whether calling it with the / given number of arguments would throw.
Given the type of an argument, try to determine if it contains / a throwing function in a way that is permitted to cause a / 'rethrows' function to throw.
Given the witness table vector from an existential object, find the / witness table corresponding to the given protocol.
Given two SIL types which are representations of the same type, / check whether they have an abstraction difference.
Given two expressions used as indexes to the same SubscriptDecl (and thus / are guaranteed to have the same AST type) check to see if they are going to / produce the same value.
Given whether it's known to be a definition, resolve an optional / SIL linkage to a real one.
Global DCE can change types of locals across blocks.
Global NamedEntity table.
Global error code/message
Global information about importing clang types.
Global properties have no base or subscript.
Global registry for wrappers
Global state for this pass, visible while processing any block.
Global stored properties don't get a materializeForSet.
Global systemlib extensions implemented entirely in PHP
Global type aliases are okay.
Global variable decls must bind variables, except in scripts.
Global variables can be accessed directly with global_addr.
Global variables require an initializer (except in top level code).
Global vars are definitions if they have an initializer.
Global, non-disabled wrapper
Global-init functions should not be inlined GlobalOpt is done.
GlobalARCOpts seems to be taking up a lot of compile time when running on globalinit_func.
Globals and statics are lazily initialized, so they are safe for potential unavailability.
Globals and superglobals can be fetched by finding the symbol
Globals of type NSString * should be imported as 'let'.
Go ahead and initialize the substitution entry.
Go and actually compress the data
Go back through a second time now that we know all of our users are loads.
Go back through the loads a second time, rewriting them into a load + bitcast from our source.
Go down our PAs until we find the referenced PA.
Go find 'Any' in the Swift module.
Go find 'Void' in the Swift module.
Go get the actual nested type.
Go hunting for an unclaimed argument whose name does match.
Go make sure that type declarations that would act as witnesses did not get injected while we were performing checks above.
Go over the collected calls and try to insert speculative calls.
Go perform the resolution again now that we have more information.
Go through all SILVTables in SILMod and write them if we should serialize everything.
Go through all blocks of the function, accumulate the cost and find benefits.
Go through all instructions and find candidates for inlining.
Go through all instructions of the block.
Go through all of our non local successors.
Go through all of our pointers and merge all of the retains with the first retain we saw and all of the releases with the last release we saw.
Go through all of the pretty-printed entries and record their locations.
Go through all the SILFunctions in SILMod and write out any mandatory function bodies.
Go through all users of the constant and try to fold them.
Go through all uses of our closure.
Go through and convert all the entries to i8*.
Go through list of global variables in the SILModule.
Go through our sorted list creating new GEPs only when we need to.
Go through the input array
Go through the loads uses and add any users that are projections to the projection list.
Go through the string and quote necessary characters
Go through the subregions.
Go through the tracking list and add its contents to the worklist and then clear said list in preparation for the next iteration.
Go through the whole list, stopping if you find a match.
Go through uses of the memory allocation of AI...
Go to the (nparams + 1)-th prologue, which is always the "too many args" entry point.
Go to the history item, if it's valid
Go up archetype parents until we find our containing protocol.
Go with PHP5 default behavior of allowing all
Goes through the buffer sending 4K byte batches.
Good, they have migrated already
Got an ExitException during exception handling, handle similarly to the case below but don't call obEndAll().
Government and others acting in its behalf permission to use and distribute the software in accordance with the terms specified in this license.
Grab AI's operands and the relevant types from the ConvertFunction function type and AI.
Grab Target and find the RC identity root of its operand.
Grab a chunk of the mask.
Grab a chunk of the value.
Grab all uses looking past RCIdentical uses from RCIdentityAnalysis.
Grab and 0-index the end line
Grab caller info from ActRec.
Grab caller info from the ActRec, free the ActRec, and return control to the caller.
Grab from the requested context
Grab one of the candidates (if present) and get its input list to help identify operators that have implicit inout arguments.
Grab our relevant callee types...
Grab server information
Grab the BBState associated with it and set it to be the current BB.
Grab the SILLocation and the new managed value.
Grab the absolute path of the script filename
Grab the address info
Grab the apparent 'self' type.
Grab the block pointer and make it the first physical argument.
Grab the breakpoint message and do the break.
Grab the breakpoint, ignore it if it is the wrong type or the classname doesn't match.
Grab the breakpoints matching the passed info
Grab the callee function
Grab the class decl from the alloc ref inst.
Grab the context if it provided
Grab the context if it was passed
Grab the current projections.
Grab the depth if it is provided
Grab the depth if it was provided
Grab the exception name and message
Grab the external entity whitelist and set up the map, then register the callback for external entity loading.
Grab the file as an array
Grab the file, use the current if none provided
Grab the file/line for the frame.
Grab the first fully transparent entry, if any, as the value of the simple-transparency index, mostly for backwards binary compatibility.
Grab the first item off the stack.
Grab the first predecessor BB.
Grab the grouping data out of the array
Grab the hit condition if it was passed
Grab the hostname and port to connect to
Grab the incoming values.
Grab the indexed offset.
Grab the ip address and port of the client that is connected to this proxy.
Grab the last instruction in the BB.
Grab the max data if it was provided
Grab the monetary grouping data out of the array
Grab the new hit value if it was passed
Grab the new line if it was passed
Grab the new state if it was passed
Grab the next constraint from the worklist.
Grab the next non-invalidated node for the next iteration.
Grab the next result.
Grab the operand of the release value inst.
Grab the optional depth argument
Grab the original load.
Grab the page if it was provided
Grab the parameter infos corresponding to this tuple element (but don't drop them from ParamInfos yet).
Grab the parent of this node.
Grab the precomputed frame data for this level
Grab the predecessors state...
Grab the pretty-printed location.
Grab the region associated with the subloop...
Grab the request data and set up a step in
Grab the standard exception type.
Grab the static properties from the class.
Grab the substitutions.
Grab the superclass entry and continue searching for a non-inherited conformance.
Grab the terminator of our one predecessor and if it is a switch enum, mix it into this state.
Grab the the constant, f_constant throws a warning on failure so we ensure it's defined before grabbing it
Grab the thumbnail, corrected
Grab the unit offsets
Grab the value part, except for an 'x' reln.
Grab the write lease before touching the TC.
Gracefully drain any incomplete requests.
Gradually, those gotos should go away as we can handle more kinds of conversions via disjunction constraints.
GraphTraits specialization so the CGForDotView can be / iterable by generic graph iterators.
Graphic Control Extension
Gross hack: strip a level of unchecked-optionality off both sides when matching against a protocol imported from Objective-C.
Group results by module.
Group these individual checks into groups rooted at a canonical non-hoistable IRInstruction.
Grow args, if necessary.
Grow the buffer to sufficient size
Grow to the smallest allowed capacity that is sufficient.
Guaranteed by the memory_order_acquire
Guaranteed just means that we guarantee the lifetime of the object for the duration of the call.
Guaranteed to exit, at least upon timeout.
Guarantees space for at least one push.
Guard doesn't allow labels, so no break/continue.
Guard the inner type before we call the helper.
Guard was relaxed to Gen---don't record it.
Guess 4 spaces as extra indentation.
Guess whether a global entry is a definition from this TU.
Guesstimate the weight of the new block.
Gzip has 20 bytes header, so anything smaller than a few bytes probably wouldn't benefit much from compression
H if before a vowel and not after C,G,P,S,T
HACK HACK HACK: Omit-needless-words hack to try to cope with the "NS" prefix being added/removed.
HACK HACK HACK: This is a workaround for some module invalidation issue and inconsistency.
HACK: 'NSUInteger' suggests both 'UInt' and 'Int'.
HACK: Deal with imports of submodules by importing the top-level module as well, unless it's the top-level module we're currently in.
HACK: Deal with imports of submodules by importing the top-level module as well.
HACK: For synthesized trivial accessors we may have not a valid location for the end of the braces, so in that case we will fall back to using the range for the storage declaration.
HACK: Just update the original declaration instead of importing a second property.
HACK: don't type-check the same function body twice.
HACK: emitVirtualLocal would pollute m_evalStack before visiting exp, YieldExpression won't be happy
HACK: functions can get queued multiple times in definedFunctions, so be sure to be idempotent.
HAS TO BE UPDATED BEFORE calling sample_stack
HAVE_LIBBFD Basically everything in here requires libbfd.
HAVE_SNAPPY / NZLIB functions
HDF values take priority over INI.
HEADER Metadata required for reading the completions.
HHBBC may have proven something about the inner type of this wait handle.
HHIR may have figured the topFunc even though the RegionDesc didn't know it.
HNI conversions implicitly unbox references, this behavior is wrong, in particular it breaks the way type conversion works for PHP 7 scalar type hints
HPHP logs may need to access data in ServerStats, so we have to clear the hashtable after writing the log entry.
HTTPPushTransactionHandler interface
HW events for each region
Hack around buffer overflow in libicu.
Hack to deal with types already getting set during type validation above.
Hack to deal with unannotated Objective-C protocols.
Hack to handle thunks eagerly synthesized by the Clang importer.
Hack to make it process IDF1 I hope There are 2 IDFs, the second one holds the keys (0x0201 and 0x0202) to the thumbnail
Hack to stop the mangled name from showing up
Hack--We emit a static thunk for ObjC allocating constructors.
Hack: If the name of the constant being defined is itself a constant expression, assume that its not yet defined.
Hack: These two are not really page specific.
Hack: mark any method named "print" with less than two parameters as warn_unqualified_access.
Halt means to stop processing along this control flow path---something during analysis had to pessimize and we can't continue.
Handle "exit" edges from the lifetime region.
Handle "x.dynamicType" - A metatype expr.
Handle "x.self" expr.
Handle 'int8' and friends.
Handle .foo by just making an AST node.
Handle AnyObject directly.
Handle AnyObject in a special way.
Handle C pointer arguments imported as indirect `self` arguments.
Handle Int and UInt specially.
Handle LLVM intrinsic functions.
Handle SILArgument for base invalidation.
Handle SILArgument, SILArgument can invalidate.
Handle Swift builtin functions.
Handle a SILBasicBlock record.
Handle a SILInstruction record.
Handle a nested optional case (see above).
Handle a parameter block requirement.
Handle a regular call.
Handle a special case, where ArgBB is the entry block.
Handle a specialized emitter operating on evaluated arguments.
Handle a store to "x.y" where 'base' is the expression for x and 'decl' is / the decl for 'y'.
Handle a tuple that has been exploded in both the input and / the output.
Handle a tuple that has been exploded in the input but wrapped in / an optional in the output.
Handle accessors as part of their property.
Handle accessors specially, they are mangled as modifiers on the accessed declaration.
Handle all builtins which can be optimized.
Handle all moves that aren't part of a cycle.
Handle all of the SIMPLE_DECL_ATTRs.
Handle all other references.
Handle all other reverse-dependency instructions, like cond_fail and fix_lifetime.
Handle all the integer types as opaque values.
Handle an interrupt from the VM.
Handle an opaque lvalue that refers to an opened existential.
Handle any attribute-specific processing logic.
Handle any attributes that are not printed at all before we make printer callbacks.
Handle any decl-modifiers.
Handle archetype-to-super and derived-to-base upcasts.
Handle argument label mismatches when we have multiple candidates.
Handle arguments common to all invocations of the frontend (compilation, / module-merging, LLDB's REPL, etc).
Handle arguments' changes.
Handle array addition first because we don't want to bother with boxed locals.
Handle associated type lookup as a special case, horribly.
Handle atomic ops on pointers by casting to intptr_t.
Handle boolean conditions.
Handle both degenerate '#' and '# identifier'.
Handle bridged types.
Handle builtin types by adding entries to the cache that reverse the mapping done by the importer.
Handle builtin types by importing them and getting the Swift name.
Handle cases where one or the other name is empty.
Handle checking a metatype object's type by directly comparing the address of the metatype value to the subclass's static metatype instance.
Handle class 'Self', which is just a class type.
Handle classes directly here, since only top-level classes are hoistable.
Handle cleanup locations.
Handle cold blocks separately.
Handle collection downcasts separately.
Handle complete name matches.
Handle cond_fail instructions.
Handle consumes that only remove the reference if the taken branch is not traversed, after we've propagated to taken.
Handle contextual type, result type, and returnsSelf.
Handle custom accessor names.
Handle destruction of a local array.
Handle do/catch differently.
Handle dynamic lookup.
Handle dynamic references.
Handle dynamically set constants
Handle each of these in turn.
Handle edits that occurred after we processed the AST.
Handle empty identifiers.
Handle exception thrown by async function.
Handle exception thrown by async generator.
Handle falling out of the do-block.
Handle finding an empty strong iterator slot when the first slot was already in use.
Handle fixup and unwind information.
Handle format arguments if any
Handle full apply sites that have a resolvable callee function with an effects attribute.
Handle globals treated as members.
Handle hex numbers str is used instead of ptr to disallow signs and keep old behavior
Handle identifier type representations.
Handle includes of pseudomains.
Handle initializers, they have their own approach to name lookup.
Handle inout bases specially here.
Handle instance and type computed variables.
Handle integrated test tools which do not use llvm::cl::ParseCommandLineOptions.
Handle integrated tools.
Handle it as other diagnostics.
Handle it better way.
Handle it specially to avoid unnecessary control flow.
Handle known type names.
Handle leading and trailing quotes
Handle literals, which are a call to the conversion function.
Handle local and top-level computed variables.
Handle local declarations.
Handle lvalue-to-lvalue assignments with a high-level copy_addr instruction if possible.
Handle member dependencies specially.
Handle member initializers.
Handle metatype references, as in "some_type.some_member".
Handle method calls with a specific diagnostic + fixit.
Handle methods first.
Handle missing optional requirements.
Handle nominal types that are not directly generic.
Handle nominal types.
Handle non-enclosure field
Handle nontrivial tags.
Handle one file or directory.
Handle only integer values for now.
Handle optional operands and results in an explicit cast.
Handle optional unwrapping of the cast source.
Handle other closures.
Handle output being an exploded tuple when the input is opaque.
Handle parameter type constraint failures
Handle per-connection termination cleanup.
Handle polymorphic functions by properly substituting their parameter types.
Handle pre-versioned input
Handle privately visible modules as well.
Handle productions that are always leaf patterns or are already resolved.
Handle properties and subscripts, anchored by the getter's selector.
Handle properties directly.
Handle protocol 'Self', which is an archetype.
Handle protocol compositions.
Handle recursive inheritance.
Handle redeclared decls.
Handle relational constraints.
Handle results of XXX_with_overflow arithmetic.
Handle return type constraint failures
Handle return value's change.
Handle self-recursion.
Handle sil-constant-kind-and-uncurry-level.
Handle sil-dotted-path.
Handle simple subtype bindings.
Handle single-expression closures.
Handle some kind of instructions specially.
Handle special abstraction differences in "self".
Handle special arg '*' for all codes and check argv overflows
Handle special case write when we're returning the entire transfer
Handle stacked args like `tar -xzf`
Handle stacks specially to be less pessimistic.
Handle store and assign.
Handle stores as a special case here: we want to make sure that the object is being stored *to*, not itself being stored (which would be an escape point).
Handle stuff specific to cppext classes
Handle subscripting of generics.
Handle subtype conversions involving optionals.
Handle suffix expressions.
Handle switch / case, indent unless at a case label.
Handle symbols marked as explicitly unavailable.
Handle symbols that are matches, but are not accessible from the current scope.
Handle the "reset" form.
Handle the (label: ()) param used by functions imported as labeled nullary initializers.
Handle the CPU and its preferences.
Handle the None case.
Handle the ObjC prefix.
Handle the Some case.
Handle the arguments of an ObjC method.
Handle the bridging header case.
Handle the case of a promoted capture argument.
Handle the case when the payload has no storage.
Handle the case where the callee of the apply is a load instruction.
Handle the case where the constraint is a type alias
Handle the cases covered by each tag bit value.
Handle the cases where we didn't have enough preallocated Ents in tl_miter_table, and we need to allocate from `extras'.
Handle the common case where the caller passed two params (a callback and a container)
Handle the direct result type, checking for supposedly scalar result types that we actually want to return indirectly.
Handle the extensions that we have not yet visited.
Handle the first instruction in the BB.
Handle the fully inlined Builtin.
Handle the implicit rethrow block.
Handle the integer 'select' modifier.
Handle the last unsubstituted case.
Handle the leading byte, based on the number of bits in the value.
Handle the likely case someone typed 'case X, case Y'.
Handle the mechanical aspects of removing an unreachable block.
Handle the module-not-found diagnostic specially if it's a top-level module we're looking for.
Handle the nominal type.
Handle the obvious case.
Handle the possibility of nested existentials.
Handle the requirements.
Handle the return value, unblock any additional parents, release the WaitHandle, and transfer control to the parent.
Handle the return value.
Handle the special case of copying an lvalue.
Handle the split backedge case.
Handle the subsequent VM frames.
Handle the top frame.
Handle the uncommon case where the caller passed a callback and two or more containers
Handle the usual case here: the class in question should be a real subclass of a bound generic class.
Handle the various field types.
Handle these cases below.
Handle this by / inserting a bitvector that tracks the liveness of each tuple element / independently.
Handle this by diagnostic various cases that come up.
Handle this by performing a concrete lookup.
Handle this by rewriting the arguments to UnresolvedType().
Handle tuple destinations by destructuring them if present.
Handle type-function if we have an arrow or 'throws'/'rethrows' modifier.
Handle type-function if we have an arrow.
Handle unknown preds.
Handle unspecialized types directly.
Handle variadic parameters.
Handle weak/unowned/unowned(unsafe).
Handle weird, encoded offset, used by cgLdObjMethod
Handle wrapping an Optional target.
Handle zero-argument selectors directly.
Handled at the EnumElement level.
Handled at the PatternBindingDecl level.
Handled by printName.
Handled directly by emitClass().
Handled in visitSwitch.
Handles MemoryRef arguments and load the data input from memory, but these ones have no output other than the sign flag register update (SF)
Handles output of `json_encode` with fallback value for partial output on errors, and `false` otherwise.
Handles properly formed UTF-8 characters between 0x01 and 0x7F.
Handling database name
Handling these is part of C++ interoperability.
Hansen, "Profile Guided Code Positioning", PLDI '90
Hardcode a particular annoying case in the OS X headers.
Hardcoded for destructors.
Has a typed valueref and a field decl.
Has only an effect if the -gsil option is specified.
Has timeout set to zero because pollSocketLoop() already does a sleep(1).
HasFallthroughTo - True if there is a fallthrough into this case.
Hash and lookup the type-protocol pair in the cache.
Hash table will store Formattable::Type objects directly, so no need for destructor
Hash the supplied password
HashCollection can't handle that yet.
Have not encountered a strong retain/release.
Have to have a server to break.
Have to look up and down for matches
Haven't registered the control target in this region yet.
Haven't registered the control target with region r yet.
Having a rollback fail is actually a normal, expected case, so just swallow this.
Having a solution implies the extension's requirements have been fulfilled.
Having an improper module name is only bad if we have inputs or if we're in REPL mode.
Having real source locations would be far, far better.
Having this twice does make sense, as zval_to_bson can thrown an exception
Haystack isn't statically known
Hdf still takes precedence but will be removed once we have made all options ini-aware.
Hdf's and ini (via Variant arrays) internal storage handles ordering naturally (as specified top to bottom in the file and left to right on the command line.
Head of this Interval chain.
Heads up that we're assuming CreateSucceeded can't throw, or we won't decref the return value.
Heap allocations are at least pointer aligned.
Heap metadata for ErrorProtocol boxes.
Heap metadata for a box, which may have been generated statically by the / compiler or by the runtime.
Heap metadata for runtime-instantiated generic boxes.
Heap object destructor for a generic box allocated with swift_allocBox.
Heckbert-style quantizers vary a good deal in their policies for choosing the "largest" box and deciding where to cut it.
Helper class for emitting code to dispatch to a specialized function.
Helper class storing HDF raw pointer and reference counts on it.
Helper class to copy only a set of SIL instructions providing in the / constructor.
Helper class used to set the LangOpts target before initializing the / ASTContext.
Helper code ABI registers.
Helper flag used during building the worklist for the dataflow analysis.
Helper for creating a single-element mixed array with a string key.
Helper for dealing with disjointDataFn's---most of them are commutative.
Helper for doing array-style Idx translations, even if we're dealing with a collection.
Helper for emitPropSpecialized to check if a property is Uninit.
Helper for emitting instructions whose Vptr operand specifies a segment.
Helper for format_filename that removes characters defined by xdebug to be "special" characters.
Helper for function entry, including pseudo-main entry.
Helper for iterator instructions.
Helper for making invokers for the single-argument magic property methods.
Helper for pretty-printing punctuation.
Helper for removing instructions in the rest of this file---if a debugging mode is enabled, it will replace it with a debugging instruction if appropriate instead of removing it.
Helper for returning the lowest index of an AStack range, non inclusive.
Helper for stepping after we've created a MemRefAnalysis.
Helper for the breakpoint commands that returns an xml node containing breakpoint information
Helper for the freeLocalsHelpers which does the actual work of decrementing a value's refcount or releasing it.
Helper for vasm-simplification routines.
Helper function for printing a type that is embedded within a larger type.
Helper function for simplifying conversions between / thick and objc metatypes.
Helper function for whether to emit a function body.
Helper function to convert from Type to SILType.
Helper function to create a bogus SILFunction to appease error paths.
Helper function to determine if given the current state of the / deserialization if the function body for F should be deserialized.
Helper function to extract types that markers are instantiated on from the markers.
Helper function to find a SILFunction, given its name and type.
Helper function to find a SILGlobalVariable given its name.
Helper function to perform SSA updates in case of jump threading.
Helper function to produce a SILValue from a result value / produced by a basic block responsible for handling a / specific enum tag.
Helper function to remove any cv (and restrict) qualifiers from a type.
Helper function to update ListOfValues for MethodInst.
Helper functions for collection style iterators.
Helper functions to check if an object type's name is that of a special marker type:
Helper functions to check statically whether a method has been overridden from its implementation in Expr.
Helper functions to check statically whether a method has been overridden from its implementation in Stmt.
Helper functions to verify statically whether source-location functions have been overridden.
Helper lambda function to determine if instruction b is strictly after instruction a, assuming both are in the same basic block.
Helper machinery for jemalloc-stats-print command.
Helper macro for SWIFT_VERSION_STRING.
Helper method from converting between a PHP function and a CufIter.
Helper method which initializes this state map with the data from the / first predecessor BB.
Helper method which returns true if the linkage of the SILFunction / indicates that the objects definition might be required outside the / current SILModule.
Helper template for dispatching post-visitation.
Helper template for dispatching pre-visitation.
Helper that adds the given function breakpoint corresponding to the given function and id as a breakpoint.
Helper that adds the given line breakpoint that has been matched to the given unit as a breakpoint.
Helper that checks if the given breakpoint has been "hit".
Helper that sets a value to a new value and also returns whether it changed.
Helper to deal with emitting list assignment and keeping track of some associated info.
Helper to emit getting the value for ActRec's m_this/m_cls slot from a This pointer depending on whether the callee method is static or not.
Helper to emit the appropriate service request to exit with a given target bytecode offset.
Helper to produce a dummy value that can stand in for a global constant / for us to build relative references against before the constant is / instantiated.
Helper used to create an absolute filename using the passed directory and xdebug-specific format string
Helper used when looping through the unmatched breakpoints.
Helpers These are used a lot, prevent unnecessary verbosity.
Helpers for comparison generation:
Helpers for recovering context of this instruction.
Helpers for usage logging NB: the usage logger is not owned by the Debugger.
Helpers that diagnose failures when generic requirements mismatch.
Helpers to set the MOpFlags immediate of a bytecode struct, whether it's subop2 for Base* opcodes or subop1 for a Dim.
Hence "copy forwarding".
Hence exactly one of (0 OP b) and (1 OP b) is true.
Hence the default is now to store 32 bits per Long.
Hence there is exactly one boolean value of "left" that results in the overall expression being true.
Hence we may check for equality with that boolean.
Here are typical scenarios: (1) AST reads decl, get's scope.
Here is the right place to do so, because this is the first action (other than possibly a back-up) that will match for the new input source.
Here is what we do to obtain the number's magnitude: a.
Here we add all uses of I to the worklist, replace all uses of I with the new value, then return I, so that the combiner will know that I was modified.
Here we also store the value index to use into the value map (versus non-argument values where the operand use decides which value index to use).
Here we don't know if it is going to be a cell or a ref.
Here we don't want that.
Here we handle "mixed", typevars, and some other ignored typehints (ex. "(function(..): ..)" typehints).
Here we handle a special case: all defer-edge paths must eventually end in a points-to edge to pointsTo.
Here we just convert external definitions to declarations.
Here we just emit the behavior witness table, if any.
Here we know both the ClassInfo and the static property name, but it may not actually be on this ClassInfo.
Here we need to be generating hopefully-dead stores to initialize non-parameter locals to KindOfUninit in case we have to leave the trace.
Here we only compute the number of bytes.
Here we only do it if there are "constant" arguments to the branch or if we know how to fold something given the duplication.
Here we want to pre-compute the transfer function for each block, so we don't need to visit each instruction repeatedly during the fixed point computation.
Here's an example from emitEnumElementDispatch:
Here's an example showing how an acyclic CFG can become cyclic by chaining its retranslation blocks:
Here's some things still to look at:  o More is_pure_licmable.
Here's why:  - If a destructor for any of these things throws a php exception, it's swallowed at the dtor boundary and we keep running php.
Here, both source and destination have payloads.
Here, the destination has a payload.
Here, the modular division first probe is gives way to a faster exclusive-or manipulation.
Here, the source has a payload but the destination doesn't.
Here, the source value has a payload.
Hermite filter, default radius 1
Heuristic: We only want to hoist array.props instructions if we can hoist all of them - only then can we get rid of all the control-flow if we specialize.
Heuristically, all other things being equal, we should complain about the ambiguous expression that (1) has the most overloads, (2) is deepest, or (3) comes earliest in the expression.
Hex literals shouldn't match.
Hide editor placeholders.
Hide literals other than the ones that are also keywords if they don't match the expected types.
Hide or disable controls based on the control name with 'State' appended
Hide private stdlib declarations.
Hide the upgrade link
Hide unrelated options.
High precision timer related functions.
Higher priorities are preloaded first.
Highlight the whole operator.
Highlights the given TypeRepr, and adds a note pointing to the type's / declaration if possible.
Hint at missing 'self.' or 'super.' then skip this statement.
Hint metadata that doesn't fit into the `variables' vector.
Hit condition and value.
Hit max number of levels.
Hit the chained cache.
Hit the fast path below.
Hitting this means we've messed up with syncing the stack in a catch trace.
Hmm, no program fragment passed along.
Hoist bounds check in the loop to the loop preheader.
Hoist decrement to predecessors.
Hoist globals out of loops.
Hoist in the current loop nest.
Hoist loop invariant code out of innermost loops.
Hoist make_mutable in two dimensional arrays if there are no array value mutating operations in the loop.
Hoist releases, but not epilogue release.
Hoist the access function and the check to the preheader for start and end of the induction.
Hoist the loop nests.
Hoist the make_mutable call and optionally the projection chain that feeds / the array self argument.
Hoist the overflow check of induction variables out of the loop.
Hoist this call to make_mutable.
Hoist this make_mutable call and depend instructions to the preheader.
Hoistable check instructions.
Hoistable checks if we're willing to side-exit.
Hoisting instructions as we go.
Hoisting some but not others is not as beneficial.
Hoists the necessary check for beginning and end of the induction / encapsulated by this access function to the header.
Hold an AstUnit so that the Decl* we have are always valid.
Hold onto the original payload, so we can pass it on as the copy.
Hold ref here for later promoting the object
Hold the break mutex while we update the proxy's state.
Hold the new object in a deleter and release it later if the insert is successful.
Holds a set of subpatterns after a global match
Holds list of subpatterns
Holds results of studying
Holds the distance information for a block in all it's scopes, i.e. in all / its containing loops and the function itself.
Holds the entire state of the reentrant scanner.
Holds the list of DefaultWitnessTables.
Holds the list of SIL global variables.
Holds the list of VTables.
Holds the list of WitnessTables.
Hole and BigObj are skipped in ForEachHeader.
Honor an explicit placement if given.
Hook called from exception unwind to signal that we are about to handle an exception.
Hook called from iopThrow to signal that we are about to throw an exception.
Hook called on function entry.
Hook called on function exit.
Hook called on request shutdown after main() exits
Hook called on request start before main() is invoked
Hook called when the VM raises an error.
Hook up the Phi nodes, loads, and debug_value_addr with incoming values.
Hooks Hook called from the bytecode interpreter before every opcode executed while a debugger is attached.
Hope the C compiler is smart enough.
Hopefully lots of requests won't require any new translation.
Host (string) and port (max 5 digits) + 2 separators
How many letters to skip because an eariler encoding handled multiple letters
How this occurs depends on the current context and where the type was found.
How to generate the raw value for each element of an enum that doesn't / have one explicitly specified.
How to perform our stack overflow check.
How to process the current function.
However PCRE_G(pcre_cache) must be consistent on the next request as well.
However if the request just finished is not the current oldest we don't need to check anything as there cannot be any WorkItem to run.
However it is not the case that every tmp in the set necessarily has a subtype of widestType, because of situations that can occur with AssertType and interface types.
However it requires a mapping from vreg numbers to the instruction that defines them, and a way to address individual instructions.
However since Sets currently only support integer and string elements, there is no way user code can really tell whether the existing element was replaced so for efficiency we do nothing.
However the following ones can't read locals from our frame on the way out, except as a side effect of raising a warning.
However the methods are not declared in the core brotli libraries.
However the transformation we want to make extends the setcc flags lifetime, and we don't want it to overlap another flag's lifetime.
However we have to explicitly guard against that here because we get called as part of validateDecl().
However, / general NRVO is not handled via local propagation without global data / flow.
However, CLI overrides still win the day over everything.
However, IE in all it's wisdom always sends the full path of the file on the user's filesystem, which means that unless the user does basename() they get a bogus file name.
However, XHP wants to use different type codes for bool, int, float, and string, so we need to fix up the type code here to make XHP happy.
However, Zend does it this way, as proven by the fact that you can inject code into the evaled unit's pseudo-main:
However, any allocation of the type only contains one instance of that type.
However, by doing so, we can only do the data forwarding after the data flow stabilizes.
However, by doing so, we can only eliminate the dead stores after the data flow stabilizes.
However, certain aspects of object types can't be completely inferred at the declaration site (mainly static variable linkage related things like linkage name and address).
However, currently IndirectFixup is only used for destructors, which aren't allowed to throw, so this is ok.
However, doing limited code duplication can lead to major second order simplifications.
However, even if the iterator is at the end, it is safe to call next().
However, exit blocks of the original loop are still valid.
However, for Checks, we first pre-relax the instruction's typeParam, which we pass as `knownType'.
However, for completeness this analysis has the ability to /  follow struct_extract users.
However, for the first VM frame, there is no code at returnRIP-1, since the AR was set up manually.
However, headRoom comes from RuntimeOption::ServerMemoryHeadRoom, which isn't initialized until after the code here runs.
However, if JitEnableRenameFunction is enabled, then systemlib has to actually be merged every request -- and since much of systemlib is written in Hack, that would trigger auto-typecheck.
However, if it's dependent, doing so won't allow us to cache the result.
However, if the body is simple enough, we can end up with no branches to the failureBB.
However, if the layout has a suffix layout, the base layout is only applied once on the beginning of the block.
However, if the tested case is the only non-trivial case in the enum, then the destruction on the failure path will be a no-op, so we can disable the cleanup on that path.
However, if there are default values, we don't actually want to do this.
However, if this is a direct reference to a decl (e.g. "x") then don't create a repl metavariable.
However, if we don't have a fallthrough or a multi-pattern 'case', we can just emit the body inline and save some dead blocks.
However, if we have a method defined in Swift on an ObjC generic class, that method is restricted not to have access to the generic parameters, since it wouldn't be able to polymorphically.
However, in the init and destructor methods for the type immediately containing the property, accesses are done direct.
However, it appears that Foo() was the caller of Bar().
However, it does allow eliminating the earlier copy, and we may later be able to eliminate this initialization copy.
However, it does allow us to eliminate the later copy, and the init copy may be eliminated later.
However, it is fairly common for people to forget a 'where' clause and write something like:
However, it is not identical.
However, it is very common for someone to write something like:
However, multiple connections can still be used concurrently, because SQLite as a whole is thread-safe.
However, note that this transformation can turn acyclic graphs into cyclic ones (see example below).
However, only Sig nodes can have multiple successors, so this situation doesn't apply.
However, our optimizer is smart enough now to recognize that an initializer can "never" produce nil, and will optimize away any attempts to check the resulting optional for nil.
However, pass though all other errors.
However, since constructor ordering is only known to be an issue with GNU libc++ we're probably OK on other compilers so let the situation pass silently instead of issuing a warning.
However, since indexed types are keyed by a type index, they are only applied on specific instances of the type with that type index at runtime.
However, since templates can be parameters to other templates, this process must be repeated until the linkage of no types are changed.
However, since the field offset vector only stores offsets of stored properties defined in Swift, we don't have to worry about indirect indexing of the field offset vector.
However, since we already know the instruction to replace and the value to replace it with, we can record it for now and forwarded it after all the forwardable values are recorded in the function.
However, so long as we see already-resolved types that refer to protocols, skip over them to keep looking for a misplaced raw type.
However, so long as we see already-resolved types that refer to protocols, skip over them to keep looking for a misplaced superclass.
However, some of the indexed types may have the same layout.
However, some special functions written in hhas (e.g. array_map) have complex DV funclets that get retranslated for different types.
However, such address casts cannot be converted to value casts.
However, tcmalloc does allocations really fast, especially for the types of small items one sees in STL, so it's better off just using us.
However, that conformance info might be more concrete than we're expecting.
However, the captured arguments are not arguments of *this* apply, so they are not pre-incremented.
However, the driver kind may be overridden if the first argument is --driver-mode.
However, the goal for each stack frame is to print stack fragments from deepest to shallowest -- a then b in the following example:
However, the prologue passes us the callee actRec, whose predecessor has to be the caller.
However, the resulting error message is misleading if the real problem is an empty input file, so we handle that case specially.
However, there is no evidence so far of an IDE using these, plus they are not documented anywhere.
However, this can be changed by setting the PCRE_UCP option.
However, this can easily lead to loss of / opportunities, e.g. a read that only kills part of a store may need to be / treated as killing the entire store.
However, this shadow value is *only* needed when the argument is closed over (and when that closure isn't inlined).
However, using ProjectionPath does / lead to more memory uses.
However, vixl has 33 separate register codes, because it treats the zero register and stack pointer (which are really both register 31) separately.
However, we always constrain the input to this opcode with at least DataTypeSpecific, so we only have to skip the optimization if the typeParam is specialized.
However, we can rely on a subsequent mark_dependent / instruction to take that object as an operand, causing it to escape / for the purpose of this analysis.
However, we can skip this if the value was actually loaded from the cache.
However, we can't rely on it being the only action because there may be other actions (e.g. BackenJobActions) that are not merge-module inputs but nonetheless should be run.
However, we do allow Optimize translations past that limit.
However, we do need to make sure that the cleanup state gets restored later, because being final on this path isn't the same as being final along all paths.
However, we limit the effectivness of this during parse to ensure that we eliminate only very simple scalars that don't require analysis in later phases.
However, we need to autoload typedefs because they can affect whether VerifyParamType would succeed.
However, we want highest bit of the first byte to always be set so that we can tell if the string is fb_serialize'd or fb_compact_serialize'd.
However, we will need to fix this if we want to use InjectEnumTag value witnesses for write reflection.
However, we'd like to delay our stack overflow check until after we've entered our frame, so we can combine it with the surprise flag check (which must run after we've created the callee).
However, when the base is a reference type and the target is a non-class protocol, this is innocuous.
However, whenever we handle removing memory support, if you need to remove one bit, you generally speaking are going to need to remove the support for the whole conflict set.
However, with call we are supposed to just return null (according to the PHP 7 implementation) Here is that speciality check, then.
HttpOnly, false by default
I added 15 extra bytes for safety.
I am purposely restricting this to array semantic functions that we know are well behaved (i.e. the ref counts are the same on both sides of the callsite).
I am squinting at you simplifySwitchEnumToSelectEnum.
I am using a helper here in case I find more cases where I need / to expand it.
I can't think of a reason why we would get more than one decl called deinit here, but just in case, if it is a function type, we should remember it.
I changed it to only consider routeable addresses as valid.
I chose not to use a RequestEventHandler because setlocale() may be called during static variable initialization before any of the HHVM stuff like memory managers, etc.
I do not know the significance of the constant 0xf000.
I don't care what the ini_ret was if it isn't equal to what
I don't know why, but things work a lot better if this process ignores the tstp signal (ctrl-Z).
I don't really want to inline my arm, thanks.
I don't think there is any need to send an empty chunk, other than sending out headers earlier, which seems to be a useless feature.
I don't understand what's going on here well enough to fix the underlying issue.
I exclude vertical tab because it never seems to be used in real text.
I guess the user can call dead() on the cursor.
I have chosen to use the spellings found in the Encyclopedia Judaica.
I have yet to find a specific date when the current set of rules were known to be in use.
I haven't been able to confirm that this is correct either.
I include bell because some programs (particularly shell scripts) use it literally, even though it is rare in normal text.
I probably could have just used strlen...
I really don't know why this doesn't work properly with MSVC, but I know this fixes the problem, so use it instead.
I suppose I could have been using a character pointer instead of accesssing the array directly...
I think the only way this can happen is if we have a switch_enum of some sort with multiple incoming values going into the destination BB.
I think the sanest thing to do here is drop labels, but maybe that's not correct.
I think we can probably handle more of these.
I tried some trickery to avoid a branch here, but gcc did not cooperate.
I very much doubt you can see it.
I wonder if we can refactor into a third method that takes an array semantic call.
I would support a wider range of dates, but I have not been able to find an authoritative definition of when leap years were to have occurred.
I'll admit I didn't try to measure it though...
I'm honestly not sure where these constants came from I've brought them for ward from their IDL definitions with their previous hard-coded values.
I'm relying on gcc to be smart enough to optimize away the next two lines when T is int64.
I've also made it reentrant and made a number of other changes.
I've reviewed the changes made in OpenBSD (as of 2.7) and modified the original code in a similar way where applicable.
I.e. no non-fallthrough instructions mid-block and no control flow (not counting calls as control flow).
I.e. we were called from CmdGlobal, or the client's current frame is the global frame, according to OnServer
I.e., the caller must still be able to filter directories out.
IBootstrapperApplication
ICU 4.9 / IntlGregorianCalendar
ICU UChar type is platform dependent.
ICU shallow clones the UText
ID, local discriminator
IE, it would have at least one action.
IEEE 802 format: Six hexadecimal digits separated by colons.
IEEE 802 format: Six hexadecimal digits separated by hyphens.
IF there is a ( or ), then do nothing (we can't complete)
IIS sets this value but sets it to off when SSL is off.
IMAGE_FILETYPE_JPEG2000 is a userland alias for IMAGE_FILETYPE_JPC
IMPORTANT: On some systems it is required that RESBUF is correctly aligned for a 32 bits value.
IN assertion: the stream s has been successfully opened for reading.
INFRINGES ON USER NAME SPACE
INTERPOLATE constants
IOW, both opaque pixels and transparent pixels will be mapped into the transparent entry.
IP and port conversion box
IR instructions with no associated assembly will still get entries in the instRanges vector so they will be printed too (they just get an empty machine code range).
IRGen the current line(s).
IRGen the main module.
IRGen the modules this module depends on.
Id's of must-alias-sets.
Ideally this shouldn't happen, but the AST can contain overlapping nodes, such as multiple PatternBindingDecl in code like: var a, b : Int.
Ideally we should handle the void case in TypeConstraint::check.
Ideally we would just re-execute from jccAddr---except the status flags will have been trashed.
Iden is the basic block containing the direct call.
Ident appropriately depending on whether we're inside a for loop or not.
Identical RC root blocks code motion, we will be able to move this release further once we move the blocking release.
Identical RC root blocks code motion, we will be able to move this retain further once we move the blocking retain.
Identical values are known to be equal, or less than or equal.
Identifies potential memoization opportunities by comparing the serialized form of function return values.
Identify Bison output.
Identify any solutions that are worse than any other solution.
Identify certain vacuous names to which we do not want to reduce any name.
Identify gerunds, which always end in "ing".
Identify individual checks that appear hoistable.
Identity expressions are no-ops.
Identity function, used to suppress warnings about constant conditions.
Identity optimization
Identity optimization.
If "K1" is yes, or no, then switch to partial if we find a different answer.
If "done" is true make sure we don't increment "e"
If "from" position is negative, count start position from the end.
If "global_addr token" is used more than one time, bail.
If "length" position is negative, set it to the length needed to stop that many chars from the end of the string.
If "name" is one of the standard library types used to map in Clang / primitives and basic types, print out the appropriate spelling and / return true.
If "opt.purge" is absent, it's either because jemalloc is too old (pre-4.1.0), or because ratio-based purging is no longer present (likely post-4.x).
If "overrideLocationForMagicIdentifiers" is set, then we use it as the location point for these magic identifiers.
If "this" is already partial, we won't learn anything.
If "w" was *not* set as an option, then assign the default
If 'Bin' is an archive, recursively look inside all children within the archive.
If 'a' is passed, the value is expected to be a class name that will be prepended to the passed method name.
If 'case n:' appears multiple times, only the first will ever match
If 'class' is a modifier on another decl kind, like var or func, then treat it as a modifier.
If 'function' is a string we simply assign it to name and leave this_ and cls set to NULL.
If 'inout' was specified, turn the type into an in-out type.
If 'self' is address-only, copy 'self' into the indirect return slot.
If 'self' is an inout type, turn the base type into an lvalue type with the same qualifiers.
If 'start' or 'length' are arrays and we've gone past the end, default to 0 for start and the length of the input string for length.
If *pMonth is 13, the SDN represents one of the holidays at the end of the year and pDay will be in the range 1 to 6 inclusive.
If *target is NULL determine required destination buffer size (pre-flighting).
If -s has been specified, treat character special files like ordinary files.
If / StructVal is valid, the value is the address of an element within the / Struct.
If / diagnostics are being deferred,
If / no swap has occurred, these methods will work the same.
If / we succeed and it is safe to move increment/releases, we return true.
If /every/ usable register is assigned to a lifetime interval which intersects with `current', we have to split current before that point.
If 0 is returned, *error_message is set and must be free()d.
If 2 locations may alias, we can still keep both stores.
If AI does not have a function_ref definition as its callee, we can not do anything here...
If ARC optimizations are disabled, don't optimize anything and bail.
If AccessPathSuffix is empty and / StructVal is invalid, then the value is the address of the Struct.
If AccessPathSuffix is non-empty, then the value is the address of an / aggregate containing the Struct.
If Arg is not ignorable, it will be now and we will not be.
If Attr.def says that the attribute cannot appear on this kind of declaration, diagnose it and disable it.
If B.Type needs to be casted to A.Type and A is a superclass of B, then it can be done by means of a simple upcast.
If BB is trivially unreachable, remove it from the worklist, add its successors to the worklist, and then remove the block.
If BBCount is not BBIndex, continue.
If BBSetIn changes, then keep iterating until reached a fixed point.
If BBWriteSetIn changes, then keep iterating until reached a fixed point.
If CalleeFunction is a declaration, see if we can load it.
If Clang's expansion schema matches Swift's, great.
If Closure is a partial apply...
If CurrentBB is empty, just return fn.
If DB has dups then UnitEmitter commons them - spec should outlaw dups because UE will assert if db has dups with different ids.
If DefInlineFP is not pushed these cells were marked as both stored and killed by BeginInlining so now actual stores should be aliased.
If DestroyPoint is a block terminator, we must hoist.
If E is already an ErrorExpr, then we've diagnosed it as invalid already, otherwise emit an error.
If EnableHipHopSyntax is true, it forces EnableXHP to true regardless of how it was set in the config
If EnumValue is null, we deleted this entry.
If F is a declaration, first deserialize it.
If F is a declaration, it has no body to emit...
If F is an external declaration, there is nothing further to do, return.
If F is an external declaration, there is nothing to specialize.
If F is transparent, we should always emit its body.
If FindClass() has failed but no exception has been thrown, throw a default exception.
If FirstIV is not an enum, then we must bail.
If FrameStateMgr's type for a local isn't as good as the type param, we're missing information in the IR.
If Func* is from a PreClass, it doesn't know about base classes etc.
If HH syntax is not enabled and we're not in the HH namespace, allow Hack-specific reserved names such "string" to be used
If HardReturnTypeHints is false OR if the constraint is soft, then there are no optimizations we can safely do here, so just leave the top of stack as is.
If I has no side effects, we can ignore it.
If I is a use of the value that we are going to track, this is the position right after I where we would want to move the release.
If I is not an increment, ignore it.
If II is not a closure that we support specializing, skip it...
If II is the terminator, skip it since our terminator was already processed in our successors.
If IV is a no payload enum, we don't care about it.
If Index is greater than zero, then we know that the two projection paths have a common base but a non-empty symmetric difference.
If Inst does not read or write to memory, have side effects, and is not a terminator, we can zap it.
If Inst is an instruction that we know can never use values with reference semantics, return true.
If Left's value is false, then we return None as the final sign bit depends on the unknown Right value.
If Left's value is true, then we return None as the final sign bit depends on the unknown Right value.
If LookupTy is a non-archetype, look up its conformance.
If MALLOC is undefined, malloc will be invoked directly -- and assumed always to succeed.
If NO_EMPTY flag is set
If NSError wasn't loaded, any base class constraint must not be NSError.
If NewLoads is specified, this / can return the newly generated sub-element loads.
If O1 and O2 do not equal and they are both values that can be statically and uniquely identified, they cannot alias.
If O1 and O2 do not equal, see if we can prove that they cannot be the same object.
If OK1 is unset, ignore it.
If OK2 is unset, take K1.
If ObjC interop is disabled, we have a Swift refcount.
If ObjC interop is enabled, casting a metatype to AnyObject succeeds if the metatype is for a class.
If Objective-C interop is enabled, generic types might contain Objective-C references, so we have to use unknown reference counting.
If Op is a load from an in_guaranteed parameter, it is guaranteed as well.
If Op is a part of ROp or Rop is a part of Op.
If Op is not a consumed argument, we must break since this is not an Op that is a part of a return sequence.
If PHP disables a particular compression, then it is the same as if encoding is not accepted.
If Prefix is greater than or equal to Path in size, Prefix can not be a prefix of Path.
If Ptr has reference semantics itself, create a strong_release.
If Ptr is refcounted itself, create the strong_retain and return.
If QUALITY is in the range 0-100, increasing values represent higher quality but also larger image size.
If QUALITY is negative, the IJG JPEG library's default quality is used (which should be near optimal for many applications).
If R and OtherR are blocks, then OtherR should be a successor of the real block.
If RTy is a builtin raw pointer type, it can alias anything.
If ResultsInError is None, we do not emit any diagnostics.
If ResultsInError is some, we use it as our return value.
If Reusable TC is enabled then the prologue may have already been smashed and the memory may now be in use by another function.
If Right is still not None, then get both values and AND them together.
If Right is still not None, then get both values and OR them together.
If S has a default case bail since the default case could represent multiple cases.
If S is not contained in L, then:
If SIL parsing succeeded, verify the generated SIL.
If StopAtTypeAttributes is true, then we sniff to see if the following attribute is a type attribute.
If StrippedRCID is not V, then we know that User's result is conservatively not RCIdentical to V.
If Sub's replacement is not an archetype type or is from an opened existential type, skip it...
If T already has a superclass, make sure it's related.
If TC reuse is enabled, attempt to relocate the newly-emitted translation to a hole reclaimed from dead code.
If TRACE env var is not set, nothing should be traced...
If TrueBB and FalseBB equal, we cannot find an arg for this DestBB so return an empty SILValue.
If Ty is guaranteed, just pass it through.
If Ty is not trivial and we found a callee release, pass it as guaranteed.
If Ty is trivial, just pass it directly.
If U has side effects...
If U is a terminator inst, return false.
If UserInst cannot be analyzed, Oper is set / to nullptr.
If V1 is an address projection, attempt to use information from the aggregate type tree to disambiguate it from V2.
If V2 is also a gep instruction with a must-alias or not-aliasing base pointer, figure out if the indices of the GEPs tell us anything about the derived pointers.
If VD is a noescape decl, then the closure we're computing this for must also be noescape.
If Value is not null, collate all users of Value the appropriate child nodes and add such items to the worklist.
If Xenon owns a pthread, tell it to stop, also clean up anything from start.
If YYTABLE_NINF, syntax error.
If __invoke is static, invoke it as such
If `block' only goes to `takenBlk' and `takenBlk' can only be reached directly from `block', merge them and leave `takenBlk' unreachable.
If `definer' ends its block, it must have a fallthrough block, and `inst' will be inserted at the beginning of that block, as long as the block has no other predecessors.
If `f' is a method, either `thiz' or `cls' must be non-null.
If `f' is a regular function, `thiz' and `cls' must be null.
If `f' is a static method, thiz must be null.
If `ivl' contains its def, try a coalescing hint.
If `keep_uses' is set, uses exactly at the end of the first interval will stay with the first split (rather than the second).
If `l' can't record the update, save it to scratch.
If `other' is a big integer, the following will return false.
If `rhs' is a big integer, the following will return false.
If `rhs' is a constant, we must be the same constant.
If a ClosureExpr's parameter list has types on the decls, and the types and remove them so that they'll get regenerated from the associated TypeLocs or resynthesized as fresh typevars.
If a SR is used then certain optimizations will not fire since they do not set the condition codes as the original instruction(s) would.
If a SequenceExpr survived until CSGen, then there was an upstream error that was already reported.
If a TypedPattern is implicit, then its type is definitely implicit, so we should ignore its location.
If a base class is generic and a derived class substitutes some generic parameter of the base with a concrete type, the derived class can override methods in the base that involved generic types.
If a basic / block is the target of such a back edge we will identify it as a header.
If a basic block does / not have LoadInst, we do not actually perform the last iteration where / RLE is actually performed on the basic block.
If a basic block does / not have StoreInst, we do not actually perform the last iteration where / DSE is actually performed on the basic block.
If a bit in the vector is set, then the location has an / upward visible store at the beginning of the basic block.
If a bit in the vector is set, then the location is dead at the end of / this basic block.
If a bit is set, it indicates that that memory location may contain a pointer to that must alias set.
If a bit is set, that means there is / potentially an upward visible store to the location at the particular / point of the basic block.
If a block ends with an unconditional jump, change it to a fallthrough edge.
If a capture references a local function, return a reference to that / function.
If a closure is nested within an auto closure, we'll need to update its parent to the auto closure parent.
If a contextual function type exists, we can use that to obtain the expected return type, rather than allocating a fresh type variable.
If a contextual type exists for this expression, apply it directly.
If a continuation matches, we bump the current continuation level so that higher-level continuations are processed.
If a custom scanner for the object type is specified, it will only be invoked if any of the types in the custom guards list is interesting.
If a custom scanner function for bases is specified, the list of immediate bases which the scanner applies to.
If a datatype was passed, add the appropriate type cast
If a decimal point/exponent is found, it's a double.
If a declaration has already been bound, use it.
If a declaration was provided instead of a location, and that declaration has a location we can point to, use that location.
If a defaulted type witness failed, diagnose it.
If a dependency went unsatisfied, just return false.
If a dependent member refers to an associated type, replace it.
If a dependent member type appears in lowered position, we need to lower its context substitution against the associated type's abstraction pattern.
If a depth was provided, we're only interested in that depth
If a duplicate breakpoint already exists, it is overwritten.
If a dynamic alloc_stack is immediately initialized by a copy_addr operation, we can combine the allocation and initialization using an optimized value witness.
If a fatal occurs during emission, some extra cleanup is necessary.
If a file was removed, we've lost its dependency info.
If a frame pointer is used for something that can be modified to not be a use as long as the whole frame can go away, we'll track that here.
If a function exists already and it is a non-optimizing compilation, simply convert it into an external declaration, so that a compiled version from the shared library is used.
If a generic type name was given without arguments, allow a match to
If a given class has no subclasses and - private - or internal and it is a WMO compilation then this class can be considered final for the purpose of devirtualization.
If a globalinit_func is called by "once" from a function that is not an addressor, we set count to 2 to disable optimizing the initializer.
If a instruction may write to a local that is not live, it can be marked as removable if it is known to have no other side-effects.
If a key (after various conversions) occurs more than once in the container, we'll simply overwrite the old entry and that's fine.
If a label is recgonized, we want the cursor pointing at it.
If a language is specified and is not "javascript", reject it.
If a large store is broken down to too many smaller stores, bail out.
If a let-binding doesn't follow, diagnose the problem with a tailored error message.
If a method has an 'override' keyword but does not override anything, complain.
If a node has both syntactic and semantic components, you should make sure you visit every node in both.
If a non-default begin parameter was specified, first iterate over all the compilation units.
If a non-expression thing exists after the comma, then we don't know what is going on.
If a property has an override attribute but does not override anything, complain.
If a release is hoisted from / Region B to Region A, that means there is no blocking operation from where / the release was in Region B and where the release is hoisted to in Region A.
If a restart is required and we're not displaying a UI or we are not supposed to prompt for restart then allow the restart.
If a restart was encountered and we are not suppressing restarts, then restart is required.
If a restart was required but we were not automatically allowed to accept the reboot then do the prompt.
If a restart was required.
If a retain is found outside the loop ignore it.
If a shared function/global is referenced from another file it must have weak instead of linkonce linkage.
If a simpler result can be found, it is / returned, otherwise a null SILValue is returned.
If a stored property does not have a setter, it is still settable from the designated initializer constructor.
If a stored property lacks an initial value and if there is no way to synthesize an initial value (e.g. for an optional) then we suppress generation of the default initializer.
If a string is static it better be the one in the table.
If a subscript has an override attribute but does not override anything, complain.
If a substitution is in play, just bitcast the address.
If a thread doesn't stop, return false so we can try again later.
If a tracked store must aliases with this store, then this store is dead.
If a type was explicitly specified, use its opened type.
If a type was provided, create the type for the parameter.
If a typealias with this name exists in one of the parent protocols, give a special diagnosis.
If a use is visited that potentially causes defInst's address to escape, then return false without fully populating the data structures.
If a value (after various conversions) occurs more than once in the container, we'll simply overwrite the old entry and that's fine.
If a vtable or witness table (method) is only visible in another module it can be accessed inside that module and we don't see this access.
If adding 'private' or 'internal' can help, suggest that.
If address-only, make a +1 copy and operate on that.
If advance the state's sequence appropriately for a decrement.
If after advancing the iterator we have not reached the end, jump to the location specified by the second immediate argument.
If after advancing the iterator we have reached the end, free the iterator and fall through to the next instruction.
If after skipping dead successors, if our SuccIter is not end, then return.
If alias analysis is disabled, always return may alias.
If all SILValues have been set, we are complete.
If all basic blocks will have their predecessors processed if the basic blocks in the functions are iterated in post order.
If all basic blocks will have their predecessors processed if the basic blocks in the functions are iterated in reverse post order.
If all basic blocks will have their successors processed if the basic blocks in the functions are iterated in post order.
If all else fails, diagnose the failure by looking through the system's constraints.
If all mismatches are of this type, we'll return a different closeness for better diagnoses.
If all of the elements were guaranteed, we can form a guaranteed tuple.
If all of the predecessor blocks end in a try_apply to a noreturn function, the entire block is dead.
If all of the predecessors of this successor are unreachable, check if it contains user code.
If all of the projections are equal (and they have the same base pointer), the two GEPs must be the same.
If all of those happen, then we need a timer attached to a signal handler.
If all other registers are used by their owning intervals before the first register-use of `current', then we have to spill `current'.
If all predecessor edges are 'not set' this is a new phi.
If all requests that got enqueued are done, and no more request is coming in, accelerate shutdown.
If all stores are leaves in the AddressProjectionTrie, then we can analyze the stores that reach the end of the object lifetime.
If all such instructions cannot decrement Op, return nothing.
If all such instructions cannot use Op, return false.
If all the bits corresponding to the stack range are dead, we can eliminate this instruction.
If all the elements have default values, the scalar initializes the first value in the tuple.
If all the members of the union have the same layout, we can just use that.
If all the parameters in the compact() call are statically known, there is no need to create a variable table.
If all the supplied UseInfos represent unused stack slots, make a pop that is considered unused.
If all went well, we're done.
If an 'inout' marker was specified, build the type.
If an ArrowExpr survived until CSGen, then there was an upstream error that was already reported.
If an UnresolvedDotExpr, SubscriptMember, etc has been resolved by the / constraint system, return the decl that it references.
If an abstract class has any concrete subclasses, those classes will make sure the right entries are in the conflict sets.
If an abstract protocol conformance was passed in, just return false.
If an allocation has an unknown type-index, then by definition we don't know which type it contains, and therefore the auto generated scanners will never report a pointer to such a type.
If an argument has a single release and it is rc-identical to the SILArgument.
If an argument value was specified, but this is a simple enumerator, then we fail with a nice error message.
If an array grows, the old array pointer may not be used for any more array operations except to eventually call Release---these grown-from arrays are sometimes described as being in "zombie" state.
If an element is known to be initialized, then we can strictly destroy its value at releases position.
If an element is known to be uninitialized, then we know we can completely ignore it.
If an entry exists and its value equals pos, we increment it, otherwise we do nothing.
If an error is encountered adding a tagset, the read preference will again be cleared to avoid being left in an inconsistent state.
If an error is encountered, the read preference will not be changed.
If an error is signalled by a nil result, inject a non-nil result.
If an error is signalled by a non-nil error, be sure to store a nil error there.
If an error is signalled by a non-zero result, return zero.
If an error is signalled by a zero result, return non-zero.
If an error was already emitted, then we're done, don't emit anything redundant.
If an event hook throws we need the current bytecode to be after the FCallAwait, otherwise the unwinder will expect to find a PreLive ActRec on the stack.
If an exception is throwing, regstate for this call is actually still correct, and we don't have information in the fixup map for interpOne calls anyway.
If an exception was caught, rethrow it
If an exit is associated with an FP that was already sunk walk up the chain to the first FP that wasn't sunk and associate it there.
If an expression follows the comma, then it is a second boolean condition.
If an expression other than "and", "or", or "not" is encountered, this method calls EmitterVisitor::visit() to handle the expression.
If an expression references 'self.init' or 'super.init' in an / initializer context, returns the implicit 'self' decl of the constructor.
If an external function was able to be specialized, it would have been specialized in its own module.
If an individual sub-member is passed as inout, then we model that as an inout use.
If an initial value expression was specified by the decl, emit it into the initialization.
If an initial value was given, copy or take it in.
If an initializer has an override attribute but does not override anything or overrides something that doesn't need an 'override' keyword (e.g., a convenience initializer), complain.
If an insertion point is specified, / then the new instruction is inserted before the specified point, otherwise / the new instruction is returned without a parent.
If an instruction can be handled here, then it must also be handled in isIdenticalTo, otherwise looking up a key in the map with fail to match itself.
If an instruction consumes a reference both for taken and next, this function should return false.
If an instruction takes a register operand defined as a constant, and there is valid immediate-form of that instruction, then change the instruction and embed the immediate.
If an instruction, which is not releaseinst nor releasevalue, that could decrement reference count is found.
If an object type is marked pointer followable, all its bases must be as well (because a pointer to a base could be pointing towards this object type).
If an offset pointer is passed, we store in it it the pc offset of the call to the callee.
If an old capacity was specified, use that
If an oversized block is found instead, the remaining space before and/or after the return space it re-added to the appropriate free lists.
If an unbound generic type was spelled in the source (e.g. `case Optional.None:`) this will fill in the generic parameters.
If an update is needed, however, update and run make_native-func-caller.php as well
If annot was "Awaitable" with no type args, getTypeArg() will return an empty annotation
If another thread in the sandbox fails to stop and consume the signal then it will be passed to the dummy sandbox instead.
If any ancestor classes have generic parameters or field offset vectors, inherit them.
If any are not no alias, we have a use.
If any are unbound archetypes, then the problem is that it couldn't be resolved.
If any arguments are not objects, return false.
If any arguments were provided out-of-order, check whether we have violated any of the reordering rules.
If any block is removed, reflow all types.
If any constraints were added here, create a new disjunction.
If any cookie has expired since last execution, purge and save before going any further
If any elements or the 'super.init' state are conditionally live, we need to emit conditional logic.
If any entries were superseded, remove them now.
If any fixes needed to be applied to arrive at this solution, resolve them to specific expressions.
If any free type variables remain and we're not allowed to have them, fail.
If any have a non-trivial payload, then we can't disable the cleanup.
If any modules have been loaded since we did the search last (or if we hadn't searched before), look in those modules, too.
If any nested types remain unresolved, produce diagnostics.
If any of AI's arguments must alias Ptr, return true.
If any of cond_br edges are critical edges, do not perform the transformation, as SIL in canonical form may only have critical edges that are originating from cond_br instructions.
If any of the bound patterns fail (because this is a 'for case' pattern with a refutable pattern, the code should jump to the continue block.
If any of the children were errors, we're done.
If any of the elements was locally satisfied, make sure to mark them.
If any of the enum elements have address-only data, the enum is address-only.
If any of the following checks fail, we want to start searching past the end of the match.
If any of the fromElements can be cast by value to the singleton toElement, then the overall enum can be cast by value.
If any of the functions are external declarations, add them to the worklist for processing.
If any of the parameters are guaranteed, attempt to prove that the passed in parameter cannot alias Ptr.
If any of the parameters needed type conversions, we need to do that here too.
If any of the protocols are class-bound, then it must be a class.
If any of the results have a base, we need to remove overridden and shadowed declarations.
If any of the specialization cases is refutable, we must copy.
If any of the type witnesses was erroneous, don't bother to check this value witness: it will fail.
If any of the types changed, rebuild the tuple type.
If any of the updates fails an error is thrown
If any of them are removed, however, they must all be removed, because of the need to keep eval stack consumers and producers balanced.
If any of them cannot be ignored, we bail for simplicity.
If any of them do potentially decrement the ref count of Ptr, we can not move it.
If any of them do, we advance the sequence for the pointer and create an insertion point here.
If any of these makes a change we'll end up restarting the function passes on the current function (after optimizing any new callees).
If any property is marked as non-removable, their initialization and storage cannot be completely removed.
If any simplification happened to this instruction, drop it.
If any sub-interval was spilled, a single store is generated after each definition point.
If any tag bits are present, they must match.
If anything about the TupleExpr changed, rebuild a new one.
If anything of the fbjni calls fail, an exception of a suitable form will be thrown, which is what we want.
If anything remains of the string, it's not a selector.
If arg is not an ignorable tester, but we are an ignorable tester, we need to be inserted into the constructed testers set.
If artificial normal BB was introduced, branch to the original normal BB.
If asked to skip overrides and witnesses, do so.
If assertions are on, before we do anything, each region makes a call to a C++ function that checks the state of everything.
If at least one of the contexts is a non-type context, the two are unrelated.
If at least one of the properties of the enclosing type cannot be used externally, then no initializer can be implemented externally as it wouldn't be able to initialize such a property.
If at the current lattice state, we don't care if the value we are tracking can be decremented or used, just return false.
If at the current lattice state, we don't care if the value we are tracking can be decremented, just return false.
If at the current lattice state, we don't care if the value we are tracking can be used, just return false.
If auto-apply fixits is on, rewrite the original source file.
If available, check the OutputMap first.
If b is the current buffer, then hphp_init_buffer was _probably_ called from hphprestart() or through yy_get_next_buffer.
If b is the current buffer, then yy_init_buffer was _probably_ called from yyrestart() or through yy_get_next_buffer.
If basic block has no predecessor, do nothing.
If basic block has no predecessor, simply reset and return.
If basic block has no successor, do nothing.
If basic block has no successor, simply reset and return.
If basic block has no successor, then all local writes can be considered dead for block with no successor.
If both a given integer x and its equivalent string presentation were both keys in the collection, we better warn the user.
If both allow_ipv4 and allow_ipv6 flags flag are used, then the first dot or colon determine the format
If both are Objective-C, then match based on selectors or subscript kind and check the types separately.
If both are convenience initializers, and the instance type of one is a subtype of the other's, favor the subtype constructor.
If both args are strings AND either of args is not numeric string then use ICU-compare.
If both arguments are an integer or both arguments are a double, we know the exact type of the return value.
If both conformances are non-replaceable, diagnose the superseded one.
If both declarations come from Clang, and one is a type and the other is a function, prefer the function.
If both have the same position, choose `r1'.
If both metatypes are class metatypes, check if classes can be cast.
If both of those conditions apply, the alloc_ref and its entire use graph is eliminated.
If both operands are constants, constant-fold them.
If both ops are not constants, we cannot do anything.
If both paths are empty, return Equal.
If both sides of the requirement are open archetypes, combine them.
If both size() and RHS.size() equal then we know that the entire sequences equal.
If both states equal, return the first.
If both the delegated-to initializer and our enclosing initializer can fail, deal with the failure.
If both the first key and value types are bridgeable object types, this can only be an upcast.
If both the original partial_apply and the apply of the callee are in the same basic block we can assume they are executed the same number of times.
If both types are boxed, this is okay and even expected as a means to update the hint for the inner type.
If both types are builtin types, handle them separately.
If both types are classes and dest is the superclass of src, simply perform an upcast.
If both types are vectors, look through the vectors.
If both types can have superclasses, which whether one is a superclass of the other.
If both wrapped types are classes and dest is the superclass of src, simply perform an upcast.
If buf is not the complete file, apptype can incorrectly identify the exe type.
If buildArgumentForwardingExpr failed, then it was because we tried to forward varargs, which cannot be done yet.
If c2 is an interface, see if c1 declared it.
If caller is a resumable (aka a generator) then whats likely happened here is that we're resuming a yield from.
If calling a static method...
If calling the specialization utility resulted in new functions (as opposed to returning a previous specialization), we need to notify the pass manager so that the new functions get optimized.
If callsite has an argument that is a plus zero or trivial rvalue, emit / a retain so that the argument is at PlusOne.
If cancelled, don't try to extract anything.
If cannot find the synthesized USR, find the actual USR instead.
If captured directly, the variable is captured by box or pointer.
If casting among classes, and there are open type variables remaining, introduce a subtype constraint to help resolve them.
If casting between address-only types, cast the address.
If cdata tags are in the text, then we must base64 encode.
If changing the inner type of a boxed local, also drop the information about inner types for any other boxed locals.
If check and dest were the same, we would have replaced the check instead of creating a new one, so we only want to add a Halt block if that's not the case.
If class is abstract final, its constants should not be abstract
If class is abstract final, its static methods should not be abstract
If class is not abstract, all abstract constants should have been defined
If class is not abstract, check that all abstract methods have been defined
If className is present, it already includes the namespace
If classType shares an exemplar types with the abstract type, that will end up re-entrantly building the layout of the same ClassTypeInfo.
If code relocation is supported and enabled, set up temporary code blocks.
If coercing a literal to an unresolved type, we don't try to look up the witness members, just do it.
If compared against a bool, convert the string to a bool.
If compared against a bool, convert to a bool.
If compared against a boolean, convert to a boolean.
If compared against a double, convert the string to a double.
If compared against a double, convert to a double.
If compared against a double, emit a collection check before performing the comparison.
If compared against a double, promote to a double.
If compared against a string, commute the expression and do a specialized string-int comparison.
If compared against a string, first do a collection check, and then emit an object-string comparison.
If compared against an integer, convert to an integer.
If compared against an integer, do no conversion and use the specialized string-int comparison.
If compared against an integer, emit a collection check before doing the comparison.
If compared against an object, emit a collection check before performing the comparison.
If compared against an object, first do a collection check on the object, and then emit an object-string comparison (swapping the order of the operands).
If compared against null or bool, convert both sides to bools.
If conditions are not equivalent along all paths, try harder / to check if they are actually equivalent along a subset of paths.
If conservative is true, only actually conservative scan if any of these types are interesting.
If constraint solving resolved this to an UnresolvedType, then we're in an ambiguity tolerant mode used for diagnostic generation.
If container1 is empty, we can stop here and return the empty array
If control branched to the failure block, inject .None into the result type.
If copy is true, we also copy the data to stdout
If correcting for daylight savings time, we set the adjustment to the value of timezone - 3600 seconds.
If createTrueBB or createFalseBB is / false, then only one of the two blocks is created - a CFG triangle instead / of a diamond.
If ctx is an ancestor of this, check if ctx has a private property with the same name.
If ctx is the class that first declared this method, then we know we have the right method and we can stop here.
If currently supporting a different ASet, try to clear any support there first.
If d is +-Infinity or NaN, then *decpt is set to 9999.
If delimiters should be captured
If do_bind is true, update any bound columns.
If document in the context is the same, return it.
If doing a non-interactive install and download source is available, let's try downloading the package silently
If doing a self-assignment, we're done.
If dominance / information or loop info is non null update it.
If each is as specialized as the other, and both are constructors, check the constructor kind.
If edge is critical, split it by inserting an intermediate block.
If edgeTargetsEdgeSource returns true, this method is called to determine / which outgoing edge of Node is the target of this edge.
If either (or both) types are type variables, unify the type variables.
If either Left or Right is unknown then we can't say anything about the sign of the final result since XOR does not short-circuit.
If either Op1 or Op2 is not a literal, we cannot do anything.
If either are none, return None.
If either aren't found we return the default-constructed cache entry.
If either fail to be found, then it isn't a valid split.
If either is an interface, we'd need to explore all implementing classes in the program to know if they have a non-empty intersection.
If either of our types are raw pointers, they may alias any builtin.
If either of the types still contains type variables, we can't compare them.
If either the destination key or value type is a type variable, we can't simplify this now.
If either type is a protocol type, we don't know the underlying type so return may alias.
If either type is address only, do not do anything here.
If either type is an address only type, bail so we are conservative.
If either types are not unique return true
If empty, there is nothing to purge
If enough extra inhabitants are available, no tag bits are needed, otherwise more are added as necessary.
If errors were produced during SIL analysis, return true.
If evaluating or using custom function, copy result to the buffer and clean up.
If evaluating, do it and add the return string's length
If every value in values is equivalent and safe to sink through a phi, return a model instruction to be copied.
If everything is reachable, we are done.
If everything matched, all remaining properties are dynamic.
If exactly one of the type variables can bind to an lvalue, we can't merge these two type variables.
If exceptions are thrown, new_iter_object_any takes care of decRefing the object.
If expected is not nullptr, it will be used.
If explicitly provided a timestamp to the ret array and always make sure there is at least one returned value
If expr is not the target, do the default constraint generation.
If false was returned, we should skip the callee.
If false, / uses forced bridging.
If false, this method is definitely accessible.
If file doesn't look like any sort of text, give up.
If file is null, opening the passed filename failed.
If filename points to a user file, invoke UserStreamWrapper::chgrp(..)
If filename points to a user file, invoke UserStreamWrapper::chmod(..)
If filename points to a user file, invoke UserStreamWrapper::chown(..)
If filename points to a user file, invoke UserStreamWrapper::touch(..)
If first encoded token
If fn is empty, we failed to deserialize its body.
If for some reason we are passed a string (i.e., a leaf value), just return it back
If for testing purposes we were asked to not eliminate dead closures, return.
If for whatever reason, m_thread isn't debugging anymore (for example, it runs in Sticky mode, but it finishes running), kick it out.
If format of 1 is specified, then the function will return an array containing all the words found inside the string.
If format of 2 is specified, then the function will return an associated array where the position of the word is the key and the word itself is the value.
If forwarding from a nonmutating to a mutating accessor, we need to put `self` in a mutable temporary.
If found a backreference..
If function is marked as "keep-as-public", don't remove it.
If function with a given name wasn't seen anywhere yet or if it is known to exist, perform a lookup.
If generator's optional result is address-only, create a stack allocation to hold the results.
If generic, demangle the type parameters.
If group name is given and the decl does not belong to the group, skip it.
If guaranteed plus zero is not ok, we bail.
If hasBlock returns true, then IRUnit already has a block for that offset and makeBlock will just return it.
If hoistDestroy returns false, it was not worth hoisting.
If ignore isn't set, the issue has already been decided (conservative scan).
If imported as member, the member should be final.
If in Remote Webdriver Mode, we need to manipulate the PATH, to point it to a resource in `ghostdriver.qrc`
If in always on mode, the Xenon Surprise flags have to be on for each thread and are never cleared.
If in an eagerly executed async function, not called by FCallAwait, wrap the return value into succeeded StaticWaitHandle.
If in an eagerly executed async function, wrap the user exception into a failed StaticWaitHandle and return it to the caller.
If inference of IUO type is disabled, IUOs may only be specified in the following positions: outermost type function param function return type
If inferredReturn is TBottom, the callee didn't execute a return at all.
If inlining was disabled...
If instance type is type alias, showing users that the constructed type is the typealias instead of the underlying type of the alias.
If invalid return false.
If invokeGet fails due to recursion, it leaves KindOfNull in get_result.
If invokeGet fails due to recursion, it leaves the KindOfNull.
If isObject, the array is temporary and we should not check or save its pointer.
If isSourceTypeExact is true, we know we are casting the result of a MetatypeInst instruction.
If isn't legal to declare something both inout and variadic.
If isn't really a use, but we account for the alloc_box/mark_uninitialized as a use so we see it in our dataflow walks.
If it a call of a throwing callee, bail.
If it already exists, it was either a forward reference or a redefinition.
If it changes the PC, InterpOneCF will get us to the new location.
If it did, reset our iteration range to the block after the insertion.
If it didn't, check to see if it provides something else.
If it didn't, the next invocation of the server will just have to kill us.
If it didn't, use the standard logic.
If it does "x +++ y", then it isn't likely to be a case where a space was forgotten.
If it does / not, then we can eliminate the destructor.
If it does not exist, ignore the error.
If it does not have a basic block associated with it...
If it does not, return None so we keep searching up the domtree.
If it does, it is removed from the unmatched set using the given iterator.
If it does, the overloads were created after the associated overloaded id expression was created, and we'll need to add a new disjunction constraint for the new set of overloads.
If it does, then pick one of those cases as a default.
If it does, we need to / rerun the data flow to reach fixed point.
If it does, we need to rerun / the data flow on this block's predecessors to reach fixed point.
If it does, we need to rerun / the data flow on this block's successors to reach fixed point.
If it doesn't belong to any other instruction then print it.
If it doesn't have a parent, or the parent doesn't need remapping, do nothing.
If it doesn't have function type, we must have invalid code.
If it doesn't just return fileurl.
If it doesn't start with a number, then we know it can never collide with an int or any of our constants, so it's fine as is
If it doesn't succeed, we put it back and try again later.
If it doesn't throw, this argument does not cause the call to throw.
If it doesn't, / issue a diagnostic and return false.
If it doesn't, we have a bigger problem.
If it doesn't, we've probably got an error message from the db, so return that
If it ever needs to be emitted, it crashes the compiler because Sema missed something.
If it exists, move it into position in the diamond.
If it failed and diagnosed something, then we're done.
If it fails, loop around as if 'continue' happened.
If it fails, we'll do the generic load/IncRef on the exit block, otherwise we do type-specialized versions.
If it fails, we're done.
If it has a Clang node (directly),
If it has a global imported as a member.
If it has a result, remember that we saw one, but keep traversing in case there's a no-result return somewhere.
If it has an initializer expression, this is trivially true.
If it has no successors that are in LiveIn, then the last use in the block is the final release/dealloc.
If it has non-trivial type and is an initialization, we can also replace it with a store.
If it has template parameters, the conservative scan is conditional.
If it has the value 2, it prints 'baz'.
If it has, reject the program.
If it hasn't started, perform one "next" operation before the actual operation (auto-priming)
If it intersects with the remove range, ignore the whole diagnostic.
If it is a BB argument received on a success branch of a checked_cast_br, then we know its exact type.
If it is a class and it can be proven that this class and its superclasses cannot be extended, then it is safe to proceed.
If it is a common (not leap) year and the molad occurs on Tuesday at or after 3:11:20 A.M., Tishri 1 must be delayed.
If it is a declaration with a swift_name attribute, we might be able to resolve this later.
If it is a forward reference, it should be in our undefined set.
If it is a load from the memory object (as oppose to a load from something else), track it as an access.
If it is a normal character or an already-diagnosed error, just munch it.
If it is a store to the memory object (as oppose to a store to something else), track it as an access.
If it is a switch on a function type, check that all case values are function references or undef.
If it is a switch on an integer type, check that all case values are integer literals or undef.
If it is a trunc to a signed value then sign bit should not be set to avoid overflows.
If it is addr cast then store the result.
If it is address-only, then we can't load it, so capture it by its address (like a var) instead.
If it is all 'no' then we can handle it specially without conditional code.
If it is already in the user callbacks, continue to use it from there.
If it is an apply, attempt to prove that the callee is unable to affect Ptr.
If it is an assignment, / a live-in value can be provided to optimize out the reload.
If it is an empty / declaration, we fill in the contents.
If it is an interpreter, don't use try to use any advanced calling conventions and use instead a more conservative C calling convention.
If it is before, check to see if it produces the value we are looking for.
If it is before, it may produce some of the elements we are looking for.
If it is before, it produces the value we are looking for.
If it is initialized on some paths, but not others, then we have an inconsistent initialization, which needs dynamic control logic in the general case.
If it is known to have swift metadata, just load.
If it is not a *_token global variable, bail.
If it is not a load, bail...
If it is not a sandbox, sourceRoot will be the same as RuntimeOption::SourceRoot.
If it is not a struct which is a simple type, bail.
If it is not a tuple which is a simple type, bail.
If it is not an exact match, it may mean that all of the superclasses do not have this conformance, but the actual type may still have this conformance.
If it is not attached, check if we need it.
If it is not possible, then None / is returned.
If it is not required, it also pushes an accumulating set of instruction ids that must be removed if the instruction which produces the stack slot is removed.
If it is not working, it's not Thomas G.
If it is not, emit the generic error that we would emit before.
If it is possible for it to see a weak reference count of 1, then at the end of this function, the weak reference count will logically be 0.
If it is record, we succeeded.
If it is safe to remove, do it.
If it is settable, then the base must be the problem, recurse.
If it is something else, then this is the end of the token.
If it is the destination, then this is an unknown assignment.
If it is the only instruction in our BB, it is a failure BB.
If it is the page server, it will continue accepting requests for ServerPreShutdownWait seconds 2.
If it is the year following a leap year and the molad occurs on Monday at or after 9:32:43 and 1/3 sec, Tishri 1 must be delayed.
If it is, go to the interpreter
If it is, we replace it with null instead of shifting all members of the worklist towards the front.
If it is, we'll record the linkage dependence for the later template linkage fix-up.
If it is, you can ignore the error code.
If it isn't a 'let', don't touch it.
If it isn't necessary, then we might be able to short-circuit considering the bases of this protocol.
If it isn't settable, return it.
If it isn't synthesized, then DCE will report an error on the dead code.
If it isn't, we actually need to retain it, because we've still got a release active.
If it looks like an option or a path, then invoke in interactive mode with the arguments as given.
If it looks like we have an AST, set the source file kind to SIL and the name of the module to the file's name.
If it looks potentially interesting, decide whether we *can* do the operation and whether the block is small enough to be worth duplicating.
If it makes you feel any better, the PHP contributor responsible for this has since said that he regrets his decision.
If it matches FirstIV, we may be able to succeed here.
If it matches an existing declaration, there's nothing to do.
If it matches an existing macro, overwrite the existing entry.
If it might be, we do some more digging.
If it needs a result, like subtract operations, the destination register must be filled considering the size of operation.
If it patches the Immed, replace the vasm for its non-immediate variant
If it points to whitespace return the SourceLoc for it.
If it recurses again, we promote to a hash set to track all the information needed.
If it returns false, the support bits may still be marked on some must-alias-sets.
If it returns false, we just skip entering subnodes of this tree.
If it starts with the magic string, then skip that
If it succeeds, then we win, but if it fails, we'll have to diagnose this another way.
If it succeeds, there's nothing more to do.
If it throws an exception, catch it and return the exception object.
If it turns out there are no uses of the catch block, just drop it.
If it was a tuple in the original type, the parameters will have been exploded.
If it was invalidated, then don't bind the jump.
If it was replaced with a new translation, then bind to the new one.
If it was used, we link it up with the cleanup chain, otherwise we just remove it.
If it wasn't used in any fulfillments, remove it.
If it's -1 then we have the payload.
If it's ALL we create two resources, but only return one - this matches Zend, and is the documented behavior.
If it's Objective-C, start layout from our static notion of where the superclass starts.
If it's a Clang declaration, try to import it.
If it's a collection name and of pointer type, call it an array of the pointee type.
If it's a computed variable, push a reference to the getter and setter.
If it's a declared property we're good to go: even if a subclass redefines an accessible property with the same name it's guaranteed to be at the same offset.
If it's a function with a parameter with leading underscore, it's a private function.
If it's a jump, we're printing relative offsets, and the dest is within the range we're printing, add the dest as a relative offset.
If it's a literal token, we might be able to translate the literal.
If it's a map with a non-static string key, we can do a map-specific optimization.
If it's a non-numeric string, this may cause it to exceed the max length.
If it's a php-exception, we'll go to the taken block.
If it's a physical value (e.g. a local variable in memory), push its address.
If it's a poor match in the middle of a token, see if the next char starts a token and also matches.
If it's a projection of a promoted parameter, drop the instruction.
If it's a release of a promoted parameter, just drop the instruction.
If it's a retain of a promoted parameter, just drop the instruction.
If it's a same-ish comparison and the types don't match (taking into account Str and StaticStr), lower to a bool comparison of constants.
If it's a string of the next packed index,
If it's a struct type associated with the literal conformance, test against it directly.
If it's a subclass, rTestClass must be at the appropriate index.
If it's a type reference or it's a module type, we're done.
If it's a unary selector with no name for the first argument, we're done.
If it's a value reference, refer to the metatype.
If it's a wrapper, load from the 'Class' field, which is at index 1.
If it's already been filled in, we're done.
If it's already in memory, great.
If it's already in the set, then we've already queued and/or processed the predecessors.
If it's already there we need to merge the used vars in with what we saw last time.
If it's an existential, we need to check for conformances.
If it's an extension class with a custom instance initializer, that init function does all the work.
If it's an identifier that is itself a macro, look into that macro.
If it's an integer key, check if it's the next packed index.
If it's an llvm intrinsic, fold the intrinsic.
If it's an object, retain and enter a release cleanup.
If it's definitely not either kind of metatype, then we can report failure right away.
If it's fixed, emit the constant size and alignment mask.
If it's implicit, try to find an overridden ValueDecl that's not implicit.
If it's indirect, / grab its SILArgument.
If it's indirect, we should be emitting into an argument.
If it's inout, we need writeback.
If it's known non-null, use that.
If it's known to be a ref, this behaves like FPassV, except we need to do it slightly differently to keep stack flavors correct.
If it's missing, we will stop right here, with compiled code.
If it's not a local object we don't know anything about the value.
If it's not a string or a MongoBinData, give up
If it's not a tagged pointer, mask off the spare bits.
If it's not a tuple, it could be a unary function.
If it's not an overflow, it was probably a surprise flag trip.
If it's not found, instructs the JNI environment to throw an exception.
If it's not present, inject 'nothing' into the result.
If it's not private it could be overridden, so we don't have an exact func.
If it's not there, try the slow path.
If it's null, then we return false.
If it's obviously non-exhaustive, great.
If it's of a managed object type, it is (retain).
If it's present, apply the recursive transformation to the value.
If it's retainable for the purposes of ObjC ARC, we can trust the presence of ns_returns_retained, because Clang will add that implicitly based on the method family.
If it's set, the string is fb_compact_serialize'd, otherwise it's fb_serialize'd.
If it's some kind of keyword, it can't be mapped.
If it's some other keyword, grab an identifier for it.
If it's the same image, mapping is NOT trivial since we merge with greyscale target, but if pct is 100, the grey value is not used, so it becomes trivial.
If it's the same image, mapping is trivial
If it's the same requirement, we can derive it here.
If its Nullptr, we need to DecRef the old value.
If its a RefData*, we need to DecRef that - but in that case the new value is the same as the old.
If its a vector collection we don't need to worry about refs in the above fast-path.
If its bigger than 4 bytes, the dir entry contains an offset.
If its not persistent, we must make sure its loaded.
If its not within a namespace (IE, within a class), give it a unique name based on how many unnamed types we've seen so far.
If its visibility implies that this optimization pass cannot analyze all uses, don't process it.
If just tried and failed to reuse lookahead token after an error, discard it.
If kPackedKind changes to a value that is not 0, change this to a conditional add.
If knownCls is not null and is safe to use, that will be returned.
If knownCls isn't a normal class, our caller may want to do something different.
If last encoded token
If layout depends on generic parameters, we have to load the offset from the class metadata.
If leak tracking is enabled, start tracking this object.
If left bound but not right bound, handle some likely situations.
If legal, create an unchecked_ref_cast from the given operand and result type, otherwise return null.
If less than zero, it's a valid value of the enum type.
If let properties can be assigned externally, we don't know the values they may get.
If level is non-zero, offset is the current offset within the frame
If live code relocation is enabled, record metadata for the current translation.
If loadable, it's better to do this directly to the value than in place, so we don't need to RMW out the tag bits in memory.
If loading from memory, set the base reference uri for the document
If loading from memory, we need to set the base directory for the document
If loading from memory, we need to set the base directory for the document but it is not apparent how to do that for schema's
If loading from memory, we need to set the base directory for the document.
If loc contains a valid location, reset the frontiers of all code and data blocks to the positions recorded by the last call to markStart().
If looking for an associated type and the archetype is constrained to a class, continue to the default associated type lookup
If loop `loopId' already contains a `preExit' block, then return it.
If lowering of the assign introduced any new loads or stores, keep track of them.
If lstat() fails we still can return successfully if there are no more path components left.
If m_override is set, use it unconditionally.
If m_pos is the canonical invalid position, we need to update it to what the new canonical invalid position will be after compaction
If malformed, add replacement characters.
If mightRelax(src) returns true, we can't generally depend on the src's type.
If moving the declaration can help, suggest that.
If necessary insert an overflow for this induction variable.
If necessary, add delayed members to the declaration.
If necessary, split the current interval so the first part gets a register, and enqueue the rest.
If necessary, split the victims again before their first use position that requires a register.
If necessary, thunk to the native ownership conventions and bridged types.
If needed, mark 'self' as uninitialized so that DI knows to enforce its DI properties on stored properties.
If needed, split the base name.
If negative, reduce the rule which number is the opposite.
If neither class is an interface, their intersection is trivial.
If neither destination nor source have payloads, we can just primitive-store the new empty-case value.
If neither has a position after `pos', choose the higher one.
If neither or both are protocol types, consider the bases unrelated.
If neither the property's getter nor its setter are mutating, the base can be an rvalue.
If new_iter_array creates an iterator, it does not increment the refcount of the specified array.
If new_iter_array does not create an iterator, it decRefs the array.
If new_iter_object does not create an iterator, it decRefs the object.
If new_iter_object_any creates an iterator, it does not increment the refcount of the specified object.
If no ':' on the line, add to previous line
If no ActRec was pushed for the builtin function inspect the caller to determine if the call used strict types.
If no Objective-C methods were defined in this file, we're done.
If no SDK was specified via -sdk, check environment variable SDKROOT.
If no abstraction is required, try to honor the emission contexts.
If no alternate name is found, returns nullptr.
If no arguments were renamed, the call arguments match up with the parameters.
If no bits are demanded, we trivially succeed.
If no catastrophic error has happened yet, we're fine, set errmsg to null
If no conclusive match can be found, leaves m_streamType as its default value of empty_string_ref.
If no context was provided, use the declaration itself.
If no contextual type is present, Merge equivalence classes of key  and value types as necessary.
If no default witness table was found, bail.
If no error message was provided, use the error code to try and get an error message.
If no filename is passed, php5 xdebug stores in the default output directory with the default file name.
If no generator/element pair exists, solve for them.
If no generic parameters remain, this is a non-generic function type.
If no inferred types remain, skip this witness.
If no member type was provided, use the member's type.
If no memory is accessed, then something is being done with the pointer: maybe it is bitcast or GEP'd.
If no methods were overridden, we're done.
If no name was specified, the name defaults to 'value'.
If no old capacity was provided, we compute the largest capacity where m_size/cap() is less than or equal to 0.5 for good hysteresis
If no one could find a problem with this expression or constraint system, then it must be well-formed...
If no return type was specified, create a fresh type variable for it.
If no scope is specified, scope it to the Closure class.
If no such instruction exists, returns null.
If no type has been set for the initializer, we need to diagnose the failure.
If no witness table was found, bail.
If node is not a leaf, add its children to the worklist and continue.
If non-empty, the name of the field in the object which is a "flexible array" member (a trailing array of unbound size).
If none of the declarations were shadowed, we're done.
If none of them can decrement our ptr value, we can move the retain over the ref count inst.
If nonzero, form the case index from the extra tag value and the value stored in the payload.
If not FBCompactSerializeBehavior::MemoizeParam fall-through to default
If not UINT32_MAX, then this value is an extra value that appears at offset 0 to tell one or more empty enums apart.
If not already recovering from an error, report this error.
If not from the same file, sort by file name.
If not localized, use standard mysql functions on m_res
If not null, *rve is set to point to the end of the return value.
If not passed in we use the default swift module cache.
If not present, that type is implicitly "void".
If not special builtin...
If not there, the inherited conformance must be available through one of our parents.
If not this is a bad expression, and a potential security hole.
If not yet visited, visit the callee.
If not, add them to AvailableValues.
If not, construct SSA form by first calculating the required / placement of PHIs and then inserting new PHIs where needed.
If not, create a specialized version of ApplyCallee calling the closure directly.
If not, diagnose the error.
If not, emit an error and just recovery by synthesizing without the copy call.
If not, emit the builtin call normally.
If not, first transcode it to UTF16.
If not, it locks up if you hit ctrl-Z then "bg" the program.
If not, its a LayoutError, as a custom scanner is needed to disambiguate it.
If not, lay out the protocol's witness table, if it needs one.
If not, or if we fail, return false.
If not, remember the / instruction and return true.
If not, return a default-constructed instance of f's return type.
If not, return false.
If not, that pointer followable type is a root, and must be dealt with specially by the GC.
If not, the SILVerifier object will explode trying to compute dominance info.
If not, the instruction can mark itself (and all downstream instructions that depended on it) as removable.
If not, the template actually has parameters but is failing to emit them.
If not, this mapping isn't guaranteed to be consistent for all platforms we care about.
If not, thread out through a bunch of cleanups.
If not, we allow all connections.
If not, we can't explode to a load.
If not, we may have an implicit conversion going on.
If not, we need to combine the generator result with that last chunk.
If not, we're importing globals-as-members into an extension.
If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
If nothing changed since the last run of this pass, we can skip this pass.
If nothing changed, fail: something is unresolvable, and the caller should complain.
If nothing changed, we're done.
If nothing changes, we're done.
If nothing has changed, just keep going.
If nothing uses it, it'll just be DCE'd.
If nullability is available on the type, use it.
If nullability is provided as part of the type, that overrides optionality provided externally.
If offsets should be captured
If on entry, you have completely disabled a node via taskset, the node will not be available, and calling numa_run_on_node will not work for that node.
If one class is a subclass of another, and they aren't equal, the other isn't a subclass of it.
If one component is unspecialized, it behaves like Top, and the intersection is the other component (the Bottom case is handled by the subtype checks above).
If one declaration is available and the other is not, prefer the available one.
If one declaration is in a protocol or extension thereof and the other is not, prefer the one that is not.
If one entry is fixed and the other is not, we have our answer.
If one has a type parameter remaining but the other does not, drop the one with the type parameter.
If one is a compound name and the other is not, they do not conflict if one is a property and the other is a non-nullary function.
If one is a static/class method and the other is not...
If one is an OptionalSomePattern and one is an EnumElementPattern, then they are the same since the OptionalSomePattern is just sugar for .Some(x).
If one is noescape but the other isn't, then the result is escaping.
If one needs to make / changes that cause the asserts the fire, please update them.
If one of the GEPs is a super path of the other then they partially alias.
If one of the alias classes have a non-None stag, we can only keep it if the other doesn't have any of the corresponding bits set.
If one of the merged edges spans a call then mark them both as spanning
If one of the merged edges was interp'ed mark the result as interp'ed
If one of the predecessors has a phi state with this same block, it'll find the dst we just added in phi_record.
If one of the protocols being extended inherits the other, prefer the more specialized protocol.
If one of the string literals is UTF8 and another one is UTF16, convert the UTF8-encoded string literal into UTF16-encoding first.
If one of the struct instruction operands is not a simple initializer, bail.
If one of the types is a type variable, we leave this unsolved.
If one parameter is variadic and the other is not...
If one projection path is a prefix of another, then the locations could alias.
If one protocol remains, its nominal type is the canonical type.
If one type does not have an error result, we can still trivially cast (casting away an error result is only safe if the function never throws, of course).
If one type is a subtype of the other, but not vice-versa, we prefer the system with the more-constrained type.
If one type is an aggregate and it contains the other type then the record reference may alias the aggregate reference.
If one type is an implicitly unwrapped optional of the other, prefer the non-optional.
If one type is convertible to of the other, but not vice-versa.
If only a part of a type is being printed, use / visitPart().
If only a subset is given or the class has protected members then you need to merge the properties separately by calling zend_merge_properties().
If only conforms to AnyObject protocol, nothing to print.
If only one declaration has this signature, it isn't shadowed by anything.
If only one location is valid, the valid location comes first.
If only one of the types is a type variable, perhaps we can do something with it below.
If only the destination label is within the statement associated with the current statement, just perform a direct jump.
If only the width matches exactly, do a bitcast.
If only the width matches exactly, we can still do a bitcast.
If only there is the appropriate label inside the current region perform a jump.
If our DFS number is the minimum found, we've found a (potentially singleton) SCC, so pop the nodes off the stack and push the new SCC on our stack of SCCs.
If our SILValue was blotted, skip it.
If our TEDAI has no users, there is nothing to do.
If our argument is of trivial type, continue...
If our base is an existential type, we can't make use of any constructor whose signature involves associated types.
If our base is an existential type, we can't make use of any member whose signature involves associated types.
If our call does not have guaranteed self, bail.
If our callee is not a builtin, be conservative and return may have side effects.
If our caller requested partial translation and we don't already have the write lease, we're done here.
If our candidates are instance members at curry level #0, then the argument being provided is the receiver type for the instance.
If our client is ok with a +0 result, then we can compute our base as +0 and return its element that way.
If our contextual type is an optional, look through them, because we're surely initializing whatever is inside.
If our enum type is address only, we cannot do anything here.
If our expression already has the right type, we're done.
If our generator finished earlier (or if there was nothing to do) just continue on and let YieldFromDelegate handle cleaning up.
If our input is trivial and our output type is not, do not do anything.
If our install is at the end (success or failure) and we're not showing full UI or we successfully installed the prerequisite then exit (prompt for restart if required).
If our kinds do not match, bail.
If our list of extensions is out of date, update it now.
If our nominal type has type arguments, make sure they are representable as well.
If our object type is not trivial, we may need to release the old value and retain the new one.
If our payload has reference semantics, insert the strong release.
If our payload is trivial, we do not need to insert any retain or release operations.
If our predecessors cover any of our enum values, attempt to hoist releases up the CFG onto enum payloads or sink retains out of switch regions.
If our preferred access method is to go via an accessor, it means there is some non-trivial computation that needs to be cached.
If our source location is invalid (this may be synthesized code), climb the decl context hierarchy until we find a location that is valid, collecting availability ranges on the way up.
If our successor iterator has reached the end of the successor list.
If our superclass isn't default constructible, we aren't either.
If our target is an address, prepareForEmitSome should have set this up so that we emitted directly into
If our type variable shows up in the base type, there's nothing to do.
If paramType contains any substitutions already, find them and add them to our list before matching the two types to find more.
If parameter can be converted to a qint64, do so and use that value instead
If parsing produced an error, don't run any passes.
If part of the locations have covering values, / find the values in its predecessors.
If php_mysql_localize_result ever gets rewritten to use standard APIs, this can be opened up to everyone.
If pos is the canonical invalid position, no guarantees are made about what this method returns.
If pos is the canonical invalid position, this method will return the canonical invalid position.
If positive, shift that token.
If possible, emit the enum directly into the indirect return.
If present, InitCtx must dominate all occurrences of LdCtx and LdCctx.
If present, but empty, the scanner does not have linkage (which is an error).
If printed Decl is the top-level, merge the constraint-free extensions into the main body.
If projection paths are different, then the locations cannot alias.
If raise was true than lookupMethodCtx should have thrown, so we should only be able to get here if raise was false
If rawTarget doesn't have the flag bit we must have a smash in flight, but the call is still pointed at us.
If reading entire image is requested, read the rest of the data.
If recursive type checking failed, then an error was emitted.
If referencing the best method would produce an ambiguity and referencing the new method would not, we have a new "best".
If refine_public_statics is called more than once, the subsequent calls may only shrink the types we recorded for each property.
If rename didn't work, fall back to copy followed by unlink
If replace is an array and not a callable construct
If requested, look into the superclasses of this archetype.
If requested, sort the results.
If resolve_include() could not find the file, return NULL
If resulting string turns out to be shorter than input string, we simply copy the input and return.
If return_value is not null, store values into it according to HOW.
If rhs isn't specialized no further checking is needed.
If right-hand side is a type variable, the constraint is unsolved.
If run in cli mode, print nothing in the lowest pseudomain
If running the function transforms did not result in new functions being added to the top of the worklist, then we're done with this function and can pop it off and continue.
If running the transform resulted in new functions on the top of the worklist, we'll return so that we can begin processing those new functions.
If salvage produced an error message, then it failed to salvage the expression, just bail out having reported the error.
If self is a struct, properly qualify it based on our base qualification.
If self is already deallocating, self does not need to be retained or released since the deallocating bit has been set.
If self is null, branch to the epilog.
If self was consumed in a predecessor P, don't look at availability at all, because there's no point in making things more conditional than they are.
If server is not yet started, e.g., when not running in server mode, or before server starts, we assume everything is OK.
If set and its value is "isdbgrid", it signals we connected to a mongos
If set, delete the session cookie
If setting the flag failed, it's because it was already set.
If short_open is '-' this is the last option.
If signed less than zero, we have a valid value.
If simplification has turned this into the same types, then this isn't the broken constraint that we're looking for.
If size was given take minimum of len and size
If so advance the state's sequence / appropriately and return true.
If so advance the state's sequence appropriately and return true.
If so complete the forward reference.
If so then we know that both this BB and the predecessor are boundaries of a loop that is not understood by SILLoopInfo.
If so, and if this conversion constraint is different than the types being cast, produce a note that talks about the overall expression.
If so, any uses of the pointer result need to keep using the MUI, not the alloc_stack directly.
If so, call `f' on the specific instruction, and return the result.
If so, check for matching types.
If so, convert it / into a BraceStmt that can be used as the body of a control flow statement / to improve error recovery.
If so, create a new select_enum instruction / This is used to simplify arbitrary simple switch_enum diamonds into / select_enums.
If so, diagnose it as a common error.
If so, diagnose them as such.
If so, dig into them to produce better location info in the diagnostics and be able to do more precise analysis.
If so, dig through that.
If so, do a direct assignment.
If so, don't import this field.
If so, emit a specific diagnostic.
If so, emit specific diagnostics for it and return true, / otherwise return false.
If so, emit specific diagnostics for it.
If so, increase the threshold, because inlining will (probably) eliminate the closure.
If so, it does not conflict.
If so, it is / consumed and false is returned.
If so, just nuke the type.
If so, just return it.
If so, just return that value.
If so, mark the latch head/tail blocks as head/tail unknown cfg boundaries.
If so, nuke the space afterward to keep things consistent.
If so, parse it to an UnresolvedPatternExpr and name binding will perform final validation.
If so, pop its frame, wrap the exception into failed StaticWaitHandle object, leave it on the stack as a return value from the async function and resume VM.
If so, propagate the sugar to the curried result function type.
If so, propagate the sugar.
If so, propagate the type out to the ParenExpr as well.
If so, reset our state to not be in a pattern for any recursive pattern parses.
If so, return true, if nothing obvious / is possible, return false.
If so, strip that prefix off when present.
If so, swallow the error.
If so, that's really unfortunate in a lot of ways.
If so, the contextual type is the problem.
If so, the madness starts
If so, the new bb dominates DestBB now.
If so, then simplify.
If so, then the pair of the / partial_apply instruction and the index of the box argument in the closure's / argument list is added to IM.
If so, then we have to assure consistency between YY_CURRENT_BUFFER and our globals.
If so, then we know that V2 must partially alias V1 via a must alias relation on O1.
If so, there is a conflicting writeback happening, so emit a / diagnostic.
If so, these type variables would be accessible to name lookup of the subexpression and may thus leak in.
If so, this is an error, as the user shouldn't be using such types in this template.
If so, this release must be known safe.
If so, we add an extra retain.
If so, we can fold this into the copy_addr as a take.
If so, we can ignore the release for the retain before the call exactly matches it.
If so, we can zap the pair.
If so, we can't re-authenticate and bailout.
If so, we consider it to be part of the proceeding expression.
If so, we disambiguate the parse as the / start of a get-set block in a variable definition (not as a trailing / closure).
If so, we have an "if let" condition and we want to enforce some more structure on it.
If so, we have to do some fixups.
If so, we may be able to lower this sequence to a select_enum.
If so, we should deallocate and destroy at the same time.
If so, we stop here, instead of producing an error on it.
If so, we're done, otherwise keep converting.
If some value is not available at this load point, then we fail.
If someone defines a weird __invoke (e.g. as a static method), we don't bother caching it here so the translated code won't have to check for that case.
If someone is using an unlabeled break inside of an 'if' or 'do' statement, produce a more specific error.
If someone just called __call() or __callStatic() directly, branch to a normal non-magic prologue.
If someone really wants to use them they can write them directly.
If something has matched
If something started executing, leave it in the overall progress text.
If something went wrong in the binding (warning, for example), then we can get an empty object back.
If source or target are existentials, then it can be cast successfully only into itself.
If specialization isn't required, just return immediately.
If specialized, dump the substitutions.
If splicing blocks not in the same function, update the parent pointers.
If stackT is a subtype of tcT, use stackT.
If still "looping", close Phantom (usually caused by "CTRL+C" / "CTRL+D")
If study option was specified, study the pattern and store the result in extra for passing to pcre_exec.
If subpatterns array has been passed, fill it in with values.
If substitution is trivial, fast path.
If such a value exists, it is a candidate for RC-identity with the / argument itself--the caller must verify this after evaluating all paths.
If such an instruction exists, we cannot perform this optimization so continue.
If swift gets user attributes then all identifiers will be treated as syntactic attribute nodes.
If t contains Uninit, replace it with InitNull.
If target is a Swift type bridging to an ObjC type, / return the ObjC type it bridges to.
If tcT could be an interface or trait, we upcast it to TObj/TOptObj.
If template_params is provided, the parent DIE is an object type, so template_params should be filled with any template parameters in the child DIE.
If terminator instruction can block the RC root.
If that changed anything, check for a lowering at the lowered type.
If that condition is not true, we can still sink to the end of this BB, but not to successors.
If that didn't find anything, we can still synthesize AnyObject conformances from thin air.
If that didn't succeed, and we allocated, free the allocation.
If that didn't succeed, check whether this is an anonymous tag declaration with a corresponding typedef-name declaration.
If that didn't turn up an issue, then we don't know what to do.
If that didn't work, use a bogus pattern so that we can fill out the AST.
If that doesn't exist neither, complain.
If that doesn't work, make a new memory block and copy.
If that failed, be sure to give the variables error types before we type-check the guard.
If that failed, check whether it's because of the conformance we're evaluating.
If that failed, convert the type, cache, and return.
If that failed, mark any variables binding pieces of the pattern as invalid to silence follow-on errors.
If that fails, arbitrarily pick the extension whose protocols are alphabetically first.
If that fails, fall back on importing the underlying type.
If that fails, just print the name.
If that fails, let dlopen search for system frameworks.
If that fails, return nullptr.
If that fails, slow exit.
If that fails, try it as an SUS integer type if it begins with "d" or as an SUS string type if it begins with "s".
If that fails, try it as an SUS integer type.
If that fails, try our runtime library path.
If that fails, try to deserialize it.
If that field is trivial, we do not care about it...
If that gives us a forward declaration (which can happen with bound generic types), don't propagate that into the cache here, because we won't know how to clear it later.
If that happens, there's nothing to constrain.
If that happens, we need to return to the caller, but the handler will have already popped the callee's frame.
If that happens, we'll have to wrap getServiceDataInstance around a pthread_once and pay some runtime synchronization cost.
If that is not true, you might end up looking at this code in a debugger and now you know why.
If that is true we clear all the state since we cannot hoist safely.
If that satisfied all of the elements we're looking for, then we're done.
If that succeeds, then we stitch the result back into our expression.
If that successfully emitted into the initialization, we're done.
If that works, return it, otherwise none.
If that's less than best-so-far, update best distance and color number.
If that's not present, this conformance must be implied by some associated-type relationship.
If that's not present, this must be an associated type.
If that's the case, just skip this optimization.
If that's zero, go ahead and short-circuit out.
If the #available() is not useless then there is potential false flow, so join the false flow with the potential versions of the current context.
If the 'self' parameter is a metatype, we'll throw it away.
If the 'self' value is a metatype, update the target type accordingly.
If the -c option is specified without a -n, php behavior is to load the default ini/hdf
If the 2nd type is an autoclosure, then we don't actually want to treat these as parallel.
If the AllocBox is used by a mark_uninitialized, scan the MUI for interesting uses.
If the AllocStackInst is also deallocated inside the allocation block then make sure that all the users are inside that block.
If the BB is in the worklist, null out its entry.
If the BB is the head of a backedge in our traversal, we have hit a loop boundary.
If the C type does not have the expected size, don't import it as a stdlib type.
If the C type of the argument is a const pointer, but the Swift type isn't, treat it as indirect.
If the Clang declaration is from a protocol but was mirrored into class or extension thereof, treat it as an override.
If the Clang module is null, use the bridging header lookup table.
If the Class is unique but not persistent, it's safe to use it as a const after the LdClsCached, which will throw if the class can't be defined.
If the EULA control exists, show it only if a license URL is provided as well.
If the Enum only contains two cases, test for the non-payload case and invert the result.
If the Node is not complete, then we have reached a dead lock.
If the Objective-C selectors match, always call it exact.
If the Objective-C value isn't optional, wrap it in an optional.
If the PUE is not a negation expression, return false
If the RHS is not a simple variable, we need to evaluate it and assign it to a temp local.
If the RPO number of S is less than the RPO number of ER, then we know that the edge in between them is not a backedge and thus we do not want to clip the edge.
If the SIL parameter isn't passed indirectly, we need to map it to an explosion.
If the SILLoader is null, create it.
If the SILModule does not have the VTable, attempt to deserialize the VTable.
If the Self type is concrete, we have a witness thunk with a fully substituted Self type.
If the SpecifierLoc is invalid, then the caller just wants us to synthesize the default, not actually try to parse something.
If the Swift name starts with the word "is", use that Swift name as the getter name.
If the Swift property name starts with the word "is", strip the "is" and lowercase the rest when forming the Objective-C property name.
If the UI should be visible, display it now and hide the splash screen
If the URL refers to a folder but does not end with a slash, then we need to redictect
If the Unbox ended up being a noop, don't bother refcounting
If the Unit is merge only, it then contains enough information to simulate executing the pseudomain.
If the `copy' argument is true, the returned array must be indistinguishable from an array that did a COW, in terms of the contents of the array.
If the above was an under estimate, increment the cycle number until the correct one is found.
If the abstract layout of the enum is dependent on generic parameters, then we additionally need to constrain any layout optimizations we perform to things that are reproducible by the runtime.
If the abstract type parameter already has an archetype assigned, use that information.
If the accessed field is stored, emit a StructExtract on the base.
If the accessor wants the value 'in', we have to copy if the base isn't a temporary.
If the accessor wants the value 'inout', always pass the address we were given.
If the accessor wants the value directly, we definitely have to load.
If the actual argument count is 1, it can match a tuple as a whole.
If the address is marked uninitialized, load through the mark, so that DI can reason about it.
If the address of an array-field escapes, we give up for that field.
If the adjacency is not empty, leave the information in there.
If the apply has no arguments, we don't need to worry about any guaranteed parameters.
If the apply in the caller is not in a significant loop, just stop with what we have now.
If the arc is non-critical, we can figure out its weight by looking at its incident blocks.
If the archetype doesn't have the requested type and the parent is not self derived, error out
If the archetype has a superclass constraint, it has at least the retain semantics of its superclass, and it can be represented with the supertype's pointer type.
If the archetype is class-constrained, use a class pointer representation.
If the archetype is the same as for the 'Self' type variable, return the 'Self' type variable.
If the argtype is a tuple type with default arguments, or a labeled tuple with a single element, pull the scalar element type for the subexpression out.
If the argument and parameter indices differ, or if the names differ, this is a shuffle.
If the argument being specified is actually varargs, then we're just specifying one element of a variadic list.
If the argument cannot be initialized with a scalar, then it is an error, so we might as well pass down the expected type, to get a specific error involving it.
If the argument has an unresolved type, then we're not actually matching against it.
If the argument is a block, copy it.
If the argument is a call, it might be to init(__builtinStringLiteral:byteSize:isASCII:).
If the argument is a match, then check the result type.
If the argument is a metatype of what we're looking for, propagate that.
If the argument is a type variable created for a literal that has a default type, this is a favored param/arg pair if the parameter is of that default type.
If the argument is already lowered to an LValue, it must be the receiver of a self argument, which will be the first inout.
If the argument is consumed, we're still responsible for releasing the original.
If the argument is existential, open it.
If the argument is not present then we expect members without arguments.
If the argument isn't a tuple, it is some scalar value for a single-argument call.
If the argument isn't named, and we're cloning for an inherited constructor, give the parameter a name so that silgen will produce a value for it.
If the argument labels for this result are incompatible with the call site, skip it.
If the argument type exactly matches, this just works.
If the argument type is in error, we're done.
If the arguments are live, we need to keep the terminator that delivers those arguments.
If the array / escapes in some way that cannot be tracked, the analysis must fail.
If the array escaped through an unknown use, the analysis must abort earlier.
If the associated type is directly fulfillable from the type, we don't need a cache entry.
If the associated type is from our own protocol or we inherit from the associated type's protocol, resolve it
If the associated type is non-dependent, we can use an ordinary metadata access function.
If the associated type requirement is satisfied by an associated type, these will all be null.
If the attribute follows the new representation, switch over to the alternate parsing path.
If the attribute is only valid on one kind of declaration (which is pretty common) give a specific helpful error.
If the base is +1, we want to forward the cleanup.
If the base is a +1 r-value, just borrow it for materializeForSet.
If the base is a Str, the result will always be a CountedStr (or an exception).
If the base is a boxed existential, we will open it later.
If the base is a class or an rvalue, then this store just loads the base.
If the base is a module type, just use the type of the decl.
If the base is a primitive type, SetM pushes null.
If the base is a protocol composition, enumerate members of the protocols.
If the base is a protocol, enumerate its members.
If the base is a reference type, just handle this as loading the lvalue.
If the base is a string, SetM pushes a new string with the value of the first character of the right hand side converted to a string (or something like that).
If the base is already an lvalue with the right base type, we can pass it as an inout qualified type.
If the base is an implicit self type reference, and we're in a property initializer, then the user wrote something like:
If the base is an lvalue, then a reference produces an lvalue.
If the base is an object, and it does not implement ArrayAccess, it is still ok to push the right hand side, because it is a fatal.
If the base is currently an address, we may have to copy it.
If the base is currently scalar, we may have to drop it in memory or copy it.
If the base is known to be a string and the operation is exactly SetElem, we're guaranteed that either the base will end as a CountedStr or the instruction will throw an exception and side exit.
If the base might be a str, the result wil be CountedStr or Nullptr.
If the base name is prefixed by "getter:" or "setter:", it's an accessor.
If the base name is vacuous or is a keyword and there are two or fewer words in the base name, don't split.
If the base names are different, they can't conflict.
If the base object is already a metatype type, then something weird is going on.
If the base of the access is mutable, then we may be invoking a getter or setter that requires the base to be mutable.
If the base of the lookup is an existential metatype, emit an error specific to that
If the base type is a tuple type, look for the named or indexed member of the tuple.
If the base type is an IUO, look through it.
If the base type is known to have a single protocol conformance in the current generic context, then we don't need to disambiguate the associated type name by protocol.
If the base type is not optional, the constraint fails.
If the base type isn't specialized, there's nothing to substitute.
If the base type variable doesn't have an associated archetype, just form the member constraint.
If the base type was an optional, look through it.
If the base type was an optional, try to look through it.
If the base value is already known, it may conflict with the parameter of this function.
If the base was a subtype of Null this will give newBase.
If the base was an lvalue but it will only be treated as an rvalue, turn the base into an rvalue now.
If the base was an opened existential, erase the opened existential.
If the bases are not must-alias, the locations may not alias.
If the bases do not alias, then the locations cannot alias.
If the basic block has neither, we do not need to / process the block again in the last iteration.
If the behavior couldn't be resolved during validation, we can't really do much more.
If the best method was from a protocol, keep it.
If the best method was from a subclass of the place where this method was declared, we have a new best.
If the best so far is not from a protocol, or is from a protocol that inherits this protocol, we have a new best.
If the binding is not refutable, and there *is* an else, reject it as unreachable.
If the bit is set, that means this basic block creates a / retain which can be sunk or a release which can be hoisted.
If the bit is set, then the basic block generates a / value for the location.
If the bit is set, then the basic block kills the / value for the location.
If the bit is set, then the current basic block / generates an upward visible store.
If the bit is set, then the current basic block / kills an upward visible store.
If the bit is set, then the location currently has an / downward visible value at the beginning of the basic block.
If the bit is set, then the location currently has an / downward visible value at the end of the basic block.
If the bit is set, then the location currently has an / upward visible store at the end of the basic block.
If the bit is set, then the location currently has an / upward visible store in middle of the basic block.
If the block ends the region, then call irgen::endRegion to sync the state and make a REQ_BIND_JMP service request.
If the block has a cond_fail, try to move it to the predecessors.
If the block has already been created, use it.
If the block has never been named yet, just create it.
If the block is dead, remove it.
If the block is in the dom tree (dominated by the entry block).
If the block isn't empty, check if we need to create a new block.
If the blocks are different, it's as easy as whether A's block dominates B's block.
If the blocks are different, it's as easy as whether BB1 post dominates BB2.
If the body consists of a single expression, turn it into a return statement.
If the body hasn't been type checked yet, be super-conservative and mark all variables as used.
If the body is completely empty, reject it.
If the body of the closure looked ok, then look for a contextual type error.
If the bound pattern is a single value, use a DeclRefExpr on the underlying Decl to print it.
If the box address has a MUI, route accesses through it so DI still works.
If the box has escaped at this instruction, we can't safely promote the load.
If the branch predicates for the two merge differ, mixing them is unsafe since they are not control dependent.
If the bridged ObjC type is known, check if source type can be cast into it.
If the bridged ObjC type is known, check if this type can be cast into target type.
If the bridged value type is generic, the generic arguments must be bridged to Objective-C for bridging to succeed.
If the bridged value type is generic, the generic arguments must match the  FIXME: This should be an associated type of the protocol.
If the buffer alignment is good enough for the type, great.
If the buffer's refcount is 1, we can teleport the elements to a new buffer
If the buffers are the same, use source location ordering.
If the builder has an empty path, just extract its base locator.
If the builtin is read none, it does not read or write memory.
If the builtin is side effect free, then it can only read memory.
If the builtin parameter has no type hints to cause coercion, this function returns TBottom.
If the cached unit is null, we always need to consider it out of date (in case someone created the file).
If the call has any arguments, the FPushFunc will be in a different tracelet -- the tracelet will break on every FPass* because the reffiness of the callee isn't knowable.
If the call is curried, emit a direct call to the curry thunk.
If the call is interpreted, then we spend some time in the TC inside g(), then eventually end in dispatchBB() (called by MCGenerator::handleResume()) for g()'s RetC, the logic here kicks in.
If the call is naturally to an explosion, emit it that way and then initialize the temporary.
If the call is naturally to memory, emit it that way and then explode that temporary.
If the call is to the 'unreachable' builtin, then remove the call, as it is redundant with the actual unreachable terminator.
If the call to xdebug_get_stack_depth was NOT done via CallBuiltin, then it will be included in the depth count, and we need to manually substract it
If the callee is a concrete witness method thunk, apply substitutions from the conformance, and drop any substitutions derived from the Self type.
If the callee is a concrete witness method thunk, we ignore generic parameters derived from 'self', the generic parameter at depth 0, index 0.
If the callee is a default witness method thunk, preserve substitutions from the call site.
If the callee is not polymorphic, no substitutions are required.
If the callee is on the stack, it update our minimum DFS number based on it's DFS number.
If the callee isn't of function type, then something else has gone wrong.
If the callee will consume the 'self' parameter, let's retain it so we can keep it alive.
If the caller and callee are both fragile, preserve the fragility when cloning the callee.
If the caller couldn't provide a setter type, there is nothing to rectify.
If the caller didn't wrap the argument in parentheses or make it a tuple, add the extra parentheses now.
If the caller expected something inout, but we didn't have something of inout type, diagnose it.
If the caller gave us a cache to use, check that.
If the caller is fragile but the callee is not, bail out.
If the caller produced a context for us, but we can't use it, then don't.
If the caller takes the argument indirectly, the argument has an inout type.
If the calling context class is the same as the target class, and method is defined on this class, it must be accessible.
If the candidate function is public, then it has to be the right function.
If the candidate has the same name, its probably the right function.
If the candidate set has been narrowed to a single parameter or single / archetype that has argument type errors, diagnose that error and / return true.
If the candidate's is at least as long as the potential base (testClass) it might be a subclass.
If the canonical declarations are equivalent, we have a match.
If the canonical type was already computed, just return what we have.
If the capture is of a computed property, grab the transitive captures of its accessors.
If the capture is of another local function, grab its transitive captures instead.
If the case does not have an argument type, skip the predecessor since there will not be a retain to sink.
If the case has non-zero tag bits stored in spare bits, we need to mask them out before the data can be read.
If the case insensitive comparison is equal, then secondary sort order should be case sensitive.
If the case is indirect, then the payload is boxed.
If the case value is provided to us as a BB argument as long as the enum is not address-only.
If the cast failed, destroy the input and return false.
If the cast failed, we can't resolve the pattern.
If the cast reduces to unchecked_ref_cast, then the source and dest have identical cleanup, so just forward the cleanup as an optimization.
If the cast succeeded, use the result value as the class instance below.
If the catch block is from a call we don't do this because vmfp()/vmsp() should be further up the stack.
If the catch trace isn't going to finish by calling _Unwind_Resume, we consume the exception here.
If the category is invalid, don't add it.
If the character after the '.' is not a digit, assume we have an int literal followed by a dot expression.
If the character following the prefix is a '_', eat that, too.
If the character was incorrectly encoded, give up.
If the characters aren't all printable, reject it.
If the checks are incompatible we then give up on hoisting the checks for this particular variable.
If the class declares its own ObjC runtime base, use it.
If the class exists, we can verify that the method is valid.
If the class has fragile fixed layout, return the constant size and alignment.
If the class has no methods, no need to loop through breakpoints
If the class in which this initializer was declared conforms to a protocol that requires this initializer, then this initializer is required.
If the class is already defined in this request, the class is persistent or a parent of the current context, and this constant is a scalar constant, we can just compile it to a literal.
If the class is an enum, pull out the actual base type.
If the class is an interface, we can just hit the class's vtable or interface map and call it a day.
If the class is generic, the superclass type may contain generic type parameters from the signature of the class.
If the class is generic, we need to give it a name for Objective-C.
If the class is generic, we'll instantiate its name at runtime.
If the class is not in a generic context, return the original superclass type.
If the class is unique, there will only be one resolution.
If the class is visible only through the Objective-C runtime, form the appropriate runtime call.
If the class must not require dynamic initialization --- e.g. if it is a super reference --- then respect everything that might impose that.
If the class pointer is valid as metadata, no translation is required.
If the class requirement was not the first requirement, complain.
If the class would use the Objective-C allocator, only emit -dealloc.
If the client allows the solution to have unresolved type expressions, check for them now.
If the client can handle unresolved type variables, leave them in the system.
If the client can't handle a +0 result, retain it to get a +1.
If the client changed the type, we're done.
If the client is cool with a +0 rvalue, the decl has an address-only type, and there are no conversions, then we can return this as a +0 address RValue.
If the client is telling us that it knows what it is doing, then believe it.
If the client wants to know about super.init, check to see if we failed it or some other element.
If the closeness is a miss by a single argument, then this returns / information about that failure.
If the closest matches all mismatch on self, we either have something that cannot be subscripted, or an ambiguity.
If the closure had an expected result type, use it.
If the closure had an explicitly written return type incompatible with the contextual type, diagnose that.
If the closure has a multi-statement body, we don't walk into it here.
If the closure has a single expression body, we need to walk into it with a new sequence.
If the closure includes a capture list, create an AST node for it as well.
If the closure is noescape, then we can capture the decl as noescape.
If the closure requires captures, emit them.
If the closure was created in the context of an array type signature's size expression, there will not be a local context.
If the closure's only body element is a single return statement, use that instead of creating a new wrapping return expression.
If the closure's type was inferred to be noescape, then it doesn't need qualification.
If the cmpxchg failed, someone beat us to landing their field type vector.
If the code sequence falls thru, then add the next instruction as a possible target
If the coercion type is a struct, we need to expand it.
If the command line contains an explicit request about whether to add LLVM value names, honor it.
If the component has already been bound to a declaration, handle that now.
If the concrete type is dependent, substitute dependent types for archetypes.
If the condition fails, control flow is transferred to the / specified JumpDest.
If the condition fails, jump to the CondFalseBB.
If the condition is an integer literal, we can constant fold the branch.
If the condition wasn't of boolean type, diagnose the problem.
If the conformance is complete, we're done.
If the conformance is dependent in any way, we need to unique it.
If the conformance is generic, its generic parameters apply to the witness.
If the conformance is generic, mangle its generic parameters.
If the conformance is generic, the accessor takes the metatype as an argument.
If the conformance is in this object's table, then the witness table should also be in this object file, so we can always directly reference it.
If the conformance is not visible, fail.
If the conformance is resilient, this is always true.
If the conformance is resilient, we require runtime instantiation.
If the conformance was synthesized by the ClangImporter, give it shared linkage.
If the conforming type isn't dependent, the below check is never true.
If the connection is closed before the cursor is destroyed, the cursor might try to fetch more results with disasterous consequences.
If the constant is a thunk we haven't emitted yet, emit it.
If the constant produced a tuple, be smarter than RAUW: explicitly nuke any tuple_extract instructions using the apply.
If the constraint represents a protocol, use the shorter mangling.
If the constraint system had a contextual type specified, we use it - it will have a purpose indicator which allows us to give a very "to the point" diagnostic.
If the constraint system has a contextual type, then we can test to see if this is the problem that prevents us from solving the system.
If the constructor can fail, set up an alternative epilog for constructor failure.
If the constructor is invalid, we fail entirely to avoid error cascade.
If the consumption rules say that this is already +1 given a successful operation, just use the value.
If the contents cannot be retrieved m_code will be an empty string.
If the context is non-generic, we're done.
If the context is not a method entry point, returns nullptr to fall back to the tracelet compiler.
If the context is not the declCls, protected methods are visible in context classes related the declCls.
If the context wants a +0 value, guaranteed or immediate, we can give it to them, because OpenExistential emission guarantees the value.
If the context wants us to initialize a buffer, copy there instead of making a temporary allocation.
If the contextual type is an UnsafePointer or UnsafeMutablePointer, then that is probably what is happening.
If the continuation block has no predecessors, this point is not reachable.
If the continuation block has no uses, ...
If the continuation block was used, emit it now, otherwise remove it.
If the control value isn't set then disable it.
If the conversion is trivial, just cast.
If the conversion type contains no info, drop it.
If the convertType is *only* provided for that hint, then null it out so that we don't later treat it as an actual conversion constraint.
If the copied address is also loaded from, then destroy hoisting is unsafe.
If the copyaddr is of a non-loadable type, we can't promote it.
If the counterpart to the method we're attempting to import has the swift_private attribute, don't import as a subscript.
If the current BB is the entry BB, initialize a state corresponding to each of its owned parameters.
If the current BB isn't terminated, and we require a return, then we are not allowed to fall off the end of the function and can't reach here.
If the current ast context has no type checker, create one for it.
If the current bb is terminated then the epilog is just unreachable.
If the current constructor is not failable, force out the value.
If the current context is not a generic type context, returns / the maximum depth of any generic parameter in this context.
If the current frame represents async function that is running, mark it as abruptly interrupted.
If the current function was the last frame in the current VM nesting level, re-throw the C++ exception, otherwise go to the first step and repeat this process in the caller's frame.
If the current function was the last frame in the current VM nesting level, rethrow the exception, otherwise go to the first step and repeat this process in the caller's frame.
If the current loop is only a small part of its outer loop, we don't take the outer loop that much into account.
If the current period has not finished and there is a log file, use it
If the current position in the bytecode is reachable, emit code to return 1.
If the current result matches the remaining found declaration, keep it and move to the next found declaration.
If the current score is worse than the best score we've seen so far, there's no point in continuing.
If the current state is OUT and we are still at a stack level less than the original, then we skip over the PopR opcode if it exists and then break (matching hphpd).
If the current tuple size isn't a multiple of the field's required alignment, we need to pad out.
If the current unit used any spill slots, allocate and free spill space where appropriate.
If the cursor_id is 0, the db is out of results anyway
If the cursor_id is 0, the db is out of results anyway.
If the day of the month is not as expected one then we must have adjusted back to the previous day so add 24 hours worth of seconds.
If the debugger is attached, only allow single-block regions.
If the decimal precision guaranteed by FP arithmetic is higher than the requested places BUT is small enough to make sure a non-zero value is returned, pre-round the result to the precision
If the decl belongs to an ObjC method family, use that family's ownership conventions.
If the decl has a value bound to it but has no PBD, then it is initialized.
If the decl has an explicitly written initializer with a pattern binding, then it isn't settable.
If the decl is currently being type checked, then we have something cyclic going on.
If the decl is currently being validated, this is likely a recursive reference and we'll want to skip ahead so as to avoid having its type attempt to desugar itself.
If the decl is monomorphically a stored property, allow aliases.
If the decl is stored, convert it to StoredWithTrivialAccessors by synthesizing the full set of accessors.
If the decl ref is nil, just insert at the beginning.
If the decl ref requires captures, emit the capture params.
If the decl ref was emitted, emit after its function.
If the decl uses currying syntax, complain that that syntax has gone away.
If the decl was captured from us, it isn't captured *by* us.
If the declaration context from which the type witness was determined differs from that of the conformance, adjust the type so that it is based on the declaration context of the conformance.
If the declaration has an override, name lookup will also have found the overridden method.
If the declaration is an accessor, treat its storage declaration as the enclosing declaration.
If the declaration is const, consider it audited.
If the declaration is dynamic, there's no materializeForSet.
If the declaration is dynamically dispatched through a class, we have to use materializeForSet.
If the declaration is dynamically dispatched through a protocol, we have to use materializeForSet.
If the declaration is exported as a C function, emit its native-to-foreign thunk too, if it wasn't already forced.
If the declaration is generic, fail.
If the declaration is in a different resilience domain, we have to use materializeForSet.
If the declaration is invalid, fail.
If the declaration is not in type context, there's no materializeForSet.
If the declaration is unavailable, note that in the score.
If the declaration is unavailable, we're done.
If the declaration isn't generic, fail.
If the declaration name isn't parallel to the actual parameter list (e.g. if the method has C-style parameter declarations), don't try to apply error conventions.
If the declaration reference is specialized, create the partial application.
If the declaration was imported from C, we won't gain anything from using materializeForSet, and furthermore, it might not exist.
If the declaration was not global to start with, we're done.
If the declaration we attached the 'objc' attribute to is within a class, record it in the class.
If the declaration we found was not a method or initializer, complain.
If the declaration we're looking at doesn't allow a superclass, complain.
If the declaration we're starting from is in a class, first look for a class member with the appropriate selector.
If the declarations come from different modules, order based on the module.
If the declcontext is a Module, then we're in a special error recovery situation.
If the decls in question are distinct protocol members, let the checks below determine if the two choices are 'identical' or not.
If the decls match, then this could conflict.
If the default case is unreachable, don't bother branching at all.
If the default case is unreachable, we don't need to conditionally branch.
If the default literal type is bridged to a class type, add the class type.
If the default value is returned, it might mean either Bottom or Top, so we need more checks.
If the definition is a declaration, try to reconstruct a name and optionally an access path to the uninitialized element.
If the denominator is zero...
If the derived method is ABI-compatible with the base method, give the vtable thunk the same signature as the derived method.
If the desired type matches the payload slot exactly, we don't need to do anything.
If the dest of the Assert/Check doesn't fit `tc', there's no point in continuing.
If the dest started with a landingpad, copy it to middle.
If the destination BB accepts the case argument, set up a waypoint BB so we can feed the values into the argument's PHI node(s).
If the destination base type is a type variable, we can't simplify this now.
If the destination block ends with a return, we don't want to duplicate it.
If the destination block is a simple trampoline (jump to another block) then jump directly.
If the destination has a payload but the source doesn't, we can destroy the payload and primitive-store the new no-payload value.
If the destination is '_', queue up a discard.
If the destination is a class, walk the supertypes of the source.
If the destination is a discard, do nothing.
If the destination is a tuple, recursively destructure.
If the destination type is a foreign class or a non-specific class-bounded archetype, use the most general cast entrypoint.
If the destination type is a subtype of the source type, we have a downcast.
If the destination type is an NSError, and the source type is an ErrorProtocol, then the cast can succeed by NSError bridging.
If the destination type is known to have a Swift-compatible implementation, use the most specific entrypoint.
If the destination type is variadic, compute the injection function to use.
If the destination wants a non-address value, load
If the destructor has an objc_method calling convention, we cannot analyze it since it could be swapped out from under us at runtime.
If the diagnostic is local, flush it before returning.
If the disjunction requested us to, remember which choice we took for it.
If the dominating checked_cast_br is exact then then it is in general not safe to assume that the current non-exact cast would have the same outcome.
If the edge from ER to S is a back edge, we want to clip it and add exiting subregion to
If the edit distance would be too long, we're done.
If the element carries no data, neither does the injection.
If the element changed, rebuild a new ParenExpr.
If the element decl was not resolved (because it was spelled without a type as `.Foo`), resolve it now that we have a type.
If the element has non-tuple type, just serve it up to the initialization.
If the element index is the one we are extracting, skip it...
If the element is not a condition, walk it in the current TRC.
If the element is the first non-empty element to be added to the structure, we can assign it a fixed offset (namely zero) despite it not having a fixed size/alignment.
If the element type is empty, it adds nothing.
If the element was is in the cache, return it.
If the element was not already marked as recursive by a re-entrant call, we can be sure it's not recursive.
If the elt we are extracting is trivial, we cannot be a non-trivial field...
If the elt we are extracting is trivial, we cannot have any non trivial fields.
If the enclosing category is invalid, suppress this declaration.
If the enclosing category is invalid, we cannot import the declaration.
If the enclosing context doesn't handle anything, use a specialized diagnostic about non-exhaustive catches.
If the enclosing scope is a DC directly, rather than a local scope, then the closure should be parented by an Initializer.
If the end of the file has been reached, the routine has a choice of ERREXIT() or inserting fake data into the buffer.
If the end of the function isn't terminated, we screwed up somewhere.
If the end of the store is reached, a new token will be scanned from the frontier.
If the ending delimiter is not found, display a warning.
If the entire pattern is "(pattern_expr (type_expr SomeType))", then this is an invalid pattern.
If the entry fits our requirements
If the entry is a witness method...
If the entry is defined at the current point, (1) we know there won't be a better entry and (2) we should remove it.
If the entry is not visible, skip it.
If the entry was already present, we may need to update it.
If the enum case has no bound value, we're done.
If the enum does not have a payload create the enum/store since we don't need to worry about payloads.
If the enum element has no explicit raw value, try to autoincrement from the previous value, or start from zero if this is the first element.
If the enum has to be accessed resiliently from this resilience domain, we can't assume anything about its layout.
If the enum is address-only, take from the enum we have and load it if the element value is loadable.
If the enum is address-only, we better not have any spare bits, otherwise we have no way of copying the original payload without destructively modifying it in place.
If the enum is already indirect, its cases don't need to be.
If the enum is empty, simply return zero.
If the enum is loadable, do this directly using values, since we have to strip spare bits from the payload.
If the enum is loadable, it's better to do this directly using values, so we don't need to RMW tag bits in place.
If the enum is trivial, then there is no cleanup to disable.
If the enum isn't fixed-layout, get the runtime to do this for us.
If the enum only has 2 values and its tag isn't the true branch, then we know the true branch must be the other tag.
If the enum was not imported, the derived conformance is either from the enum itself or an extension, in which case we will emit the declaration normally.
If the enum we're testing is non-trivial, there will be a cleanup in this stack that will release its value.
If the epilog has a single predecessor and there's no current insertion point to fall through from, then we can weld the epilog to that predecessor BB.
If the epilog is reachable, and the caller provided an epilog, just remember the block so the caller can continue it.
If the epilog was not branched to at all, kill the BB and just emit the epilog into the current BB.
If the error is a bridged NSError, then the "box" is in fact itself the value.
If the error parameter is the first parameter, try removing the standard error suffix from the base name.
If the error value is non-null, branch to the error destination.
If the eval stack is empty, then there is no work to do
If the execution engine doesn't understand the source, the content will be spit out verbatim.
If the existential is class, lower it to a class existential representation.
If the existential type cannot be represented or the protocol does not conform to itself, there's no point in looking further.
If the existing constructor has a less-desirable kind, mark the existing constructor unavailable.
If the expected type is ObjectiveC.Selector, add #selector.
If the explicit conformance is associated with a type that is different from the type we're checking, retrieve generic conformance.
If the explicit protocol for the left-hand side is implied by the explicit protocol for the right-hand side, the left-hand side supersedes the right-hand side.
If the explicit protocol for the right-hand side is implied by the explicit protocol for the left-hand side, the right-hand side supersedes the left-hand side.
If the explosion must be passed indirectly, load the value from the indirect address.
If the expression feeding them is false, they are dead.
If the expression has the effect of a forced downcast, find the / underlying forced downcast expression.
If the expression is already typed to the protocol, lookup the protocol method directly.
If the expression is an explicit closure expression (potentially wrapped in / IdentityExprs), change the type of the closure and identities to the / specified type and return true.
If the expression is an implicit call to _forceBridgeFromObjectiveC or / _conditionallyBridgeFromObjectiveC, returns the argument of that call.
If the expression is obviously something that produces a metatype, then don't put a constraint on it.
If the expression is the result of a call, it is an rvalue, not a mutable lvalue.
If the expression might be a dynamic method call, return the base / value for the call.
If the expression was deemed "too complex", stop now and salvage.
If the expression we've found is the intended target of an RebindSelfInConstructorExpr, wrap it in the RebindSelfInConstructorExpr.
If the extended type is generic or is a protocol.
If the extension doesn't add protocols or has no members that we should print then skip printing it.
If the extension is already known to be invalid, we're done.
If the extension is constrained, mangle the generic signature that constrains it.
If the extra tag bits are zero, we have a valid payload or extra inhabitant (checked below).
If the extract param is non-scalar, and we've made changes already, dont try to optimize yet.
If the failure callback requested a retry for 'class' or 'type' or both, jump back to the top to try again.
If the failure callback requested that we stop autoloading for 'class', then return false here so we don't fall through to the PHP5 autoload impl below.
If the failure is that different occurrences of the same generic have different concrete types, substitute in all the concrete types we've found into the failureInfo to improve diagnosis.
If the field is empty, its address doesn't matter.
If the field is not a let, bail.
If the field is the one we are extracting, skip it...
If the field offset can't be known at compile time, we need to load a field offset, either from a global or the metadata's field offset vector.
If the field offset is fixed relative to the start of the superclass, reference the global from the ivar metadata so that the Objective-C runtime will slide it down.
If the field requires no storage, there's nothing to do.
If the field we are extracting is trivial, we cannot be a non-trivial field...
If the file contents are the same, we are done.
If the file/line combo is invalid, throw an error
If the final block is empty because it would've only contained instructions producing literal values, kill it.
If the final component has an abstraction change, introduce a reabstraction component.
If the final emitted function does not have a self param or it does have a self param that is consumed, convert what we think is self to be plus zero.
If the first and second names are equivalent and non-empty, and we would have an argument label by default, complain.
If the first argument name doesn't start with a preposition, add "with".
If the first argument name doesn't start with a preposition, and the method name doesn't end with a preposition, add "with".
If the first base type is a bridgeable object type, this can only be an upcast.
If the first concat operand is from the previous concat in the stream, continue the current stream.
If the first element of this value is available, check any extra ones before declaring success.
If the first extension is at least as specialized as the second, we're done.
If the first function has fewer effective parameters than the second, it is more specialized.
If the first method has a valid source location but the first conflicting declaration does not, swap them so the primary diagnostic has a useful source location.
If the first module is the current module, the second declaration is shadowed by the first.
If the first node in the list is no primary, we fall back to picking a random node from the set.
If the first operator's precedence is higher than the second operator's precedence, or they have matching precedence and are both left-associative, fold LHS and RHS immediately.
If the first operator's precedence is lower than the second operator's precedence, recursively fold all such higher-precedence operators starting from this point, then repeat.
If the first parameter is the variadic one, it's not more specialized.
If the first parameter list is (self), mark it implicit.
If the first selector piece ends with "Error", it's here.
If the first side-effect instruction in this block is a cond_fail that / is guaranteed to fail, it is returned.
If the first solution has already lost once, don't bother looking further.
If the first thing we found is a fix, add a "don't fix" marker.
If the fixit hint turned out to be / bogus, this returns false and doesn't emit anything.
If the formal root class is imported from Objective-C, then we should use that.
If the forward reference was of the wrong type, diagnose this now.
If the frame becomes live via DefInlineFP, we don't need to treat it as memory support for this set anymore, for the same reason that LdCtx doesn't need that.
If the from type is an integer type, and the to type is String.CharacterView.Index, then we found one.
If the from value is loadable, move it to a buffer.
If the from/to types are equivalent or explicitly convertible, this is a coercion.
If the from/to types are invalid, then use a cast that will fail at runtime.
If the fulfilled value is type metadata, refine the path.
If the fully-uncurried reference is to a generic method, look up the witness.
If the function being called is not our unresolved initializer reference, we're done.
If the function doesn't throw at all, we're done here.
If the function has a dynamic Self, it's okay.
If the function has a throw block we must also find a matching release in the throw block.
If the function has captures, apply them.
If the function is explicit or may be externally referenced, we must emit it.
If the function is exported to C, it must be representable in (Obj-)C.
If the function is fully uncurried and natively foreign, reference its foreign entry point.
If the function is marked readonly, then we know it can't have any interesting side effects, so we don't need to analyze it at all.
If the function is not externally visible, we will not be serializing its body.
If the function is recursive, a function_ref inst inside of the function will give the function a non-zero ref count triggering the assertion.
If the function name passed is already mangled then we assume the user knows exactly what function they want and thus don't try to demangle any functions.
If the function pointer is a witness method call, include the witness table in the context.
If the function pointer is dynamic, include it in the context.
If the function returns an inner pointer, we'll need to lifetime-extend the 'self' parameter.
If the function type throws, set the lower bit of the return type address, so that we can carry this information over to the function type metadata.
If the function wasn't delayed, then we're emitting it now.
If the function's body is 'rethrows' for the number of arguments we gave it, apply the rethrows logic.
If the generator cannot automatically create a layout, it will throw LayoutError.
If the generator is done, just copy the return value onto the stack.
If the generic signature differs from that of the nominal type, it's a constrained extension.
If the generic signature is empty, this is a no-op.
If the given VarDecl is a computed property whose getter always returns a / particular enum element, return that element.
If the given method is a factory method, import it as a constructor
If the given type is a direct reference to an associated type of / the given protocol, return the referenced associated type.
If the global is fixed-size in all resilience domains that can see it, we allocated storage for it statically, and there's nothing to do.
If the global variable has storage, it might also have synthesized accessors.
If the group name is specified, we sort them according to their source order, which is the order preserved by getTopLeveDecls.
If the handledCount is non-zero, we've already seen this fault once while unwinding this frema, and popped all eval stack temporaries the first time it was thrown (before entering a fault funclet).
If the hash is known key.entities should be missing otherwise it should exist, even as an empty array, so create it here.
If the header starts with a DefLabel, the arguments from all the incoming edges need to be collected in a new DefLabel in the new pre-header, and Jmp'd into the header.
If the headers have not been fully received we never started the transport and exiting without receiving an onComplete is safe.
If the hint / decl is specified, the new decl is inserted next to the hint.
If the hint was the last in the parent context's chain, update it.
If the identifier contains non-ASCII character, we mangle  with an initial X and Punycode the identifier string.
If the im-pointer points to a brand new image, the cache gives out bogus colorindexes.
If the image does not fill the box completely the box is filled with image's background color.
If the implicit load's value is available, explode it.
If the imported module name is the same as the current module, produce a diagnostic.
If the imported module name is the same as the current module, skip the Swift module loader and use the Clang module loader instead.
If the imported typealias is unavailable, return the underlying type.
If the incoming values of all predecessors are equal usually this means that the common incoming value dominates the BB.
If the index is 0xffff, then there are no nodes for the property.
If the index type is an integral type, we have an indexed subscript.
If the index type is an object type in Objective-C, we have a keyed subscript.
If the index value doesn't lower to literally the same SILValue's, do some fuzzy matching to catch the common case.
If the indexed type is still marked as ignored, it cannot be conservative scanned.
If the indices are literally identical SILValue's, then there is clearly a conflict.
If the inferred property types don't match up, we can't form a property.
If the information is on the AST, use it.
If the initializer is a C function imported as a member, there is no 'self' parameter.
If the initializer type is TUninit, it means an 86sinit provides the actual initialization type.
If the initializer we found is a designated initializer, we're okay.
If the initializers in the PBD aren't checked yet, do so now.
If the inlined apply was a thick function, then we need to balance the reference counts for correctness.
If the inner abstraction pattern is a tuple, that result will be expanded.
If the inner pattern is a tuple, expand it.
If the inner result is a tuple, we need to expand from a temporary.
If the inner result is indirect, plan to emit from that.
If the inner result is indirect, we need some memory to emit it into.
If the innermost cast fails, the entire expression fails.
If the input IR is in SSA form, this also implies the definition of each SSATmp comes before all uses.
If the input SILFunction is / null, we create a SILFunction.
If the input and result types are canonical, then so is the result.
If the input day is in the first two months, we want the molad at the start of the year.
If the input day is in the fourth to last months, we want the molad at the end of the year.
If the input day is in the third month, it doesn't matter which molad is returned, because both will be required.
If the input instruction has a dest, this will return an SSATmp that represents the same value as dst(0) of the input instruction.
If the input instruction has no dest, this will return nullptr.
If the input is SSA, the start position of each interval dominates every live range and use position in the interval.
If the input is a native type with a bridged mapping, convert it.
If the input is too short for this to be a four-byte encoding, or it isn't one for real, just copy it on through.
If the insert into the files collection fails, it fails - and nothing to cleanup there anyway
If the insertion created a new entry, set up the metadata we were passed as the insertion result.
If the insertion to 'map' is successful, we release the ownership of value object from valuePtr.
If the instance type is String bridged to NSString, compute the type we'll look in for bridging.
If the instance type is a bridged to an Objective-C type, perform a lookup into that Objective-C type.
If the instance type is not representable, the metatype is not representable.
If the instanceSize of the superclass equals the stored instanceStart of the subclass, the ivar offsets will not be changed.
If the instruction corresponds to user-written return or some other statement, we know it corresponds to user code.
If the instruction is a deallocation of uninitialized memory, no action is required (or desired).
If the instruction is a matched release we can ignore it.
If the instruction is an alloc stack inst, add it to the worklist.
If the instruction is not dead and force is false, do nothing.
If the instruction is not dead, always add the local to the set of upward exposed uses.
If the instruction itself has any uses, recursively zap them so that nothing uses this instruction.
If the instruction produces a reference, we can assume the SSATmp it defines corresponds to a new increment on the lower_bound.
If the instruction was modified, it's possible that it is now dead.
If the instruction we were looking at just got exploded, don't skip the next instruction.
If the instruction we're examining is a value, replace it with undef.
If the instructions are close enough, then we should sink them anyway.
If the instructions are different, but only in terms of a cheap operand then we can still sink it, and create new arguments for this operand.
If the interesting-keys set is limiting the set of interesting conformances, collect that filter.
If the interface parameter is a type constant we require the implementer to specify a type
If the interface type is generic, make sure its requirements line up with the archetypes.
If the intermediate operation ends up calling misLea(), this will be set to true.
If the internal pointer points to this element, advance it.
If the intersection allowed data, and either type was an option type, we can simplify the case to whether the unopt'd version of the option type couldBe the other type.
If the intrinsic was lowered from a call to a function that takes two arguments of the same type, use the type of the LHS argument.
If the invocation's argument expression has a favored constraint, use that information to determine whether a specific overload for the initializer should be favored.
If the ivar's size doesn't match the field layout we computed, overwrite it and give it better type information.
If the jit maturity counter is enabled, update it with the current amount of emitted code.
If the key begins with a NUL, it's a private or protected property.
If the key could be an illegal key type, the array may remain empty.
If the key is a number in ascending order, we're still dealing with an array, not an object, so increase the count
If the key is already in the map because someone else beat us to the insertion, we will return the existing value and delete the object we created.
If the key maps / to true, we want to emit a declaration only.
If the kind changed, complain.
If the kinds are different, there's nothing we can do.
If the kinds of overload choice don't match...
If the known type fits the constraint, we're done.
If the last component is logical, just emit a get.
If the last component is physical, just drill down and load from it.
If the last component is physical, then we just need to drill through side effects in the lvalue, but don't need to perform the final load.
If the last extension we included is the same as the last known extension, we're already up-to-date.
If the last fixed-offset field is also fixed-size, we can statically compute the end of the fixed-offset fields.
If the last letter is a 'y', try 'ies'.
If the last path element is an archetype or associated type, ignore it.
If the last pattern had no init, we take the end of its pattern.
If the last use is a / copy, eliminate both the copy and the destroy.
If the layout contains nothing but conservative scans, mark it as if it was explicitly marked for conservative scans.
If the layout is fixed, load and store the fixed-size payload and tag.
If the layout of the class metadata is statically known, then there should be a fixed offset to the right offset.
If the leaf node is not alive, do not add it to our leaf list.
If the left-hand type variable cannot bind to an lvalue, but we still have an lvalue, fail.
If the left-hand-side is a 'try', hoist it up.
If the legacy name was used (e.g., #Image instead of #imageLiteral) prompt an error and a fixit.
If the length of period is equal or longer than a day then we have to check tht the calculation is not thrown out by the start or end of daylight saving time.
If the lengths match, the data is to spec, so we use len2 as the true length.
If the lexer stopped with an EOF token whose spelling is ")", then this is actually the tuple that is a string literal interpolation context.
If the line doesn't contain any part of the range, then ignore it.
If the line is invalid there's not much we can do to inform the client in the dbgp protocol at this point.
If the linking mode is not link all, AI is not transparent, and the callee is not shared, we don't want to perform any linking.
If the list is empty, always conservative scan.
If the list is empty, the custom scanner is always invoked.
If the literal has been assigned a builtin float type, don't mess with it.
If the literal has been assigned a builtin integer type, don't mess with it.
If the load yielded null, emit the type metadata.
If the location has a single type-source instruction, pass it along to preOptimizeAssertTypeOp(), which may be able to use it to optimize away the Assert*.
If the location is invalid, do not emit source ranges or fixits.
If the locator is empty, ignore it.
If the locator points to a function application, find the function itself.
If the looked up witness table is a declaration, there is nothing we can do here.
If the lookup found no hits at all (either viable or unviable), diagnose it as such and try to recover in various ways.
If the lookup occurs from within a trailing 'where' clause of a constrained extension, also look for associated types.
If the low bit is set in mcePrime, we're in the middle of smashing immediates into the TC from the handlePrimeCacheInit, and the upper bits is not yet a valid Func*.
If the lowered metatype has a thick representation, we need to derive it dynamically from the instance.
If the lvalue is purely physical, then it won't have any side effects, and we don't need to drill into it.
If the lvalues don't have the same base value, then they aren't the same.
If the macro is equal to an existing macro, map down to the same declaration.
If the mask is all ones, do a simple store, otherwise do a load/or/store sequence to mask in the bits.
If the mask is no longer than the stored spare bits, we can just apply the stored spare bits.
If the match should not be empty
If the match wasn't the next one, we have potentially out of order arguments.
If the member came by optional unwrapping, then unwrap the base type.
If the member has weak or unowned storage, convert it away.
If the member is a constructor, verify that it can be legally referenced from this base.
If the member is dynamic, reference its dynamic dispatch thunk so that it will be redispatched, funneling the method call through the runtime hook point.
If the member is not part of a type, there's nothing to substitute.
If the member is part of a protocol or extension thereof, we need to substitute in the type of Self.
If the member isn't settable, then it is the problem: return it.
If the member reference expression failed to type check, the Expr's type does not conform to the given protocol.
If the member type maps to an archetype, resolve that archetype.
If the member type uses 'Self' in non-covariant position, we cannot use the existential type.
If the members agree on instance-ness, a property is better than a method (because a method is usually immediately invoked).
If the memory (or some element thereof) is not initialized on some path, the bad things happen.
If the memory object had any non-trivial stores that are init or assign based on the control flow path reaching them, then insert dynamic control logic and CFG diamonds to handle this.
If the memory object has multiple tuple elements, we need to destroy any live subelements, since they can each be in a different state of initialization.
If the memory object has non-trivial type, then removing the deallocation will drop any releases.
If the memory object has nontrivial type, then any destroy/release of the memory object will destruct the memory.
If the memory object has nothing in it (e.g., is an empty tuple) ignore.
If the memory object is completely initialized, then nothing needs to be done at this release point.
If the metatype has already been lowered, it will already carry its representation.
If the metatype is existential, there may be witness tables in the value, which we don't need.
If the metatype matches a dependent type, it must be thick.
If the metatype value isn't a type expression, the user should reference '.init' explicitly, for clarity.
If the metatype's instance type does not contain any type parameters, substitution does not alter anything, and the empty representation can still be used.
If the method has a related result type that is representable in Swift as DynamicSelf, do so.
If the method is dynamic, access it through runtime-hookable virtual dispatch (viz.
If the method is foreign, its foreign thunk will handle the dynamic dispatch for us.
If the method is private, the above case is the only case where we'd know it was accessible.
If the method is the wrong kind (instance vs.
If the method isn't defined in the requested class, skip it.
If the method returns Self, substitute AnyObject for the result type.
If the method was declared within a protocol, check that it does not conflict with the setter of a property.
If the method we're attempting to import has the swift_private attribute, don't import as a subscript.
If the model type does not conform to the protocol, the bases are unrelated.
If the module is being built with -sil-serialize-all, everything has to have public linkage.
If the molad occurs on or after noon, Tishri 1 must be delayed.
If the month is 1 or 2, the calculation is simple addition to the first of the year.
If the month is 4 to 7, it is considered whether it is a leap year and then simple subtraction from the beginning of the following year is used.
If the month is 8 (Nisan) or greater, the calculation is simple subtraction from beginning of the following year.
If the name didn't actually line up, complain.
If the name ends in the CF typedef suffix ("Ref"), drop that.
If the name has leading underscore then it's a private symbol.
If the name is an operator name, also look for operator methods.
If the name matched, report this result.
If the name matches, claim this argument.
If the name of our match differs from the name we were looking for, complain.
If the name we found matches, report the declaration.
If the name word is longer, there's no match.
If the name word is shorter, try for a partial match.
If the names don't match, we may have a conflict.
If the names match, continue.
If the names of the witness and requirement differ, we need to specify the name.
If the native type conforms to _ObjectiveCBridgeable, use its _bridgeToObjectiveC witness.
If the nested type comes from a type alias, use either the alias's concrete type, or resolve its components down to another dependent member.
If the nested type has been resolved to an associated type, use it.
If the nested type is not an archetype (because it was constrained to a concrete type by a requirement), return the fresh type variable now, and let binding occur during overload resolution.
If the nested type was not already resolved, do so now.
If the new PHInode is not dominated by the allocation then it's dead.
If the new PHInode is properly dominated by the deallocation then it is obviously a dead PHInode, so we don't need to insert it.
If the new kind is the same as the existing kind, stick with the existing constructor.
If the next character is not uppercase, stop.
If the next entry is going to be too big for the code size, then increase it, if possible.
If the next entry is the end of the block, then this function has no contents.
If the next month is invalid, then we need to try the first month of the next year, bearing in mind that the next year after 1 BCE is actually 1 AD and not 0.
If the next non-uppercase character was not a letter, we seem to have a plural, we should still lowercase the character we're on.
If the next thing isn't an arg-type then assume string.
If the next token can be an argument label or is ':', this is a name.
If the next token is '_', parse a discard expression.
If the next token is 'catch', this is a 'do'/'catch' statement.
If the next token is not a binary operator, we're done.
If the next token is not an operator, just parse this as expr-postfix.
If the next token is obviously not the start of a decl, bail early.
If the next token isn't a following '(', we don't have a compound name.
If the next word is a plural suffix, add it on.
If the node already has a pointsTo _edge_ we don't change it (we don't want to change the structure of the graph at this point).
If the node is a leaf and is not a live, continue.
If the nominal type declaration of the context type we're looking at matches the owner's nominal type declaration, this is how we found the member type declaration.
If the nominal type doesn't, it's an error.
If the nominal type is bridged to Objective-C (via a conformance / to _ObjectiveCBridgeable), print the bridged type.
If the non-fixed conformance is not replaceable, we have a failure to diagnose.
If the non-local successor edge points to a parent successor that is not dead continue.
If the normal conformance is for a generic type, and we didn't hit a specialized conformance, collect the substitutions from the generic type.
If the number of argument labels does not match, these overrides cannot be compatible.
If the number of calls is less than the natural uncurry level, the callee emission might create a curry thunk.
If the number of captured subpatterns on this run is less than the total possible number, pad the result arrays with empty strings.
If the number of parameters doesn't match, we're done.
If the objc type has any generic args, convert them and bind them to the imported class type.
If the object does not define a __toString() method, raise a recoverable error
If the object has a small number of properties, just emit stores inline.
If the offset is inside an interpolated expr segment, re-lex.
If the only remaining constraints are conformance constraints or member equality constraints, and we're allowed to have free variables, we still have a solution.
If the only users of the alloc_stack are alloc, destroy and init_existential_addr then we can promote the allocation of the init existential.
If the op and operand types are a supported combination, return the modified value.
If the opaque value is consumable, we can just return the value with a cleanup.
If the opaque value is not an lvalue, open the existential immediately.
If the opcode that threw was a member instruction, we have to decref tvRef and tvRef2.
If the operand is an instruction that is only used by the instruction being deleted, delete it.
If the operand is an otherwise-unused 'metatype' instruction in the same basic block, zap it and create a 'metatype' instruction that directly produces a thick metatype.
If the operand is an otherwise-unused 'metatype' instruction in the same basic block, zap it and create a 'metatype' instruction that directly produces an Objective-C metatype.
If the operands are simple enough we can fold this expression right here and keep the parse tree smaller.
If the operator is a cast operator, the RHS can't extend past the type that's part of the cast production.
If the operator is infix operator, highlight specifiers like "associativity" or "assignment" as keywords.
If the operator's precedence is lower than the minimum, stop here.
If the optimizer is enabled, we run the ARCOpt pass in the scalar optimizer and the Contract pass as late as possible.
If the option kinds are the same, and the wrapped types are the same, but the arities are different, we can peephole the optional-to-optional conversion into a series of nested injections.
If the origin *is* the destination, we can stop here.
If the original annotation was soft, make sure we preserve the softness
If the original declaration was implicit, we may want to change that.
If the original object is immediately destroyed after passing off the copy, then the copy was unnecessary.
If the original type had extra inhabitants, carry over its extra inhabitant flags.
If the original type is opaque and the substituted type is materializable, the count is 1 anyway.
If the original type is passed indirectly, copy to memory if it's not already there.
If the original type was an archetype, check the conformance map.
If the original type was an archetype, use that archetype as the original type of the element --- the actual archetype doesn't matter, just the abstraction pattern.
If the original variable was settable, then Sema will have treated the VarDecl as an lvalue, even in the closure's use.
If the other ref count value was blotted, blot our value and continue.
If the other state's value is blotted, skip it.
If the outer abstraction pattern is also a tuple, that result will also be expanded, in parallel with the inner pattern.
If the outer is indirect, force it into the context.
If the outer result is indirect, plan to emit into that.
If the outer type is not a tuple, it must be optional.
If the output type will be used as a prediction and not as fact, we can be optimistic here.
If the outstanding weak retain count is 1 (i.e. only the initial weak retain), we can immediately call swift_slowDealloc.
If the overall memory allocation has multiple elements, then dive in to explain *which* element is being used uninitialized.
If the overall operator is a binary one, then we're looking at juxtaposed binary and unary operators.
If the overall structure so far has a fixed layout, then add this as a field to the layout.
If the overridden method has a foreign error convention, adopt it.
If the override is ABI compatible, we do not need a thunk.
If the overriding declaration does not have the 'override' modifier on it, complain.
If the overriding declaration is 'throws' but the base is not, complain.
If the owning Objective-C class has designated initializers and this is not one of them, treat it as a convenience initializer.
If the param is not a 'let' and it is not an 'inout'.
If the param type is an empty existential composition, the function can only have one argument.
If the parameter has a default argument, it's vacuous.
If the parameter is a block, we need to copy it to ensure it lives on the heap.
If the parameter is a class type, we only consider it interesting if the convention decided it was actually a source.
If the parameter is a direct metatype parameter, this is a static method of the instance type.
If the parameter is a thick metatype, bind it directly.
If the parameter is an inout type, and we have a proper lvalue, match against the type contained therein.
If the parameter is consumed, we have to emit at +1.
If the parameter is indirect, we need to drop the value into temporary memory.
If the parameter is named, it will be removed and correctly disposed of by the hash_update call that follows
If the parameter is of function type, it's vacuous.
If the parameter is variadic, we will print the "..." after it, but we have to strip off the added array type.
If the parameter was a tuple, try to look through the various tuple operations.
If the parameters can live independent of the context, release it now so we can tail call.
If the parameters depended on the context, consume the context now.
If the paren expr has a favored type, and the subExpr doesn't, propagate downwards.
If the parent DIE was an object type, fill the supplied vector with the template parameters.
If the parent context has a generic signature, add its generic parameters.
If the parent didn't change, we won't change.
If the parent exists in our backtrace, it means we have detected a cycle.
If the parent has been favored on the way down, propagate that information to its children.
If the parent is a dependent type, the member is a dependent member.
If the parent is a type parameter, the member is a dependent member.
If the parent is a type variable, retrieve its member type variable.
If the parent is an archetype, extract the child archetype with the given name.
If the parent is dead, continue.
If the parent is dependent, create a dependent member type.
If the parent is directly at the top, it's implicit.
If the parent is non-mutable, it's okay to be covariant.
If the parent lexer should stop prematurely, and the ArtificialEOF position is in this subrange, then we should stop at that point, too.
If the parent was unchanged, return the original pointer.
If the parsed stmt was a GuardStmt, push the VarDecls into the Entries list, so that they can be found by unqual name lookup later.
If the parser has a message, prepend it to the given message.
If the parser returned null, it is an already diagnosed parse error.
If the path cannot be resolved and is relative, the path of the sandbox is used to qualify the relative path.
If the path length is 1 the type directly references itself.
If the pattern already has a type, we're done.
If the pattern binding appears in a type or library file context, then it must bind at least one variable.
If the pattern didn't get a type or if it contains an unbound generic type, we'll need to check the initializer.
If the pattern didn't get a type, it's because we ran into some unknown types along the way.
If the pattern has a registered match expression, it's a type-checked ExprPattern.
If the pattern has been type-checked, walk the match expression, which includes the explicit subexpression.
If the pattern is typed as optional (or tuples thereof), it is default initializable.
If the pattern was valid, check for an implicit VarPattern on the outer level.
If the patterns are exactly the same kind, we might be able to treat them similarly.
If the payload has extra inhabitants left over after the ones we used, forward them as our own.
If the payload is POD, then we can use POD value semantics.
If the payload is a single refcounted pointer and we have a single empty case, then the layout will be a nullable pointer, and we can pass enum values directly into swift_retain/swift_release as-is.
If the payload is boxed, project it.
If the payload is empty, so is the explosion.
If the payload is empty, there's only one case per tag.
If the payload is empty, turn the case into a no-payload case, but only if case numbering remains unchanged from all resilience domains that can see the enum.
If the payload is indirect, emit it into a heap allocated box.
If the payload is indirect, project it out of the box.
If the payload is indirect, we can use the NativeObject type metadata without recurring.
If the payload is larger than the value, zero out the rest.
If the payload is loadable, forward its explosion schema.
If the payload size is greater than 32 bits, the calculation would overflow, but one tag bit should suffice.
If the payload value is vacant, or the mask is all ones, we can adopt the mask value directly.
If the payload value is vacant, the mask can't change it.
If the payload was indirect, we already evaluated it and have a single value.
If the physical register has never been redefined, we will be safe rewriting uses of other Vregs that we know were defined in terms of it.
If the piece is zero, this doesn't affect the switch.
If the ping failed, deregister the connection
If the pixel is transparent, we assign it the palette index that will later be added at the end of the palette as the transparent index.
If the platform doesn't use ObjC tagged pointers, we can go crazy.
If the pointed-to type is unrepresentable in Swift, import as OpaquePointer.
If the pointee is 'const void', 'CFTypeRef', bring it in specifically as AnyObject.
If the pointee is a record, consider creating a class type.
If the pointee is another CF typedef, create an extra typealias for the name without "Ref", but not a separate type.
If the pointer cannot escape to the function we are done.
If the pointer itself is optional, we need to branch based on whether it's really there.
If the potential archetype has been bound away to a concrete type, it needs no requirements.
If the pre-req required a restart (any restart) then do an immediate restart to ensure that the bundle will get launched again post reboot.
If the preceding token in the call is the leading parameter separator, we'll expand replacement to cover that.
If the predecessor *is* in the loop it must be the tail of a backedge.
If the predecessor block has already been visited (potentially due to a cycle in the CFG), don't revisit it.
If the predecessor is not in the loop, make the predecessor a predecessor / of the loop instead of the header.
If the predecessor is the head of a backedge in our traversal, clear any state we are tracking now and clear the state of the basic block.
If the predecessor region is an unknown control flow edge tail, the dataflow that enters into the region bottom up is undefined in our model.
If the preposition is "of", look for a previous preposition.
If the preposition is "with" followed by "zone", never consider it vacuous.
If the preposition was "by" and is followed by a gerund, also remove "by".
If the prereq package is already installed, remember that.
If the previous checking gives the expr error type, clear the result and re-check.
If the previous declaration didn't have a semicolon and this new declaration doesn't start a line, complain.
If the previous removal range was the previous argument, combine the ranges.
If the previous statement didn't have a semicolon and this new statement doesn't start a line, complain.
If the printed Decl is not the top-level one, reset analyzer.
If the problematic decl is 'self', then we might be trying to mutate a property in a non-mutating method.
If the producer knows that the cell is not the last reference (e.g. if it is a Dup), then Use:UsedIfLastRef is equivalent to Use::Not.
If the producer of the cell knows that it is not the last reference, then it can treat Use::UsedIfLastRef as being equivalent to Use::Not.
If the program wasn't specified on the command-line, ala' -r, is no command-line parameter, read the PHP file from stdin.
If the prologue has a matching guard, then smash its guard-callers as well.
If the proper action on seeing token YYTOKEN is to reduce or to detect an error, take that action.
If the property came from ObjC, we need to register this as an external definition to be compiled.
If the property can be proved to be true, the / corresponding semantics-call is replaced by a true-literal.
If the property decl is an instance property, its accessors will be instance methods and the above condition will mark them ObjC.
If the property does not have a fixed layout from the given context, we cannot do direct access.
If the property has storage, emit the ivar name last.
If the property is a generic requirement, allow aliases, because it may be conformed to using a stored property.
If the property is already settable, we're done.
If the property is defined in a non-final class or a protocol, the accessors are dynamically dispatched, and we cannot do direct access.
If the property is dynamic, propagate to this accessor.
If the property is not found as a public property anywhere in the hierarchy, we don't want to merge this type.
If the property isn't from Clang, we can't safely update it.
If the property name is known, try to look it up and get its RAT.
If the property occurs within a generic extension context, consider the generic signature of the extension.
If the property was declared with a parameter, but the behavior didn't use it, complain.
If the property was declared with an initializer, but the behavior didn't use it, complain.
If the protocol comes from clang and is not annotated and the protocol requirement itself is not annotated, then infer availability of the requirement based on its types.
If the protocol contains missing requirements, it can't be conformed to at all.
If the protocol has a default type, check it.
If the protocol introduces a class constraint, track whether we need to check for it independent of protocol witnesses.
If the protocol is Objective-C-compatible, go through the path that produces an ObjC-compatible protocol_t.
If the protocol is in the same module as the conformance, we're not resilient.
If the protocol is not resilient, the conformance is not resilient either.
If the protocol itself is invalid, there's nothing we can do.
If the protocol requires a class, non-classes are a non-starter.
If the proxy has an enabled breakpoint that matches entry into the given function, arrange for the VM to stop execution and notify the debugger whenever execution enters the given function.
If the r-value doesn't require reabstraction, the final context is the emission context.
If the range is "all", this is the same as not having an available attribute.
If the record applies to a specific type, cache it.
If the record provides a nondependent witness table for all instances of a generic type, cache it for the generic pattern.
If the redeclaration context is namespace-scope, then we're mapping as a member.
If the reference is indirect, flag it by setting the low bit.
If the reference isn't to a constructor, we're done.
If the reference needs to be converted, do so now.
If the referenced decl is a local func with context, then the SILDeclRef uncurry level is one deeper (for the context vars).
If the referenced decl isn't a VarDecl, it should be a constant of some sort.
If the region wasn't complete, don't cache the result, unless we already know it will be too expensive, or we've stopped profiling it
If the replacement string should be eval'ed
If the replacement type has dependent conformances, we might be able to use an abstract conformance.
If the representatives are already the same, we're done.
If the representatives are equivalent, do nothing.
If the request has already been satisfied, we're done.
If the request local cache isn't filled, try to use the Func* from the TC's mcePrime as a starting point.
If the requested size is a page or larger, map page(s) for it specifically.
If the requirement has a self parameter passed as an indirect +0 value, and the witness takes it as a non-inout value, we must load and retain the self pointer coming in.
If the requirement is generic, reparent the requirement parameters to the conformance parameters.
If the requirement is optional, it's okay.
If the requirement is rethrows, the witness must either be rethrows or be non-throwing.
If the requirement is settable and the witness is not, reject it.
If the requirements don't match up, complain.
If the requirements match up, move on to the next requirement.
If the result element wasn't computed, we must be analyzing code within an unreachable cycle that is not dominated by "TheMemory".
If the result is a tuple, we need to expand it.
If the result is a value, lowercase it.
If the result is address-only, emit the result into a common stack buffer that dominates both branches.
If the result is address-only, we need to return something in memory, otherwise the result is the BBArgument in the merge point.
If the result is indirect, and we have an address to emit into, and there are no abstraction differences, then just do it.
If the result is invalid, don't cascade errors.
If the result is invalid, skip it.
If the result is loadable, emit each branch and forward its result into the destination block argument.
If the result is unitialized, the property must be undefined
If the result isn't a metatype, there's nothing else to do.
If the result type is a non-lvalue, then we are failing because it is immutable and that's not a great thing to assign to.
If the result type is address-only, get a result buffer for it.
If the result type is dependent on a type parameter we might have to cast to the result type - it could be substituted.
If the result type matches the context, remove the context type from the prefix of the name.
If the result was from a Selector("selector-name"), add a separate note that suggests wrapping the selector in parentheses to silence the warning.
If the result was not ambiguous, we're done.
If the result was returned autoreleased, implicitly insert the reclaim.
If the result wasn't computed, we must be analyzing code within an unreachable cycle that is not dominated by "TheMemory".
If the result's type contains delayed members, we need to force them now.
If the resulting argument is used at the destination these terminators will end up live, and then our normal liveness propagation will mark the single operand of these instructions as live.
If the resulting declaration context is not a nominal type, we're done.
If the resulting value is a refcounted type, it will have one unconsumed reference.
If the retain and release are to obviously pointer-equal objects, then we can delete both of them.
If the retain value's argument is not the cond_br's argument, we can't do anything with our simplistic analysis...
If the retain value's argument is not the switch's argument, we can't do anything with our simplistic analysis...
If the rethrow block wasn't actually used, just remove it.
If the rethrow destination has a single branch predecessor, consider emitting the rethrow into it.
If the rethrow destination isn't used, we're done.
If the return address is in functionEnterHelper or callToExit, rvmfp() won't contain a real VM frame, so we skip those.
If the return block is not already a canonical merged return / block, then split it.
If the return is in a defer, then it isn't valid either.
If the return location is known to be that of an already processed return, use it.
If the return type has nullability, use it.
If the return type is address-only, emit the indirect return argument.
If the return type is not Void, add a BBArg that / propagates NewRetVal to the return instruction.
If the right hand side is already defined, don't invoke the autoloader at all, this means we have to check for both a type alias and a class before attempting to load them via the autoloader.
If the right hand side was a class, we need to autoload and ensure it exists at this point.
If the right operand is a try, it's an error unless the operator is an assignment or conditional operator and there's nothing to the right that didn't parse as part of the right operand.
If the root class was implemented in Objective-C, use Objective-C's allocation methods because they may have been overridden.
If the rules are changed so that fields aren't necessarily laid out sequentially, the computation of InstanceStart in the RO-data will need to be fixed.
If the sample is Enter, then do not record this function name because it hasn't done anything.
If the schemas don't even match in number, we have to go through memory.
If the score is better than the best we've seen, update the best and clear out the list.
If the score is relatively high, don't warn: this is probably unrelated.
If the scores are different, we have a winner.
If the second operator's precedence is lower than the min precedence, break out of the loop.
If the second solution has already lost once, don't bother looking further.
If the second type is a protocol type, we're done.
If the second type is a type variable, the expression itself is ambiguous.
If the select is non-exhaustive, we require a default.
If the selector did not provide an index for the error, find the last parameter that is not a trailing closure.
If the selector piece is "error", this is the location of the error parameter.
If the selectors of the getter match in Objective-C, we have an override.
If the self type couldn't be computed, or is the result of an upstream error, return an error type.
If the self value may have been consumed, we need to check for this before doing anything else.
If the self value was conditionally consumed, we need to emit conditional logic.
If the self.init() or super.init() call threw an error and we caught it, self is no longer available.
If the sequence is an implicitly unwrapped optional, force it.
If the server checked the validity of the breakpoints, the values of the m_bindState flags are copied to the client's breakpoint list.
If the server definition has not set the repl_set_name member yet, set it here
If the server hasn't received the entire request body ServerShutdownEOM seconds after shutdown starts, the request will be aborted.
If the set changes, reschedule that predecessor.
If the shapes were nontrivial and equal, the specs would be equal.
If the shuffle conversion is invalid (e.g. incorrect element labels), then we have a type error.
If the shuffle index is Variadic, the argument sources are stored separately.
If the shuffle is invalid, then there is a type error.
If the sign bit isn't set, we can get the same results by emitting a testlim.
If the single array argument contains a zeroth index, consider it an array of pipeline operators.
If the single predecessor terminator is a branch then the root is the argument to the terminator.
If the situation is not cacheable, we just put a value into the immediate that will cause it to always call out to handleSlowPath.
If the size is larger than we can represent in 32-bits, complain about the unimplementable ivar.
If the skip extends beyond the data currently in the buffer, the buffer can be marked empty so that the next read will cause a fill_input_buffer call that can suspend.
If the solver has allocated an excessive amount of memory when solving for this expression, short-circuit the binding operation and mark the parent expression as "too complex".
If the solver recorded what we should do here, just do it immediately.
If the source and destination index are different, we'll be shuffling.
If the source and destination types match, there's nothing to do.
If the source expression is a tuple literal, we can break it up directly.
If the source file contains an artificial main, emit the implicit toplevel code.
If the source is a physical lvalue, the destination is a single address, and there's no semantic conversion necessary, do a copy_addr from the lvalue into the destination.
If the source is an NSError, and the target is a bridgeable ErrorProtocol, try to bridge.
If the source is an existential, attempt to cast it first without unwrapping the target.
If the source is not existential, an archetype, or (under the ObjC runtime) a class, and the destination is a metatype, there is no way the cast can succeed.
If the source key and value types are object types, this is an upcast.
If the source of a cast should be destroyed, emit a release.
If the source of the VarDecl is a trivial PatternBinding with only a single binding, rewrite the whole thing into an assignment.
If the source of the assignment is an application of a C function, there is no metatype argument, so treat the assignment to the self box as the initialization.
If the source type is a value type, it cannot possibly conform to a class-bounded protocol.
If the source type is already an error type, we've already posted an error.
If the source type is bridged to Objective-C, try to bridge.
If the source type is existential, project out the class pointer.
If the source type is private or target protocol is private, then conformances cannot be changed at run-time, because only this file could have implemented them, but no conformances were found.
If the source type isn't a metatype, the cast fails.
If the source value has no payload, we can primitive-store the empty-case value.
If the source value is a metatype, either do a metatype-to-metatype cast or cast it to an object instance and continue.
If the sourceDecl didn't explicitly name a raw value, this is the most / recent preceding decl with an explicit raw value.
If the spare bits are all zero, then we have a valid value and not an extra inhabitant.
If the specified value is a 'let' property in an initializer, return true.
If the srcs and dsts don't intersect, simplify to a sequence of copies.
If the stack isn't clean or doesn't match the marker's irSPOff, the unwinder won't see what we expect.
If the stack pointer tmps are different, clear the tracked value (we can make a new one, given fp and irSPOff).
If the stag bits for the two classes overlap, but the stags were different, we're dealing with a union-style STag (like IterBoth).
If the standard library provides a _stdlib_didEnterMain intrinsic, call it first thing.
If the start or end is a partial word, don't scan that word.
If the static property "slaveOkay" is set, we need to switch to a MONGO_RP_SECONDARY_PREFERRED as well, but only if read preferences aren't already set.
If the static types are invalid, simply avoid promotion, that way the runtime will then report a failure if this cast is ever executed.
If the step out command is active and if our stack depth has decreased, we are out of the function being stepped out of
If the storage is dynamic or ObjC-native, we can't add a dynamically- dispatched method entry for materializeForSet, so force it to be statically dispatched.
If the store dest cannot alias the pointer in question, then the specified value cannot be modified by the store.
If the store is to a non-mutating member, then this is just a load, even if the base is an inout expr.
If the string base is empty, it will be promoted to an array.
If the string contains a class name (e.g. Foo::bar), all kinds of weird junk happens (wrt forwarding class contexts and things).
If the string contains non-ASCII and the type can handle UTF-16 string literals, prefer them.
If the string contains only ASCII, force a UTF8 representation
If the string is empty, just leave, remembering that we did all this.
If the string literal was coerced to Selector, replace the coercion with the ")".
If the string operand has a constant value, convert it to the appropriate numeric and lower to a numeric comparison.
If the string's length is less than or equal to the specified width, there's nothing to do and we can just return the string.
If the struct has to be accessed resiliently from this resilience domain, we can't assume anything about its layout.
If the struct in which this constructor is being added was imported, add it as an external definition.
If the struct we are extracting from only has one non trivial element and we are not extracting from that element, this is an ARC escape.
If the subcommand is one of the "built-in" 'repl' or 'run', then use the normal driver.
If the subexpression is a conditional checked cast, emit an unconditional cast, which drastically simplifies the generated SIL for something like:
If the subexpression is a metatype, build a direct reference to the constructor.
If the subexpression is a monadic optional operation, peephole the emission of the operation.
If the subexpression type checks as a non-optional type, then that is the error.
If the subexpression type is exactly the same, then just peephole the whole thing away.
If the subexpression was in error, just propagate the error.
If the subject is a simple variable, then we have to evaluate it every time we compare against a case condition.
If the subscript kinds don't match, it's not an override.
If the subscript occurs within a generic extension context, consider the generic signature of the extension.
If the substituted type is passed indirectly, so must the unsubstituted type.
If the substituted type is returned indirectly, so must the unsubstituted type.
If the substituted type isn't a reference type, then we can't have a class-bounded protocol or inheritance, and the simple case just works.
If the substitution didn't change anything, we know that the original type was a lowered type, so we're good.
If the substitution didn't change the type, then a negative response to the above is determinative as well.
If the successfully applied constraint is favored, we'll consider that to be the "best".
If the successor is already dead, skip it.
If the successor region is already in this LRegion this returns that regions index. Otherwise it returns a new index.
If the successor region is an unknown control flow edge head, the dataflow that leaves the region bottom up is considered to be undefined in our model.
If the super.init call is implicit generated, produce a specific diagnostic.
If the superclass constructor is a convenience initializer that is inherited into the current class, it's okay.
If the superclass doesn't require in-class initial values, the requirement was introduced at this point, so stop here.
If the superclass is resilient to us, we cannot statically know the layout of either its instances or its class objects.
If the superclass was imported from Objective-C, its size is not known at compile time.
If the switch did a break, we made some progress moving this retain.
If the switch is non-exhaustive, we require a default.
If the system failed to produce a solution, post any available diagnostics.
If the systems made the same choice, there's nothing interesting here.
If the table builder doesn't take this one, we have to free it.
If the table entry is null, the resource has been closed.
If the table was emitted, emit after it.
If the tag bits do not fit in the spare bits, the remaining tag bits are the extra tag bits.
If the tag has spare bits, we need to mask them into the payload area.
If the tag indicates a payload, then we're done.
If the takeover was fully completed the socket should already be closed.
If the target encoding was unknown, or no decoder function was specified, return the UTF-8-encoded data as-is.
If the target existential requires witness tables, we can't do this cast.
If the target type can't throw, neither can the source.
If the target type is bridged to Objective-C, try to bridge.
If the target type is either an unknown dynamic type, or statically known to bridge, the cast may succeed.
If the template class has already been scoped to `ctx', we're done.
If the temporary is non-trivial, we need to release it later.
If the terminator is a cast instruction then use the pre-cast value.
If the test class cannot be extended, we only need to do the same-class check, never the strict-subclass check.
If the test must be extended, don't check for the same class.
If the theme did not provide an icon, try using the icon from the bundle engine.
If the thread mode is Normal we let other threads with interrupts go ahead and process them.
If the throw destination is not valid, then the PatternMatchEmission logic is emitting an unreachable block but didn't prune the failure BB.
If the time of day is not equal to midnight then we need to adjust for daylight saving time.
If the token after that isn't an argument label or ':', we don't have a compound name.
If the token has the same location as a reset location, reset the token stream
If the token is not in the MemoryManager map, it means a pointer to the File has been stored directly in the XML context.
If the top bit of Result is known to be 0, then it is safe to replace the whole pattern by original bits of x
If the top of stack is a loc that is not marked, do nothing
If the transfer is doable bitwise, and if the elements of the explosion are the same type, then just transfer the elements.
If the translation corresponds to a DV Funclet, then add an entry into dvFuncletDB.
If the trigger has already been claimed, do nothing.
If the true case did need the continuation block, but the false case doesn't, just merge the continuation block back into its single predecessor and move the IP there.
If the true case didn't need the continuation block, then we don't either, regardless of whether the current location is reachable.
If the true/false values already match, it must be a contextual problem.
If the tuple element has a label, parse it.
If the tuple element has a label, propagate it.
If the tuple element starts with "ident :", then it is followed by a type annotation.
If the tuple element starts with "ident :", then the identifier is an element tag, and it is followed by a type annotation.
If the tuple is address only, we need to do the operation in memory.
If the tuple is address-only, we'll get much better code if we emit into a single buffer.
If the tuple pattern had a label for the tuple element, it must match the label for the tuple type being matched.
If the tuple pattern has a single element, we can reduce it to a paren pattern.
If the tuple we are extracting from only has one non trivial element and we are not extracting from that element, this is an ARC escape.
If the two conformances are normal conformances with locations, sort by location.
If the two conformances come from the same file, pick the first context in the file.
If the two declarations are in different source files, and one of those source files is the source file we're biasing toward, prefer that declaration.
If the two declarations are in the same source file, order based on location within that source file.
If the two declarations occur in the same source file, make sure we get the diagnostic ordering to be sensible.
If the two generic signatures are identical, neither is as specialized as the other.
If the two projections do not equal exactly, return Unrelated.
If the two types are the same they may alias.
If the two values equal, quickly return must alias.
If the two writebacks we're comparing are of different kinds (e.g. ownership conversion vs a computed property) then they aren't the same and thus cannot conflict.
If the type after replacing DynamicSelf with the provided base type is no different, we don't need to perform a conversion here.
If the type also conforms to _ConditionallyBridgedToObjectiveC, use conditional bridging.
If the type binding does not have a type parameter, there's nothing to do.
If the type changed at all, make a note of it.
If the type checker has any newly created functions with the operator's name.
If the type conforms to this protocol, we're covered.
If the type does not actually conform to the protocol, skip this member entirely.
If the type does not bind any generic parameters, return the superclass type as-is.
If the type does not conform to StringLiteralConvertible, it should be ExtendedGraphemeClusterLiteralConvertible.
If the type doesn't guarantee that it has an access function, we might have to use a non-unique accessor.
If the type gets more refined, we need to forget the old value, or else we may end up using a value with a more general type than is known about the stack slot.
If the type has a fixed size, allocate static storage.
If the type has a statically fixed offset, return that.
If the type has no name and no structure name, but is not anonymous, generate a name for it.
If the type hasn't changed and doesn't rely on context, just use the original parameter.
If the type info hasn't been added to the list of types, do so.
If the type involves a type variable, don't cache it.
If the type is 2, check if the binary data is prefixed by its length.
If the type is a block or C function pointer, it must be representable in ObjC.
If the type is a class, try its superclass.
If the type is a singleton aggregate, the field's layout is equivalent to the aggregate's.
If the type is a type variable itself, don't permit the binding.
If the type is a type variable or is dependent, just fill in empty conformances.
If the type is address-only, we need to move or copy the elements into a tuple in memory.
If the type is already materializable, then we're already done.
If the type is complete we can just retrieve it and use it directly.
If the type is dependent, substitute it into our current context.
If the type is fixed-layout, emit a copy of its layout.
If the type is floating-point, then we need to bitcast to integer.
If the type is generic, check whether its generic arguments are also bridged to Objective-C.
If the type is in the same source file, or has a common value witness table exported from the runtime, we can project from the value witness table instead of emitting a new record.
If the type is inout, get the metadata for its inner object type instead, and then set the lowest bit to help the runtime unique the metadata type for this function.
If the type is itself an archetype, we could always potentially bind it to the superclass (via external retroactive conformance, even if the type isn't statically known to conform).
If the type is itself canonical, return it.
If the type is known to be empty, don't actually allocate anything.
If the type is known to have Swift metadata, this is trivial.
If the type is nontrivial, keep the context alive since the field depends on the context to not be deallocated.
If the type is not a function type, then we just return the original type, but we don't check that the Decl is the associated one.
If the type is not an lvalue, this is a no-op.
If the type is not dependent, or we have no generic params, there's nothing to map.
If the type is not dependent, there's nothing to map.
If the type is not generic, we can use a global variable to cache the address of the field type vector for the single instance.
If the type is null, lazily resolve it.
If the type is resilient or generic, see if there's a witness table keyed off the nominal type descriptor.
If the type is right, we're done.
If the type is simple, just print the tuple elements.
If the type is specialized, find the conformance for the generic type.
If the type is specialized, we need to gather all of the substitutions for the type and any parent types.
If the type is trivial, it's always +1.
If the type isn't a leaf type, also check it as an inexact match.
If the type isn't actually dependent, we're okay.
If the type isn't existential, then there is no representation.
If the type isn't fixed, we have to do something dynamic.
If the type isn't fixed-size, check whether we added an emission note.
If the type isn't loadable, the explosion size is always 1.
If the type matches exactly, use it.
If the type obviously has or lacks the trait, emit a constant result.
If the type of the captured argument is trivial, pass the argument as Direct_Unowned.
If the type of the result of the call differs from the type used elsewhere in the caller due to ABI type coercion, we need to coerce the result back from the ABI type before extracting the elements.
If the type of this expression has a type variable or is invalid, overwrite it with ErrorType.
If the type references the type variable, don't permit the binding.
If the type still has parameters, the constrained extension is considered unusable.
If the type to be fixed is an optional type that wraps the type parameter itself, we do not want to go through with the assignment.
If the type variable can't bind to an lvalue, make sure the type we pick isn't an lvalue.
If the type variable is fixed, look no further.
If the type variable is in the list of member type variables, it is fully bound.
If the type variable isn't one for which we should be looking at the bindings, don't.
If the type variables are the same, do nothing.
If the type was imported from Clang, check whether it is representable in the requested language.
If the type was previously uninteresting, but the new layout makes it interesting, mark it as pointer followable.
If the type wasn't optional, an array, or unowned, complain.
If the type witness was unchanged, just copy it directly.
If the type-scanners has non-conservative scanners, we must treat all unknown type-index allocations in the heap as roots.
If the type-specific test(s) failed, fallback on actually calling the tvCoerceParamTo*() helper
If the typed pattern was propagated from somewhere, just walk the subpattern.
If the typedef / should be skipped, returns the underlying declaration that the typedef / refers to -- this declaration should be imported instead.
If the typeloc has a valid location, use it to end the range.
If the types already match, there's nothing to do.
If the types are already equivalent, we don't have to do anything.
If the types are equal, the answer is simple.
If the types are equivalent, there's nothing more to do.
If the types are identical and there was no optionality change, we're done.
If the types are obviously equivalent, we're done.
If the types are the same, forward the existing value.
If the types disagree, but we're comparing a non-void, single-expression closure result type to a void function result type, allow the conversion.
If the types don't match, this is a different constructor with the same selector.
If the types exactly match, this is easy.
If the types have unbound generic arguments then we don't know the possible range of the type.
If the types match, then it must not be the contextual type that is the problem.
If the types on either side of a cast do not have / equivalent reference counting semantics, then the source and destination / values are not RC identical.
If the unbound decl hasn't been validated yet, we have a circular dependency that isn't being diagnosed properly.
If the uncurrying/unbridging process changed the type, re-check the cache and add a cache entry for the curried type.
If the underlying declaration is an Objective-C type parameter, pull the corresponding generic type parameter from the imported class.
If the underlying expression was a read-only subscript, diagnose that.
If the underlying objects are not aliased, the projected values are also not aliased.
If the underlying type is a class, see if it is an enum and get that.
If the underlying type is private, don't print it.
If the underlying type was validated, we're done.
If the uninitialized array is only written into then it can be removed.
If the unreachable is preceded by a no-return apply inst, then it is a non-failure exit BB.
If the unwrapped from/to types are equivalent, this isn't a real downcast.
If the upcast is used by a class_method + apply, then this is a call of a superclass method or property accessor.
If the upcast is used by a ref_element_addr, then it is an access to a base ivar before super.init is called.
If the usable space in the chunk is smaller than PaddingSize, no TombHash is needed, because we can tell that the chunk is used up.
If the use is a DSI, add it to our memory analysis so that if we can chop up allocas, we also chop up the relevant dealloc stack insts.
If the use is a conditional branch/switch then look for an incoming edge that is dominated by DominatingSuccBB.
If the use is a load, keep track of it for splitting later...
If the use is a struct_element_addr, add it to the worklist so we check if it or one of its descendants escape.
If the use is a tuple_element_addr, add it to the worklist so we check if it or one of its descendants escape.
If the use is dominated we can replace this use by the value flowing to DominatingSuccBB.
If the user chose not to close, do *not* let the default window proc handle the message.
If the user dynamically checks for correct type sizes in the generic function, a specialized function can contain the (not executed) bitcast with mismatching fixed sizes.
If the user error handler decides to allow execution to continue, we return the empty string.
If the user error handler throws an exception, discard the uninitialized value(s) at the top of the eval stack so that the unwinder doesn't choke
If the user explicitly wrote the incorrect name, complain.
If the user explicitly wrote the wrong name, complain.
If the user has specified an SDK, use it.
If the user is a load or a store and we can prove that it does not access the object then return true.
If the user is a tuple_extract, just substitute the right value in.
If the user is extracting a trivial field of an aggregate structure that does not overlap with the ref counted part of the aggregate, we can ignore it.
If the user is trying to create a breakpoint where a disabled breakpoint already exists, then re-enable the original breakpoint.
If the user typed anything other than tab, reset the completion state.
If the value already has a name, honor that.
If the value being stored is a call to self.init()...
If the value being substituted is an enum, check to see if there are any switches on it.
If the value has a common size and alignment, use specialized value witnesses we already have lying around for the builtin types.
If the value is 0, the diagnostic prints 'foo'.
If the value is IUO, but the desired formal type isn't optional, force it.
If the value is a (possibly optional) ObjC block passed into the entry point of the function, then copy it so we can treat the value reliably as a heap object.
If the value is a specialized object type and we don't have to constrain a guard to get it, we can avoid emitting runtime checks if we know the result is true.
If the value is always directly accessed from this context, do it.
If the value is an ObjC tagged pointer, pass it through verbatim.
If the value is available, use it, otherwise emit a load of the value.
If the value is less optional than the desired formal type, wrap in an optional.
If the value is live only in part of the predecessor blocks we have to split those predecessor edges.
If the value is not definitively initialized, emit an error.
If the value is taken from a default argument, ignore it.
If the value isn't address-only, go ahead and load.
If the value type cannot be bridged, we're done.
If the value's type source is non-null and not a FramePtr, it's a real value that was killed by a Call.
If the var is marked final, then so is the getter.
If the var pattern has no variables bound underneath it, then emit a warning that the var/let is pointless.
If the variable declaration is for a 'self' parameter, it may be because the self variable was reverted whilst validating the function signature.
If the variable has no initial value, emit a mark_uninitialized instruction so that DI tracks and enforces validity of it.
If the variable has no storage, it never needs an initializer.
If the variable is already unnamed, ignore it.
If the variable is computed, ignore it.
If the variable is defined in a pattern in an if/while/guard statement, see if we can produce a tuned fixit.
If the variable is empty in all resilience domains that can see it, don't actually emit a symbol for the global at all, just return undef.
If the variable is immutable, we can bind the value as is.
If the variable is implicit, ignore it.
If the variable isn't public, or has already been defined in this TU, then it definitely doesn't need a GOT entry, and we can relative-reference it directly.
If the variable was invalid, ignore it and notice that the code is malformed.
If the version range for the current TRC is completely contained in the range for the spec, then a version query can never be false, so the spec is useless.
If the warning couldn't be suppressed, don't warn.
If the weak references are equal to the normal references, the instruction is not necessary and can be removed (if we make the required changes to each instruction that used it weakly).
If the whole enum is indirect, we lower it as if all payload cases were indirect.
If the whole pattern is implicit, the user didn't write it.
If the witness actually explicitly provided that accessor, then great.
If the witness and the potential witness are not the same, there's no ordering here.
If the witness is 'throws', the requirement must be.
If the witness is a designated or required initializer, we can't move it to an extension.
If the witness is a free function, consider the self argument uncurry level.
If the witness is a free function, drop it completely.
If the witness is a free function, there is no Self type.
If the witness is dynamic, go through dynamic dispatch.
If the witness is invalid, record that and stop now.
If the witness is stored property accessor, it may not be synthesized yet.
If the witness is within a struct or enum, it can be freely moved to another extension.
If the witness is within an extension, it can be moved to another extension.
If the witness table is directly fulfillable from the type, we don't need a cache entry.
If the word preceding the preposition extends the preposition, it will never be dropped.
If the xdebug profiler is attached, ensures we still need it.
If there already is a result, check it for conflict.
If there are FixIt hints introduced into the system, they may well be the reason that this isn't an lvalue.
If there are UnresolvedPatterns floating around after name binding, they are pattern productions in invalid positions.
If there are a different number of argument labels, we're done.
If there are any -verify errors (e.g. differences between expectations / and actual diagnostics produced), apply fixits to the original source / file and drop it back in place.
If there are any / obvious conflicts between the structure of the two types, / returns true.
If there are any BB arguments in the destination, replace them with the branch operands, since they must dominate the dest block.
If there are any attributes, we are going to parse them.
If there are any errors in doing so, return 'nullptr'.
If there are any path components left, then append them to symlink.
If there are any substitutions for the callee, apply them now.
If there are any such parameters, remember where they start in the substitutions list.
If there are any transparent functions that are deserialized from another module that are now unused, just remove them from the module.
If there are captures, put the placeholder curry level in the formal type.
If there are dead blocks in the SIL function, we might have left invalid blocks in the IR.
If there are enough extra inhabitants for all of the cases, then the size of the enum is the same as its payload.
If there are extra inhabitants, see whether the payload is valid.
If there are extra tag bits, check them.
If there are extra tag bits, set them to zero.
If there are extra tag bits, switch over them first.
If there are extra tag bits, test them first.
If there are factored edges, make a copy of the state (except stacks) in case we need to propagate across factored exits (if it's a PEI).
If there are generic arguments, apply them now.
If there are more callee parameters than arguments it means that the callee is the result of a partial_apply - a thick function.
If there are more callee parameters than arguments it means that the callee is the result of a partial_apply.
If there are more than one input files, we need one extra arg to run.
If there are multiple elements, the pairs of types need to match in size for the coercion to work.
If there are multiple equally-good candidates, we fail.
If there are multiple solutions, try to diagnose an ambiguity.
If there are multiples they will be diagnosed.
If there are no VM frames, we're done.
If there are no abstraction changes, we can just forward normally.
If there are no argument names, our lookup will be based solely on the base name.
If there are no cleanups to run, just return the Dest block directly.
If there are no cleanups to run, this just / returns the dest block.
If there are no constraints remaining, we're done.
If there are no decrements between our ref count inst and terminator, sink the ref count inst into either our successors.
If there are no default ctors for our supertype, we can't do anything.
If there are no disjunctions, we can't solve this system.
If there are no edges to the return block, we never want to emit it.
If there are no elements, just build a parenthesized expression around the closure.
If there are no empty cases, don't need a conditional.
If there are no enumers, there is no prefix to compute.
If there are no extra tag bits, or they're set to zero, then we either have a payload, or an empty case represented using an extra inhabitant.
If there are no inherited protocols, produce null.
If there are no labels, use a null pointer.
If there are no modifiers, buildAttrs() defaults to AttrPublic.
If there are no more hooks attached, clear the blacklist.
If there are no non-default cases, evaluate the subject for side effects and fall through.
If there are no or multiple outputfiles, derive the name from the module name.
If there are no posted constraints or failures, then there was not enough contextual information available to infer a type for the expression.
If there are no prefixes, just dump all the results.
If there are no program arguments, always invoke as normal.
If there are no ref count decrements in between the increment and the terminator of the BB, then we can sink the retain out of the switch enum.
If there are no requirements left, we're missing requirements.
If there are no rows remaining, then we fail.
If there are no substitutions, return an empty array.
If there are no tokens, there is nothing to convert.
If there are no type variables in the fixed type, there's nothing to do.
If there are no uses of the catch block, just drop it.
If there are no valid captures left, then stop.
If there are no valid overloads, give up.
If there are no values available at this load point, then we fail to promote this load and there is nothing to do.
If there are non-case-label statements at the start of the switch body, raise an error and recover by parsing and discarding them.
If there are non-scalar initializers (i.e. 86sinit methods), run them now.
If there are null bytes in the path, treat it as the empty string
If there are only two interesting cases, do a cond_br instead of a switch.
If there are other users to the box then bail out.
If there are other users to the box value address then bail out.
If there are remaining call sites, apply them to the result function.
If there are still args that haven't been accounted for, they have either been ...
If there are substitutions, add them now.
If there are substitutions, add them, always at depth 0.
If there are substitutions, add them.
If there are substitutions, specialize the generic accessor.
If there are substitutions, verify them and apply them to the callee.
If there are such decrements, move the retain right before that decrement.
If there are too many highlight lines, truncate spew by setting lastLine ...
If there aren't any arguments, then it can't destroy locals -- even if the call is to extract(), there's no argument, so it won't do anything.
If there aren't any candidates, we're done.
If there aren't any coverage maps, there's nothing to emit.
If there aren't any generic parameters at this level, we're done.
If there aren't any more inputs, we can use a default argument.
If there aren't, then just delete the block - it / turns out to have not been needed.
If there exist more than one typecheck of the same variable, they must be compatible with each other (i.e. their intersection must not be Bottom).
If there hasn't yet been a value stored here, we can use the adjusted value directly.
If there is 'else' logic, then emit it.
If there is a "/*" in the middle of an identifier token, it starts a multi-line comment.
If there is a "//" in the middle of an identifier token, it starts a single-line comment.
If there is a ':', this is a dictionary type.
If there is a Clang declaration, use it's runtime name.
If there is a Phi definition in this block:
If there is a basic block argument list, process it.
If there is a class, use it.
If there is a cleanup for the optional value being tested, we can disable it on the failure path.
If there is a code completion token right after the '(', do a special case callback.
If there is a comma after the expression, parse a list of let/var bindings.
If there is a conflict, complain.
If there is a context argument, it comes after the polymorphic arguments.
If there is a continuation block, we should branch to it if the current point is reachable.
If there is a declared result type, check that as well.
If there is a default literal type for this protocol, it's a potential binding.
If there is a didSet, it will take the old value.
If there is a duplicate diagnostic this can be used for better error presentation.
If there is a first argument for a function, include its text along with the base name's text.
If there is a fix associated with this constraint, apply it before we continue.
If there is a hint decl that specifies where to add this, just link into the chain immediately following it.
If there is a lookahead token, return that.
If there is a loop bypass edge, add the loop length to the loop pre-pre- header instead to the header.
If there is a name, check whether the kind of name is appropriate.
If there is a name, print it.
If there is a non-local / successor edge path that points to a dead edge in Parent, mark the / descendant non-local successor edge as dead.
If there is a parent context, add the generic parameters and requirements from that context.
If there is a parser diagnostic in a line, ignore diagnostics in the same line that we got from the semantic pass.
If there is a parser frame, put it at the beginning of the backtrace.
If there is a potential modification in the current block, scan the block to see if the store or escape is before or after the load.
If there is a repeated letter at the back, drop that second instance of that letter and try again.
If there is a returns_nonnull attribute, non-null.
If there is a same-type requirement to be added for the given nested type / due to a superclass constraint on the parent type, add it now.
If there is a setter, check that the property it implies matches that of the getter.
If there is a signal, it is passed as an interrupt to the proxy in an attempt to get other threads in the sandbox to stop.
If there is a single constraint, this isn't a disjunction at all.
If there is a single removal range that covers everything but the trailing closure at the end, also zap the parentheses.
If there is a single viable candidate, form a substitution for it.
If there is a store (that must come after the phi), use its value.
If there is a store in the current block, scan the block to see if the store is before or after the load.
If there is a subpattern, push the enum element type down onto it.
If there is a superclass bound, then obviously it must be a class.
If there is a superclass, it is a direct supertype.
If there is a timeout set, create a TimeoutTimer
If there is a toString() method, use it (via ConvObjToStr) to turn the object into a string, and then do a string comparison.
If there is a trailing slash, remove it
If there is a transition from 1 to 0, that means we have a partial merge, which means the release can NOT be hoisted to the current block.
If there is a transition from 1 to 0, that means we have a partial merge, which means the retain can NOT be sunk to the current block, so place it at the end of the predecessors.
If there is a type that we're expected to convert to, add the conversion constraint.
If there is a user error handler it will be invoked, otherwise the default error handler will be invoked.
If there is a value associated with this setting in the hdf config
If there is a where clause on this let/var specification, parse and remember it.
If there is a witness, record it if it's within this context.
If there is already an argument label, do nothing.
If there is already an internal breakpoint set when a StepDestination is constructed then it will not remove the breakpoint when it is destructed.
If there is an "Options" page, the "Options" button exists, and it hasn't been suppressed, then enable the button.
If there is an 'else' block, we make a new one, otherwise it is our continue block.
If there is an 'objc' attribute with a name, use that name.
If there is an address in play, then we / can initialize the address elements of the tuple though.
If there is an alternate declaration and the name matches, report this result.
If there is an alternate declaration for this member, add it.
If there is an alternate declaration, also look at it.
If there is an argument, apply it.
If there is an entry to update, do so.
If there is an error getting to / the specified input, this returns a null Type.
If there is an error with fixits it writes the fixits as edits in json / format.
If there is an error, don't do our splicing trick, just return the Decl and the status for reporting.
If there is an existing AST and the offset can be mapped back to the document snapshot that was used to create it, then use that AST.
If there is an existing cast with the same arguments, indicate we cannot improve it.
If there is an existing subscript operation, we're done.
If there is an existing subscript within this context, we cannot create a new subscript.
If there is an expr-call-suffix, parse it and form a call.
If there is an inout difference in self, load the inout self parameter.
If there is an interface type, it shouldn't have any unresolved dependent member types.
If there is an outstanding Ctrl-C from the client, go ahead and break now.
If there is an unbound generic type involved in the cast, bail.
If there is an unconditionally executed call to the same array we can still hoist it.
If there is an upgrade link, check for update on a background thread
If there is any more work left to do, setup a new frame ready to execute the pseudomain.
If there is any such data, it will be uninitialised.
If there is just some horizontal whitespace before the next token, its addition is probably incorrect.
If there is more than one argument yet none of them have names, we're done.
If there is more than one viable system, attempt to pick the best solution.
If there is new temporary for this argument, use it instead.
If there is no ID, use session module to create one
If there is no argument to the constructor function, then just pass in the empty tuple.
If there is no base name, there is nothing to find.
If there is no base, or if the base isn't being used, it is settable.
If there is no colon, we have a nullary selector.
If there is no comma then we're done.
If there is no conflict, then we're ok.
If there is no contextual type available, tell typeCheckExpression that it is ok to produce an ambiguous result, it can just fill in holes with UnresolvedType and we'll deal with it.
If there is no continuation block, it's because we constant-folded the branch.
If there is no corresponding argument in the first parameter list...
If there is no corresponding parameter, there is nothing to omit.
If there is no current file, print the desired range of eval code or give an error message if the debugger is not currently performing an eval command.
If there is no explicit 'required', print one.
If there is no false code, the continuation block has a use because the main condition jumps directly to it.
If there is no first argument, create one for this purpose.
If there is no function body, just suggest removal.
If there is no getter, there's nothing we can do.
If there is no initializer for the new variable, don't auto-print it.
If there is no log file open then open a new one.
If there is no necessary column, just emit the first row.
If there is no next available integer key, no value is appended.
If there is no next available integer key, this function does not append a value.
If there is no nominal type in the expr, try to find nominal types in the ancestors of the expr.
If there is no opportunity on the signature, simply return.
If there is no result computed for this subelement, record it.
If there is no return type constraint, or if the return type constraint is a typevar, or if the top of stack is the same or a subtype of the type constraint, then this is a no-op.
If there is no subinitialization, then we are done matching.
If there is no such enclosing declaration, then there is nothing to check.
If there is no type, parse the simple form.
If there is no varEnv, the enclosing file was called by fb_autoload_map, which wants a local scope.
If there is no way a location can have an upward visible store at a particular point in the basic block, we do not need to turn on the genset and killset for the location.
If there is not a current instance, cc trumps cls.
If there is only 1 child and we cannot strip off any projections, that means we need to create an aggregation.
If there is only one case (the fall-through case) then we're done
If there is only one list of substitutions, return it.
If there is only one possible alternative for this method, try to devirtualize it completely.
If there is, project and destroy it.
If there isn't a 'self' type, we're not going to try to access this anyway.
If there isn't one, we always have to run the job, but it doesn't affect any other jobs.
If there might be replacement constraints, get them now.
If there multiple regions starting at the lowest bytecode offset, pick the one with the largest profile weight.
If there numerous viable matches, throw out the non-viable matches and try to find a "best" match.
If there should be one but it's not present or can't be loaded, we have to run all the jobs.
If there was a 'class' requirement, mark this as a class-bounded protocol.
If there was a - sign, negate the value.
If there was a conflict on the first argument, and this was the first argument and we're not stripping error suffixes, just give up completely on error import.
If there was a conflict stripping an error suffix, adjust the name but don't change the base name.
If there was a foreign error convention, consider it.
If there was already a class declared with DefClass, check if it's compatible.
If there was an argument, apply it.
If there was an error type checking this argument, then we're done.
If there was an error while automatically generating the layout for this underlying type, it is stored here until they are all reported.
If there was an error, ignore it and just let the exec fail.
If there was an explicit arg for this, claim it.
If there was an interped FCallAwait, and we return via the jit, we need to deal with the suspend case here.
If there was an invalid witness that might have worked, just suppress the diagnostic entirely.
If there was more than one uppercase letter, this is an acronym.
If there was no default branch in SIL, use an unreachable branch as the default.
If there was no default branch in SIL, use the unreachable branch as the default.
If there was no entry for that element, this function does not remove it, and may or may not cow.
If there was no fixit specification, but some were produced, add a fixit to add them in.
If there was no name specified for this block, just create a new one.
If there was no previous value, start from zero.
If there was no such argument, leave the argument unf
If there was no type declaration, synthesize one.
If there was no type specified, and if we're not looking at a ClosureExpr, then we have a parse error (no type was specified).
If there was only one no-payload case, or the payload is empty, we already branched in the first switch.
If there were any non-viable inferred associated types, don't infer anything from this witness.
If there were any unsatisfied requirements, check whether there are any near-matches we should diagnose.
If there were any uses of instructions in the duplicated loop entry check block rewrite them using the ssa updater.
If there were call for a 'touch' operation, then the detachLocked() call would need to be omitted.
If there were forward jumps that referenced this Label, compare the the eval stack from the first foward jump we saw with the current eval stack
If there were no conflicts, we're done.
If there were no local conflicts, we're done.
If there were no local unsatisfied requirements, we're done.
If there were no replacements (i.e., matches) return original subject(s)
If there were no signature collisions, there is nothing to do.
If there were no spare bits in this part, it has nothing to add.
If there were no unsatisfied dependencies, we're done.
If there will be an ambiguity when referring to the method, introduce a coercion to resolve it to the method we found.
If there's a Clang node, see if it comes from an explicit submodule.
If there's a catch trace for this block, return it.
If there's a collision, compare by cost, ignoring higher-cost entries.
If there's a comma, keep parsing the list.
If there's a custom scanner for the entire object, list of types to guard on.
If there's a data pointer required, but it's a swift-retainable value being passed as the context, just forward it down.
If there's a data pointer required, grab it and load out the extra, previously-curried parameters.
If there's a default case it will be emitted immediately after this.
If there's a foreign error parameter, fill it in.
If there's a listener, notify it that we've applied the solution.
If there's a new case value in the module file, ignore it.
If there's a remaining count on this cmd then we want it left installed in the proxy.
If there's a semantic conversion necessary, do a load then assign.
If there's a single best solution, keep only that one.
If there's a superclass constraint that conforms to the protocol, add the appropriate same-type relationship.
If there's a trailing arrow, parse the rest as the result type.
If there's actually any reference to these types, they'll be reported as the pseudo-type.
If there's already an entry, use that.
If there's also an existing GOT-equivalent entry, rewrite it too, since LLVM won't recognize a global with bitcasts in its initializers as GOT- equivalent.
If there's an abstraction difference, we always need to use the get/set pattern.
If there's an exact type match, we're done.
If there's an explicit name, just use that.
If there's data in the read buffer, then we're clearly not EOF
If there's exactly one register argument slot left, the whole TypedValue goes on the stack instead of being split between a register and the stack.
If there's just an r_paren, consume that.
If there's just one element, we can always coerce as a scalar.
If there's no Objective-C runtime, we have to do this ourselves.
If there's no UMSGPAT_PART_TYPE_ARG_TYPE right after a UMSGPAT_ARG_TYPE_SIMPLE argument, then the pattern is broken.
If there's no abstraction difference, it's just returned directly.
If there's no abstraction difference, that can just be in-place into the outer result address.
If there's no abstraction difference, we can just materialize as normal.
If there's no abstraction difference, we just need to store.
If there's no abstraction difference, we're done.
If there's no cache variable, just perform the direct access.
If there's no check for the current platform, this condition is trivially true.
If there's no code in 'a', then the entry must be in 'aCold'
If there's no continuation block, it's because the condition was folded to false.
If there's no continuation block, it's because the condition was folded to true.
If there's no fixed type info, we rely on the runtime anyway, so there's nothing to verify.
If there's no fp, we've already executed a RetCtrl or similar, so there's no reason to try to jump anywhere now.
If there's no interference, we can kill this store.
If there's no message, but this is specifically an imported "unavailable in Swift" attribute, synthesize a message to look good in the generated interface.
If there's no new_x, but lhs.x() is nontrivial, then rhs.x() is not equal to it and also nontrivial.
If there's no reader, we've found all there is to find.
If there's no representation difference, we're done.
If there's no suffix, the scanner is wrapped within a for loop which loops over the entire allocation given by the size parameter.
If there's no super conformance, we're done.
If there's no superclass, return a null type.
If there's no superclass, there's nothing to inherit.
If there's no toString() method, than the object is always greater than the string.
If there's no type representation, there's nothing to revert.
If there's no type yet, come back to it later.
If there's nothing but whitespace before the cursor, indent to the next 2-character tab stop.
If there's one that's a complete definition, use that.
If there's only 1 byte of meaningful bits in the mask, we can adjust the pointer offset and use testbim instead.
If there's only one case to test, do a simple compare and branch.
If there's only one case, do a cond_br.
If there's only one generic param, mangle nothing.
If there's only one no-payload case, or the payload is empty, we can jump directly to cases without more branching.
If there's only one no-payload case, we can jump to it directly.
If there's only one preresolved ClassInfo, we can give out a specific res::Class for it.
If there's only one protocol, the existential type name is the protocol name.
If there's only one stored property, we have the layout of its field.
If these are both function types, then they are near misses.
If these are simply redeclarations, they do not conflict.
If these are the first bindings, or they are better than what we saw before, use them instead.
If these checks were performed already, no need to repeat them.
If these destructors call restore_*_handler() they can trigger a pop_back() on the vector resulting in double destruction.
If these functions are called we cannot elide the inlined frame.
If these functions are persistent, it's possible another thread could call one of those functions before we define the closures, and try to use closure classes that don't exist yet.
If these get thrown away, breakpoints that are temporarily disabled will suddenly fire again, which is not what we want to happen if we create a new breakpoint or just even list breakpoints.
If these style options are changed, compute_hhvm_argc() will need to be updated appropriately
If they are equal, merge their addresses and their scan field anded together.
If they are still different, fail.
If they are textually the same, don't show them.
If they aren't needed, they carry a set of instructions that must be removed if the instruction that produces the stack value is also removable.
If they fail, they fail inside the conversion function.
If they have the same specialized tag, then since isect is equal to m_bits, the stagBits must be part of the intersection or be BEmpty.
If they have the same stag, try to merge them with unionData.
If they weren't, we'd have a chicken-egg problem.
If they're ambiguous, they're ambiguous.
If they're both numeric, the result is at least numeric.
If things fail, we can revert the types back to their original state.
If this DeclContext is a NominalType declaration or an / extension thereof, return the NominalTypeDecl.
If this IR program contains a return sequence, it might DecRef the frame context below one (possibly freeing it).
If this Objective-C class has a supertype, import it.
If this Pattern binding was not supposed to have an initializer, but it did, diagnose this and remove it.
If this SILValue was blotted, there is nothing left to do, we found some sort of conflicting definition and are being conservative.
If this VarDecl is nested inside of a CaptureListExpr, remember that fact for better diagnostics.
If this VarDecl is represented as an address, emit it as an lvalue, then perform a load to get the rvalue.
If this access is for a read, we can just call the getter.
If this access stores something of non-trivial type, then keep track of it for later.
If this adjacency is last in the vector, just pop it off.
If this already had an entry in the capture list, make sure to merge the information together.
If this ambiguous store is only of trivial types, then we don't need to do anything special.
If this application is part of an operator, then we allow an implicit lvalue to be compatible with inout arguments.
If this argument binds to the same parameter as the previous one or to a later parameter, just update the parameter index.
If this argument from a different BB, then jump-threading may require too much code duplication.
If this argument is completely dead, delete this argument and return ArgOffset.
If this argument is live, but we cannot optimize it.
If this argument is not ABI required and has no uses except for debug instructions, remove it.
If this argument is not dead and we can explode it, add 's' to the mangling.
If this argument is not dead and we did not perform SROA, increment the offset and return.
If this argument is promoted, it is a box that we're turning into an address because we've proven we can keep this value on the stack.
If this argument was completely removed, don't emit any Fix-Its for it.
If this assert fires, it means we have probably synthesized an implicit declaration without location information.
If this assert fires, we're trying to put things on the stack in a catch trace that the unwinder won't be able to see.
If this assert is failing, you may have forgotten a sync point somewhere
If this attribute doesn't apply to the active platform, we're done.
If this base *is* the destination, go ahead and start building the path into ReversePath.
If this basic block does not define a value we can just use the value live at the end of the block.
If this becomes a performance problem, we could perhaps have ASTWalker visit the element name as well.
If this binding is one of multiple patterns, each individual binding will just be let, and then the chosen value will get forwarded into a var box in the final shared case block.
If this bit is set, that means this basic block stops retain / or release of the refcounted root to be moved across.
If this bit is set, that means this is potentially a retain / or release that can be sunk or hoisted to this point.
If this block branches to a block with a single predecessor, then merge the DestBB into this BB.
If this block has no predecessors then nothing dominates it and the instruction is unreachable.
If this block is a catch block, it must have at most one predecessor.
If this block was changed and it now consists of only the unreachable, make sure we process its predecessors.
If this can't possibly be a contextual keyword, then this identifier is not interesting.
If this candidate has no arguments, then we're a match.
If this candidate otherwise matched but was marked unavailable, then treat it as unavailable, which is a very close failure.
If this case can only have one predecessor, then merge it into that predecessor.
If this case of the switch is not matched up with this BB, skip the case...
If this catch clause is reachable at all, it's because a function parameter throws.
If this changes the in-state for any of them, enqueue them for (re)processing.
If this changes, please change PrintAsObjC as well.
If this changes, then this will need to specialize on sub object types instead.
If this check is reachable via success, failure and unknown at the same time, then we don't know the outcome of the dominating check.
If this class doesn't use Swift-native reference counting, use objc_release instead.
If this class had the 'requires_stored_property_inits' attribute, diagnose here.
If this class has a superclass, we set up self as a box.
If this class has designated initializers, everything it imports is a convenience initializer.
If this class has no formal superclass, then its actual superclass is SwiftObject, i.e. the root class.
If this class has the same func at the same method slot we're good to go.
If this class needs an implicit constructor, add it.
If this class requires all of its stored properties to have in-class initializers, diagnose this now.
If this class was defined in Objective-C, perform the lookup based on the Objective-C class.
If this collection is an OuterHandle, then we need to do a full check on this array for things like circularity.
If this comes from an inner element, move the appropriate inner element values over.
If this comparison is for the purpose of trying to merge two indexed type together (see below), skip comparing certain fields.
If this compilation unit entirely lies within the begin/end range, specify a begin parameter of "0", which will stop printDIE() from doing range checks (which is more efficient).
If this constructor overrides another constructor, mark it as such.
If this constructor was imported, we don't need the initializing constructor to be emitted.
If this containment cannot be guaranteed, we say the reference is not available.
If this conversion will cause a function conversion, score it as worse.
If this decl context is a plain old serializable decl, queue it up for normal serialization.
If this decl in the result list isn't a close match, ignore it.
If this decl is associated with a swift_newtype typedef, return it, otherwise null
If this decl is invalid, mark any parsed accessors as invalid to avoid tripping up later invariants.
If this declaration context came from source, there's nothing to do here.
If this declaration has the swift_private attribute, prepend "__" to the appropriate place.
If this declaration is a function which goes into a vtable, then it's symbol must be as visible as its class.
If this declaration is already in the lookup table, don't add it again.
If this declaration is in a class but not marked final, then it is always dynamically dispatched.
If this declaration isn't from a source file, don't check it.
If this declaration shouldn't be visible, don't add it to the list.
If this designated initializer wasn't overridden, we can't inherit.
If this element comes from the sub-expression, we've already analyzed it.
If this element has a label, parse it.
If this element is not required, don't fill it in.
If this element is resiliently- or dependently-sized, record that and configure the ElementLayout appropriately.
If this ends up not the case for some reason, we can consider adding escaping for '##'.
If this entity was introduced after the minimum platform version, it's availability can only be determined dynamically.
If this entity was obsoleted before or at the minimum platform version, consider it obsolete.
If this entry has a conformance associated with it, note that.
If this entry is synthesized or implied, scan to determine whether there are any explicit better conformances that make this conformance trivially superseded (and, therefore, no worth recording).
If this entry was superseded, move on.
If this ever changes, this implementation will need to be architecture-dependent (and the sizeof* routine will probably need to take a TCA).
If this expression is already typechecked and has an i1 type, then it has already got its conversion from Boolean back to i1.
If this extension shows up in the list of extensions not yet included in the lookup table, there's nothing to do.
If this fails (picked up above) we advance to the next character.
If this fails, it's because we didn't lay out padding correctly.
If this frame had its return address smashed by the debugger, the real catch trace is saved in a side table.
If this function does not have a caller in the current module.
If this function fails, close the mcrypt module to prevent crashes when further functions want to access this resource
If this function has a self parameter, make sure that it has a +0 calling convention.
If this function has too many basic blocks or too many locations, it may / take a long time to compute the genset and killset.
If this function is a constructor or destructor, bail.
If this function is a method, we found our result.
If this function is associated with the target class, go ahead and emit the witness offset variable.
If this function is executing then valOut was already decrefed during iter_next_mixed_impl.
If this function is generic or is within a generic type, it should have an interface type.
If this function is not fragile, don't do anything.
If this function is part of the caller's scope length take the caller's scope length.
If this function maybe called indirectly, e.g. from virtual table do not function signature specialize it, as this will introduce a thunk.
If this function returns it means the process is running again.
If this function returns true for an operand, then the register allocator may give it an XMM register, and the instruction will store the whole 16 bytes into memory.
If this generic parameter has an archetype, use it as the concrete type.
If this global is internal or private, it should be
If this happens again it's a programmer error, so blow up.
If this happens, we produce better diagnostics below by diagnosing this here rather than trying to peel apart the failed conversion to function type.
If this has a PatternBindingDecl parent, use its pattern.
If this has an address, return it.
If this import is specific to some named type or decl ("import Swift.int") then filter out any lookups that don't match.
If this indexed type is always going to be a complete conservative scan, than we're always going to have a non-trivial action for its scanner, so its always pointer followable.
If this indexed type's action is conservative, examine guards (if any) to see if we want to ignore or conserative scan it.
If this inherited type has not been resolved, we depend on it.
If this init is defined inside of the same type (or in an extension thereof) as the let property, then it is mutable.
If this initializer came from a factory method, inherit it as an initializer.
If this initializer is required, add the appropriate attribute.
If this initializer overrides a 'required' initializer, it must itself be marked 'required'.
If this inserts a new instruction, it / returns it, otherwise it returns null.
If this instruction can have no further effects on another instructions, continue.
If this instruction can not read or write any memory.
If this instruction can read memory, we try to be conservatively not to move it, as there may be instructions that can clobber the read memory from current place to the place where it is moved to.
If this instruction defines the base of a location, then we need to invalidate any locations with the same base.
If this instruction does not read or write memory, we can skip it.
If this instruction has side effects, but is inert from a load store perspective, skip it.
If this instruction has side effects, but is inert from a store perspective, skip it.
If this instruction is a post dominating release, skip it so we don't pair it up with anything.
If this instruction is a skip-barrier end the scan.
If this instruction is in a dead region, don't report the error.
If this instruction is not a release, skip it...
If this instruction is not a retain_value, there is nothing left for us to do...
If this instruction is unrelated to the element, ignore it.
If this instruction is unrelated to the memory, ignore it.
If this instruction traps then it must have side effects.
If this instruction was a barrier then we can't sink anything else.
If this is "db", return the parent database.
If this is 'unowned', check to see if it is valid.
If this is 0b10XXXXXX, then it is a continuation character.
If this is a "high" UTF-8 character, validate it.
If this is a "super." dispatch, we do a dynamic dispatch for objc methods or non-final native Swift methods.
If this is a 'let' initialization for a non-global, set up a let binding, which stores the initialization value into VarLocs directly.
If this is a 'let' value, any stores to it are actually initializations, not mutations.
If this is a 'mayAppear' diagnostic, then we're ok.
If this is a 'self' in a delegating initializer, we only track one bit: whether self.init is called or not.
If this is a 'var' decl, then we're settable if we have storage or a setter.
If this is a CopyAddr, verify that the element type is loadable.
If this is a DEBUG build, use pretty names for the LLVM IR.
If this is a DeclRefExpr found in a random place, it is a load of the vardecl.
If this is a DotSyntaxCallExpr, then the callee is a method, and the argument list of this apply is the base being applied to the method.
If this is a DynamicSelf metatype, turn it into a metatype of the underlying self type.
If this is a FunctionType and we inferred new function attributes, apply them.
If this is a Main source file, determine if we found code that needs to be executed (this is used by the repl to know whether to compile and run the newly parsed stuff).
If this is a ParamDecl for a closure argument that has an Unresolved type, then this is a situation where CSDiags is trying to perform error recovery within a ClosureExpr.
If this is a SIL-only attribute, reject it.
If this is a SILArgument of current basic block, we can split it up to values in the predecessors.
If this is a ValueMetatypeInst, check to see if it's part of a self.init call to a factory initializer in a delegating initializer.
If this is a VarDecl, then add it to our list of things to track.
If this is a basic block argument with a single caller then we know exactly which value is passed to the argument.
If this is a binary operator, relex the token, to decide whether it has whitespace around it or not.
If this is a bottleneck it can be converted into a hash-map
If this is a boxed variable, we can use it directly.
If this is a builtin which might have side effect, but its side effects do not cause reference counts to be decremented, return false.
If this is a button control with the BS_AUTORADIOBUTTON style, try to set its default state to the state of a matching named Burn variable.
If this is a call to a method in a class initializer, then it must be a use of self before the stored properties are set up.
If this is a call to a method or a mutating property access, indicate that.
If this is a call to an unavailable ++ / -- operator, try to diagnose it / with a fixit hint and return true.
If this is a callee that mismatches an expected return type, we can emit a very nice and specific error.
If this is a checkbox control, try to set its default state to the state of a matching named Burn variable.
If this is a class member, mark it final if the class is final.
If this is a class pointer, we need to look through ref_element_addrs.
If this is a class reference type, we have reached end of the type tree.
If this is a class type, it may be the superclass.
If this is a class type, we also have reached the end of the type tree for this type.
If this is a closure expression that did not have any named parameters, generate the anonymous variables we need.
If this is a comparison against nil, then we should produce a specific diagnostic.
If this is a complex leaf closure, there is nothing more we can do.
If this is a computed variable, we don't need to do anything here.
If this is a conditional cast, the result type will always have at least one level of optional, which should become the type of the checked-cast expression.
If this is a constraint inside of the disjunction with a fix, ignore it.
If this is a contextual conversion problem, dig out some information.
If this is a convenience initializer (i.e. one that calls self.init), then let properties are never mutable in it.
If this is a conversion from T to () in a call argument context, it is almost certainly an extra argument being passed in.
If this is a conversion to a type variable used to form an archetype, Then diagnose this as a generic parameter that could not be resolved.
If this is a copy addr that doesn't intersect the loaded subelements, just continue with an unmodified load mask.
If this is a copy of a tuple, we should scalarize it so that we don't have an access that crosses elements.
If this is a copy_addr or store_weak, we just set the initialization bit depending on what we find.
If this is a copy_addr that defines or destroys the value, then remove it.
If this is a copy_addr to a delegating self MUI, then we treat it as a self init for the purposes of testcases.
If this is a copy_addr, make sure we remember that it is an initialization.
If this is a curried call to an integer literal conversion operations, then we can "safely" assume it is readnone (btw, yes this is totally gross).
If this is a debugger function, suppress 'try' marking at the top level.
If this is a decl that we have an lvalue for, produce and return it.
If this is a declaration with generic function type, build a specialized reference to it.
If this is a declaration without an initializer, reject code if uninitialized vars are not allowed.
If this is a defer body, use the parent name.
If this is a deinit, we're done searching.
If this is a delegating initializer, collect uses specially.
If this is a derived class init method for which stored properties are separately initialized, track an element for the super.init call.
If this is a derived class init method, track an extra element to determine whether super.init has been called at each program point.
If this is a derived class, we may have to do a load of the 'self' box to get the class reference.
If this is a different swift_allocObject than we started with, then there is some computation feeding into a size or alignment computation that we have to keep...
If this is a direct reference to a vardecl, it must be a let constant (which doesn't need to be loaded).
If this is a direct reference to underlying storage, then this is a capture of the storage address - not a capture of the getter/setter.
If this is a direct store in a "willSet", we reject this because it is about to get overwritten.
If this is a direct/devirt method application, check the location info.
If this is a discarded foreign static 'self' parameter, force the argument and discard it.
If this is a failable ctor, then we actually jump to the failure epilog to keep the invariant that there is only one SIL return instruction per SIL function.
If this is a failable initializer, project out the payload.
If this is a failing lookup, it has no viable candidates here.
If this is a final member and isn't overriding something, we don't need to add it to the vtable.
If this is a final use along this path, we don't need to change any of the args.
If this is a forbidden template (and forbidden template checking has been enabled), check if any of the template's type parameters are interesting.
If this is a foreign thunk, it always has the foreign calling convention.
If this is a function at global scope, it may close over a global variable.
If this is a function conversion that discards throwability or noescape, emit a specific diagnostic about that.
If this is a get+mutableAddress property, synthesize an implicit setter and record what we've got.
If this is a get+mutableAddress property, synthesize the setter body.
If this is a getter/setter for a funcdecl, ignore it.
If this is a global imported as a member, record is as such.
If this is a global variable, force the accessors to be serialized.
If this is a global variable, initialize it without allocations or cleanups.
If this is a label on a loop/switch statement, consume it and pass it into parsing logic below.
If this is a let variable we're initializing, remember this so we don't allow reassignment.
If this is a let with an initializer or bound value, we only need a buffer if the type is address only.
If this is a let-param whose type is a type variable, this is an untyped closure param that may be bound to an inout type later.
If this is a let-value without an initializer, then we need a temporary buffer.
If this is a load expression, we try hard not to actually do the load (which could materialize a potentially expensive value with cleanups).
If this is a load from within an enum projection, we can't promote it since we don't track subelements in a type that could be changing.
If this is a load into a promoted closure capture, diagnose properly as a capture.
If this is a load of self in a struct/enum/protocol initializer, then it must be a use of 'self' before all the stored properties are set up.
If this is a load with a single user that is a return (and optionally a retain_value for non-trivial structs/enums), then this is a return in the enum/struct init case, and we haven't stored to self.
If this is a load with a single user that is a return, then this is a return before self.init.
If this is a load/copy_addr from a struct field that we want to promote, compute the access path down to the field so we can determine precise def/use behavior.
If this is a loop, and depth is one, just allocate a fresh control target, since there are no more entries to delegate to.
If this is a member in a capture list, just say it is unused.
If this is a member of a nominal type, build a reference to the member with an implied base type.
If this is a member of a nominal type, don't allow it to have a name of "Type" or "Protocol" since we reserve the X.Type and X.Protocol expressions to mean something builtin to the language.
If this is a memset/memcpy/memmove *to* the object, we can zap it.
If this is a method application, produce a nice, specific, error.
If this is a method in a protocol, generate it as a protocol call.
If this is a method or enum case member (not a var or subscript), then the uncurry level is 1 if self has already been applied.
If this is a method whose result type has a dynamic Self return, replace DynamicSelf with the actual object type.
If this is a method whose result type is dynamic Self, or a construction, replace the result type with the actual object type.
If this is a method whose result type is dynamic Self, replace DynamicSelf with the actual object type.
If this is a method, then its formal type includes the archetypes of its parent.
If this is a multi-statement closure with no explicit result type, emit a note to clue the developer in.
If this is a mutable 'var', and it was never written to, suggest upgrading to 'let'.
If this is a negative literal in an unsigned type, use a specific diagnostic.
If this is a nested function with a capture list, mark any captured variables.
If this is a new PHI node then it may require additional definitions, so add it to the PQ.
If this is a non-address-only stored 'let' constant, we can capture it by value.
If this is a non-generic local function that does not capture any generic type parameters from the outer context, don't need a signature at all.
If this is a non-present optional requirement, emit a MissingOptional.
If this is a non-take access at plus zero, we can perform a +0 load of the address instead of materializing a +1 value.
If this is a normal expression (not an expr-basic) then trailing closures are allowed, so this is obviously one.
If this is a normal library, you can't have expressions or statements outside at the top level.
If this is a normal variable definition, then we can change 'let' to 'var'.
If this is a parameter explicitly marked 'var', remove it.
If this is a partial application of self, then this is an escape point for it.
If this is a partial store into a struct and the whole struct hasn't been initialized, diagnose this as an error.
If this is a performance impact, we can add a CheckedCastMode::Unchecked.
If this is a potentially-escaping closure expression, start looking for references to self if we aren't already.
If this is a property requirement, check that the static-ness matches.
If this is a property, check if it needs to be exposed to Objective-C.
If this is a property, we accept the match and then reject it below if the types don't line up, since you can't overload properties based on types.
If this is a protocol or protocol composition type, record the protocols.
If this is a random nul character in the middle of a buffer, skip it as whitespace.
If this is a read from a global let variable, map it.
If this is a read-only access to 'let variable' then we can strip away the write access.
If this is a reference to a module, produce an undef value.
If this is a reference to a type, produce a metatype.
If this is a reference to a var, produce an address or value.
If this is a reference type a specialized type, form a TypeExpr.
If this is a regular read-write access then return the computed memory behavior.
If this is a release instruction, it also generates.
If this is a release on a guaranteed parameter, it can not call deinit, which might read or write memory.
If this is a release or dealloc_stack, then remember it as such.
If this is a release right after an allocation of the object, then we can zap both.
If this is a resilient conformance, copy in the rest.
If this is a retain instruction, it also generates.
If this is a root class, use SwiftObject as our formal parent.
If this is a simple "try expr" situation, where the expr is a closure literal, and the next token is a 'catch', then the user wrote try/catch instead of do/catch.
If this is a simple 'let' constant, emit a note with a fixit indicating / that it can be rewritten to a 'var'.
If this is a simple PatternBinding, use its location.
If this is a simple name, we're done.
If this is a simple property access, then we must have a conflict.
If this is a simple variable marked with a 'let', emit a note to fixit hint it to 'var'.
If this is a single-expression closure, convert the expression in the body to the result type of the closure.
If this is a skippable suffix, skip it and keep looking.
If this is a start curly quote, do a fuzzy match of a string literal to improve recovery.
If this is a statement or expression at the top level of the module, Parse it as a child of a TopLevelCodeDecl.
If this is a statement parent, dig the pattern out of it.
If this is a static member, look up any definitions which refer to this member, and pull any additional information out of it.
If this is a static method, get the instance type.
If this is a store *to* the object, we can zap it.
If this is a store to a 'let' property in an initializer, then we only allow the assignment if the property was completely uninitialized.
If this is a subscript, we need to handle the indices in the callback storage.
If this is a sugared type that needs to be folded into a single TypeExpr, do it.
If this is a trailing comma in an object definition, we're in Mode::KEY.
If this is a tuple expression, recursively ignore its elements.
If this is a tuple type, walk into it.
If this is a tuple, it is always recursively flattened.
If this is a type argument, we've fully updated sourceKey.
If this is a typealias, it does not need a witness check.
If this is a use of self before super.init was called, emit a diagnostic about *that* instead of about individual properties not being initialized.
If this is a use, and the type metadata is emitted lazily, trigger lazy emission of the metadata.
If this is a valid identifier continuation, but not a valid identifier start, attempt to recover by eating more continuation characters.
If this is a var in the top-level of script/repl source file, wrap the PatternBindingDecl in a TopLevelCodeDecl, since it represents executable code.
If this is a vardecl with 'inout' type, then it is an inout argument to a function, never diagnose anything related to it.
If this is a variable that was only written to, emit a warning.
If this is a willSet/didSet observing property, record this and we're done.
If this is a willSet/didSet property, synthesize the getter and setter decl.
If this is a zero-parameter initializer with a long selector name, form that selector.
If this is adding a level to an active partial application, advance it to the next level.
If this is an "inout" marker for an identifier type, consume the inout.
If this is an "uninteresting picture" ignore it.
If this is an 'as' pattern coercing between two different types, then it is "useful" because it is providing a different type to the sub-pattern.
If this is an 'is' pattern or an 'as' pattern where the types are the same, then produce a warning.
If this is an (inlined) function scope, the function may not have been created yet.
If this is an ApplyInst, check to see if this is part of a self.init call in a delegating initializer.
If this is an AssignExpr, see if we're mutating something that we know about.
If this is an ExprPattern that isn't resolved yet, do some simple syntactic checks.
If this is an LLVM IR intrinsic, lower it to an intrinsic call.
If this is an OpaqueValueExpr that we've seen a mapping for, jump to the mapped value.
If this is an UnresolvedType in the system, preserve it.
If this is an accessor for something, ignore it.
If this is an accessor, check if the transparent attribute was set on the value decl.
If this is an accessor, don't complain if we would have complained about the storage declaration.
If this is an accessor, use the name of the storage.
If this is an address-only case, get the address of the buffer we want the result in, then cast the address of it to the right type, then emit into it.
If this is an allocation of an unrelated object, just ignore it.
If this is an allocation, try to remove it completely.
If this is an always matching 'is' pattern, then it isn't refutable.
If this is an anonymous namespace, that means any type found in child DIEs will have internal linkage.
If this is an anonymous tag declaration with a typedef name, use that.
If this is an application of a function that cannot be partially / applied, arrange for us to check that it gets fully applied.
If this is an apply instruction and we're in a class initializer, we're calling a method on self.
If this is an argument conversion, handle it directly.
If this is an argument label mismatch, then diagnose that error now.
If this is an argument look up the value in the value map.
If this is an argument, attach it to the current function scope.
If this is an assign, rewrite it based on whether it is an initialization or not.
If this is an assignment into a mutating subscript lvalue expr, then we are mutating the base expression.
If this is an assignment operator, and the left operand is an optional evaluation, pull the operator into the chain.
If this is an authentication failure, let the engine try to handle it for us.
If this is an early release of a class instance, we need to emit a dealloc_partial_ref to free the memory.
If this is an end curly quote, just diagnose it with a fixit hint.
If this is an enum inheritance clause, check for a raw type.
If this is an enum, get its type constraint.
If this is an enumeration, use the first enumerator.
If this is an epilogue release and we are freezing epilogue release simply continue.
If this is an error type, ignore it.
If this is an escaping closure, then any captured decls are also escaping, even if they are coming from an inner noescape closure.
If this is an exact source, and it's an interesting type, add this as a fulfillment.
If this is an expr-basic, then a trailing closure is not allowed.
If this is an implicit TypeExpr, don't validate its contents.
If this is an implicit statement or expression, just skip over it, don't emit a diagnostic here.
If this is an imported CF type, use that name.
If this is an in-parameter, it is like a load.
If this is an init(), explicitly walk the initializer values for members of the type.
If this is an init, we're done searching.
If this is an initialization of only trivial elements, then we don't need to update the bitvector.
If this is an initialization or a normal assignment, upgrade the store to an initialization or assign in the uses list so that clients know about it.
If this is an initialization, or the storage type is trivial, we can just replace the assignment with a store.
If this is an initializer, replace the result type with the base object type.
If this is an inout marker in an argument list, consume the inout.
If this is an operator declaration, handle it.
If this is an operator func decl in a type context, the 'self' isn't actually going to be applied.
If this is an optional chain that isn't chaining anything, and if the subexpression is already optional (not IUO), then this is a noop: reject it.
If this is an out-parameter, it is like a store.
If this is an union, use the first union member.
If this is an unknown instruction, we have more interesting things to consider.
If this is an upcast instruction, it is a conversion of self to the base.
If this is at top-level scope, validate that the members of the overload set all agree.
If this is called in the middle of a flow command we short-circuit the other commands
If this is called we are either in a TIFFs thumbnail or a JPEG where we cannot handle it
If this is caller default initialization, generate the appropriate value.
If this is conversion failure due to a return statement with an argument that cannot be coerced to the result type of the function, emit a specific error.
If this is default initialization, call the default argument generator.
If this is dynamic and isn't overriding a non-dynamic method, it'll always be accessed by objc_msgSend, so we don't need to add it to the vtable.
If this is ever insufficient --- if we have interesting bridging to do to 'self' --- we have the right information to be more exact.
If this is false, then we / do not need to generate the genset or killset, i.e. we can simply do 1 / pessimistic data flow iteration.
If this is final, we can consume the owner (stored as 'base').
If this is in a resolvable scope, diagnose redefinitions.
If this is indexing into a field of 'self', look it up.
If this is just for a read, emit a load into a temporary memory location.
If this is not / specified, any lvalue will be forced to be loaded into an rvalue.
If this is not ARC-inert, do not do anything to it.
If this is not a SILArgument, maybe it is a part of a SILArgument.
If this is not a delegating constructor, emit member initializers.
If this is not a function name, just parse the base name and we're done.
If this is not a no-op, update semantic info.
If this is not a nominal kind and Other is nominal, return false.
If this is not a one iteration data flow, then the forward sets have been computed.
If this is not a php file, check the static and dynamic content caches
If this is not a simple instruction that we can value number, skip it.
If this is not an initialization, copy the value before we translateIt, translation expects a +1 value.
If this is not the case we can safely hoist the call without the retain/releases.
If this is not the case, it is potentially a store into sub-property of a property.
If this is not the first entry in the inheritance clause, complain.
If this is not the only release of the box then bail out.
If this is not the only store into the box then bail out.
If this is not the representative, produce a same-type constraint to the representative.
If this is null, it is probably implicitly generated code, so we'll adjust it.
If this is obviously not the start of a decl, then we're done.
If this is our second, then we bail out, because we don't want to pick one arbitrarily.
If this is part of a call to a witness method for a non-class-bound protocol in a root class, then we could have a store to a temporary whose address is passed into an apply.
If this is testing for one case, do simpler codegen.
If this is the 'self' argument of a non-mutating method in a value type, suggest adding 'mutating' to the method.
If this is the case we have a single block switch_enum loop.
If this is the case, check if there is a specialization available for it already and use this specialization instead of the generic version.
If this is the case, it is possible to try jump-threading along this path.
If this is the case, replace by a simple apply.
If this is the case, then such an indirect subclass would need a dedicated checked_cast_br check to be devirtualized.
If this is the dealloc_stack, just zap the instruction.
If this is the end of string, we are done.
If this is the error parameter, remember it, but don't build it into the parameter type.
If this is the first attribute, and if we are on a simple decl, emit a fixit to move the attribute.
If this is the first call site, use its formal type directly.
If this is the first change we've seen, copy all of the previous elements.
If this is the first documentation comment, save it (because there isn't anything to merge it with).
If this is the first error, complain about the junk tokens in-between but re-sync at the 'in'.
If this is the first error, complain about the missing 'in'.
If this is the first instruction in the block then we are done.
If this is the first instruction in the region, we check inner type eagerly, insert `EndGuards` after the checks, and generate profiling code in profiling translations.
If this is the first match against the sugar type we found, use it.
If this is the first method, use it.
If this is the first requirement, take its name.
If this is the first result we found, record it.
If this is the first time saving state for block, create a new snapshot.
If this is the first time we see this unreachable block, store it along with the folded branch info.
If this is the first time we see this unreachable block, store it along with the noreturn call info.
If this is the first time we've seen a check on this particular SSATmp, the insert will succeed.
If this is the first, and we're using MixedArray, we need to pre-allocate space in the array to ensure the elements dont move during unserialization.
If this is the interesting case, we need to generate a CFG diamond for each element touched, destroying any live elements so that the resulting store is always an initialize.
If this is the last constraint, just pop it off the list and we're done.
If this is the last instruction, handle block transitions.
If this is the name of an LLVM intrinsic, cons up a swift function with a type that matches the IR types.
If this is the only breakpoint on this line, unregister the line
If this is the only context argument we end up with, we can just share it.
If this is the payload case, we're done.
If this is the payload of an enum, and the type is a single-element labeled tuple, treat this as a tuple pattern.
If this is the scalar field, act like we're shuffling the 0th element.
If this is the script-mode file for the module, create a toplevel.
If this is the simple case, then the identifier is both the name and the expression to capture.
If this is the source of the copy_addr, then this is a load.
If this is the start of a get/set accessor, then it isn't a trailing closure.
If this is the state associated with the instruction that we are currently visiting, bail.
If this is the target, we're done.
If this is the top level of 'self' in an init method, we treat each element of the struct as an element to be analyzed independently.
If this is the top level of a 'self' value, we flatten structs and classes.
If this is the top level of a function input list, peel off the ImmediateFunctionInput marker and install a FunctionInput one instead.
If this is the variadic argument, note it.
If this is true, hoisting any loop invariant definition will create uses of SSATmps that span a call on some path to the back edge.
If this is within a namespace, don't infer any name at all, keep it nameless.
If this isn't a "scan-only" indexed type (which can't be pointer followable), and the type was previously un-interesting, make this pointer followable.
If this isn't a function or isn't valid at this uncurry level, treat it as a general mismatch.
If this isn't a protocol member to be given special treatment, just add the result.
If this isn't a tuple or struct, it is a single element.
If this isn't the name of an Objective-C collection, we're done.
If this isn't the protocol we're looking for, continue looking.
If this iterator was set to the _old_ canonical invalid position, we need to update it to the _new_ canonical invalid position after compaction.
If this job or the previous job that ran on this thread have a custom initial document, make sure we do a reset
If this length does not match the / 'DestinationCapacity' this function must be called again with a buffer of / the required length to get a lowercase version of the string.
If this length does not match the / 'DestinationCapacity' this function must be called again with a buffer of / the required length to get an uppercase version of the string.
If this let value has an address, we can handle it just like a single buffer value.
If this line is _longer_ than MAXLINELEN, remember it.
If this list is empty, don't actually bother with a copy.
If this location does have an available value, then clear it.
If this looks like a plausible escape character, recover as though this is an invalid escape.
If this member is a method that is a getter or setter for a property, don't add it into the table.
If this memory object has multiple tuple elements, we need to make sure to test the right one.
If this merge is undefined due to unknown control flow, assume that the empty set is flowing into this block so clear all state and exit early.
If this method comes from Objective-C, ignore it.
If this method is not overridden in the module, there is no other implementation.
If this method is within a protocol...
If this method overrides another method, mark it as such.
If this method returns true, then usesVariableArgumentFunc() must also return true.
If this node /does/ have a parent, make sure that all non-local successors point to a successor in the parent and match whether or not it is dead.
If this node does not have a parent, it should have no non-local successors.
If this node has a parent and that parent is alive...
If this not an identifier, the attribute is malformed.
If this object pointer refers to an Objective-C class (possibly qualified),
If this parameter had an ellipsis, check whether it's the last parameter.
If this parameter is deallocating, emit an unmanaged rvalue and continue.
If this parameter is the foreign error slot, pull it out.
If this pass invalidated anything, print and verify.
If this path is part of the covered path, then continue.
If this piece is all ones, it has no effect.
If this piece is zero, it doesn't affect the comparison.
If this piece is zero, it has no effect.
If this piece is zero, it wipes out the chunk entirely, and we can drop it.
If this pixel is transparent, we want to assign it to the special transparency color index past the end of the palette rather than go through matching / dithering.
If this potential archetype was renamed due to typo correction, complain and fix it.
If this projection is the same as the last projection we processed, just replace all uses of the projection with the load we created previously.
If this prologue has a DV funclet, then generate a translation for the DV funclet right after the prologue.
If this property is in a class or class extension context, add "final".
If this protocol has been deserialized, it already has generic parameters.
If this protocol is class-constrained but not AnyObject, checking its conformance will check the class constraint too.
If this query expression has no queries, we will not introduce a new refinement context.
If this region's entry block is at the entry point for a function, we have some additional information we can assume about the types of non-parameter local variables.
If this requirement has a different name from one we've seen, bail out and let protocol-conformance diagnostics handle this.
If this resolved inherited type is existential, keep going.
If this resolved type is a class, we're done.
If this result is not from the current module, try to get a popularity score for it.
If this satisfied all of the demanded values, we're done.
If this score matches the (possible new) best score, record it.
If this set has support bits, then the reverse map in the state is consistent with it.
If this solution is worse than the best solution we've seen so far, skip it.
If this starts with atomicload or atomicstore, we have special suffixes to handle.
If this starts with atomicrmw, we have special suffixes to handle.
If this starts with cmpxchg, we have special suffixes to handle.
If this starts with fence, we have special suffixes to handle.
If this state is not tracking anything, there is nothing to update.
If this static property was declared by this class, we can get the initial value directly from its value.
If this static property was declared in a parent class, its value will be KindOfUninit, and we'll need to consult the appropriate parent class to get the initial value.
If this static_assert fails, the compiler error will have the real value of sizeof_Class in it since it's in this struct's type.
If this sub-expression is currently being diagnosed, refuse to recheck the expression (which may lead to infinite recursion).
If this succeeds and yields a valid protocol conformance, then keep searching.
If this succeeds, argument A will have no uses afterwards.
If this succeeds, someone raced us to scoping the template.
If this succeeds, the caller will be responsible for clearing it.
If this successor allows for leaks, skip it.
If this swift_name attribute maps a factory method to an initializer and we were asked not to do so, ignore the custom name.
If this table is used instead of the above one, some of the special cases for the NEL character can be taken out of the code.
If this token didn't come from the lookahead store, we need to stash it there
If this token is located at the / beginning of the line, then the location is adjusted to point to the end / of the previous token.
If this triggered a recursive validation, back out: we're done.
If this type alias is a KindOfObject and the name on the right hand side was another type alias, we will bind the name to the other side for this request (i.e. resolve that type alias now).
If this type declaration was not parsed from source code or introduced via the Clang importer, don't add any synthesized conformances.
If this type has no linkage or pseudo-linkage, it matches nothing else, so just retrieve it.
If this type is already immutable, it has no immutable superclass.
If this type is either a bound generic type, or a nested type inside a bound generic type, we will need to fish out the generic parameters.
If this type is parenthesized, remove the parens.
If this type isn't interesting, mark it as if it was explicitly ignored.
If this type supports a UID, enter it to the cache.
If this type variable has a fixed type, skip it.
If this type variable is not the representative of its equivalence class, add it to its representative's set of equivalences.
If this type variable represents a literal, check whether we picked the default literal type.
If this type was mapped to a concrete type, then there are no requirements.
If this type was mapped to a concrete type, then there is no requirement.
If this typedef is merely a restatement of a tag declaration's type, return the result for that tag.
If this typedef name does not contain "Mutable", it has no immutable superclass.
If this unconditional branch has BBArgs, check to see if duplicating the destination would allow it to be simplified.
If this use cannot be analyzed, then abort.
If this use is not an apply inst or an apply inst with substitutions, there is nothing interesting for us to do, so continue...
If this use of a partial_apply is not an apply which uses it as a callee, bail.
If this used by another upcast instruction, recursively handle it, we may have a multiple upcast chain.
If this value is already defined, check it to make sure types match.
If this value is zero, it has nothing to add to the spare bits.
If this value was already defined, check it to make sure types match.
If this value was already defined, it is either a redefinition, or a specification for a forward referenced value.
If this variable has WeakStorageType, then it can be mutated in ways we don't know.
If this variable is a class member, mark it final if the class is final, or if it was declared with 'let'.
If this variable is in the left-hand side, it is fully bound.
If this variable is marked final and has a getter or setter, mark the getter and setter as final as well.
If this was Selector(("selector-name")), suppress, the diagnostic.
If this was a negative number, record that and strip off the '-'.
If this was a single-element tuple expression, reach into that subexpression.
If this was a subscript accessor, try to create a corresponding subscript declaration.
If this was an escaped identifier that need not have been escaped, say so.
If this was an exact match, downgrade it to inaccessible, so that accessible decls that are also an exact match will take precedence.
If this was built with forRethrowsArgument, return the expression.
If this was done in SSA registers, then the value is provided as an argument to the block.
If this was not the last member type, swap it with the last member type.
If this wasn't type checked correctly then don't worry about it.
If this would make the current solution worse than the best solution we've seen already, stop now.
If this_ is non-NULL, then this_ is the current instance and cls is the class of the current instance.
If this_ is non-null AND we could not find a method, try looking up __call in cls's method table
If those types are equivalent, then it doesn't matter which declaration is chosen.
If toType has more elements, it may be larger.
If toType is a NoEscape or NoReturn function type and the expression is a ClosureExpr, propagate these bits onto the ClosureExpr.
If toType is not an enum, handle it like a singleton
If tracing is enabled, we may need to collect a serialized version of the arguments or the return value.
If tracing or profiling are enabled, we need to store end frames as well.
If transferring instructions within the same basic block, no reason to update their parent pointers.
If true, all arrays in memory are considered to be unsafe.
If true, it may or may not be accessible.
If true, the value witness will be / tail-emplaced inside the metadata pattern and initialized by the fill / function.
If true, this is a "real" function not an inlined one.
If true, we're not done with our dataflow analysis yet.
If tvRef is not Uninit, DecRef tvRef2 and move tvRef's value to tvRef2, storing Uninit to tvRef.
If two threads are accessing this function for the first time concurrently, we might end up creating two Impl object.
If two types are checked-cast-able, so are their metatypes.
If type is not nullptr, the witness table depends on the substituted conforming type, so use that are the key.
If type of the source and the expected ObjC type are equal, there is no need to generate the conversion from ObjCTy to _ObjectiveCBridgeable._ObjectiveCType.
If type-checking failed, we've failed.
If typechecking was performed we use the computed accessibility, otherwise / we fallback to inferring accessibility syntactically.
If typo correction renamed this type, get the renamed type.
If unavailable, attempt UTF-8 codec
If unknown references don't exist, we can just use the same rules as regular pointers.
If user asks for ordered dither, give him F-S.
If user requests interlace, translate that to progressive JPEG
If valid, try to assign the same physical register here as `hint' was assigned at `pos'.
If vals64 is zero, or we're testing a single bit, we can get away with a single test, rather than mask-and-compare.
If value is null, an empty string is returned, which is good and expected.
If value names are globally disabled, honor that.
If var is a lazy property, its value is provided for the underlying storage.
If we 'break' out of the switch, break out of the loop too.
If we (still) have more than one solution, find the one with more-specialized witnesses.
If we actually resolved the member to use, return it.
If we actually solved something, record what we did.
If we add other 'whole program' passes that want to iterate, iterating this one at the same time would probably be mostly free, so we can consider that later.
If we allocated an initContext and the expression had a closure in it, we'll need to keep the initContext around.
If we allowed for PlusZero and we *did* get the value back at +0, then we assumed that self could be passed at +0.
If we already added implicit initializers, we're done.
If we already bound this archetype, make sure the new binding candidate is the same type.
If we already cached the metadata, use it.
If we already checked the inheritance clause, don't do so again.
If we already computed the result, return it.
If we already diagnosed this injection, we're done.
If we already emitted the function, return it (potentially preparing it for definition).
If we already emitted the note, we're done.
If we already emitted this thunk, reuse it.
If we already emitted this witness table, we don't need to track the fact we need it.
If we already failed finding a unique sugar, bail out.
If we already failed, or simplification fails, we're done.
If we already found a candidate without a fix, we can't do this.
If we already found an error, stop checking.
If we already found an unbound type, we're done.
If we already had an error, don't repeat the problem.
If we already have a block that qualifies as a pre-header, but pre-header was nullptr (asserted above), that means the block was added after this LoopAnalysis was created.
If we already have a cached copy of the substitutions, return them.
If we already have a conformance, we're done.
If we already have a failure, use that.
If we already have a main class, and we haven't diagnosed it, do so now.
If we already have a nested type with this name, return it.
If we already have a rebind, then we're re-typechecking an expression and are done.
If we already have a reference, it's not unique.
If we already have a specialized version of this function, do not respecialize.
If we already have a type witness, do nothing.
If we already have a viable result, it's ambiguous, so give up.
If we already have an rvalue, we're done, otherwise emit a load.
If we already have it, we have exited the return value sequence so break.
If we already have out-of-line storage, the padding invariants will still apply, and we just need to copy the old data into the new allocation.
If we already have seen a load, or if the slot does not / match the exit slot, the analysis fails.
If we already have seen a store on this BB, or if the / slot does not match the entry slot, the analysis fails.
If we already have such a cloned function in the module then just use it.
If we already have this information, return it.
If we already have this specialization, reuse it.
If we already know the concrete type is recursive, just return an error.
If we already looked for alternative literal types, return those results.
If we already recoded this type witness, there's nothing to do.
If we already recorded this witness, don't do so again.
If we already saw a class requirement, complain.
If we already saw a non-vararg field missing a default value, then we cannot assign a scalar to this tuple.
If we already saw an application, we're done.
If we already validated this extension, there's nothing more to do.
If we already visited this BB, don't reprocess it since we have a cycle.
If we also /  converted to a static initializer, then remove the load from the addressor.
If we are able to promote at least one capture of the alloc_box, then add the promotable index to the main map.
If we are accessing different fields of a common object, the two projection paths may have a non-empty symmetric difference.
If we are an accessor on a var or subscript, make sure it is deserialized too.
If we are analyzing a variable, we can generally get the decl associated with it.
If we are appending to the end of a block being constructed, then we create a new basic block to continue cons'ing up code.
If we are asked do debug serialization, instead of running all diagnostic passes, just run mandatory inlining with dead transparent function cleanup disabled.
If we are asked to emit a module documentation file, configure lexing and parsing to remember comments.
If we are asked to emit diagnostics, override ResultsInError with a Some optional initialized to false.
If we are asked to emit sorted SIL, print out our BBs in RPOT order.
If we are asked to just emit a declaration, return the declaration and say that the witness table is not fully deserialized.
If we are asked to link all, link all.
If we are asked to serialize everything, go ahead and do it.
If we are asked to splice into the same function, don't update parent pointers.
If we are asked to treat ref count increments as being inert, return None for these.
If we are assigning to _ and have unresolved types on the RHS, then we have an ambiguity problem.
If we are at conditions, take the indent of 'if' and continue.
If we are at the end of a scan line, set curx back to the beginning If we are interlaced, bump the cury to the appropriate spot, otherwise, just increment it.
If we are at the start of a trailing closure, do not add indentation.
If we are casting a protocol, then the cast will fail as we have not found any conformances and protocols cannot be extended currently.
If we are changing either the scope or the attributes of the closure, we need to re-scope its Closure subclass.
If we are concatenating, just create and return a new block.
If we are configured to use an external emitter and we are compiling a strict mode hack file, try external emitting.
If we are constructing a tuple with initializer syntax, the expected argument list is the tuple type itself - and there is no initdecl.
If we are currently delegating to a generator, return its key instead
If we are currently delegating to a generator, return its value instead
If we are defining a default initializer for a class that has a superclass, it overrides the default initializer of its superclass.
If we are detached, short circuit
If we are doing a forwarding call and this_ is null, set cls appropriately to propagate the current late bound class.
If we are doing second pass of code completion, we don't want to suddenly cut off parsing and throw away the declaration.
If we are dominated by a constraint:
If we are done succeeded, use the coerced result.
If we are drawing this AA, then redraw the border with AA lines.
If we are emitting a witness thunk for a concrete conformance, Self is just the conforming type.
If we are falling through from the current block, the return is implicit.
If we are forming a tuple and the tuple only has one element with reference semantics, a retain_value on the tuple is equivalent to a retain value on the tuple operand.
If we are freezing this epilogue release.
If we are going to apply a downgrade, bail.
If we are going to clone it for a previous checked_cast_br the argument will not dominate the blocks which it's used to dominate anymore.
If we are going to print something, make sure that we have a separator first.
If we are going to print something, we'll need to print a blank before we print something else.
If we are importing a function declaration mark it as external since we are not importing the body.
If we are in SIL mode, and if the first token is the start of a sil declaration, parse that one SIL function and return to the top level.
If we are in XenonForceAlwaysOn, do not clear the Surprise flag.
If we are in an accessor, check to see if the associated property is matches the predicate.
If we are inferring a variable to have type AnyObject.Type, "()", or optional thereof, emit a diagnostic.
If we are inheriting a variable environment, then `args' must be empty.
If we are inlining, we've done various DefInlineFP-type stuff that can affect stack depth.
If we are inside an implicit BraceStmt, don't verify source locations.
If we are inside of a method, check to see if there are any ivars in scope, and if so, whether this is a reference to one of them.
If we are invoking a constructor and there are absolutely no candidates, then they must all be private.
If we are loading from the AllocStackInst and we already know the content of the Alloca then use it.
If we are looking at a member of an existential, open the existential.
If we are looking at the init method for a root class, just walk the MUI use-def chain directly to find our uses.
If we are merging already serialized modules with local decl contexts, we handle them here in a similar fashion.
If we are missing a parameter, diagnose that.
If we are missing any of the available values in this struct element, compute an address to load from.
If we are no longer on the active line breakpoint, clear it
If we are not a mutator, there is nothing further to do here.
If we are not a subregion...
If we are not asked to emit overflow diagnostics, just return nullptr on overflow.
If we are not done, print the ", ".
If we are not exiting, check pointers using HeapGraph
If we are not in canonical SIL return early.
If we are not in repo-authoriative mode, we need to check that baseClass cannot change in between requests.
If we are not linking anything, bail.
If we are not run as 'swift', don't do anything special.
If we are not starting at the beginning of the source file, we had better already have a root type refinement context.
If we are not the first instruction in this basic block...
If we are not tracking a ref count inst for this increment, there is nothing we can pair it with implying we should skip it.
If we are not tracking a ref count, just return false.
If we are not tracking any state transitions bail.
If we are not tracking anything, bail.
If we are not trivial, bail.
If we are now at () we skip over it and terminate the loop
If we are on the install, options or modify pages and this is a named control, try to set its default state.
If we are optimizing, we should use the return location from the single, previously processed, return statement if any.
If we are parsing a refutable pattern, check to see if this is the start of a let/var/is pattern.
If we are passed in a null conformance (a valid value), just return nullptr since we cannot map a witness table to it.
If we are predecessors only successor, we can potentially hoist releases into it, so associate the first pred BB and the case for each value that we are tracking with it.
If we are profiling the heap, we always need to sync because regs need to be correct during allocations no matter what.
If we are projecting into an opened archetype, capture the witness tables.
If we are reading an i1, then check to see if it comes from a switch_enum.
If we are referring into a protocol or extension thereof, the base type is the 'Self'.
If we are referring to a type within its own context, and we have either a generic type with no generic arguments or a non-generic type, use the type within the context.
If we are returning a large unsigned value, we have to convert it back to a string since PHP only supports signed values.
If we are revisiting a block and asking for different required elements then anything that isn't agreeing is in conflict.
If we are running an optimistic data flow, set forward max to true initially.
If we are running with 'frozen' owned arg releases, check if we have a frozen use in the side table.
If we are seeing a redundant release we have exited the return value sequence, so break.
If we are showing UI, wait a beat before moving to the final screen.
If we are still a subregion, increment the SubregionIter and return.
If we are supposed to override the target triple, do so now.
If we are the only user, then take this opportunity to set the max.
If we are the operand itself set the operand to the incoming argument.
If we are to filter out this result, do so now.
If we are tracking leaks, stop tracking this object.
If we are trivial, there is no difference in between +1 and +0 since a trivial object is not reference counted.
If we are unsure of the base, it indicates that we are in base 8 or base 16 (if it is followed by an 'x').
If we are using Objective-C allocation, the caller can return nil.
If we are using XPG specifiers, make sure that we grow to a large enough size.
If we are using a default argument, handle it now.
If we are using jemalloc, it is keeping track of allocations outside of the slabs and the usage so we should force this after an allocation that was too large for one of the existing slabs.
If we are verifying all of the intermediate steps, add the verifier...
If we are visiting our own field continue.
If we are warning about a switch condition being a constant, the main emphasis should be on the condition (to ensure we have a single message per switch).
If we are, no interesting information can be extracted, so bail...
If we are, we need to do some fancy cloning and creating a new mongo_servers structure.
If we aren't a class or type alias, nothing special to do.
If we aren't about to (re-)connect then all we care about if it was a known connection or not
If we aren't allowed to have a class requirement here, complain.
If we aren't currently working with a completion set, generate one.
If we aren't even sure this is a wait handle, there's nothing we can infer here.
If we aren't going to fall back to the internal emitter, generate a Fatal'ing unit.
If we aren't in a closure, no diagnostics will be produced.
If we aren't inheriting initializers, remove any initializers from the list.
If we aren't performing dynamic lookup, we're done.
If we aren't representing 'self' in a non-delegating initializer, then we can't have 'let' properties.
If we aren't running the LLVM ARC optimizer, we don't need to emit this.
If we aren't using FCallBuiltin, the stack frame of the call to assert will be in middle of the code we are about to eval and our caller, whose varEnv we want to use.
If we called a constructor that requires a downcast, perform the downcast.
If we came from a scalar, create a scalar-to-tuple conversion.
If we came here, it means that no further EHs were found for the current fault offset and handledCount.
If we can bridge through an Objective-C class, do so.
If we can cast two types, we can cast their metatypes.
If we can completely represent the struct in SIL, leave the body implicit, otherwise synthesize one to call property setters.
If we can derive a definition for this requirement, just call it missing.
If we can derive a type witness, do so.
If we can diagnose a problem based on the constraints left laying around in the system, do so now.
If we can diagnose the problem with the fixits that we've pre-assumed, do so now.
If we can directly coerce the scalar values, avoid going through memory.
If we can emit a constant table, do so.
If we can emit the base witness table as a constant, do so.
If we can form a default type, do so.
If we can inline it, we can reference it.
If we can just split the initialization, do so.
If we can not find a releases for all parts with reference semantics that means we did not find all release for the base.
If we can order by kind, do so.
If we can propagate type sugar from input arguments types to the result of / an apply, do so.
If we can prove that Other cannot use the pointer we are tracking, return...
If we can prove that all mutations to x occur before the closure is formed.
If we can resolve the class, we'll give an object of a type according to that resolution.
If we can resolve the desired bits out of the current chunk, all the better.
If we can satisfy the tuple type by breaking up the aggregate initialization, do so.
If we can show that it's exhaustive without full type-checking, great.
If we can solve the solution, the protocol extension is usable.
If we can statically determine that the operation overflows, warn about it if warnings are not disabled by ResultsInError being null.
If we can't acquire the write lock, the caller (FreeRequestStubTrigger) retries
If we can't borrow one of the elements as a guaranteed parameter, then we have to +1 the tuple.
If we can't consume the specified word, returns false.
If we can't figure out the Base or Projection Path for the memory location, simply ignore it for now.
If we can't figure out the Base or Projection Path for the read instruction, process it as an unknown memory instruction for now.
If we can't figure out the Base or Projection Path for the read, simply ignore it for now.
If we can't figure out the Base or Projection Path for the store instruction, simply ignore it.
If we can't figure out the Base or Projection Path for the write, process it as an unknown memory instruction.
If we can't find a constructor then assume it has side effects.
If we can't find it, bail we can't match this increment up with anything.
If we can't find it, diagnose and then just don't store anything.
If we can't find the depth of a type, return ErrorDepth.
If we can't find the member constraint in question, then we failed.
If we can't free the stub, enqueue again to retry.
If we can't get a translation at the current SrcKey, interpret basic blocks until we end up somewhere with a translation (which we may have created, if the lease holder dropped it).
If we can't ignore the instruction, return false.
If we can't infer dynamic here, don't.
If we can't lower the original storage type, give up.
If we can't open the source file, fail.
If we can't represent the Swift name in Clang, bail out now.
If we can't represent the Swift name in Clang.
If we can't resolve the associated type during this iteration, try again on the next.
If we can't resolve the base type, then we can't solve this constraint.
If we can't resolve the locator to an anchor expression with no path, we can't diagnose this well.
If we can't stat the source file, fail.
If we can't zap this instruction...
If we can, post the fix-it to the sub-expression if it's a better fit.
If we can, return No Alias.
If we canceled disable cancel button since clicking it again is silly.
If we cannot conservatively prove that the given RefCountState will not be removed, be conservative and clear the transition state, so we do not propagate KnownSafety forward.
If we cannot default initialize the property, we cannot synthesize a default initializer for the class.
If we cannot do this, skip this release.
If we cannot examine the function body, assume the worst.
If we cannot explode this value, handle callee release and return.
If we cannot find either of them, return false.
If we cannot find information of the so-named function, it might not exist, or it might go through __call(), either of which cannot have reference parameters.
If we cannot find it in the module, we attempt to / deserialize it.
If we cannot find the declaration, be extra careful and print the type qualified.
If we cannot get the previous frame, default to 1
If we cannot get the type info in an expected way, describe the type.
If we cannot prove such a thing, return the relevant memory behavior.
If we cannot seek, it must be a pipe, socket or fifo.
If we cannot update the type, we have to fail.
If we change the global ValueNumberTable during the pass, the hash values of the SSATmps will change which is apparently a no-no for unordered_map.
If we check and accept this use higher up in the AST, don't recheck here.
If we choose to support this, header() and setcookie() do not work without a transport so we'd need to get around that.
If we complain about any associated types, there is no point in continuing.
If we contextually had an inout type, and got a non-lvalue result, then we fail with a mutability error.
If we continued, get the value out as the result of the expression.
If we could perform a bridging cast, try it.
If we could read the destination file, and it matches the source file in size, they may be the same.
If we could theoretically use the same information to increase the lower bound of a different set B, we can't do that at the same time---we have to choose one to apply it to.
If we couldn't emit ArraySet, fall through to the generic path.
If we couldn't emit into the Initialization, emit into a temporary allocation.
If we couldn't find a property that is accessible in the current context, bail out
If we couldn't find anything, give up.
If we couldn't flatten this expression, don't explode.
If we couldn't get the name of the callee, then it must be something of a more complex "value of function type".
If we couldn't import this Objective-C entity, determine whether it was a required member of a protocol.
If we couldn't infer the result type of the closure expr, then we have some sort of ambiguity, let the ambiguity diagnostic stuff handle this.
If we couldn't parse anything for one of the types, propagate the error.
If we couldn't parse the result type, clear out the arrow location.
If we couldn't pick a method to use for #selector, just wrap the string literal in Selector(...).
If we couldn't resolve a specific type for the base expression, then we cannot produce a specific diagnostic.
If we couldn't resolve an argument, then produce a generic "ambiguity" diagnostic.
If we created a fresh context and didn't make any autoclosures, destroy the initializer context so it can be recycled.
If we created a new context and didn't run into any autoclosures during the walk, give the context back to the ASTContext.
If we created the DISubprogram for a forward declaration, attach it to the function now.
If we delayed any extension declarations because we didn't have a resolver then, but we have a resolver now, process them.
If we delayed emission of this witness table, move it to its rightful place within the module.
If we delayed emitting this function previously, we need it now.
If we delayed emitting this witness table, force it.
If we detect a line starting with a colon, treat it as a special REPL escape.
If we detect unbalanced braces, keep reading before we start parsing.
If we diagnosed this parameter as a parse error, propagate to the decl.
If we did and self is not actually passed at +0, retain Self.
If we did any string manipulation, cache the result.
If we did evaluate into the initialization buffer, disable the cleanup.
If we did find something, it might be a duplicate of something we found earlier, because we aren't tracking generation counts for Clang modules.
If we did insert a new entry, the value at the handle should reflect the value we inserted.
If we did not find a static method AND this_ is null AND there is a frame ar, check if the current instance from ar is compatible
If we did not find an index, there is nothing further to do, continue.
If we did not find any favored constraints, just introduce the replacement constraints (if they differ).
If we did not find any non-payloaded enum, there is no RC associated with this Phi node.
If we did not find such a block or if it is the current block then bail out.
If we did not pass in a None and the optional is set to true, add the user to our error set.
If we did not remove any instructions or have any nested increments, do not perform another iteration.
If we did some shared thing, we would just hand you back the strings and you'd have to parse them on every request or build some convoluted caching mechanism which is slower than just the int access.
If we did take the branch, we now rewrite the code so that the branch is straightened.
If we did, consume it.
If we didn't actually build a disjunction, clone the underlying constraint so we can mark it as favored.
If we didn't already outdent, do so.
If we didn't bail out, do post-order visitation.
If we didn't build the type differently above, build it normally now.
If we didn't change the fp for this block we don't need to re-process it's successors.
If we didn't clean up the rethrow destination, we screwed up somewhere.
If we didn't compute any new bindings, we're done.
If we didn't consume any tokens failing to parse the expression, don't put in the source range of the ErrorExpr.
If we didn't escape or reprocess anything, then we don't need to use the temporary string, just point to the original one.
If we didn't evaluate into the initialization buffer, do so now.
If we didn't find a copy_addr to fold this into, emit the destroy_addr.
If we didn't find a function, create a new one - it must be a forward reference.
If we didn't find a match, then just return tok::pound.
If we didn't find a matching declaration, the iteration is restarted but we won't look anymore for the specific nominal type declaration
If we didn't find a retain to fold this into, emit the release.
If we didn't find a valid initializer (maybe the initial value was incompatible with the raw value type) mark the entry as being erroneous.
If we didn't find any declaration at all, we're stuck.
If we didn't find any delegating or chained initializers, check whether the initializer was explicitly marked 'convenience'.
If we didn't find any exact matches, accept any type aliases
If we didn't find any matches at all, fail.
If we didn't find any methods, complain.
If we didn't find any side effects, we win.
If we didn't find anything with the appropriate name, look again using only the base name.
If we didn't find anything, /and/ this is a nominal type, check to see if any of the nominal's protocols are derivable and contain the name we're looking for.
If we didn't find anything, complain.
If we didn't find anything, expand implied conformances.
If we didn't find anything, mark the result as "None".
If we didn't find anything, we're done.
If we didn't find anything...
If we didn't find multiple methods, there is no ambiguity.
If we didn't find one, create it.
If we didn't find the first word in the name at all, we're done.
If we didn't find the tool there, search for it.let the OS search for it.
If we didn't find the type in the TypeRepr, fall back to the type in the type checked expression.
If we didn't get anything, add a () pattern to avoid breaking invariants.
If we didn't have an up-to-date cache entry, scan the conformance records.
If we didn't have any parameters, create a parameter list from the anonymous closure arguments.
If we didn't leave the bit alone in this situation, the lower bound could end up too high after a later IncRef.
If we didn't manage to diagnose anything well, so fall back to diagnosing mining the system to construct a reasonable error message.
If we didn't manage to import the declaration context, we're done.
If we didn't manage to keep something in the first non-extra slot, scan extras again to swap something over.
If we didn't manage to resolve directly to an expression, we don't have a great diagnostic to give, so bail.
If we didn't map down to a specific expression, we can't handle a default argument.
If we didn't need the context, "destroy" it, which recycles it for the next user.
If we didn't parse a type, fill in an error type and bail out.
If we didn't parse a type, then we already diagnosed that the type was invalid.
If we didn't parse any patterns, don't create the pattern binding decl.
If we didn't reach RCIdentityBB, keep processing up the DomTree.
If we didn't reach the end of the type name, don't match.
If we didn't return a reduce above, we still can compute a partially-known FCall effect with our res::Func.
If we didn't see a header we like, just ignore the ones we don't like and see if the response looks xmlish
If we didn't see an expression, statement, or decl which might have side-effects, keep reading.
If we didn't simplify anything, just return the input.
If we didn't visit this nominal type above, add this declaration to the list.
If we didn't, then this is unexpected.
If we didn't, we'd have a chicken-egg problem.
If we do / advance return true.
If we do change states continue...
If we do find a type, we use it to check for contextual type mismatches.
If we do have a non-trivial type, return false.
If we do have data we'll attempt to read and decode it below, even if there are other error bits set.
If we do not find a ref count increment in the relevant BB, skip this enum since there is nothing we can do.
If we do not find any such function, we have no function to devirtualize to...
If we do not find state for a specific value in any of our predecessor BBs, we cannot be the end of a switch region since we cannot cover our predecessor BBs with enum decls.
If we do not find such an increment, there is nothing we can do, bail.
If we do not have a release_value or strong_release.
If we do not have a retain_value or strong_retain...
If we do not have a tag associated with this enum value for each predecessor, we are not a switch region exit for this enum value.
If we do not have an RPO number for a predecessor, it is because the predecessor is unreachable and a pass did not clean up after itself.
If we do not have any argument, just delete the release value.
If we do not have any argument, kill the retain_value.
If we do not have any decrements to attempt to match up with, bail.
If we do not have any increment to attempt to match up with again, bail.
If we do not have any insertion points but we do have increments, we must be eliminating pairs.
If we do not have any interesting instructions, bail and return false since we can not have any nested instructions.
If we do not have any more information, just use the general memory behavior implementation.
If we do not have any payload arguments, then we should have an empty delete list and there is nothing to do here.
If we do not support this instruction kind, then just bail.
If we do not understand one of the exit BBs, bail.
If we do something after onRequestShutdown registered a RequestEventHandler.
If we do, it has to be nominal one way or another.
If we do, load the original type and create the appropriate bitcast.
If we don't actually need an entry point for the getter, do nothing.
If we don't allow unresolved dependent member types, fail.
If we don't already have a fixed type for this type variable, assign the fixed type from the solution.
If we don't bail out, we end up filling in just one type in "result" instead of two and then the compiler will crash later when it tries to create the bound generic from only 1 type.
If we don't create the connection, register it (done in mongo_get_connection_single) and add it to the list of servers that we're processing so we might use this host to find more servers.
If we don't do this, DI will miss the uses.
If we don't emit a function body then make sure to mark the declaration as available externally.
If we don't find any witness table for the conformance, bail and return false.
If we don't find anything, stop.
If we don't have 'self', we don't need to do anything special.
If we don't have a 'lib/arc/' directory, find the "arclite" library relative to the Clang in the active Xcode.
If we don't have a callback, we don't have to conditionalize the writeback.
If we don't have a class or a struct, bail.
If we don't have a connected server then there is no point in continuing
If we don't have a context but the other type does, we'll return ABIDifference::ThinToThick below.
If we don't have a default definition, we're done.
If we don't have a default witness table list, we can't look anything up.
If we don't have a fixed type, use the standard copy-opaque-POD routine.
If we don't have a formal superclass, start with the basic heap header.
If we don't have a forward reference, make sure the function hasn't been defined already.
If we don't have a mapped node in the destination graph we still have to honor its escaping state.
If we don't have a name to hang on to, it'll be hard to diagnose this overload.
If we don't have a nominal type, there are no conformances.
If we don't have a parent type, fast-path.
If we don't have a reference range, there is nothing we can do, so return null.
If we don't have a requested placement, but we do have a current insertion point, insert there.
If we don't have a rethrow destination, we're done.
If we don't have a string, complain.
If we don't have a substitution for this type and it doesn't have a parent, then we're not substituting it.
If we don't have a type for the expression, then we cannot use it in conversion constraint diagnostic generation.
If we don't have a witness table list, we can't look anything up.
If we don't have an Objective-C method table, there's nothing to do.
If we don't have an actrec, the stack depth was invalid
If we don't have an argument for this case, there is nothing to do...
If we don't have an enum tag (which can happen if we have a default statement), return.
If we don't have an enum tag for each predecessor of this BB, bail since we do not know how to handle that BB.
If we don't have an error result, we can make a simple 'apply'.
If we don't have an exact type, then we can't say for sure the class doesn't have the method.
If we don't have an incoming value for each one of our predecessors, just return SILValue().
If we don't have an indentation location yet, grab one from this member.
If we don't have an initialization for the tuple, just build the individual components.
If we don't have an lbrace, then this witness table is a declaration.
If we don't have an sfp, we're returning from the first frame in this VM nesting level.
If we don't have an unreachable inst at this point, this is a terminator we don't understand.
If we don't have any arguments return.
If we don't have any casts in our symmetric difference (i.e. only typed GEPs), then we can say that these actually have a symmetric difference we can understand.
If we don't have any data to read (POLLIN) then we're done.
If we don't have any local captures (including function captures), there's no context to apply.
If we don't have any no-payload cases, we are done -- the payload tag alone is enough to distinguish between all cases.
If we don't have any such state, then the predecessor must be unreachable from the entrance and thus is uninteresting to us.
If we don't have anything that we can simplify, don't do it.
If we don't have anything we really need to check, then trivially succeed.
If we don't have attributes, then it cannot be an accessor block.
If we don't have concrete conformance information, the type must be an archetype and the conformance must be via one of the protocol requirements of the archetype.
If we don't have exactly one kind of specialization, or if our bits support both kinds, don't specialize.
If we don't have it, we need to call the general name via the witness table.
If we don't have more than one component, just solve the whole system.
If we don't have one, bail.
If we don't have one, continue.
If we don't have one, skip this release value inst.
If we don't have sufficient type information to inline the region return early
If we don't have the base available, we might still be able to get a value with a good type from its pointer.
If we don't have the leading '(', complain.
If we don't have this last case, be conservative and assume that we can use the value.
If we don't have to do any cleanup work, just exec the subprocess.
If we don't have to shuffle anything, we're done.
If we don't have type arguments, the collection element type is "Object".
If we don't have type parameters, use the prefix of the type name as the collection element type.
If we don't insert anything, just continue.
If we don't know any better, assume that the cast may succeed.
If we don't know exactly where the base is, we have to be conservative and apply the operation to all locals/stack slots that could be affected.
If we don't know of an object type at the given location, assume its referring to something we never parsed in the first place, so return the pseudo-type.
If we don't know what kind of expression this is, assume it's a reference and mark it as a read.
If we don't know whether we have a This, we need to check dynamically
If we don't know, we still have to emit a runtime check because src might be a subtype of the specialized type.
If we don't need generic parameters, just build the result.
If we don't need to look up any witness tables, we're done.
If we don't pass a name, then we just use the raw config as-is.
If we don't see a 'while', this is just the bare 'do' scoping statement.
If we don't succeed, throw away the inference information.
If we don't want to emit now, remember how for later.
If we don't, be compatible with Zend by allowing usercode in hphp_context_shutdown to run before we end the request.
If we don't, we must have a single source parameter.
If we dropped "with" and ended up with a reserved name, put "with" back.
If we dropped the variadic, handle it now.
If we dug out a problematic decl, we can produce a nice tailored diagnostic.
If we emit a deprecation diagnostic, produce a fixit hint as well.
If we emitted an error, there is no reason to proceed with load promotion.
If we emitted into context, be sure to finish the overall initialization.
If we emitted into the provided context, we're done.
If we emitted the "done" check inline, join the branches.
If we encounter a non acceptable character (see above)
If we encounter an error validating the parameter list, don't bail.
If we end up here with a stored property of a type that's resilient from some resilience domain, we cannot do direct access.
If we end up looking for ourselves, don't recurse.
If we end up with other classes that need special behavior, turn the assert into an if and add cases.
If we ended up building our parent archetype, then we'll have already filled in our own archetype.
If we ended up here, it's because we have two operators with mismatched or no associativity.
If we ended up with a vacuous name like "get" or "set", do nothing.
If we ended up with something that can't be a member name, do nothing.
If we enter the current block through P, the self value will be null and we don't have to destroy anything.
If we entered an initializer context, contextualize any auto-closures we might have created.
If we enumerated any dependencies, we can't complete this request.
If we ever allow importing non-top-level decls, it's possible the rule above isn't what we want.
If we ever change ConcatStrFoo not to decref its sources we'll need to address this (or punt on a boxed source).
If we ever change that we'll have to change this to patch to some sort of rebind requests.
If we ever change this, we'll need to be careful about unlinking dead CF instructions here.
If we ever detect a conflicting element, we record it and do not look at the result.
If we ever lose a light process, stop the server instead of proceeding in an uncertain state.
If we ever reach an unreachable point, stop emitting statements and issue an unreachable code diagnostic.
If we ever reach an unreachable point, stop emitting statements.
If we ever remove 'self' from manglings, we should stop resetting the context here.
If we ever start using StMem to store to pointers that might be stack/locals, we have to update tracked state here.
If we fail to attach to a debugger, then we can choose to wait for an exception to be thrown so we try again, or we can just detach the debugger hook completely.
If we fail to constrain on an end-position use, we must still split and spill.
If we fail to create a projection, add User as a user to this node and continue.
If we fail to do so, blot this SILValue and continue.
If we fail to do that as well, bail.
If we fail to find a root, return V.
If we fail to get the socket, we just return up to higher-level code (the HttpServer class will then try to kill the existing server).
If we fail to get the write lease, just let it stay unsmashed for now.
If we fail to load it, bail.
If we fail to lookup the SILFunction, again skip Class and attempt to resolve the method in the VTable of the super class of Class if such a super class exists.
If we fail to match anything, just rethrow the exception.
If we fail to match anything, we can just emit unreachable.
If we fail to process it, just move on to the next match.
If we fail, blot this ref counted value and continue.
If we fail, don't even look for the module documentation file.
If we fail, dump out some internal state.
If we fail, just return the declaration.
If we fail, return true.
If we fail, then bail.
If we fail, we found an unreachable block, bail.
If we failed due to circular inlining, then emit some notes to trace back the failure if we have more information.
If we failed lookup of a binary operator, check to see it to see if / it is a binary operator juxtaposed with a unary operator (x*-4) that / needs whitespace.
If we failed lookup of an operator, check to see it to see if it is because two operators are juxtaposed e.g. (x*-4) that needs whitespace.
If we failed to find the decl a clean and principled way, try hacks: map back to the AST and look for some common patterns.
If we failed to generate the callee don't fail the caller, instead retry without the callee
If we failed to load, we should have already diagnosed
If we failed, advance str, by 1 char if it's a valid char, or past all invalid bytes otherwise.
If we failed, keep the ExprPattern as is.
If we failed, return nil or trap.
If we fall off the end of the inline assembly, we're expected to leave a single value on the stack.
If we fell out of the catch clause, branch to the fallthrough dest.
If we fell through the switch, mangle the requirement.
If we find a "where", and there is a preceding item without a where, and if they are on the same source line, then warn.
If we find a closure, update its declcontext and do *not* walk into it.
If we find a dealloc_stack of the right memory, great.
If we find a fallthrough, then we got what we came for.
If we find a member, then all of the results aren't non-members.
If we find a node in the lvalue path that is problematic, this returns it.
If we find a non-OrdStr use, we're not going to do the optimization, so clear the list, and make sure this one is first, so we can easily skip without searching the whole vector.
If we find a subtree that cannot be type checked on its own (even to an incomplete type) then that is where we focus our attention.
If we find an UnresolvedPatternExpr, return true.
If we find another element, then we must have more than 2, so bail.
If we find any autogenerated copies to/from an alloc_stack, then / remove the alloc stack in favor of loading/storing to the inout pointer / directly.
If we find any loads or any escape sites of the object, we give up.
If we find one, / change the block to have an unreachable instruction right after it, and / diagnose any user code after it as being unreachable.
If we find that a given named parameter has been used twice, we will raise an error, as we can't be sure that it is safe to bind multiple parameters onto the same zval in the underlying driver
If we find the word, check whether it's a valid match.
If we find this situation, add the original one to our list for diagnosis.
If we find unresolved pattern, diagnose this as an illegal pattern.
If we find what looks to be a / string literal, diagnose the problem and return a pointer to the end of the / entire string literal.
If we found a backedge, add ER's ID to LRegion's Backedge list.
If we found a candidate list with a recursive walk, try adjust the curry level for the applied subexpression in this call.
If we found a closing quote character, we're done.
If we found a decl for the UDE, check it.
If we found a decl for the subscript, check to see if it is a set-only subscript decl.
If we found a decl that is being assigned to, then mark it.
If we found a declaration from the standard library, make sure it does not show up in the lookup results for the imported module.
If we found a function pointer statically, great.
If we found a generic parameter, map to the archetype if there is one.
If we found a generic parameter, try to resolve it.
If we found a mapping, check to see if the matched up arguments agree in their type and count the number of mismatched arguments.
If we found a member, try to find its offset statically.
If we found a method and its static, null out this_
If we found a non-implicit declaration, use its source location.
If we found a non-legal user, bail early.
If we found a parameter to fulfill, do it.
If we found a projection path, but there are no projections, then the two loads must be the same, return PrevLI.
If we found a property accessor, import the property.
If we found a protected or private method, we need to do some accessibility checks.
If we found a rebind target, note the insertion point.
If we found a reference to an associated type or other member type that was marked invalid, just return ErrorType to silence downstream errors.
If we found a single candidate, and have no contextually known argument type information, use that one candidate as the type information for subexpr checking.
If we found a single solution, take it.
If we found a sinkable instruction that is identical to our goal then return it.
If we found a store, record its source and erase it.
If we found a stored property, add a default constructor.
If we found a straight-quote, then we're done.
If we found a strong release, replace it with a strong release of the source of the store and erase it.
If we found a typealias first, and now have an associatedtype with the same name, it was a Swift 2 style declaration of the type an inherited associatedtype should be bound to.
If we found a valid connection check if we need to ping it
If we found an Objective-C-defined class, continue checking.
If we found an accessible method in cls's method table, return it.
If we found an alias type in an inherited protocol, resolve it based on our own `Self`.
If we found an associated type in an inherited protocol, the base for our reference to this associated type is our own `Self`.
If we found an ending curly quote (common since this thing started with an opening curly quote) diagnose it with a fixit and then return.
If we found an exact match, this must be a problem with a conversion from the result of the call to the expected type.
If we found an explicit ClosureExpr, update its type.
If we found an impossible designated initializer, then we cannot call super.init(), even if there is a match.
If we found any lowercase letters, this was a normal camel case word (not an acronym).
If we found any names of overridden methods, return those names.
If we found any solution, we're done.
If we found both prefix and postfix, or neither prefix nor postfix, complain.
If we found both, point at them.
If we found duplicated instructions, sink one of the copies and delete the rest.
If we found either a signal of a payloaded or a non-payloaded enum, return that value.
If we found it, we're ok.
If we found more than two methods, it's ambiguous.
If we found no overloads, then there is something else going on here.
If we found no results at all, mention that fact.
If we found nothing, complain and give ourselves a chance to recover.
If we found one, advance the info for the source to the current point in the path, then continue the search.
If we found our contextual type, then we know we have a conversion to some function type, and that the result type is concrete.
If we found some candidates, then we're done.
If we found some requirements with nearly-matching names, diagnose the first one.
If we found some unviable results, then fail, but without recovery.
If we found something specific, return it.
If we found something within the protocol itself, and our search began somewhere that is not in a protocol or extension thereof, remap this declaration to the witness.
If we found something, we're done.
If we found the allocation itself, then we are loading something that is not defined at all yet.
If we found the closing brace, then the caller should not care if there were errors while parsing inner decls, because we recovered.
If we found the end of the line, return.
If we found the end of the line, we can do great things.
If we found the func in baseClass and it's private, this is always going to be the called function.
If we found the func in baseClass and it's private, this would have already been handled as an exact Func.
If we found the instruction that defines the value we're releasing, don't push the release past it.
If we found the single argument being initialized, use it.
If we found the state but the state is for a trap BB, skip it.
If we get back a nullptr, then we know that the BB belongs to the function region and is also not a loop header.
If we get here with a copy_addr, it must be storing into the element.
If we get here, the break point is of a type that does not need to be explicitly enabled in the VM.
If we get here, there was no end frame.
If we get here, things are going to be slow anyway, so do all the autoloading logic in lookupFallbackFunc instead of ASM
If we get here, turn on coverage
If we get here, we couldn't simplify the path further.
If we get here, we weren't able to prove that the files are the same.
If we get to a release of the object, zap both.
If we get to a release that is provably to this object, then we can ignore it.
If we get to a release that is provably to this object, then we can zap it and the retain.
If we get to a release, we can generally ignore it and scan past it.
If we get to a retain or allocation of the / object, zap both.
If we got a cached negative response, check the generation number.
If we got a correct shuffle, we can perform the analysis of all of the input elements, with their expected types.
If we got a default initializer, install it and re-type-check it to make sure it is properly coerced to the pattern type.
If we got a fully valid type, then this is a nominal type pattern.
If we got a good PID, then we can exit the parent process.
If we got a subexpression, add it.
If we got all the way down to a truly ambiguous disjunction constraint with a conversion in it, the problem could be that none of the options in the disjunction worked.
If we got an error on the replacement, the subject will be null, and then we will return null.
If we got any data, don't worry about it.
If we got here, then we were already paused.
If we got here, we didn't throw, so we can pop the inputs.
If we got here, we know that every pred of the current block is either providing a constant or the dest of a setcc.
If we got here, we read the appropriate number of accumulated bytes.
If we got here, we should have claimed all the arguments.
If we got the choice by unwrapping an optional type, unwrap the base type.
If we got to the end of the line, and the thing before this diagnostic is a "//" then we can remove it too.
If we got to the root, we're done.
If we got to the top of the block, (and if the instruction didn't start there) move the release to the top of the block.
If we had a best solution, keep just that solution.
If we had a circular dependency, the superclass may not exist.
If we had a cleanup, create a cleanup at the new address.
If we had a connection we need to remove it from the callback map before we assign it another connection.
If we had a contextual type, then it either conforms to ArrayLiteralConvertible or it is an invalid contextual type.
If we had a contextual type, then it either conforms to DictionaryLiteralConvertible or it is an invalid contextual type.
If we had a loadable "next" generator value, we know it is present.
If we had a name with no type following it, finish it now.
If we had a parse error, don't attempt to parse suffixes.
If we had a pure transparency color, add it as the last palette entry.
If we had a return type of 'Self', erase it.
If we had a single component, try looking up an enum element in context.
If we had a thumbnail in a SUB_IFD we have ANOTHER image in NEXT IFD
If we had a valid value, return -1.
If we had all invalidated nodes, this will return nullptr.
If we had an Objective-C match, this is a serious problem.
If we had an exact match, throw away any non-exact matches.
If we had an incorrect expected fixit, render it and produce a fixit of our own.
If we had conditional ObjC checks, join the failure paths.
If we had more than one expression, form a tuple.
If we had multiple viable types, diagnose the ambiguity.
If we had semantic errors, just fail here.
If we hadn't removed anything before, this is the first removal.
If we have "case let x." or "case let x(", we parse x as a normal name, not a binding, because it is the start of an enum pattern or call pattern.
If we have HOWMANY bytes, it indicates that the data might have been truncated, probably even before this function was called.
If we have NS(U)Integer or CGFloat, return it.
If we have a '*', then this is an address type.
If we have a ':', this is a dictionary literal.
If we have a 'didSet' or a 'willSet' label, disambiguate immediately as an accessor block.
If we have a 'this' pointer ...
If we have a (cond (select_enum)) on a two element enum, always have the first case as our checked tag.
If we have a CF typedef, check whether the "other" declaration we found is just the opaque type behind it.
If we have a Clang declaration, look at it to determine the effective Clang context.
If we have a ClosureExpr parent of the specified node, check to make sure none of its arguments are type variables.
If we have a CollectionExpr with a type checked SemanticExpr, remove it so we can recalculate a new semantic form.
If we have a DCls::Sub we have to assume it could affect any subclass, so we repeat this merge for all exact class types deriving from that base.
If we have a DebugDisplay prop saved, use it.
If we have a Swift import of this type, use our lowered information.
If we have a Swift metatype, map it to the heap metadata, which will be the Class for an ObjC type.
If we have a This pointer in destCtxReg, then select either This or its Class based on whether callee is static or not
If we have a backedge...
If we have a base type for this member, try to perform substitutions into it to get a simpler and more concrete type.
If we have a best method, reference it.
If we have a binding for this parameter, we're done.
If we have a binding that does not involve type variables, or we have no other option, go ahead and try the bindings for this type variable.
If we have a bridged Objective-C type and we are allowed to bridge, do so.
If we have a bridged type, we found this declaration via bridging.
If we have a builtin type, canonicalize it on the right.
If we have a cache, remember this in the cache at the next position.
If we have a callback to report dependencies, do so.
If we have a callee release and we are dead, set the callee release's operand to undef.
If we have a catch trace at the IP in the frame given by `context', install it.
If we have a chain of identical binop expressions with homogeneous argument types, we can directly simplify the associated constraint graph.
If we have a clang decl associated with the Swift decl, derive its ownership conventions.
If we have a class address, it is a pointer so it cannot contain other types.
If we have a class type, look into its superclass.
If we have a collection, get the element type.
If we have a colon, consume it.
If we have a concrete conformance, handle Self-derived type parameters differently.
If we have a concrete conformance, we need to substitute the conformance to apply to the new type.
If we have a concrete type, produce a same-type requirement.
If we have a conflict with the word after the preposition, don't split.
If we have a conflict with the word before the preposition, don't split.
If we have a constructor member, handle it as a constructor.
If we have a constructor with no parameters and a name with an argument name, synthesize a Void parameter with that name.
If we have a context, make sure it is an identifier.
If we have a contextual type available for this closure, apply it to the ParamDecls in our parameter list.
If we have a contextual type, and if we have an ambiguously typed function result from our previous check, we re-type-check it using this contextual type to inform the result type of the callee.
If we have a contextual type, it must be an inout type.
If we have a conversion type, but it has type variables (from the current ConstraintSystem), then we can't use it.
If we have a copy_addr, explode it now, exposing the load operation within it.
If we have a covariant result type, perform the conversion now.
If we have a dead argument, bail.
If we have a deallocating parameter, it is passed in at +0 and will not be deallocated since we do not allow for resurrection.
If we have a decl identified, refine the match.
If we have a declaration, convert the witness table to a definition.
If we have a declaration, do not attempt to serialize entries.
If we have a default argument, keep going.
If we have a definition already, don't do anything.
If we have a definition already, just return it.
If we have a definition, return it.
If we have a dependent value witness table, emit its template.
If we have a final method or a method from an extension that is not Objective-C, emit a static reference.
If we have a fixed offset, add it.
If we have a foreign error convention, restore the original result type.
If we have a foreign-error convention that strips result optionality, we need to wrap both the original and substituted types in a level of optionality.
If we have a framework, mangle the name to point to the framework binary.
If we have a fully-applied enum element constructor, open-code the construction.
If we have a function ref inst, we need to especially drop its function argument so that it gets a proper ref decrement.
If we have a generic type, bind the type to the archetypes in the type's definition.
If we have a good directory to extract to above, we now check whether the "file" parameter passed in is a directory or actually a file.
If we have a guaranteed method, we will have a release due to a missing optimization in SILGen that will be removed.
If we have a guaranteed parameter, it is passed in at +0, and its lifetime is guaranteed.
If we have a hinted type that's better than the guarded type, we want to keep it around.
If we have a leading identifier followed by a ':' or 'in', then this is obviously a for-each loop.
If we have a leading token that may be part of the closure signature, do a speculative parse to validate it and look for 'in'.
If we have a live 'live range' or a live range that we have not sen a copy into, bail.
If we have a load, then this is a use of the box.
If we have a local name for the parameter, pass in that as well.
If we have a location, diagnose the issue.
If we have a lookup table, add the new member to it.
If we have a might be used, we already created an insertion point earlier.
If we have a mutable binding for a 'let', such as 'self' in an 'init' method, load it.
If we have a name for this declaration, use it.
If we have a name to import as, add this entry to the table.
If we have a nested disjunction, unwrap it.
If we have a no-payload case, this yields a non-negative value, which is the most significant bits of the current case index.
If we have a nominal kind...
If we have a nominal type decl as our base, try to emit the base rvalue's member using special logic that will let us avoid extra retains and releases.
If we have a nominal type that conforms to the protocol in which the associated type resides, use the witness.
If we have a nominal type, "use" its conformance to _ObjectiveCBridgeable if it has one.
If we have a non-class, non-objc method or a class, objc method that is final, we do not dynamic dispatch.
If we have a non-local id, just return the parent region's data.
If we have a non-trivial type...
If we have a normal metatype, we can't solve backwards unless we know what kind of object it is.
If we have a normal or inherited protocol conformance, look for its generic parameters.
If we have a normal or inherited protocol conformance, look for its generic signature.
If we have a null pointer for the metadata info, the dtor has no side effects.
If we have a parameter name, just output the name as is and skip the type.
If we have a paren expr and our contextual type is a ParenType, remove the paren expr sugar.
If we have a parent type, it's the first parameter.
If we have a parent type, we need to build a compound type repr.
If we have a parent, print out its id.
If we have a partial_apply and we converted some results/parameters from indirect to direct there are 3 cases: 1) All uses of the partial_apply are apply sites again.
If we have a partial_apply, release each captured argument at each one of the final release locations of the partial apply.
If we have a payload case, this yields a negative value, which is the final resilient tag index.
If we have a preposition, we can chop off type information at the beginning of the name.
If we have a primary input and it's a filename with extension "sil", treat the input as SIL.
If we have a protocol with a default type, look for alternative types to the default.
If we have a raw value, make sure there's a raw type as well.
If we have a reader, deserialize all of the globals-as-members data.
If we have a reader, enumerate its base names.
If we have a redefinition, return a new BB to avoid inserting instructions after the terminator.
If we have a release, make sure that AI is guaranteed.
If we have a requirement/witness pair, diagnose it.
If we have a resolved class for the constraint, all we have to do is check if the value's class is compatible with it
If we have a retain value...
If we have a return, we place the release right before it so we know that it will be executed at the end of the epilogue.
If we have a section, enqueue the conformances for lookup.
If we have a section, enqueue the type metadata for lookup.
If we have a selfType (i.e. we're not in the parser before we know such things, configure it.
If we have a setter, rectify it with the getter.
If we have a shadowed variable definition, check to see if we have a redefinition: two definitions in the same scope with the same name.
If we have a shared case with bound decls, then the 0th pattern has the order of variables that are the incoming BB arguments.
If we have a simple name, determine whether there are argument labels we can use to restrict the set of lookup results.
If we have a single Swift-refcounted context value, we can adopt it directly as our closure context without creating a box and thunk.
If we have a single argument, look through the paren expr.
If we have a single candidate that failed to match the argument list, attempt to use matchCallArguments to diagnose the problem.
If we have a single match (exact or not), take it.
If we have a single-buffer "emit into" initialization, use that for the result.
If we have a slash at the beginning, then just remove it and we are relative.
If we have a source range and an ASTContext, print the source range.
If we have a specialized protocol conformance, since we do not support currently partial specialization, we know that it cannot have any open type variables.
If we have a store to self inside the normal BB, we have a 'real' try_apply.
If we have a strong_release or a release_value, see if our parameter is in an array semantic guaranteed self call sequence.
If we have a struct instruction with only one non-trivial stored field, the only reference count that can be modified is the non-trivial field.
If we have a subregion...
If we have a substitution for this type, use it.
If we have a substitution whose replacement type is an archetype, make sure that the replacement archetype is in the context generic params of the caller function.
If we have a successor, add ourself to its prev list.
If we have a suffix, we didn't generate a for loop, just straightline code.
If we have a superclass bound, recurse on that.
If we have a superclass, import from it.
If we have a superclass, invoke its destructor.
If we have a superclass, produce a superclass requirement
If we have a superclass, start from its size and alignment instead.
If we have a swift_name attribute, use that.
If we have a switch, try to sink ref counts across it and then return that result.
If we have a target anchor, build and simplify the target locator.
If we have a target function, only print that function out.
If we have a terminator instruction, see if it can use ptr.
If we have a terminator that we cannot sink through or the cfg will not let us sink into our predecessors, just move the increment before the terminator.
If we have a thin-to-thick abstraction change, cook up new a metatype value out of nothing -- thin metatypes carry no runtime state.
If we have a trailing closure, it maps to the last parameter.
If we have a trailing where clause, deal with it now.
If we have a transparent color (the alphaless mode of transparency), we must reserve a palette entry for it at the end of the palette.
If we have a trivial bit cast between trivial types, it is not something that can use ref count ops in a way we care about.
If we have a trivial type, we do not need to put in any extra releases.
If we have a tuple expression, form a tuple type.
If we have a tuple, flatten it.
If we have a tuple_extract that is extracting the only non trivial member of a tuple, a retain_value on the tuple is equivalent to a retain_value on the extracted value.
If we have a type but no initializer, check whether the type is default-initializable.
If we have a type declaration, resolve it within the current context.
If we have a type for that, capture it so that we can calculate a substituted type, which resolves many generic arguments.
If we have a type reference, look through the metatype.
If we have a type variable that has been bound to a fixed type, look through to that fixed type.
If we have a type with reference semantics, emit a load/strong release.
If we have a type-adjusting attribute (like ownership), apply it now.
If we have a typedef that refers to a tag type of the same name, skip the typedef and import the tag type directly.
If we have a useful base type for the candidate set, we'll want to substitute it into each member.
If we have a value and index list, create a new rvalue to represent the both of them together.
If we have a value of type AnyObject that we're trying to convert to a class, force a downcast.
If we have a variadic method for which we need to drop the last selector piece, do so now.
If we have a witness method call, the inner context is the witness table.
If we have addressors, at this point mark it as addressed.
If we have all invalidated nodes, this will return nullptr.
If we have already emitted a diagnostic about an unsafe override for the property, don't complain about the accessor.
If we have already introduced an initializer with this parameter type, don't add one now.
If we have already resolved a concrete lvalue destination type, return it.
If we have already seen an init_existential_addr, we cannot optimize.
If we have already seen an open_existential_addr, we cannot optimize.
If we have already seen it, then don't reprocess all of the uses.
If we have already visited this user, continue.
If we have an AST node here, just cast it.
If we have an Initialization, emit the tuple elements into its elements.
If we have an Objective-C method, print the class name along with '+'/'-'.
If we have an Objective-C property, print the class name along with the property name.
If we have an OptStr with a value, we can at least exclude the possibility of integer-like strings by looking at that value.
If we have an OptionalEvaluationExpr at the top level, then someone is "optional chaining" and ignoring the result.
If we have an absolute or relative path, just try to load it now.
If we have an abstract conformance passed in (a legal value), just return nullptr.
If we have an abstraction change or if we have to produce a result at +1, then emit a RetainValue.
If we have an address only type don't do anything.
If we have an address only type, do nothing.
If we have an address, just bitcast, don't explode.
If we have an alias name, make it private as well.
If we have an alternate name for this type, use it.
If we have an anchor, drill into it to emit a "note: archetype declared here".
If we have an argument list (i.e., a scalar, or a non-zero-element tuple) then diagnose with some specificity about the arguments.
If we have an assignment expression, scout ahead for acceptable _'s.
If we have an early emitter, just let it take over for the uncurried call site.
If we have an enum instruction with a payload, strip off the enum to expose the enum's payload.
If we have an error convention and this is the error parameter, print it.
If we have an error convention that inserts an error parameter here, add "error".
If we have an exact match, then we must have an argument list, check it.
If we have an existential metatype, that's good enough to solve the constraint.
If we have an existential, look at its dynamic type.
If we have an existing default witness table, verify that the protocol matches up.
If we have an existing entry, destroy it, replacing it with the new variable.
If we have an existing function, verify that the types match up.
If we have an existing witness table, verify that the conformance matches up.
If we have an expect optimizer hint with a constant value input, there is nothing left to expect so propagate the input, i.e.,
If we have an explicit cast, we're done.
If we have an explicit ownership modifier and our parent doesn't, complain.
If we have an extension containing globals imported as members, use the first member as the Clang node.
If we have an identifier after this, which is not the start of another stmt or decl, we assume it is the label to break to, unless there is a line break.
If we have an identifier after this, which is not the start of another stmt or decl, we assume it is the label to continue to, unless there is a line break.
If we have an imbalance of optionals or a collection downcast, handle this as a checked cast followed by a a 'hasValue' check.
If we have an implicit force, look through it.
If we have an inclusive range "low...up" the loop exit count will be "up + 1" but the overflow check is on "up".
If we have an indirect result, bail.
If we have an indirect return slot, initialize it in-place.
If we have an init method, import it as an initializer.
If we have an initializer requirement and the conforming type is a non-final class, the witness must be 'required'.
If we have an initializer, we can also have unknown types.
If we have an instruction that may write to memory and we cannot prove that it and its operands cannot alias a load we have visited, invalidate that load.
If we have an interpolation argument, dig out the constructor if we can.
If we have an invalid case, bail out now.
If we have an lvalue coming in, we expect an inout.
If we have an opaque type, suggest the possibility of adding a class bound.
If we have an optional type, try to force-unwrap it.
If we have an order number for this function, set it up as appropriate.
If we have an out-of-order argument, diagnose it as such.
If we have an overlay, look in the overlay.
If we have an override for this constructor, it's okay.
If we have an rvalue base, make sure that the result isn't 'mutating' (only valid on lvalues).
If we have an spOff, materialize rvmsp() so that handleSRHelper() can do a VM reg sync.
If we have an unambiguous reference to a type decl, form a TypeExpr.
If we have an unbound generic bridged type, get the arguments.
If we have an unbound generic type, bind the type to the archetypes in the type's definition.
If we have an unchecked_enum_data, strip off the unchecked_enum_data.
If we have an unknown call, we need to create any retainN calls we have seen.
If we have an unspecialized form of a parameterized Objective-C class type, fill in the defaults.
If we have any arguments that were consumed but are now guaranteed, insert a release_value in the error block.
If we have any arguments that were consumed but are now guaranteed, insert a release_value.
If we have any children...
If we have any conflicting values, don't bother searching for them.
If we have any conflicting values, explicitly mask them out of the result, so we don't pick one arbitrary available value.
If we have any direct results, receive them via BB arguments.
If we have any expected fixits that didn't get matched, then they are wrong.
If we have any literal constraints, check whether there is already a binding that provides a type that conforms to that literal protocol.
If we have any nested archetypes from an outer type, include them verbatim.
If we have any non SEI, TEI instruction, don't do anything here.
If we have any type-adjusting attributes, apply them here.
If we have any unclaimed arguments, complain about those.
If we have any unfulfilled parameters, check them now.
If we have any varargs, we'll need to actually initialize the array buffer.
If we have any warmup requests, replay them before listening for real connections
If we have are recursing into validation and already have a type set...
If we have arrays of arrays, this can try to hash the inner arrays.
If we have conformances we can load, do so.
If we have determined that we need to deviate from the correct algorithm, flip bit 16 in initial expanded key.
If we have either a backwards or a forwards hint, return it---if we have both, return whichever is free the longest.
If we have exactly one argument mismatching, classify it specially, so that close matches are prioritized against obviously wrong ones.
If we have exactly one input filename, and its extension is "bc" or "ll", treat the input as LLVM_IR.
If we have exactly one input filename, and its extension is "sil", treat the input as SIL.
If we have extra inhabitants, we need to check for them in the zero-tag case.
If we have extra optionals on the input type.
If we have extra tag bits, pack the remaining tag bits into them.
If we have extra tag bits, they will be zero if we contain a payload.
If we have extra tag bits, zero them out.
If we have fewer than 2 bytes, give up.
If we have generic parameters, check the generic signature now.
If we have hit a pure Objective-C class, we won't see another ivar destroyer.
If we have insertion points and partial merges, return false to avoid control dependency issues.
If we have json-c then don't use this library since that one has a more permissive licence
If we have left some kind of error message file from MSI the show that
If we have locations for the parens, then they define our range.
If we have matched a delimiter
If we have matched an empty string, mimic what Perl's /g options does.
If we have metadata, go load from that.
If we have more distinct overload choices for this locator than for prior locators, just keep this locator.
If we have more than 2 predecessors, we do not have a pre-header.
If we have more than one solution, do some simple ranking.
If we have multiple candidates that we fail to match, just say we have the wrong labels and list the candidates out.
If we have multiple candidates, then we have an ambiguity.
If we have multiple guard statements in the same block then we may have multiple refinement contexts to pop after walking that block.
If we have multiple introduction versions, we will conservatively assume the worst case scenario.
If we have multiple non-substitutable types, this is just a mismatched mess.
If we have multiple tuple elements, we'll have to do some shifting and truncating of the mask value.
If we have no NoPayloadEnums, then we know that this Arg's RCIdentity must be FirstIV.
If we have no argument, the candidates must have expected one.
If we have no arguments, it's a nullary selector.
If we have no contextual type information and the subexpr is obviously a overload set, don't recursively simplify this.
If we have no contextual type, there is no way to resolve this.
If we have no contextual type, there is nothing to do.
If we have no filter text, add all non-hidden results.
If we have no fixits to apply, avoid touching the file.
If we have no frame just wait for the next instruction to be interpreted.
If we have no input buffered, read from socket, store into m_buffer.
If we have no local context to parse the initial value into, create one for the PBD we'll eventually create.
If we have no more rows to emit, clear the IP and destroy the continuation block.
If we have no name or no type name, there is nothing to do.
If we have no new information to pull in (and nobody else pulled in new information while we waited on the lock), we're done.
If we have no place to step out to, then unwind another frame and try again.
If we have no predecessors, there is nothing to do so return early...
If we have no useful type information from the destination, just type check the source without contextual information.
If we have no viable or unviable candidates, and we're generating, diagnostics, rerun the query with inaccessible members included, so we can include them in the unviable candidates list.
If we have not detected a change yet, then calculate new reachabilities into a new bit vector so we can determine if any change has occurred.
If we have not found user code in this block, inspect it's successors.
If we have not seen a non-trivial field yet, set the FoundNonTrivialField flag.
If we have not seen this color before, find nearest colormap
If we have not seen this color before, find nearest colormap entry
If we have not seen this protocol before, record its index.
If we have not visited this loop yet and it has subloops, add its subloops to the worklist and continue.
If we have nothing to optimize, / it returns false.
If we have one loop latch, continue.
If we have one single type decl, and that decl has been type-checked, return its declared type.
If we have only one nonSubstitutableArg so far, then this different type might be the one that we should be substituting for instead.
If we have parameters, make sure their names get into the resulting function type.
If we have predecessors, where it is not known if they are reached over success or failure path, we cannot eliminate a checked_cast_br.
If we have reached this point, all attempts to do simple simplifications have failed.
If we have reached this point, we found no spec for our target, so we return the other spec ('*'), if we found it, or nullptr, if not.
If we have registered post-send shutdown functions, end the request before executing them.
If we have resolved this nested type to more than one associated type, create same-type constraints between them.
If we have seen a field and thus the FoundNonTrivialField flag is set, return false.
If we have skipped any solutions, move this solution into the next open position.
If we have something that might be an array size expression, parse it as such, for better error recovery.
If we have something to complain about, do so.
If we have spare bits, pack tag bits into them.
If we have spare bits, pack the tag into the spare bits and the tagIndex into the payload.
If we have spare bits, we have to mask out any set tag bits packed there.
If we have tagsets configured for the replicaset then we need to do some more filtering
If we have the SIL as our primary input, we can waive the one file requirement as long as all the other inputs are SIBs.
If we have the VarDecl, use it for more accurate debugging information.
If we have the constraint graph, we can check all type variables in the equivalence class.
If we have the destructor body, we know whether SILGen generated a -dealloc body.
If we have the rebind_self_in_constructor_expr, then the call is the sub-expression.
If we have the second, create a new select_enum with the first case and swap our operands.
If we have the slot, emit a store to it.
If we have the terminating "`", it's an escaped identifier.
If we have to set the name, do so.
If we have too many generic arguments, complain.
If we have two tuples with mismatching types, produce a tailored diagnostic.
If we have type variables that have been bound to fixed types, look through to the fixed type.
If we have undef, just add the case and continue.
If we have unviable candidates (e.g. because of access control or some other problem) we should diagnose the problem.
If we have useful information about the type we're initializing, provide it.
If we have users like that we cannot hoist the release past them unless we know that there is an additional set of releases that together post-dominate this release.
If we have variadic arguments to check, do so now.
If we haven't allocated the lookup table yet, do so now.
If we haven't already promoted the AllocStack, we may see DebugValueAddr uses.
If we haven't checked bounds yet and this is the "first non-zero" case, we have to skip it.
If we haven't computed the canonical signature yet, do so now.
If we haven't found a refinement, record whether one overload is in any way more constrained than another.
If we haven't found any other bindings yet, go ahead and consider the defaulting constraints.
If we haven't found our target yet and the node we are pre-visiting doesn't have a valid range, we still have to traverse it because its subtrees may have valid ranges.
If we haven't found the type yet, look for it now.
If we haven't hit the ping_interval yet, then there is no need to do a roundtrip to the server
If we haven't imported Foundation but this is a whitelisted type, behave as above.
If we haven't made progress, don't add the parameter.
If we haven't made progress, skip ahead
If we haven't resolved the element type, generate constraints.
If we haven't run out of solutions yet, we're done.
If we haven't seen anything significant, avoid useless hoisting.
If we haven't seen this supertype, add it.
If we haven't seen this type result yet, add it to the result set.
If we haven't seen this type variable before, record it now.
If we haven't unwrapped anything before, copy all of the constraints we skipped.
If we haven't walked the member list yet to update the lookup table, do so now.
If we hit EOF, we fail.
If we hit a builtin macro, we're done.
If we hit a macro with invalid or predefined location, we're done.
If we hit a type variable without a fixed type, we can't solve this yet.
If we hit circularity, we will diagnose at some point in typeCheckDecl().
If we hit the beginning of the string, that's it.
If we hit the end of line, then zap whitespace leading up to it.
If we hit the end of the string, that's it.
If we hit the last requirement, record and check this solution.
If we ignore all unknown write, what's the maximum set / of available locations at the current position in the basic block.
If we imported a C pointer type as a non-trivial type, it was a foreign class type.
If we imported a submodule, import the top-level module as well.
If we imported as a tuple type, construct the special method-formal-parameters abstraction pattern.
If we imported the result as something trivial, we need to use one of the unowned conventions.
If we inferred a base name, use that to form the fully qualified name, otherwise treat it as an anonymous type.
If we inline the thunk, we will get the benefit of calling the signature optimized function without additional setup on the caller side.
If we just filled the map with 32 elements we'd grow because of not enough tombstones which masks the issue here.
If we just passed in a name that already has a value like: hhvm.server.apc.ttl_limit max_execution_time then we just return the value now.
If we just visited the FunctionTypeRepr, end traversal.
If we know a-priori that an object-type is a template, and the debug information indicates the object type has no template parameters, do a hacky check on the object type's name.
If we know for sure we're promoting to stdClass, we can put the locType pointing at that.
If we know that an RC root can't be released at a basic block, then we know we do not need to consider it for the killset.
If we know that an RC root can't be retained at a basic block, then we know we do not need to consider it for the killset.
If we know that our base will stay alive, we can emit at +0 for a guaranteed consumer.
If we know that there is another decrement on the same pointer that has not been matched up to an increment, then the pointer must have a reference count of at least 2 before this decrement.
If we know that this terminator is not an exit terminator, continue.
If we know the ID already...
If we know the associated type, look in the witness table.
If we know the class without having to specialize a guard any further, use it.
If we know the failure message, use that.
If we know the offset won't change, make it a constant.
If we know the platform runtime's "done" value, emit the check inline.
If we know the requested argType to use, use computeTupleShuffle to produce the shuffle of input arguments to destination values.
If we know the type representation is invalid, just return an error type.
If we know the type to have a fixed nonempty size, then the pointer is dereferenceable to at least that size.
If we know this is a designated initializer, mark it as such.
If we know we don't have any type variables, we're done.
If we know we have a fixed stride different from our size, or we have a dynamic size, do a byte-level GEP with the proper stride.
If we know we're removing a contextual constraint, then we can force a type check of the subexpr because we know we're eliminating that constraint.
If we know what type declaration we're referencing, store it.
If we leave this frame in the interpreter, we might be skipping a catch block that our caller expects to be run.
If we locally know that the type has fixed layout, we can emit meaningful flags for it.
If we loop on ourselves, bail...
If we make the function better later we'll remove the tests.
If we matched anything above, update the name appropriately.
If we may write to the property we need to allow the array to escalate
If we meet some day, and you think this stuff is worth it, you can buy me a beer in return.
If we merged blocks, there could be new optimization opportunities
If we met a store before this one, delete it.
If we miss an increment from any of the payloaded case there is nothing we can do here, so skip this enum value.
If we naively bind the type variable to the parameter tuple, we'll later end up looking to whatever expression created the type variable to find the declarations for default arguments.
If we need a conversion, add one now.
If we need to complete an override, collect the keywords already specified so that we do not duplicate them in code completion strings.
If we need to diagnose this as a bad reference to an initializer, do so now.
If we need to handle throwing cleanups, the correct thing to do here is to recreate the exception's cleanup when emitting each cleanup we branch through.
If we need to infer 'dynamic', do so now.
If we need to perform dynamic dispatch for the given function, emit class_method to do so.
If we need to recur, emit a new block.
If we need to use Objective-C allocation, do so.
If we needed a cast, wrap the pattern in a cast pattern.
If we never executed then we fall back to generic get.
If we only care about a subset, and this type variable isn't in that subset, skip it.
If we only had such users of Agg and Agg is dead now (ignoring debug instructions), remove it.
If we only have one predecessor see if we can gain any information and or knowledge from the terminator of our one predecessor.
If we only have the parameter type, output the type as a placeholder.
If we only need to capture a single Swift-refcounted object, we still need to build a thunk, but we don't need to allocate anything.
If we only want types and we didn't get one, bail out.
If we opened up an existential when performing the subscript, open the base accordingly.
If we opened up an existential when referencing this member, update the base accordingly.
If we opened up any type variables, record the replacements.
If we overflow and are not asked for diagnostics, just return nullptr.
If we overrode a decl from an extension, it won't be in a vtable either.
If we overrode a non-required initializer, there won't be a vtable slot for the allocator.
If we parsed 'class' or 'static', but didn't handle it above, complain about it.
If we parsed a .sil file that is already in canonical form, don't rerun the diagnostic passes.
If we parsed a bare closure as an expression, it will be a discarded value expression and the type checker will complain.
If we parsed an inout modifier, prepend it.
If we parsed something valid, diagnose it with a fixit to rewrite it to Swift syntax.
If we passed fewer than kNumFixedPrologues, argc is still a valid index into the prologue table.
If we passed more args than declared, we might need to dispatch to the "too many arguments" prologue.
If we passed the last concat, just append the remaining bytecode.
If we previously decided not to try to hoist checks for this SSATmp then skip this check too.
If we previously set PCRE_NOTEMPTY after a null match, this is not necessarily the end.
If we pulled a lookahead token, we need to remove it from the lookahead store
If we ran out of solutions at the first position, we're done.
If we ran out of superclasses, we're done.
If we re-enter bt_handler while already crashing, just abort.
If we reach a bad point, just return null
If we reach here it means we've found an inaccessible private method in cls's method table, handle the failure as appropriate.
If we reach here then an error occurred (typically a missing path).
If we reach here then valType is Obj and tc is Object, Self, or Parent
If we reach here, takenBlk cannot be merged into block as it has other predecessors.
If we reach here, then HardReturnTypeHints is true AND the constraint is not soft.
If we reach here, this is an equality comparison against a constant.
If we reach situations that would break that restriction, we must handle it conservatively (using a `pessimized' state, which is discussed some later, as a last resort).
If we reach the end of the pattern without matching, display a warning.
If we reach this point and do not have a pointer, be conservative and return that the two types may alias.
If we reach this point, we know that the types must be different since otherwise simplifyInstruction would have handled the identity case.
If we reached this point, then this type has no subrecords.
If we referenced a non-fragile shared function from a fragile function, serialize it too.
If we reinitialize we return / true.
If we rejected some possibilities due to an argument-label mismatch and ended up with nothing, try again ignoring the labels.
If we require a dynamic allocation of the object here, do so now.
If we require a postfix operator and the witness is not a postfix operator, these don't match.
If we require a prefix operator and the witness is not a prefix operator, these don't match.
If we resolved down to an error, make sure to mark the typeRepr as invalid so we don't produce a redundant diagnostic.
If we resolved everything, we're done.
If we resolved the constructor member, return it.
If we return indirectly, that is the first parameter type.
If we return true, we deserialized at least one function.
If we returned, then the cast succeeded.
If we run into a type we don't recognize, there's either been some corruption or we've messed up on the parsing.
If we run into any errors parsing getting any types for a type list we need to bail out and return an error.
If we run into one of the known protocols, zap it from the original list.
If we saved any global ivar offsets, make sure we write back to them.
If we saw a conflict, complain about it.
If we saw a non arc user that will keep this value alive, set known safe since we will not move non-arc instructions.
If we saw an ErrorExpr somewhere in the body, then we have a malformed AST and we know stuff got dropped.
If we saw an ErrorExpr, take note of this.
If we saw an init_existential_addr in the use list of the alloc_stack, / this is the init_existential_addr.
If we saw an open_existential_addr in the use list of the alloc_stack, / this is the open_existential_addr.
If we saw any default arguments before this, complain.
If we saw dynamic constants we cannot cache the enum values across requests as they may not be the same in every request.
If we saw more than one identifier, there's a ':' missing here.
If we saw no operators, don't build a sequence.
If we see a bound reference to a decl in an inactive #if block, then conservatively mark it read and written.
If we see a closing parentheses, we're done.
If we see a closing parenthesis,
If we see a closing parenthesis, we're done.
If we see a potential argument label followed by a ':', consume it.
If we see a property reference with an implicit base from within a closure, then reject it as requiring an explicit "self." qualifier.
If we see a store here, we have already checked that we are storing into the pointer before we added it to the worklist, so we can skip it.
If we see a tuple-to-tuple conversion that succeeded, we're done.
If we see an OpenExistentialExpr, remember the mapping for its OpaqueValue.
If we see an alloc_box as the pointer, then we're deallocating a 'box' for self.
If we see an explicit type annotation, coerce the sub-pattern to that type.
If we see another identifier or keyword, complain about the missing colon and keep going.
If we see another use of Dest, then Dest is live after the Src location is initialized, so we really need the copy.
If we see another use of Src, then the source location is reinitialized before the Dest location is deinitialized.
If we see any continuations at a higher level, process them.
If we see any lowercase characters, we can lowercase.
If we see one at top level, diagnose that it must be part of an assignment so we don't get a generic "expression is ambiguous" error.
If we see one, we can produce a single instruction, which doesn't require a CFG diamond.
If we see that there is an outstanding weak retain of the object, we need to fall back on swift_release, because it's possible for us to race against a weak retain or a weak release.
If we see two checks on the same SSATmp with non-intersecting types then give up on hoisting this particular SSATmp.
If we see whitespace in the format, skip whitespace in the string.
If we set up an initialization context for a property or module-level global, check to see if we needed it and wind it down.
If we should attempt fixes, add those to the list.
If we should call an accessor of some kind, do so.
If we should import this instance method also as a class method, do so and mark the result as an alternate declaration.
If we should use a super access if applicable, and we have an overridden decl, then use ordinary access to it.
If we side exit in an inlined callee, we short-circuit here in order to skip exit events that could unbalance the call stack.
If we simply ignored the fact that a new pointer has been created at the store, that means the lower bound would be two after the two IncRefs, with no memory support flags.
If we somehow reach this point and both gname and gid were passed, then the gid values will override the gname values, but it will otherwise function just fine.
If we somehow reach this point and both name and uid were passed, then the uid values will override the name values, but it will otherwise function just fine.
If we specialized this on Vector we could use a DecRefNZ here (since we could assume that initElem has incref'd the value).
If we spilled tag bits, however, we can offer the unused bits we have in that byte.
If we started with a metatype, it's a metatype.
If we statically know the source is an NSError subclass, then the cast can go through the scalar path (and it's trivially true so can be killed).
If we still haven't claimed all of the arguments, fail.
If we still haven't found a refinement, check if there's a parameter- wise comparison between an empty existential collection and a non- existential type.
If we store the alloca pointer, we cannot analyze its uses so bail...
If we succeed in walking the entire graph of uses, we can remove the resultant set.
If we succeed return the deserialized function.
If we succeeded, get ready to do the member lookup.
If we succeeded, return the witnesses.
If we succeeded, take from the optional buffer into the destination buffer.
If we succeeded, use the coerced result.
If we successfully applied an update close the window since the new Bundle should be running now.
If we support the specialization of closures with multiple user callsites /    that can be specialized, we need to ensure that any captured values have /    their reference counts adjusted properly.
If we syntactically match the second decl-var production, with a var-get-set clause, parse the var-get-set clause.
If we took a default argument index for this parameter, but didn't add one, then give it back.
If we track dependencies for this job, we may be able to avoid running it.
If we tried to include the function body along with a DV init, but didn't end up generating any DV init, then flag that the function body was not included.
If we try to have a common implementation, we're left with the problem of describing the layout of a node when that's technically instantiation-specific.
If we type checked the result but failed to get a usable output from it, just pretend as though nothing happened.
If we unwrapped anything, our list of constraints is the unwrapped list.
If we used TheAccessSemantics::Ordinary here, the only downside would be unnecessary vtable dispatching for class materializeForSets.
If we used extra inhabitants to represent empty case discriminators, weed them out.
If we used the entire value, we're done.
If we visited an increment or decrement successfully (and thus Op is set), if this is the state for this operand, skip it.
If we want a super.init call...
If we want an rvalue, get the rvalue.
If we want dynamic lookup and this is the AnyObject protocol, note this for later.
If we want dynamic lookup and we're searching in the AnyObject protocol, note this for later.
If we want member types only, use member type lookup.
If we want to delete the initializer we also have to delete the allocation.
If we want to perform lookup into all classes, do so now.
If we wanted a continue destination, it would probably be out here.
If we were able to find a method call, emit a diagnostic about the method.
If we were able to find a method or function call, emit a diagnostic about the method.
If we were able to move the retain down, move it now.
If we were able to process each predecessor successfully, return true.
If we were able to solve this without considering default literals, don't bother looking at default literals.
If we were already pointing to a basic block, remove ourself from its predecessor list.
If we were asked to ignore top-level optional injections, mark the top-level injection (if any) as "diagnosed".
If we were asked to print Clang stats, do so.
If we were created with a temporary, that address was passed as an indirect result.
If we were given a mangled name, do a very simple form of LLDB's logic to look up a type based on that name.
If we were in inline-and-all-clear mode, the vector might logically be much longer than a single chunk, but all-zero.
If we were never put on NamedEntity::classList, or we've already been destroy'd, there's nothing to do
If we were properly handling overrides of protocol members when requirements get restated, it would not be necessary.
If we were terminating and this was the last pending event then trigger the delete.
If we weren't able to resolve a member or if it is mutable, then the problem must be with the base, recurse.
If we weren't already adjacent to this type variable, add it to the list of adjacencies.
If we weren't handed a function, check for an existing declaration in the output module.
If we weren't merging this way, we would have to union the incoming memory bits, which easily leads to situations where more than one must alias set is supported by the same memory location.
If we weren't told what kind of initializer this should be, figure it out now.
If we won't be able to provide a result, bail out.
If we would import a factory method as an initializer but were asked not to, don't consider this as an initializer.
If we wrap over the end of the page, allocate a new page.
If we zapped or moved the retain, reset the iterator on the instruction *newly* after the prev instruction.
If we're "constructing" a tuple type, it's simply a conversion.
If we're able to do an unscoped lookup, we see everything.
If we're able to take the dynamic value, then clean up any leftover buffers it may have been contained in.
If we're aborting we already wrote the end request.
If we're about to enter an exception handler we turn interrupts on to ensure we stop when control reaches the handler.
If we're about to step out of a ClosureExpr, restore the DeclContext.
If we're accessing this member with an abstraction change, perform that now.
If we're actually turning this into an lvalue tuple element, don't load.
If we're adjusting the name, erase the error parameter.
If we're allowed to bind to subtypes, look through optionals.
If we're allowed to do a conservative check, try to just use the global class symbol.
If we're already assigned a component for this node, skip it.
If we're already in memory for some reason, great.
If we're already materialized, we're done.
If we're already processing an interrupt, enable signal polling around the execution of the new PHP to ensure that we can handle signals while doing so.
If we're already substituting a concrete type, mark this potential archetype as having a recursive concrete type.
If we're already validating the type declaration's generic signature, avoid a potential infinite loop by not re-validating the generic parameter list.
If we're an InnerHandle, someone already checked that, but we want to check for whether it's uncounted to use a better representation.
If we're appending to the file, start a new section
If we're applying a function that resulted from a covariant function conversion, strip off that conversion.
If we're applying an operator function to a nil literal operand, we disallow value-to-optional conversions from taking place so as not to select an overly permissive overload.
If we're applying more arguments than the natural argument count, then this is a call to the opaque value returned from the function.
If we're asked to convert to an UnresolvedType, then ignore the request.
If we're asked to convert to an autoclosure, then we really want to convert to the result of it.
If we're asking about parameters, we'd better have a FunctionProtoType.
If we're asking for something after the error parameter, slide the parameter index up by one.
If we're assigning to a discard, just emit the operand as ignored.
If we're at 'else', take the indent of 'if' and continue.
If we're at the beginning of a brace on a separate line in the context of anything other than BraceStmt, don't add an indent.
If we're at the bottom-most level, collect depthless requirements.
If we're at the end of a brace on a separate line in the context of anything other than BraceStmt, don't add an indent.
If we're at the end of a closure, paren or tuple expr, and the context is a paren/tuple expr ending with that sub expression, and it ends on the same line, don't add an indent.
If we're at the open brace of a NominalTypeDecl or ExtensionDecl, don't add an indent.
If we're at the open brace of a no-name getter, don't add an indent.
If we're at the open brace of the switch, don't add an indent.
If we're at the start of a case label, don't add indent.
If we're being asked to simplify this, it better be dynamically unreachable code.
If we're beyond nParams, then either all params are refs, or all params are non-refs, so if vals64 isn't 0 and isnt mask64, there's no possibility of a match
If we're binding an address to this let value, then we can use it as an address later.
If we're binding to an empty existential, we need to make sure that the conversion is valid.
If we're binding to an init member, the 'throws' need to line up between the bound and reference types.
If we're building with -sil-serialize-all, give the conformance public linkage.
If we're calling a member of a non-class-constrained protocol, but our archetype refines it to be class-bound, then we have to materialize the value in order to pass it indirectly.
If we're calling an accessor, keep the base as an inout type, because the getter may be mutating.
If we're capturing an unowned pointer by value, we will have just loaded it into a normal retained class pointer, but we capture it as an unowned pointer.
If we're capturing into a non-escaping closure, we can generally just capture the address of the value as no-escape.
If we're casting Null to NullableObj, we still need to call tvCastToNullableObjectInPlace.
If we're casting to NSError, we may need a representation change, so fall into the general swift_dynamicCast path.
If we're casting to an optional type, we need to capture the final M bindings.
If we're checking conformance of an existential type to a protocol, do a little bit of extra work to produce a better diagnostic.
If we're close to a cache line boundary, just burn some space to try to keep the func and its body on fewer total lines.
If we're coercing to an rvalue type, just do it.
If we're coming from an optional type, unwrap the optional and try again.
If we're coming from unreachable code and the dst is already initialized, it doesn't change the dst (whether it is reachable or not).
If we're complaining about a function type, don't "aka" just because of differences in the argument or result types.
If we're completing a generic TypeAlias, then we map the types provided onto the underlying type.
If we're connected to a machine that is attached to a sandbox, then we'll have an ID.
If we're conservative scanning everything, we need to take no special action, as the above problem only applies to auto generated scanners.
If we're constraining guards, some instructions need certain information to be recorded in side tables.
If we're converting on the behalf of an AutoreleasingUnsafeMutablePointer, convert the lvalue to unowned(unsafe), so we can point at +0 storage.
If we're converting to an UnsafeMutablePointer, then the pointer to the first element is being passed in.
If we're creating trivial accessors for a stored property of a nominal type, the stored property is either witnessing a protocol requirement or the nominal type is resilient.
If we're currently doing rethrows-checking on the body of the function which declares the parameter, it's rethrowing-only.
If we're currently looking at a .sil and the conflicting declaration comes from a .sib, don't error since we won't be considering the sil from the .sib.
If we're currently looking for this selector, don't load any Objective-C methods.
If we're currying a direct reference to a class-dispatched method, make sure we emit the right set of thunks.
If we're debugging, we probably don't have a main.
If we're default-initializing this member, there's nothing to do.
If we're diagnostic an issue with 'nil', produce a specific diagnostic, instead of uttering NilLiteralConvertible.
If we're directly at the top, it's implicit.
If we're doing a conditional cast, and the ObjC protocol checks failed, then the cast is done.
If we're doing a lookup for diagnostics, include inaccessible members, the diagnostics machinery will sort it out.
If we're doing a merge on a path that's previously seen a partial merge, conservatively drop the sequence, to avoid doing partial RR elimination.
If we're doing a metatype cast, it can only be existential if we're casting to/from the existential metatype.
If we're doing a multi-dimensional set, this will point at the m_data.parr inside of a RefData sometimes (via toArrRef on the variants in gpc_elements).
If we're doing a partial match or we have an initial parameter, return the empty string.
If we're doing progress then we never close, we just cancel to let rollback occur.
If we're doing takeover, we don't want to gracefully close the socket.
If we're emitting into an initialization, we can try shuffling the elements of the initialization.
If we're emitting optimized code, record the string in the module and let the late ARC pass insert it, but don't generate any calls right now.
If we're emitting this operation into the middle of existing code, we split the block.
If we're emitting to an address, just manage that.
If we're emitting to memory, project out this element in the destination buffer, then wrap that in an Initialization to track the cleanup.
If we're emitting top-level code, then emit a "mark_function_escape" that lists the captured global variables so that definite initialization can reason about this escape point.
If we're entering at a DV-init, all higher parameter locals must be Uninit.
If we're expecting a member within a constrained extension with a particular generic signature, match that signature.
If we're expecting an initializer with a specific kind, and this is not an initializer with that kind, remove it.
If we're extending a protocol, check the generic parameters.
If we're generating a profile, add the lowering pass now.
If we're generating constraints for a binary operator application, there are two special situations to consider: 1.
If we're going to code currently believed to be unreachable, take the src state, and consider the dest state changed only if the source state was reachable.
If we're going to recurse, record this expression on the stack.
If we're here, the string ended incorrectly
If we're here, then the only things left are sleepers.
If we're implicitly trying to treat an optional type as a boolean, let the user know that they should be testing for a value manually instead.
If we're importing a specific decl, validate the import kind.
If we're in -verify mode, we've buffered up all of the generated diagnostics.
If we're in REPL mode, inject temporary result variables and other stuff that the REPL needs to synthesize.
If we're in a DoCatchStmt and at a 'catch', don't add an indent.
If we're in a comma-separated list and the next token starts a new declaration at the beginning of a new line, skip until the end.
If we're in a defer, produce a tailored diagnostic.
If we're in a designated initializer the object might already be fully initialized.
If we're in a designated initializer, the elements of the memory represent instance variables -- after destroying them, we have to destroy the class instance itself.
If we're in a for loop, the offsets need to be biased by the loop iteration.
If we're in a generic context, set the interface type.
If we're in a generic type context, provide interface types for all of the variables.
If we're in a nested inlined call and we just eliminated a DefInlineFP we can eliminate it from the use map which may allow us to optimize its parent.
If we're in a nominal type, just query the type.
If we're in a protocol extension initializer, we haven't allocated "self" yet at this point.
If we're in a protocol or extension thereof, the setter thunk will be polymorphic.
If we're in a protocol, the getter thunk will be polymorphic.
If we're in a subelement of a struct or enum, just mark the struct, not things that come after it in a parent tuple.
If we're in an IfStmt and at the 'else', don't add an indent.
If we're in an inout conversion scope, disable nested writeback scopes.
If we're in the Created state we want to transition to Priming, and if we're in the Started state we want to transition to Running.
If we're in the initializer for a struct, and this is a call to a mutating method, we model that as an escape of self.
If we're in top-level code, we don't need to physically capture script globals, but we still need to mark them as escaping so that DI can flag uninitialized uses.
If we're in verify mode, install a custom diagnostic handling for SourceMgr.
If we're inheriting a default argument, mark it as such.
If we're initializing a weak or unowned variable, this requires a change in type.
If we're initializing the varargs list, use its base type.
If we're inlining into a normal apply and the callee's entry block ends in a return, then we can avoid a split.
If we're inlining into a try_apply, we already have a return-to BB.
If we're introducing a level of optionality, only certain types are ABI-compatible -- check below.
If we're just setting an error, double-check that nobody has introduced a type declaration since we deduced one.
If we're looking at members of a protocol or protocol extension, filter by whether we expect to find something in a protocol extension or not.
If we're looking for all names or for an initializer, resolve implicitly-declared initializers.
If we're looking for initializers, only look at the superclass if the current class permits inheritance.
If we're looking in a particular context and it doesn't match the entry context, we're done.
If we're looking into a metatype for an unresolved member lookup, look through optional types.
If we're looking into an existential type, check whether this result was found via dynamic lookup.
If we're looking into an instance, skip static functions.
If we're looking to define something, we may need to replace a forward declaration.
If we're looking up a dependent type, we can't cache the result.
If we're matching the base name of a method against the type of 'Self', and we haven't matched anything yet, skip over words in the name.
If we're missing a semicolon, try to recover.
If we're missing semi-colons we'll already be erroring out, and this may not even have been intended as C-style.
If we're missing the module we're shadowing, treat that specially.
If we're monomorphic, we'll emit a check for that specific Shape.
If we're not allowed to complain or we couldn't fix the source, bail out.
If we're not allowed to look in the runtime library import path, stop.
If we're not allowed to try this binding, skip it.
If we're not at the top level, need to grab the call sites for each frame on the stack.
If we're not changing anything, we're done.
If we're not checking a 'rethrows' context, we don't need to distinguish between 'throws' and 'rethrows'.
If we're not coming from something function-like, prepend the type for 'self' to the type.
If we're not defining the object now, forward declare it with the default type.
If we're not doing Objective-C interop, we can just skip adding it to the class.
If we're not doing a pre-req install, remember when our bundle would cause a downgrade.
If we're not doing private property inference, schedule only function-at-a-time work items.
If we're not done type checking, build the getter body.
If we're not emitting diagnostics, we're done.
If we're not emitting into a temporary, just wrap up the result in None and go to the continuation block.
If we're not emitting into a temporary, just wrap up the result in Some and go to the continuation block.
If we're not emitting into memory (which happens both because the type is address only or because we have a contextual memory location to initialize).
If we're not emitting to memory, remember this element for later assembly into a tuple.
If we're not in a local context, this is unnecessary.
If we're not in a local context, we'll need a context to parse initializers into (should we have one).
If we're not in a type context, just grab the interface type.
If we're not in immediate mode, pick up inputs via the -- option.
If we're not in the body of the function, the base declaration is the nominal type, not 'self'.
If we're not including literals, fallback to keywords as appropriate.
If we're not limited the set of interesting conformances, or if this is an interesting conformance, record it.
If we're not looking at a protocol and we're not supposed to visit the protocols that this type conforms to, skip the next step.
If we're not parsing an active #if block, form a new lexical scope.
If we're not passing down contextual type information this time, but the original failure had type info that wasn't an optional type, then set the flag to prefer fixits with force unwrapping.
If we're not returning self, then return () since we're returning Void.
If we're not supposed to attempt any fixes, we're done.
If we're not supposed to define the accessor, or if we already have defined it, just return the pointer.
If we're not supposed to minimize the result set, just return eagerly.
If we're not supposed to visit our supertypes, we're done.
If we're not using the Objective-C runtime, we can use the native reference counting entry points.
If we're omitting needless words and the name won't conflict with something in the standard library, strip the prefix off the Swift name.
If we're on the eager side of an async function, we have to zero-out the TV aux of the return value, because it might be used as a flag if we were called with FCallAwait.
If we're only dealing with two containers and if they are both arrays, we can avoid creating an intermediate Set
If we're only installing prereq, do not touch related bundles.
If we're only looking to resolve the structure of the type, don't walk into generic arguments.
If we're optimizing a repo that was already created by hphpc, it won't have the full SourceLocTable information in it, so we're limited to line numbers.
If we're out of colors, go for the closest color
If we're parsing an expression as the body of a refutable var/let pattern, then an assignment doesn't make sense.
If we're passing multiple parameters, then this isn't a tuple splat.
If we're planning to install a pre-req, install it.
If we're polymorphic, we'll also fall back to generic get.
If we're printing recursively, find all of the submodules to print.
If we're re-typechecking an expression for diagnostics, don't visit closures that have non-single expression bodies.
If we're reading a .sil file, treat a call to "selfinit" as a self.init call as a hack to allow us to write testcases.
If we're reading a .sil file, treat a call to "superinit" as a super.init call as a hack to allow us to write testcases.
If we're reading and the getter is mutating, or we're writing and the setter is mutating, this is readwrite.
If we're really doing ArrayIdx, it's nullptr.
If we're referencing AnyObject and we have argument labels, put the argument labels into the name: we don't want to look for anything else, because the cost of the general search is so high.
If we're referring to an invalid declaration, don't type-check.
If we're referring to an invalid declaration, fail.
If we're referring to the member of a module, it's just a simple reference.
If we're regenerating a prologue, and we want to check shouldTranslate() but ignore the code size limits.
If we're remote debugging, this proxy will go unused until we finally stop it when the user quits the debugger.
If we're removing something (e.g. a keyword), do a bit of extra work to make sure that we leave the code in a good place, without extraneous white space around its hole.
If we're returning a +1 value, emit a cleanup for the member to cover for the cleanup we disabled for the tuple aggregate.
If we're returning from a function, it's ReturnEffects.
If we're script debugging, this will be the proxy that does all of our work.
If we're serializing all function bodies, type metadata for internal types needs to be public too.
If we're setting up a TopLevelCodeDecl, configure it by setting up the body that holds PBD and we're done.
If we're shutting down do not write any more data.
If we're shutting down don't process any further requests, we may be freed
If we're shutting down the socket is closed.
If we're skipping forward and were running, the run ended.
If we're starting with an ObjC representation, convert it to a class type and let's go.
If we're still looking up for the original type, remember that we found an exact match.
If we're storing a (valid) Zend resource, call its destructor (if any).
If we're supposed to convert the expression to some particular type, do so now.
If we're supposed to create a varargs array with the rest, do so.
If we're supposed to debug a specific constraint solver attempt, turn on debugging now.
If we're supposed to disable autolinking of this framework, bail out.
If we're supposed to drop the preposition, do so.
If we're supposed to ignore this macro, return an empty identifier.
If we're supposed to pass directly as a struct type, that really means expanding out as multiple arguments.
If we're supposed to remove overridden declarations, do so now.
If we're supposed to remove shadowed/hidden declarations, do so now.
If we're supposed to visit submodules, add them now.
If we're suppressing diagnostics, just fail.
If we're suppressing error paths, just wrap it up as unreachable and return.
If we're suppressing the check, just do an unchecked take.
If we're suppressing the check, just don't check.
If we're synthesizing forward declarations, we don't want to pull in the module too eagerly.
If we're testing for the payload element, we cannot directly check to see whether it is present (in full generality) without doing a switch.
If we're thunking a static function reference, include its symbol name in the thunk name.
If we're translating *from* the foreign expansion, do an ordinary load into the output explosion.
If we're translating *to* the foreign expansion, do an ordinary initialization from the input explosion.
If we're translating *to* the foreign expansion, pull the value out of the field and add it to the output.
If we're type checking this pattern in a context that can provide type information, then the lack of type information is not an error.
If we're using a box for self, reload the value at the end of the init method.
If we're using a local context (either a TopLevelCodeDecl or a PatternBindingContext) install it now so that CurDeclContext is set right when parsing the initializer.
If we're using checked_cast_addr, take the operand (which should be an address) and build into the destination buffer.
If we're using the allocating constructor, we need to pass along the metatype.
If we're using the scalar strategy, handle the consumption rules.
If we're using this conformance and it is incomplete, queue it for completion.
If we're walking into a tuple within a struct or enum, don't adjust the BaseElt.
If we're within a case body, it's implicit.
If we're within a container, add an implicit first pattern to match the container type as an element named 'self'.
If we're within an implicit brace context, don't add indent.
If we're working with an r-value, just expand it out and emit all the elements individually.
If we're working with non-optional types, we're forcing the cast.
If we've already agreed upon an overloaded return type, use it.
If we've already been bound to a type, we're either done, or we have a problem.
If we've already checked this at a higher level, we're done.
If we've already checked this declaration, don't do it again.
If we've already created this type witness, return it.
If we've already determined this witness, skip it.
If we've already diagnosed this attribute, keep going.
If we've already done this check, return the cached result.
If we've already emitted this witness table, return it.
If we've already seen this (e.g. decls overridden on the result type), ignore this one.
If we've already seen this node in this component, we're done.
If we've already seen this object, return
If we've already seen this object, return.
If we've already seen this partial apply, then it means the same alloc box is being captured twice by the same closure, which is odd and unexpected: bail instead of trying to handle this case.
If we've already succeeded or failed or showing the help page, just close (prompts are annoying if the bootstrapper is done).
If we've already successfully type-checked the expression for some reason, just return the type.
If we've already synthesized accessors or are currently in the process of doing so, don't proceed.
If we've already tried this binding, move on.
If we've already validated this type, don't do so again.
If we've bound names already, verify as a bound node.
If we've checked types already, do some extra verification.
If we've claimed all of the arguments, there's nothing more to do.
If we've collected more redundant cond_fails then remove them now.
If we've collected redundant cond_fails then remove them now.
If we've consumed any tokens at all, build an error expression covering the consumed range.
If we've done many iterations without progress, pop the current function and any other function we've run any optimizations on on from the stack and then continue.
If we've drained the entire sequence, we're done.
If we've ended up trying to assign an inout type here, it means we're missing an ampersand in front of the ref.
If we've found a 'throw', record it and terminate the traversal.
If we've found a 'try', record it and terminate the traversal.
If we've found something, we're done.
If we've got a scalar and want a scalar, the source is exactly right.
If we've gotten here, it's an unsupported expression type.
If we've hit Eval.JitGlobalTranslationLimit, then we stop translating.
If we've imported this variable as a member, it's a static member.
If we've never seen this nominal type before, or if we have an out-of-date negative cached value, we'll have to go looking.
If we've reached an implicit return, we have not found any user code and can stop searching for it.
If we've reached this point, the optimization is valid, so optimize.
If we've resolved to an associated type, use it.
If we've run off the top of the stack, just return having setup no step outs.
If we've seen a declaration with this signature before, note it.
If we've seen a type witness for this associated type that conflicts, there is no solution.
If we've started shutting down then don't start the transport job.
If we've successfully checked all of the definitive initialization requirements, try to promote loads.
If were decremented, insert the insertion point.
If wes till don't know, check whether we have a class with a superclass: it gets an implicit chained initializer.
If what remains is a verb, we have a gerund.
If what we found is a plural suffix, keep going.
If when analyzing, we found a user that makes our optimization, illegal, bail early.
If when checking for insertion points, we find that we have non-leaking early exits, clear state and bail.
If when we're done alreadyValid is false, and pvalid is also nullptr, it means this function freed the last strong iterator.
If will probably be a common typo to write "if let case" instead of "if case let" so detect this and produce a nice fixit.
If witnesses for two difference requirements inferred the same type, we're okay.
If x is not modified in the closure body and is only loaded.
If yes, return / the SILGlobalVariable that it writes to.
If yes, the swift_bufferAllocateOnStack is replace with an alloca plus a call to swift_initStackObject and the swift_bufferDeallocateFromStack is removed.
If yes, we set the initial value of the SILGlobalVariable and / remove the "once" call to globalinit_func from the addressor.
If you add anything to this list, change the default size of PlatformConditionValues to not require an extra allocation in the common case.
If you add new imm types, you must add a printer for it here.
If you are setting an int, it does the string parsing once and then when you read it, it is already an int.
If you call it for one that doesn't, you'll get an abort.
If you can't get a unique character in the first 256 chars of your hostname, you're doing it wrong.
If you change the cache type make sure that property holds or fix this function.
If you change the layout in the header, you'll need to change it here.
If you change the logic here, please also update the error message in ps_files_open() appropriately
If you change this function, you must add or modify a test in PrintAsObjC.
If you change this value then also change bug24640.phpt.
If you change this, also change TRY_KIND_SELECT in diagnostics.
If you change this, change manageBufferForExprResult below as well.
If you define some other weird order in jmorecfg.h, you'll get compile errors until you extend this logic.
If you don't have a nice square root function for longs, you can use this hack
If you don't pass a namespace uri, then you can't set a prefix
If you don't set returnSeen things relating to hoistability break.
If you have an implicit location, use createImplicit.
If you have some other initialization that must be done asynchronously, then you can defer this call until after that initialization is done.
If you hit this assertion, you're gen'ing an IR instruction that can throw after gen'ing one that could write to the evaluation stack.
If you hit this assertion: you've created a catch block and then modified tracked state, then generated a potentially exception-throwing instruction using that catch block as a target.
If you hit this, you popped a rank that was never pushed.
If you manually call dispose on the Java object, the native object will be deleted synchronously on that thread.
If you specify textaddr/textaddrlen, a text-printable version of the address will be emalloc'd and returned.
If you take one or the other it's possible for normal context insensitive return types in the index to get bigger instead of getting smaller.
If you try to add or replace a method to a class that isn't initialized yet, the Objective-C runtime will crash in the calls to class_replaceMethod or class_addProtocol.
If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
If you want to allow partial orders, make the constituent locks unranked.
If you want to override the dot attributes printed for a particular / edge, override this method.
If you want to use this code to quantize a non-RGB color space, you'll probably need to change these scale factors.
If you're considering calling this function for some new code, please reconsider.
If you're inheriting a constant with the same name as an existing one, they must originate from the same place, unless the constant was defined as abstract.
If you're not defining the class, you shouldn't have to know what the vtable layout is.
If zero, do what YYDEFACT says.
If/when PHI nodes can be updated without invalidating the CFG, / this should be moved to the SROA pass.
Ignore IFD2 if it purportedly exists
Ignore J-edges that point to nodes that are not smaller or equal to the root level.
Ignore SCCs of size 1 for now.
Ignore _ObjectiveCBridgeable conformances in C.
Ignore a failed super.init requirement.
Ignore abstract entries if so requested.
Ignore accessibility so we get candidates that might have been missed before.
Ignore accessor methods (e.g. getters and setters), they will be handled when their storage decl is processed.
Ignore all instructions with no side effects.
Ignore any accesses inside addressors for SILG
Ignore any instructions without side effects.
Ignore any other decl-name productions for now.
Ignore any stub implementations.
Ignore blocks that allow leaks.
Ignore blocks that are successors of terminators with mandatory args.
Ignore blocks with more than one instruction.
Ignore blocks with no arguments.
Ignore both of these.
Ignore chdir failures, because the compiled version might not have the directory any more.
Ignore classes that are at the top of the class hierarchy:
Ignore compiler-generated patterns but not optional bindings.
Ignore dummy entries semitted for non-method requirements, as well as requirements without default implementations.
Ignore empty arguments (other things may still take them as arguments).
Ignore empty specializations.
Ignore empty structs.
Ignore entire object.
Ignore entries for instructions that got expanded along the way.
Ignore equality constraints to concrete types.
Ignore everything other than PBDs.
Ignore everything, a trivial scanner
Ignore expression patterns, which we should have bound in an earlier pass.
Ignore fields with a default value.
Ignore fix_lifetime instructions.
Ignore function calls which do not write to the stack location.
Ignore include guards.
Ignore indirect parameters for now.
Ignore instances of the type with this type index. If this is true, and conservative is true as well, it means that the conservative scan is still conditional.
Ignore instructions which don't write to the stack location.
Ignore invalid and anonymous declarations.
Ignore invalid escapes.
Ignore it unless the type itself is interesting.
Ignore let values captured without a memory location.
Ignore lvalues in the base type.
Ignore matched releases.
Ignore metatype argument
Ignore methods starting with underscores
Ignore moves from a register to itself
Ignore non-same-type requirements in this pass.
Ignore non-scriptable properties
Ignore non-stores for SelfInits.
Ignore non-type declarations.
Ignore non-types found by name lookup.
Ignore other declarations.
Ignore parens and other easy cases.
Ignore parentheses and implicit conversions.
Ignore pieces of the range that go onto other lines.
Ignore possible error(s)
Ignore properties starting with underscores
Ignore protocols that don't have witness tables.
Ignore reference counting and debug instructions.
Ignore removed instructions.
Ignore results from the Objective-C "Foundation" module.
Ignore results that are not the right kind of nominal type declaration.
Ignore results that aren't actually from the defining module.
Ignore retains of the struct/enum before the return.
Ignore scope-less instructions and have IRBuilder reuse the previous location and scope.
Ignore size specifier.
Ignore spaces and empty strings.
Ignore specific base.
Ignore stub implementations.
Ignore the DominatingTerminator itself.
Ignore the PBD and just handle the individual vars.
Ignore the VM Stack, we want to pass that down from ContEnter ContEnterDelegate doesn't do anything for iterators.
Ignore the array value.
Ignore the data pointer.
Ignore the deallocation of the stack box.
Ignore the duplicate.
Ignore the element that will be handled.
Ignore the entry block.
Ignore the error code for removing temporary files.
Ignore the existence of the parent type if it has no type parameters.
Ignore the first item, since it can't have preceding ones.
Ignore the first result because it may be inaccurate due to internal allocation.
Ignore the given root path, strip off leading '/'s to a single leading '/' from the addpath, and leave addpath at the first non-'/' character.
Ignore the internal members of Optional, like getLogicValue() and _getMirror().
Ignore the materializeForSet callback storage parameter.
Ignore the preallocated header.
Ignore the storage address
Ignore the thick_to_objc_metatype instruction.
Ignore the value/buffer parameter.
Ignore the values of null type
Ignore these, we'll get to them when we walk the parameter list.
Ignore this warning in this file, for CAAS()
Ignore this witness entry for now.
Ignore type metadata fulfillments for non-dependent types that we can produce very cheaply.
Ignore typealiases found in protocol members.
Ignore unacceptable entries.
Ignore unknown types, so that an older swiftc can be used with a newer build system.
Ignore unreachable blocks.
Ignore uses in the same basic block.
Ignore uses of disjoint elements.
Ignore visited nodes.
Ignore zero valued collation elements.
Ignore, we already have a fall back message
Ignored, FilePath will be used
Ignored, Impl.FilePath will be used
Illegal use of this function
Images with an alpha channel are only able to resolve down to '1/128th opaque' instead of '1/256th', and this conversion is also automatic.
Images with more than 8 bits per channel are reduced to 8 bits.
Immediate-form logical (unsigned) shift operations are obtained by specifying appropriate masks and shift values for certain Rotate instructions.
Immediately perform global name-binding etc.
Immediately stepping back (fast path).
Immediately stepping back.
Immediately stepping forward (fast path).
Immediately stepping forward.
Immediately switch to a different input stream.
Impl data structure is a singleton and globally accessible.
Implement findRetainPoints to peek though projections of the load, like unchecked_enum_data to find the true extent of the lifetime including transitively referenced objects.
Implement logic from libxml xmlTextConcat to add support for comments and PI
Implement pthread_barrier_* for platforms that don't implement them (Darwin)
Implement swift::VisibleDeclConsumer.
Implementation detail of FPushClsMethodD/F: we use "C::M:ctx" as the key for invoking static method "M" on class "C".
Implementation for palette images can be done at a later point.
Implementation of a box for a specific type.
Implementation strategy for C-compatible enums, where none of the cases / have data but they all have fixed integer associated values.
Implementation strategy for native Swift no-payload enums.
Implementation strategy for no-payload enums, in other words, 'C-like' / enums where none of the cases have data.
Implementation strategy for singleton enums, with zero or one cases.
Implementations Cygwin specific functions needed for running Swift.
Implementations of Objective-C classes and categories are not reflected into Swift.
Implementations of mangler hacks for Interface Builder
Implementations of runtime functions for looking up a type by name.
Implementations of the Swift heap
Implementations of the basic android logging functions for non-android platforms.
Implementations of the dynamic cast runtime functions.
Implementations of the metadata ABI functions.
Implementations of the stub APIs that make portable runtime easier to write.
Implemented conservatively right now, but the following better not return bottom:
Implemented in SILGenPattern.cpp.
Implementing HttpTransport...
Implements JSON::CodeError::ISerializable.
Implements logic for computing in-memory layouts from TypeRefs loaded from reflection metadata.
Implements the structures of type references for property and enum case reflection.
Implements utilities for constructing TypeRefs and looking up field and enum case types.
Implicit InOutExpr's are allowed in the base of a subscript expr.
Implicit collection conversions.
Implicit conversions are better than checked casts.
Implicit decls may be delayed if they can't be used externally.
Implicit properties don't get accessors.
Implicit sp input/output.
Implicitly autorelease the return value if the function's result convention is autoreleased.
Implicitly break out of the pattern match statement.
Implicitly import the SwiftOnoneSupport module in non-optimized builds.
Implicitly leave the owner managed and return the pointer.
ImplicitlyUnwrappedOptional is fine.
Implies HasDependentMetadata.
Implode into a maximally-abstracted indirect buffer.
Implode into a maximally-abstracted value.
Implode the outer direct results.
Implode tuples in initialization of globals if they are of trivial types.
Import Clang attributes as Swift attributes.
Import NSString * globals as String.
Import an NS_ENUM constant as a case of a Swift enum.
Import an NS_OPTIONS constant as a static property of a Swift struct.
Import any interfaces implemented.
Import each of the enumerators.
Import each of the members.
Import functions without prototypes as functions with no parameters.
Import generic arguments, if any.
Import members of the given Objective-C container and add them to the / list of corresponding Swift members.
Import mirrored declarations for protocols to which this category or extension conforms.
Import onto a swift_newtype if present
Import parameter constraints.
Import pointee types as true Optional.
Import protocols this class conforms to.
Import protocols this protocol conforms to.
Import that instead, looking through any implicit submodules.
Import the Clang declaration.
Import the DeclContext.
Import the accessor and its attributes.
Import the constructor into this context.
Import the constructor.
Import the context of this declaration, which has the side effect of creating instantiations.
Import the declaration.
Import the enumeration type.
Import the full name of the method.
Import the function type.
Import the given Objective-C protocol list, along with any implicitly-provided protocols, and attach them to the given declaration.
Import the name of the function.
Import the parameter type into Swift.
Import the parameters.
Import the property's context.
Import the result type.
Import the setter, if there is one.
Import the type of the underlying storage
Import the type that this method will have.
Import the typedef-name as a declaration.
Import the underlying declaration.
Import the underlying integer type.
Import the underlying type.
Import trait properties
Import typedefs of blocks as their fully-bridged equivalent Swift type.
Import-as-member declarations are always statically referenced.
Important note: because of the `kills' set modifications, an instruction may not report that it can re-enter if it actually can't.
Important note: every block starts with a full antOut set, including blocks that are exiting the region.
Important: null out the pointer in the resource table before destroying the resource.
Important: we move the insertion point before this new release, just in case this inserted release would have caused the deallocation of the closure and its contained capture arguments.
Imported accessors are foreign and only have objc entry points.
Imported as a static method, no real self param to claim.
Imported classes and protocols are not.
Imported inherited initializers.
Imported initializers also sometimes get "withFooBar: ()" clauses.
Imported modules are not recommended.
Imported static vars are handled solely in IRGen.
Imported structs and enums are trivially representable in C.
Imported type metadata always requires an accessor.
Imported value types require foreign metadata uniquing.
Imports from -import-name such as Playground auxiliary sources are treated specially by applying import depth 0.
Imports from C are never lazily initialized.
Imports from the stdlib are internal details that don't need to be exposed.
Impose the anti-aliased drawing on the image.
In "x.y", this returns the expr for x and the source range for y.
In / particular, we DCE instructions as we go, to avoid adding them to the / worklist (this significantly speeds up SILCombine on code where many / instructions are dead or constant).
In 3 cases do we need aggregation.
In CapCode encoding, we always minimize the exponent.
In Cygwin, dlopen() returns PE/COFF image pointer.
In Cygwin, getCLocale() is not used.
In Cygwin, it is defined as wchar_t which size is 2.
In Cygwin, swift_snprintf_l() is not used.
In HHVM, properties are copied elsewhere, so all we have to do here is make the new bucket.
In HardTypeHints mode, we assume that if this opcode doesn't throw, the parameter was of the specified type (although it may have been a Ref if the parameter was by reference).
In JIT mode these are manually registered above.
In JIT mode, we need to create protocol descriptors using the ObjC runtime in JITted code.
In JSON, this would create multiple entries with the same 'slot' key.
In NDEBUG builds, bail out as soon as we can.
In ObjC interop mode, we have up to two places we need each correct ivar offset to end up:
In OpCUGetL we rely on OutCInputL returning TCell (which covers Uninit values) instead of TInitCell.
In PGO mode, we free all the profiling data once the TC is full.
In PHP 7 VerifyRetFail can coerce the return type in weak files-- even in a strict file we may still coerce int to float.
In PHP 7 mode doubles only convert to integers when the conversion is non- narrowing
In PHP 7 mode handling of null types is stricter
In PHP, array_shift() will cause all numerically key-ed values re-keyed
In PHP, the two arg version can return false on input failure, but we don't behave the same as PHP.
In PHP5 mode, we visit the LHS elements of the list() now.
In PHP7 garbage at the end of a numeric string will trigger a notice
In PHPOutput mode, we always want doubles to parse as doubles, so make sure there's a decimal point.
In RepoAuthoritative mode (with the WholeProgram compiler optimizations), the contents of traits are flattened away into the preClasses of "use"r classes.
In RepoAuthoritative mode, loaded units are never unloaded, we don't support symlink chasing, you can't include urls, and files are never changed, which makes the code here significantly simpler.
In RepoAuthoritative mode, trait methods are already flattened into the preClass, so we don't need to add in the estimate here.
In RepoAuthoritative, we assume we won't ever deallocate units and that this is read-only, mostly cold data.
In SIL mode, we can have multiple generic parameter lists, with the first one being the outmost generic parameter list.
In SIL the inlined-at information is part of the scopes, in LLVM IR it is part of the location.
In Sticky mode, the current thread continues to block others (even while running) until the mode is switched back to Normal.
In Swift's AST-level type system, function types are allowed to be equivalent or have a subtyping relationship even if the SIL-level lowering of the calling convention is different.
In WholeProgram mode, don't use FCallBuiltin if it *has* been overridden.
In WholeProgram mode, during parse time we collected all class_alias calls so we can mark the targets of such calls redeclaring if necessary.
In Zend, object_ptr would be set to the Callable object, but here, all the magic is in callable, so we just set this to NULL as if it were a global function, and hope nobody will notice.
In Zend, the __set is silently dropped, and the protected property is not modified.
In Zend, the json_parser struct is publicly accessible.
In Zend, this creates a new store bucket and copies properties, but it does NOT copy handlers.
In `killed_edge_defining' we have the case that an instruction defining a temp on an edge (like CheckType) determined it can never define that tmp.
In a "if let" statement the equals is the start of the condition, so don't parse it as a binary operator.
In a case statement, search for the pattern that contains it.
In a class metadata, the first field is the class instance.
In a class, this prevents it from being dynamically dispatched.
In a closure, non-parameter locals can have types other than Uninit after the prologue runs.
In a closure, we assume it's a name, because the type can be inferred.
In a cold path, call into native code to unblock every member of an async function's dependency chain, if it has any.
In a convenience initializer, the sole element of the memory represents the self instance itself, so if self is neither initialized nor consumed, we have to free the memory.
In a default argument, skip immediately out of both the initializer and the function.
In a few cases, an existing array (different than the source array) may be returned.
In a few cases, libdwarf keeps internal state, which forces you walk the DIEs in a hierarchial manner.
In a few circumstances, a ResourceData instance can be stored instead of a Zend resource.
In a heuristic effort to reduce the number of weird-sized fields, whenever we see a bitfield starting on a 32-bit boundary, start a new storage unit.
In a let/else, these always require an initial value to match against.
In a multi-element query, the first element may already be defined and we want to point to the second one.
In a non-empty vector, we could have duplicates or conflicts.
In a post order, we know that all of a BB's successors will always be visited before the BB, implying we will know if conservatively we saw a release on the pointer going down all paths.
In a protocol context, variables written as "var x : Int" are errors and recovered by building a computed property with just a getter.
In a pseudomain, we have to do a non-inline DecRef, because we can't side-exit in the middle of the sequence of LdLocPseudoMains.
In a similar manner, insert conservative ranges.
In a similar way to fb_setprofile storing in m_setprofileCallback
In a synthesized accessor body, store 'value' to the appropriate element.
In a trait, a potentially rebound closure or psuedo-main, we can't resolve self:: or parent:: yet, so we emit special instructions that do those lookups.
In addition to a base pointer like the operations agove, these may take a pointer to MInstrState::tvRef, which they may store to (but not read from).
In addition to changing the current preprocessor directly, we still need to change the options structure for future module-building.
In addition to pushing it onto the stack, we are also storing it in the AFWH object.
In addition to releasing instructions (see below) we also add block / arguments as use points.
In addition to the declared arguments, the constructor implicitly takes the metatype as its first argument, like a static function.
In addition, its the only simple way to make this work lock free...
In addition, there are two forms of (non)-transparency for stores.
In all cases where a payload size is demanded in the metadata, it's runtime-dependent, so fill in a zero here.
In all cases, when you get here, the value and location stacks have just been pushed.
In all of the foo_list_t structs, either: - there's a 32-bit entry size and a 32-bit count or - there's no entry size and a uintptr_t count.
In all other cases check whether this could be a potentially releasing instruction.
In all other cases, a ReqBindJmp is generated.
In all other cases, use tcT.
In all the cases where getConstantLinkage returns something different for ForDefinition, it returns an available-externally linkage.
In all those cases we can walk them via the pattern binding decl.
In an 'inout' operator like "++i", the operand is converted from an implicit lvalue to an inout argument.
In an affine transform composed of scaling, rotation, shearing, and translation, returns the amount of scaling.
In an fbmake build, override the locations of hphp and hhvm that dirs.mk will think we're using.
In an if-let, the actual type of the expression is Optional of whatever was written.
In an inherited convenience initializer, we must use the dynamic type of the object since nothing is initialized yet.
In an initializer, ignore optionality.
In an initializer, the only expression allowed is "nil", which indicates failure from a failable initializer.
In an opaque metadata, the first two fields are the fixed buffer followed by the metadata reference.
In anonymous contexts, only public methods are visible.
In any case, erase the original Destroy.
In any case, it's not unsigned.
In any case, remember that we're in this labeled statement so that break and continue are aware of it.
In applications that need to be able to suspend compression due to output overrun, a FALSE return indicates that the buffer cannot be emptied now.
In both cases, we don't have enough information at the time we emit the function to know if it should be marked fragile or not.
In both cases, we need to expose a materializeForSet.
In both enums and structs, the parent index is at index 2.
In both of the following cases, if the transform makes it no longer a tuple type, we need to change kinds.
In case of a block argument, recursively check the enum cases of all incoming predecessors.
In case of a vtable method this is always /         the most overridden method.
In case of a witness method, / the class pointer is null.
In case of an external function, the RHS may have 0 arguments.
In case of loops, block arguments can / "extend" the liferange of a reference in upward direction.
In case of multiple llvm modules (in multi-threaded compilation) all private decls must be visible from other files.
In case of ties, pick older translations first, in an attempt to start loops at their headers.
In case the Self operand is an alloc_stack where a copy_addr copies the result of an open_existential_addr to this stack location.
In case the last user is a TermInst we add all successor blocks to the frontier (see below).
In case the object's address is stored in itself.
In case the optimizer removed the function.
In case we crash again in the signal handler or something.
In case we have a read preference of primaryPreferred or secondaryPreferred, we need to do a bit more logic for selecting the node that we use.
In case we want to encode the relative of InstID vs ValueID.
In case we were called by a jitted FCallAwait, let it know that we finished eagerly.
In case we were called by a jitted FCallAwait, let it know that we suspended.
In cases where a parameter or return type is omitted, a fresh type variable is used to stand in for that parameter or return type, allowing it to be inferred from context.
In cases where there is no parent EnumCaseDecl (such as imported or deserialized elements), print the element independently.
In cli mode, we only record samples if we're in recording to replay later.
In combination with a table size that is a power of 2, this guarantees a probe sequence of length tableSize that probes all table elements exactly once.
In command line mode, we want the xbox workers to output to STDOUT
In concrete terms, this means we can immediately evaluate the base down to an address.
In contrast to exif_process_string this function does always return a string buffer
In contrast to load instructions, we first collect all read-only function calls and add them later to SafeReads.
In contrast, even if we do not sink ref counts across a cond_br from a select_enum, we may be able to sink anyways.
In contrast, it is ok to have forward references between classes, functions, etc.
In contrast, note that local DCE can not change types across block boundaries.
In eager execution, the state is suspended into a new AsyncFunctionWaitHandle object so that the execution can continue later.
In earlier versions of the IJG code, this module quantized in YCbCr color space, processing the raw upsampled data without a color conversion step.
In either case it is not covered by checked_cast_br instructions generated by tryToSpeculateTarget.
In either case there can't be an alias of the container.
In either case this is a subclass, so we can just return true.
In either case, it corresponds to a single result.
In either case, it's the last thing in 'args'.
In either case, the size and structure of a type is opaque to the code manipulating a value.
In either case, we need to change the type.
In either case, we've visited it.
In fact, "function" on its own isn't an actual type in C or C++, but its easier for everything else to have them be separate concepts.
In fact, all dates after the 3rd month are consistent from year to year (once it is known whether it is a leap year).
In fact, it's possible that the IR program itself could cause a location to not be `balanced' using only PureLoads.
In general it is a simple pass to reason about the correctness of, and it cleans up some things we can miss, so it is easier to do some of the work this way than to complicate the main pass further.
In general these instructions may make decisions based on whether this is the last reference to a tmp, so we have to observe at level 2.
In general, RaiseDebuggingFrequency should be kept at 1.
In general, arrays can contain int-valued-strings, even though plain array access converts them to integers.
In general, we want to sort each chain in decreasing order of profile weights.
In immediate modes, use the SDK provided by xcrun.
In its usual use as a type, this gets a prefix 'P'.
In just-checking mode, we only need to consume the tokens, and we don't want to do any other analysis.
In methods, strip the 'inout' off of 'self' so that mutating and non-mutating methods have the same self parameter type.
In most cases it will have only one element, a return inst.
In most cases the "self" parameter is lowered as the back parameter.
In most cases, generating a warning message and inserting a fake EOI marker is the best course of action --- this will allow the decompressor to output however much of the image is there.
In most cases, systemlib is persistent, and we could check SystemLib::s_inited.
In most cases, we do not have decls associated with these parameter lists, so serialize the lists directly.
In most conditions, this will be optimized out by the simplifier.
In multi-threaded compilation this will be done for / multiple LLVM modules in parallel.
In multi-threaded compilation, the backend job must select the correct output file of the compilation job.
In neither case do we need to continue the *current* walk.
In no event will the authors be held liable for any damages arising from the use of this software.
In non-RepoAuthoritative mode, any function could get a VarEnv because of evalPHPDebugger.
In non-WholeProgram mode, we can't tell whether the function will be overridden, so never use FCallBuiltin.
In non-autopriming mode the rewind function will always call next, when autopriming is enabled, rewind matches PHP behavior and will only advance the generator when it has not yet been started.
In non-bridged contexts, drop the typealias sugar for blocks.
In non-strict mode we may be able to coerce a type failure.
In order to avoid tail call elimination optimization issues, grab the parent frame pointer in order make sure this pointer is valid.
In order to be consistent, we have to make sure we add the good amount of nulls depending on the current number of elements.
In order to handle both old dependencies that have disappeared and new dependencies that have arisen, we need to reload the dependency file.
In order to keep things simple, we return true for any instruction that reads or writes sp.
In order to make sure we have a deterministic ordering when we visiting exiting subregions, we need to sort our exiting regions by ID, not pointer value.
In order to make this work, we pick the most general function type and use a conversion constraint.
In order to recover the nested GenericParamLists, we divide genericParams and requirements according to depth.
In order to work around this, tell clang to force it to only 8 byte alignment, which causes it to emit an inlined version of memcpy which does not assume 16-byte alignment.
In other cases (especially if you don't bother to DefCls your classes in your .main) you'll just get mysterious "class not defined" errors or weird behavior.
In other words X * -1 does not does not guard X * 1.
In other words many valid things that could be considered induction variables are disallowed at this point.
In other words we could get infinite recursion if the mutex errors.
In other words, Get shouldn't append values.
In other words, it can be thought of as an optimization to clear the memory support state when we see a PureStore with a known target location: it's not required for correctness.
In other words, it will not be lowered afterwards.
In other words, it's not "exception-safe".
In other words, make sure there are no VM frames directly below this one and that we are not in a nested VM (reentrancy)
In other words, there's nothing to do.
In our recursive parse, remember that we're in a matching pattern.
In our recursive parse, remember that we're in a var/let pattern.
In particular notice that any instructions which may raise, as well as Call, CallArray, and CallBuiltin all require catch traces.
In particular this means we want that AliasClass to have an entry in the stack_ranges, so we'll populate it later.
In particular, if a case condition modifies the switch subject, things behave differently depending on whether the subject is a simple variable.
In particular, it does *not* check for overlong / encodings.
In particular, it should provide the results via the return value from writeStats, not print to stderr :) Task 3396401 tracks this.
In particular, it's /not/ correct to check the PBD's DeclContext because top-level variables in a script file are accessible from other files, even though the PBD is inside a TopLevelCodeDecl.
In particular, operator path pieces represent actual operators here, but filters on operator functions when they appear later on.
In particular, the "top" of the record is 16 bytes after rvmfp(), and the saved fp and return addr are as usual.
In php, you can access base class static properties through derived class names, and the access affects the property with that name on the most-recently-inherited-from base class.
In php5 xdebug this just means the user cannot input commands.
In practice that race is much less likely to cause problems, because the other thread will generally invoke the autoloader and then find out its defined by the time that's done.
In practice we should need no more than four bytes from the payload area.
In practice, claiming it unconditionally is fine because we want to assume it's nil in the other path.
In practice, it will either be a thunk, or an optimizer specialization.
In practice, the things we low_malloc are both long-lived and likely to be randomly accessed.
In practice, there should generally only be one item and it should be a string, but maybe that'll be extended...
In practice, this means we will warn on a private declaration that shadows a non-private one, but only in the file where the shadowing happens.
In practice, trying to use their recommended scratch registers results in a SEGV inside _Unwind_SetGR, so we pass things to the handler using the RDS.
In practice, we expect to rarely see LdCtx instructions inside of an inlined function---normally the actual context object should be copy propagated.
In practice, we're probably looking for something recently pushed.
In previous versions, most significant bits (MSBs) of the seed affect only MSBs of the state array.
In principle, any time we can do this, we should try to re-use this function for other conformances.
In principle, this is an unnecessary restriction, and you can imagine caches that might want to vend this combination of accessors.
In principle, we could synthesize 'address' from 'mutableAddress', but for now we'll enforce this.
In principle, we could use the interval configuration of the timer to count down one second at a time, but that doesn't seem worth it.
In production mode, only functions that we have assumed can be intercepted during static analysis should actually be intercepted.
In profiling mode, don't trace through a control flow merge point, however, allow inlining of default parameter funclets
In psuedomains we have to pre-constrain local guards, because we don't ever actually generate code that will constrain them otherwise.
In reality the following three calls are a no-op.
In reality, retLocal is an immediate argument.
In reality, the deallocating destructor is referenced directly from the HeapMetadata for the class.
In server mode, we exclude warmup document requests from profiling, then record samples for EvalJitProfileInterpRequests standard requests.
In short, in Normal mode any thread may hit and process an interrupt.
In some cases this may happen several times before the process finally dies.
In some language modes, we allow top-level code to omit 'try' marking.
In some unusual cases with illegal keys, SetM pushes null instead of the right hand side.
In sourcekitd, the receiver accepts ownership of the response.
In strict mode this will always fail, in weak mode it will be a noop
In strict mode type mismatches won't be coerced (for legacy reasons in HH files builtins are always weak).
In such a case we must keep the argument live across the call site of the callee and emit a matching retain for every invocation of the callee.
In such a case we want to make sure the associatedtype is frontmost to generate generics/witness lists correctly, and the alias will be unused/useless for generic constraining anyway.
In such a case, check if any predecessors have a smaller PO number.
In such a case, the SILArgument must be rc-identical.
In such a case, we assume conservatively that the bit cast could use it.
In such a case, we fill in the fields with the information from the current frame.
In such a case, we need to remove the subregion from the exiting subregion array of R after the loop.
In such a case, we say that the use / list of the alloc_stack does not allow for optimizations to occur.
In such a case, we say that the use list / of the alloc_stack does not allow for optimizations to occur.
In such case, we would miss a dead store / opportunity.
In such cases, remove the default binding suggestion because the existing suggestion is better.
In such cases, we assume that we are passing / self at +0 and then after we know what the callee is, we check if the / self is passed at +1.
In swift it is legal to cast non reference-counted references into object references.
In takeover, the agent will attempt to use libafdt to transfer a file descriptor from an existing process (which should exist, since we couldn't bind to the socket).
In that case the length is just the size of the struct without sun_path.
In that case we'll always just miss the in-TC fast path.
In that case you'll probably want to tweak the histogram sizes too.
In that case, add any instructions we are tracking or instructions that we have seen to the banned instruction list.
In that case, create the payload enum/store.
In that case, params win (which is different than zend but much easier)
In that case, reset the type.
In that case, the code uses the static empty string, so if it was an OptCStr it needs to incorporate SStr, but an OptSStr can stay as SStr.
In that case, the return type is specified in terms of archetypes, but has no TypeLoc in the TypeRepr.
In that case, throw that off the stack and restore Mode::OBJECT so that we pretend the trailing comma just didn't happen.
In that case, we don't want to reset the lineno or column.
In that case, we just bail
In that case, we just continue emitting code as if we were still in the false case, and we're unreachable iff the end of the false case is unreachable.
In that case, we just continue emitting code as if we were still in the true case, and we're unreachable iff the end of the true case is unreachable.
In that case, we perform fewer serialization checks.
In the AST form, this will look like an OptionalEvaluationExpr with an immediate BindOptionalExpr inside of it.
In the Objective-C runtime, class metatypes are also class instances.
In the VM, don't optimize __CLASS__ if within a trait, since __CLASS__ is not resolved yet.
In the absence of a better conversion constraint failure, point out the inability to find an appropriate overload.
In the case / we are the function level loop, these will of course be empty anyways.
In the case of HNI builtin classes, private properties are allowed to be mutated by native code, so we may not see all the modifications.
In the case of a catastrophic parse error, consume any trailing #else, #elseif, or #endif and move on to the next statement or declaration block.
In the case of a define or a global, the pointer will be followed by a TypedValue representing the value being defined/assigned.
In the case of a failing initializer, the release on the exit path needs to cleanup the partially initialized elements.
In the case of a function application, we would have already captured the return type during constraint generation, so there's no use in looking any further.
In the case of an exception, the VM unwinder will take care of it.
In the case of an interpolated string literal expr, the subexpressions are contained within the string token.
In the case of back edges, it may process through the loop unnecessarily, but it won't make any illegal transformations because the lower_bound will be zero.
In the case of fastcgi this is basically a full header list from apache/nginx.
In the case of us having applied a type member constraint against a synthesized type variable during diagnostic generation, we may not have a valid locator.
In the case that there is no next available integer key, this function sets out to point to the lvalBlackHole.
In the case where an exception is thrown, the VM unwinder will handle it for us.
In the case where the old partial_apply was passed in at +0, we /    know that the old partial_apply does not need to have any ref count /    adjustments.
In the cases where we can statically determine the function that / we'll call to, replace an apply of a witness_method with an apply / of a function_ref, returning the new apply.
In the comments throughout this file, three type names are used: 'B' is the type of a fixed-size buffer 'T' is the type which implements a protocol
In the comments throughout this file, three type names are used: 'B' is the type of a fixed-size buffer 'T' is the type which implements a protocol 'W' is the type of a witness to the protocol
In the common case there aren't any strong iterators, so we can just update m_used and return
In the common case when this is called by Countable#finalize(), this will be called on the system finalizer thread.
In the common case, the function won't use the extra arguments, so act as if they were never passed (NOTE: this has the effect of slightly misleading backtraces that don't reflect the discarded args)
In the common case, we don't have to perform any resolution and we can just return the token
In the context of a trait alias rule, only method access and visibility modifiers are allowed
In the continuation block, take ownership of the now non-optional result value.
In the current implementation the cache is traversed by a linear search from most-recent to least-recent.
In the derived class, a method override that involves substituted types will have a different SIL lowering than the base method.
In the early years, the beginning of the year varied, sometimes based on the ascension of rulers.
In the empty existential parameter case, we don't need to decompose the arguments.
In the end, though, we're okay with any hint from the group.
In the entry block, hhbc-translator gets a chance to emit some code immediately after the initial checks on the first instruction.
In the event that an invalid digit is found, halt the conversion and return the portion which has been converted thus far.
In the fetch block, bind the archetypes and evaluate the body.
In the final case block, it is invalid.
In the first 2 cases, the coder probably forgot a cast and expected a concrete type.
In the first block we start at the allocation instruction and not at the begin of the block.
In the first iteration we have to merge the summary graphs, even if they didn't change (in not recomputed leaf functions).
In the first pass over the image, we accumulate a histogram showing the usage count of each possible color.
In the following cases, note that if you get an elem out of an array that doesn't exist, php semantics are to return null (after a warning).
In the future attempt to recursively strip here.
In the future we should get this from the Parser if possible.
In the indirect block, clear the low bit and perform an additional load.
In the interpreter it would result in two instances for a single global: one in the imported module and one in the main module.
In the last case, the AST has this call typed as being applied to an rvalue, but the witness is actually expecting a pointer to the +0 value in memory.
In the later case, they probably didn't mean to bind to a variable, or there is some other bug.
In the latter case, we add the imported type as a nested type of the parent.
In the mean time, elide these variables, they would confuse both the user and LLDB.
In the meantime, just assume that all stores of trivial type are ok.
In the normal method case, the "saved pc" for line number printing is pointing at the cell conversion (Unbox/Pop) instruction, not the call itself.
In the parser, generic parameters won't be wired up yet, just give up on producing a type.
In the partially live case, we have to check our control variable to destroy it.
In the repl, the parent top-level context may have been re-written.
In the sense of "non-union type", not the sense of TPrim.
In the simple case of a unique alias name and a unique target name, we might be able to get away with manipulating the target classes' volatility.
In the success path, emit the 'then' part if the if.
In the success path, emit the body of the while.
In the translator, numCells can be hardcoded, and m_top is wired into a register, so the expression requires no loads.
In the unrolled block of the last iteration unconditionally jump to the ExitBlock instead.
In the usual case, the code will have emitted one or more branches to the failure block.
In the worst case, we'll produce lots of duplicate solutions for this constraint system, which is problematic for overload resolution.
In theory we can follow the same rules as mangling and only include the outermost private context.
In theory, the kernel should do just as well even if we don't explicitly advise files out.
In theory, the unwind API will let us set registers in the frame before executing our landing pad.
In theory, this can be any arbitrary expression, but we only support constant addresses right now.
In theory, this is happening within conditional code, so we need to be only conditionally claiming the value.
In these cases the closure will be emitted into every initializer of the containing type.
In these cases, don't look up the address range in the "cold" file, since it the range isn't there.
In these instances it's possible that no ActRec was pushed for the builtin call, in which case the liveFunc() will be the caller rather than the callee.
In this branch, the eventual return value is mostly created by bridging the native return value, but we may need to adjust it slightly.
In this branch, the eventual return value is mostly invented.
In this case nullptr is returned.
In this case some semantic calls can be CSEd.
In this case some semantic calls can be hoisted.
In this case the `kills' set will refer to the wrong stack locations.
In this case the list in UnsafeArrays is not relevant.
In this case the new function is not a method anymore.
In this case the size of UniqueLocations is 1.
In this case various parts of the compiler (for example, AST verifier) have less strict assumptions about the AST.
In this case we can NewPackedArray to create the array.
In this case we can avoid the SmallNode, which saves us some memory and also let's us give out 16-byte aligned pointers easily.
In this case we can just adapt all the apply sites which use the partial_apply.
In this case we can just skip the existing re-abstraction.
In this case we can kill both, which may allow removing a SpillFrame as well.
In this case we can move the alloc_ref before the alloc_stack to fix the nesting.
In this case we don't even create a node for the resulting int value.
In this case we don't need to do any work to use the value.
In this case we must drop the unknown state.
In this case we should populate m_lineTable (otherwise we might lose line info altogether, since it may not be backed by a repo).
In this case we would with this optimization merge the last retain with the first.
In this case, /var/releases/continuous_www_scripts4 was added and the duplicate /var/www was removed.s
In this case, an error will be raised.
In this case, don't check setter accessibility, it is not set.
In this case, eat any trailing whitespace.
In this case, it uses PATH_TRANSLATED.
In this case, no external initializer may exist.
In this case, nothing further needs to be done.
In this case, our local throwDest has no predecessors, and SGF.ThrowDest may not be valid either.
In this case, the array will already be incref'd.
In this case, the data will be corrupted.
In this case, the overridden vtable entry will point to a thunk which transforms parameters and results and invokes the derived method.
In this case, the stack must be empty, and we need to record that this is the case so that later backward jumps can check this is the case at their jump site.
In this case, we can do a fast subtype check using the classVec, because we know oldCls can't be an interface (because we observed an instance of it last time).
In this case, we can just mark the target location as memory support for the must-alias-set for the stored value, and leave its lower bound alone.
In this case, we can't move the release past it.
In this case, we decrement the lower bound and just eagerly behave as if the must-alias-set for the stored value may be decref'd right there.
In this case, we emit code to dynamically lookup the method given the Object and the method slot, which is the same as func's.
In this case, we have to make sure not to destroy an element that wasn't initialized yet.
In this case, we know that the instruction location will be the enclosing function.
In this case, we may be setting a breakpoint in a tracelet which could already be jitted, and present on the stack.
In this case, we still have to consider the self type to "fulfill" the type parameters so they don't get emitted as separate parameters.
In this convention, the caller creates a local copy before passing it to the callee.
In this function we do the actual check.
In this module the prescan simply updates the histogram, which has been initialized to zeroes by start_pass.
In this pass the final decision is made if stack promotion should be done.
In this situation we just Nop out the instruction and leave the old tmp dangling.
In this situation, all the sets get flagged as `pessimized', we don't do anything to them anymore, and a Halt node is added to all graphs.
In this situation, the compressor will return to its caller (possibly with an indication that it has not accepted all the supplied scanlines).
In this situation, the decompressor will return to its caller (with an indication of the number of scanlines it has read, if any).
In this situation, we can remove the memory support bit to avoid futher reductions in the lower bound of that set via that memory location.
In this situation, we put a SmallNode header at the front of the block that tells us the size for when we need to free it later.
In threadStats() we wish to solve for cactiveLimit in:
In var/let decl with multiple patterns, accumulate them all in this list so we can build our singular PatternBindingDecl at the end.
In we find arguments that are not the 'self' argument and if they are of the Self type then we abort the optimization.
In which case, call that and use the array it returns.
In which case, it is the replacement we are interested in, since it is the one in our current context.
In which case, the member will be modeled as an inout but ExistentialMemberRef and ArchetypeMemberRef want to take the base as an rvalue.
In wholecfg mode, these two runtime options are ignored and nothing is pruned based on profile counters.
In-place cast decrefs the function call result.
InOut arguments are treated as uses and may-store's, but an indirect return is treated as a full store.
InOut types are invariant.
InOutExpr's are allowed in argument lists directly.
InOutExprs can be wrapped in some implicit casts.
Inc only works on KindOfDouble or KindOfInt64, which are never kept in file-backed storage from priming.
Inc or Dec for a string, depending on Op.
IncDecL is a read-modify-write: can be removed if the local isn't live, the set can't have side effects, and no one reads the value it pushes.
Include a value from module X if: no particular module was requested, or module X was specifically requested.
Include const, volatile, etc
Include function args
Include implementation details.
Include room in for 2 EOB chars.
Include the IR in the body of the node
Include the _Tt prefix.
Include the correct TaskQueue implementation.
Include the encoding for 'self' and '_cmd'.
Include, eval, and define instructions
IncludeNodeAtLocation, / Like ExcludeNodeAtLocation, and skip past any node at the location.
Includes both iOS and TVOS.
Inclusive ranges will have a check on the upper value (before adding one).
Incoming values for the BBArg.
Incomplete requests in the I/O thread will not be executed.
Incomplete types are useless for our purposes, so just ignore them.
Incr time with the given microseconds.
Increase the buffer to prepare for a possible push.
Increase the file descriptor limit.
Increase the limit to the maximum possible value, so that this method won't be called again.
Increase the reference count to keep it alive.
Increase the uncurry level to look past the self argument to the indices.
Incref the args (they're already referenced in extraArgs) but now additionally referenced in varArgsArray ...
Incref the collection object during construction.
Incref the return value.
Increment aggregation metrics
Increment profiling counter.
Increment the backedge region.
Increment the max so the range is inclusive of max
Increment the ref count for the inlined function, so it doesn't get deleted before we can emit abstract debug info for it.
Increment the ref count to make sure it will not be eliminated.
Increment the refcount so it isn't cleaned up at the end of this method
Incrementally build the DIRefMap.
Incrementally incorporate the difference between the previous and current deltas into the memory usage statistic.
Indeed, using PHP_POLLREADABLE results in select failing only due to the timeout and not immediately as would be expected when a connection is actively refused.
Indent another level from the outer context by default.
Indent the body of the Fix-It if.
Indent two spaces per depth.
Index Projection Kinds
Index can never be used directly if shifting is necessary.
Index into the cache with adjusted pixel value
Index into the layout table for the assigned layout.
Index of phi group metadata.
Index of the first non-inherited field in the layout.
Index the case according to this chunk.
Index will be None so the Projection will be invalid.
Index+Base+Displacement
Indexed types just for scanning are never pointer followable (because they're not actually heap allocated).
Indexing is not using documentation now, so don't open the module documentation file.
Indicate that a rewritten value is available in the specified block with the / specified value.
Indicate that the existing cast cannot be further improved.
Indicate that there is a global colour map
Indicate that we are going to generate the global symbols for those runtime functions that require it.
Indicate this fact by setting ignore to true as well.
Indicate to the IR that it should take even slower path
Indicate whether igbinary serializer is available
Indicate whether json serializer is available
Indicate which pass we are on (if interlace)
Indicates that the cell is (possibly) used.
Indicates that the cell is (unconditionally) not used.
Indicates that the cell is only used if it was the last reference alive.
Indicates whether any of the arguments are potentially out-of-order, requiring further checking at the end.
Indirect checked conversion instructions.
Indirect elements make the type nontrivial, but don't affect address-only-ness.
Indirect enum cases are implemented by substituting in a SILBox type for the payload, resulting in a fixed-size lowering for recursive enums.
Indirect offsets are not valid at level 0.
Indirect parameters are bridged as Clang pointer types.
Indirect parameters are passed as owned, so we also need to pass the direct parameter as owned (except it's a trivial type).
Indirect parameters do give us a value we can use, but right now we don't bother, for no good reason.
Indirect results are passed as owned, so we also need to pass the direct result as owned (except it's a trivial type).
Indirect return of an address-only value.
Individual instruction statistics
Inexact metadata will be a problem if we ever try to use this to remember that we already have the metadata for something.
Infer associated type witnesses for all relevant value requirements.
Infer associated type witnesses for the given tentative / requirement/witness match.
Infer associated type witnesses for the given value requirement.
Infer associated types from the potential value witnesses for this requirement.
Infer requirements from it.
Infer requirements from parameter patterns.
Infer requirements from the inherited types.
Infer requirements from the parameters of the constructor.
Infer requirements from the pattern.
Infer requirements from the result type.
Infer the Objective-C name for a given declaration.
Infer the Objective-C name for this method.
Infer the Objective-C name for this property.
Infer the same availability for the mirrored declaration as we would for the protocol member it is mirroring.
Infer type witnesses from value witnesses.
Inferred associated types that don't meet the associated type / requirements.
Infers the availability required to access a type.
Infinity or NaN, convert to inf or nan with sign.
Infinity or Nan, convert to inf or nan like printf
Infix operator is only allowed on operator declarations, not on func.
Info from: http://sc.openoffice.org/compdocfileformat.pdf  N.B.
Info rather than error, since probing the format is OK.
Inform IRGenFunction that the given archetype has the given value / witness value within this scope.
Inform consumers that producers are done.
Inform the context that we have external definitions.
Inform the lexer that we're lexing the body of the SIL declaration.
Inform the target of the language options.
Information about a folded conditional branch instruction: it's location / and whether the condition evaluated to true or false.
Information about a value in memory.
Information about builtins usage.
Information about spills generated by register allocation.
Information about the IR-level signature of a function type.
Information about the definition of a virtual register, if it was defined by either copying or lea'ing off another register.
Information for each EHEnt in the func (basically which label names we chose for its handlers).
Information for transforming a single checked_cast_br.
Information needed during processing of a single loop.
Information to use for diagnosing failures when we don't have something more specific.
Informs the client of all strings that may follow a break command.
Informs the client of all strings that may follow a list command.
Inherit swift3_migration attribute.
Inherit the name from the "originating" declarations, if there are any.
Inheritance of parent allow value through multiple levels of new nodes
Inherited methods will be inserted in the recursive call later.
Inidcates the distacne the autofocus camera is focused to.
Init information about the checked_cast_br we try to jump-thread.
Init state variables for paths analysis
Init the last_sample in tsc
Init w/ 1 to avoid div by 0 when all counts are 0
Initial size of the input buffer + how much to expand it
Initial size of the map
Initial sources code is avaibable in the Gems Source Code Packages: http://www.acm.org/pubs/tog/GraphicsGems/GGemsIII.tar.gz
Initialization and execution.
Initialization and shutdown.
Initialization is the same as for the non-reentrant scanner.
Initialization points.
Initialization will be taken care of by ext_array which also uses icu.
InitializationForPattern - A visitor for traversing a pattern, generating / SIL code to allocate the declared variables, and generating an / Initialization representing the needed initializations.
Initializations can only increase refcounts.
Initialize COM and theme.
Initialize IDs so our IDs are in RPOT as well.
Initialize InfixData with default attributes: precedence 100, associativity none, non-assignment
Initialize InlineAnalysis from an IRUnit.
Initialize Kind, uncurryLevel and IsObjC.
Initialize ResultsInError as a None optional.
Initialize a SILBuilder and create a function_ref referencing the cloned closure.
Initialize a bit vector to be equal to the given bit-mask.
Initialize a relative indirectable pointer to the given value.
Initialize a variable of reference-storage type.
Initialize a writeback buffer that receives the value of a 'let' / declaration.
Initialize all of the known identifiers.
Initialize all streams up through `area'.
Initialize all the data flow bit vector for all basic blocks.
Initialize all the specialized base conformances.
Initialize an Explosion with the parameters of the current / function.
Initialize an array that records the number of times a variable is assigned to by the format string.
Initialize best-distance for each cell of the update box
Initialize block state structures and put all blocks in the worklist.
Initialize buffer pointers.
Initialize code block cb pointing to li64
Initialize code completion.
Initialize compiler state
Initialize destination --- called by jpeg_start_compress before any data is actually written.
Initialize each TypeLoc in this attribute with a concrete type, and populate a substitution map from GenericTypeParamType to concrete Type.
Initialize for each processing pass.
Initialize generator state with seed See Knuth TAOCP Vol 2, 3rd Ed, p.106 for multiplier.
Initialize given the specific instruction type and verify with asserts / that we constructed it correctly.
Initialize in the zend extension compatibility layer, as needed before any calls from legacy zend extensions to zend_strtod.
Initialize inferred private property types to their in-class initializers.
Initialize line breakpoint
Initialize metadata table, used before init() is called.
Initialize necessary things to run the iterative data flow.
Initialize one box containing whole space
Initialize our breakpoint maps.
Initialize our per-diagnostic state to default
Initialize parameters.
Initialize params, locals, and---if we have a closure---the closure's bound class context and use vars.
Initialize regions for each BB and associate RPO numbers with each BB.
Initialize return array
Initialize return value
Initialize source --- called by jpeg_read_header before any data is actually read.
Initialize stack pointers.
Initialize state for each one of our BB's in the RPOT.
Initialize static props for parent.
Initialize structure containing state of computation.
Initialize system-specific crash detection.
Initialize the "isa" pointer, which is _NSConcreteStackBlock.
Initialize the +1 result buffer without taking the incoming value.
Initialize the AvailSet and AvailVal of the current basic block.
Initialize the AvailSet by intersecting this basic block' predecessors' / AvailSet.
Initialize the AvailSetMax by intersecting this basic block's / predecessors' AvailSetMax.
Initialize the BBToLocState mapping.
Initialize the BBWriteSetMid to BBWriteSetOut to get started.
Initialize the Compression routines
Initialize the CookieJar
Initialize the LSLocation.
Initialize the NamedEntity table.
Initialize the Values array with empty SILValues.
Initialize the basic block maximum refcounted set.
Initialize the bitvectors for the current basic block.
Initialize the block state structures.
Initialize the breakpoint message node
Initialize the buffer
Initialize the buffer as an empty optional.
Initialize the buffer with junk, to help ensure we're insensitive to insignificant bits.
Initialize the case and successor arrays.
Initialize the class's own parent pointer if it has one and it wasn't emitted as a constant.
Initialize the concrete value in-place.
Initialize the data flow.
Initialize the debugger
Initialize the default location before parsing starts.
Initialize the destination with it, and set the extra tag if any to zero.
Initialize the distances for the entry and exit blocks, used when computing the distances for the function itself.
Initialize the dominator tree info.
Initialize the entry block's in state.
Initialize the error-limiting transfer function (lookup table).
Initialize the extra tag bits, if any, to zero to indicate a payload.
Initialize the extra tag bits, if we have them.
Initialize the field offset vector for a dependent-layout class, using the / "Universal" layout strategy.
Initialize the header.
Initialize the inline cache, or do a lookup in the out-of-line cache if we've finished initialization and have smashed this call.
Initialize the instantiated dependent value witness table, if we have one.
Initialize the invariant superclass components of a class metadata, / such as the generic type arguments, field offsets, and so on.
Initialize the members.
Initialize the metadata.
Initialize the parent-metadata field if it wasn't done statically.
Initialize the profiler if it isn't already.
Initialize the propagated errors to zero.
Initialize the properties
Initialize the request-local context from the trigger.
Initialize the response
Initialize the response node
Initialize the runtime options with their default values
Initialize the state for this BB with the state of its predecessor / BB.
Initialize the state for this Region with the state of its predecessor / Region.
Initialize the status and reason
Initialize the storage immediately, if we can.
Initialize the successor array.
Initialize the text on all "application" (non-page) controls.
Initialize the type expansion analysis.
Initialize the value witness table and struct field offset vector for a / struct, using the "Universal" layout strategy.
Initialize the variable value.
Initialize the worklist to all of the constant instructions.
Initialize the worklist with the function level region.
Initialize the xml node
Initialize this BB with the state of the successor basic block.
Initialize this RefCountState with an instruction which introduces a new / ref count at +1.
Initialize this Region with the state of the successor region.
Initialize tracked memory state for locals and stack slots to empty values.
Initialize with the value from the inout with an "autogenerated" copyaddr.
Initialize worklist to contain the entry block, and set up all the BlockInfo rpoIds.
InitializeData - initializes all the package and prereq information.
InitializeTaskbarButton - initializes taskbar button for progress.
Initialized 'let' properties have storage, but don't get an argument to the memberwise initializer since they already have an initial value that cannot be overridden.
Initialized by RuntimeOption.
Initialized by the setup operation.
Initializer for a let property of a class cannot exist externally.
Initializers always use the nil result convention.
Initializers can be inherited.
Initializers cannot be found by dynamic lookup.
Initializers have argument labels.
Initializers must take 'self' at +1, since they will return it back / at +1, and may chain onto Objective-C initializers that replace the / instance.
Initializes or reinitializes a buffer.
Initializes the repo schema id and the compiler id from their special sections in the hhvm binary.
Initially assign each region block to its own chain.
Initially store offset into buffer, update later to deal with reallocs
Initially, we need each entry block in this list.
Inject 'nil' into the indirect return.
Inject REPL utility functions
Inject command line parameters to be picked up by GhostDriver
Inject into an optional if necessary.
Inject object only if it's not already present
Inject some behavior into react/
Inject that into the result type if the result is address-only.
Inject the 'Some' tag.
Inject the Callbacks object in the main frame
Inject the SDK path and resource dir if they are nonempty and missing.
Inject the call into the top level stream by wrapping it with a TLCD.
Inject the enum tag if the result is optional because of failability.
Inject the self value into an optional if the constructor is failable.
Inject the typealias into the nominal decl that conforms to the protocol.
Inline function at I, which also changes I to refer to the first instruction inlined in the case that it succeeds.
Inline things into this function, and if we do so invalidate analyses for this function and restart the pipeline so that we can further optimize this function before attempting to inline in it again.
Inlined calls normally skip the function enter and exit events.
Inlining deletes the apply, and can introduce multiple new basic blocks.
Inlining related instructions can manipulate the frame but don't observe reference counts.
Inlining self-recursive functions into other functions can result in excessive code duplication since we run the inliner multiple times in our pipeline
Inlining was successful.
Inner generic parameter of the requirement -- fall through below.
Input must be (Builtin.Word, Builtin.Word, Builtin.Word)
Input must be Builtin.Int1
Input string argument
Input types can be contravariant (or equal).
Input: Y1/U1/V1: The Y/U/V data of the first image imgdata: data buffer containing webp image imgdata_size: size of the imgdata buffer  Returns the PSNR value computed bewteen the two images
Inputs are contravariant, results are covariant.
Inputs: code:   A n_bits-bit integer.
Insert 100 numbers into the map
Insert EagerSyncVMRegs at the end of catch traces
Insert I into its location in the interesting instruction list.
Insert `inst' after `definer'.
Insert a DbgAssertRefCount instruction after each place we define a maybe-refcounted SSATmp.
Insert a NamedEntity into the table.
Insert a block into the worklist and set its stack depth.
Insert a call into the entry function.
Insert a debug intrinsic into the current block.
Insert a fake EOI marker
Insert a load of the liveness bitmask and split the CFG into a diamond right before the destroy_addr, if we haven't already loaded it.
Insert a new Load of the enum and extract the data from that.
Insert a new load from our source and bitcast that as appropriate.
Insert a rank that may be lower than the current rank in an appropriate position in the stack.
Insert a release in the success BB.
Insert a space between the operators.
Insert a space in front of 'foo' decl.
Insert a spill after the def-position in `ivl'.
Insert all of the blocks that ASI is live in.
Insert an element in the actual stack at the specified depth of the actual stack.
Insert an lea fixup for any stack args at the beginning of the catch block.
Insert before the uncond branch and zap it.
Insert convert_function.
Insert copies and loads at instructions.
Insert copies inside blocks.
Insert dealloc_stack instructions at all function exit points.
Insert directly into body with spaces.
Insert empty syntax map data for replaced lines.
Insert instructions for creating spill space.
Insert into the lowered basic block.
Insert it before the 'UserInst'.
Insert lifetime-resolving copies, spills, and rematerializations, and replace the Vreg operands in the Vinstr stream with the assigned PhysRegs.
Insert new instructions to the appropriate block.
Insert new module:depth mapping.
Insert our custom init body
Insert releases after each point where the partial_apply becomes dead.
Insert releases and destroy_addrs as early as possible, because we don't want to keep objects alive longer than its really needed.
Insert spills and copies that connect subintervals that were split between instructions.
Insert the alloc_stack at the beginning of the function.
Insert the element decls.
Insert the given basic block after the IP block and move the / insertion point to it.
Insert the instruction New before instruction Old in Old's parent BB.
Insert the instruction into our InvolvedInstructions set.
Insert the new decrements.
Insert the new enum_select instruction right after enum_switch
Insert the new increments.
Insert the shadow copy.
Insert the specified decl into the DeclContext's member list.
Insert them in order.
Insert whitespace on the left if the binop is at the start, or to the right if it is end.
InsertCFGDiamond - Insert a CFG diamond at the position specified by the / SILBuilder, with a conditional branch based on "Cond".
Inserted, container owns the pointer
Inserting in an empty array creates a packed array of size one.
Inserts type checks in the original generic function for dispatching to the / given specialized function.
Inside a closure expression, an expression which syntactically looks like a discarded value expression, can become the return value of the closure.
Inside traits we already did the magic for static::class so lets reuse that
Inspect all of the open_existential_addr instructions and record the apply-witness users.
Inspect allocations and pointer literals.
Inspect integer literals.
Inspired by "How to Print Floating-Point Numbers Accurately" by Guy L.
Inspired by ext/standard/html.c:get_next_char()
Inspired by: Optimal control dependence and the Roman chariots problem TOPLAS, v19, issue 3, 1997 http://dx.doi.org/10.1145/256167.256217
Inspired loosely by William D.
Inst may be moved by hoistMakeMutable.
Inst.clone() per instruction does not work.
Install a Clang module file extension to build Swift name lookup tables.
Install a new optional-failure destination just outside of the cleanups scope.
Install a signal handler for all the above signals.
Install our dyld callback.
Install the protocol elements.
Install the self type on the Parameter that contains it.
Instance computed property
Instance properties---one for each use var, and one for each static local.
Instance property, look beyond self
Instance type check for the above.
InstanceOfD is always false if it's not an object.
Instantiate a SILBuilder for inserting instructions at the top of the original generic function.
Instantiate a brand new witness table for a resilient or generic / protocol conformance.
Instantiate a thick metatype for T.Type
Instantiate a value witness table for a class-constrained existential / container with the given number of witness table pointers.
Instantiate a value witness table for an existential metatype / container with the given number of witness table pointers.
Instantiate a value witness table for an opaque existential container with / the given number of witness table pointers.
Instantiate hoistable classes and functions.
Instantiate template members.
Instantiate the constant.
Instantiate the payload if necessary.
Instantiate the storage next to us in the enclosing scope.
Instantiation function
Instead / we store the branch's parent and the idx so that we can reconstruct the use.
Instead of a true 3-D array, we use a row of pointers to 2-D arrays.
Instead of breaking blocks on instructions that could throw, we represent the control flow edges for exception paths as a set of factored edges at the end of each block.
Instead of casting the input, we cast the function type.
Instead of casting the inputs, we cast the function type.
Instead of casting the output, we cast the function type.
Instead of emitting a bogus fixit, only emit the fixit for 'func's.
Instead of emitting an obviously dumb select, emit nothing or a zext.
Instead of linking to CrashReporterClient.a (because it complicates the build system), define the only symbol from that static archive ourselves.
Instead of passing the address, pass the loaded value.
Instead of poking at parts that are potentially not set up, just assume it is acceptable.
Instead of proceeding to "dec-4" after it applies, it moves back to reprocess at "inc-3", which lets the rule apply again to remove "inc-3" and "dec-4".
Instead of producing these diagnostics, lets let the bigger issues get resolved first.
Instead of the address we pass the loaded value.
Instead of updating the literal expr in place, allocate a new node.
Instead once we hoisted a release we scan only to this release when looking for ARC decrements or checks.
Instead the compiler creates a struct internally which stores all the information.
Instead the structure of the DIEs mimics the nesting structure in the source (IE, a nested class within a class nested within a namespace).
Instead we check that no decrement or check occurs up to this hoisted release.
Instead we collect uses wrapping uses in branches specially so that we can reconstruct the use even after the branch has been modified.
Instead we let the shell do it.
Instead we return immediately.
Instead we run an extra iteration of the ARC optimizer with / this enabled in a side table so the information gets propagated everywhere in / the CFG.
Instead we traverse thru all section headers until a symbol table one is found or else the binary is stripped.
Instead, call the appropriate setters (set() or setRef()).
Instead, go on to validate any potential result type, and bail afterwards.
Instead, it performs the matching comparison against a primitive type (usually bool).
Instead, it's much easier to allow an optional return type both before and after an optional use clause.
Instead, set AttrNone so that the modifiers of the original method are preserved.
Instead, special case the one attribute associated with the return type not the function type.
Instead, the number is converted to a string and back again using strtod().
Instead, the outermost tuple layer is exploded, even when they are being passed opaquely.
Instead, we compute with fewer bits and propagate the carry if necessary when rounding the final digit up.
Instead, we create the LSValues when we need them.
Instead, we just check once at the end and accumulate.
Instead, we leave the lower bound at zero, but set a memory support bit for the new location.
Instead, we should introduce / dynamic-indirect argument-passing conventions and map opaque / archetypes to that, then respect those conventions in IRGen by / using runtime call construction.
Instead, we'll just try to take the "better" of the two.
InstrIsPHI - Check if an instruction is a PHI.
Instruction has a proper target type already.
Instruction has been processed.
Instruction is unreachable.
Instruction which def'd each Vreg.
Instructions classified as assign are only generated when lowering InitOrAssign instructions in regions known to be initialized.
Instructions in the dead block may be used by other dead blocks.
Instructions marked in this set are dead.
Instructions that allocate new objects, without reading any other memory at all, so any effects they have on some types of memory locations we track are isolated from anything else we care about.
Instructions that can re-enter the VM and touch most heap things.
Instructions that compute a subelement are handled by a helper.
Instructions that explicitly manipulate locals
Instructions that explicitly manipulate the stack.
Instructions that never do anything to memory
Instructions that technically do some things w/ memory, but not in any way we currently care about.
Instructions that unconditionally are implemented with InterpOne are translated here.
Instructions that we do not recognize (and thus will not move) and that must* use RCIdentity, implies we are always known safe as long as meet over all path constraints are satisfied.
Instructions which (potentially) write memory.
Instructions which are none if our SILValue does not alias one of its arguments.
Instructions which extract from aggregates.
Instructions which read from memory, e.g. loads, or function calls without / side effects.
Instructions which require a FramePtr for chaining but will accept a parent FramePtr.
Instructions which return the address of non-writable memory cannot have an effect on escaping.
Instructions without side effects are safe.
Instructs the JNI environment to throw a NoClassDefFoundError.
Instructs the JNI environment to throw a RuntimeException.
Instructs the JNI environment to throw an AssertionError.
Instructs the JNI environment to throw an IOException.
Instructs the JNI environment to throw an IllegalArgumentException.
Instructs the JNI environment to throw an IllegalStateException.
Instructs the JNI environment to throw an OutOfMemoryError.
Instructs the JNI environment to throw an exception.
Insufficient information to determine which.
Insufficient result_buf.
Insufficient result_bug.
Int to accommodate truecolor single-color transparency
IntToFPWithOverflow is currently only used to convert 2048 bit integer literals.
Integer literals can be treated as floating point literals.
Integer to fixed point
Integer value of limit
IntegerLiterals are signed.
Integrate the chunk of payload into the result value.
Intended usage is by the packaging script to quickly verify that it's building the thing that it thinks it's building.
Intentional fallthrough
Intentionally copy the raw pointer value
Intentionally doesn't post to jsqueue.
Intentionally higher in case ICU adds more constants.
Intentionally leak the old value pointed to by elem, including from magic methods.
Intentionally not returning, the exception is checked a line later
Intentionally only adjusting the fp here, as the stack offsets should be unchanged in places where we've sunk the DefInlineFP
Intercept only original generator / async function calls, not resumption.
Interceptable functions can be renamed even when JitEnableRenameFunction is false.
Interesting types either contain interesting types, pointers to "pointer followable" types, or have some custom action defined on it.
Interface for ExprWalker
Interfaces implemented by the same class never share a slot, so normal addition is fine here.
Interleave the occupiedValue and spareValue bits, taking a bit from one / or the other at each position based on the spareBits mask.
Intermediate ElemD operations on strings fatal, unless the string is empty, which promotes to array.
Intermediate minstr operations.
Intermediate operations
Internal Resource Data
Internal builds embed tzdata into HHVM by keeping timelib updated
Internal classes can be extended, if we are not in whole-module-optimization mode.
Internal helper methods
Internal href try and find node
Internal resource data
Internal struct for tracking information about types within a series / of "linked" expressions.
Internal utility routines.
InternalPageServer: Server + allowed URL checking
Interned strings are not duplicated when stored in HashTable, but all the interned strings created during HTTP request are removed at end of request.
Interrupts may execute some PHP code, causing another interruption.
Intersect in all predecessors' BBSetOut.
Intersect in all predecessors' BBSetOuts.
Intersect in all successors' BBMaxOuts.
Intersect in all successors' BBSetIn.
Intersect in the successor BBSetIns.
Intersect in the successor WriteSetIns.
Intersect key_files and crt_files to find valid pairs.
Intersect the successors' BBWriteSetIns.
Intervals may be split---e.g., because the Vreg needed to be spilled in some subrange.
Intervals that overlap.
Intialize the hash table first, because the header is already in L1 cache, but the hash table may not be.
Intialize the memory manager here because various settings and initializations that we do here need it
Introduce a new overload set.
Introduce a new scope and place the variables in the pattern into that scope.
Introduce a new scope to contain any var decls in the init value.
Introduce a scope for this partial solution.
Introduce a variable to label the protocol.
Introduce a variable to reference the protocol.
Introduce accessors for a property with behaviors.
Introduce conversions from each element to the element type of the array.
Introduce conversions from each element to the element type of the dictionary.
Introduce each of the type witnesses into the hash table.
Introduce substitutions for each of the generic parameters/arguments.
Introduce the beginning part of the Selector construction.
Introduce the dependent type into the constraint set, to ensure we have a record for every dependent type.
Introduce the fill op.
Introduce the trailing closure into the call, or form a call, as necessary.
Introduce variables to the current scope.
Introduced in DOM Level 2
Introduced in DOM Level 3
Introducing a notion of a LSLocation that is used to model object / fields.
Introducing a notion of a LSLocation that is used to model objects / fields.
Introducing a notion of a LSValue that is used to model the value / that currently resides in the associated LSLocation on the particular / program path.
Ints stay ints unless they can overflow to doubles
Invalid UTF-8 sequence.
Invalid archetypes are never representatives in well-formed or corrected signature, so we don't need to visit them.
Invalid continuation byte.
Invalid escape, ignore it.
Invalid escapes are accepted by the lexer but diagnosed as an error.
Invalid field descriptor
Invalid field descriptor.
Invalid file location
Invalid header for now, to avoid truncated output due to errors looking valid (and to allow computing diskOffset while serializing).
Invalid location means that the instruction has been generated by SIL passes, such as DCE.
Invalid parameters were passed to ldap_explode_dn
Invalid rule to return a more explicit parse error with proper line number
Invalid, implicit, and Clang-imported declarations never require a definition.
Invalidate SrcDB's entries for all func's SrcKeys.
Invalidate all analysis that's related to the call graph.
Invalidate all cached SILFunctions.
Invalidate all of the basic block arguments.
Invalidate analysis information related to branches.
Invalidate any location this instruction may write to.
Invalidate everything since we delete calls as well as add new calls and branches.
Invalidate everything.
Invalidate the SrcDB entries for func's SrcKeys that have any Profile translation.
Invalidation is handled by a callback inside the cast optimizer.
Invariant: All elements at even indices are operator references.
Invariant: S is even-sized.
Invariant: The size of the bit vector is the size of the payload in bits, rounded up to a byte boundary.
Invariant: for every block in the work queue, we have visited all of its dominators.
Invariant: methods on this class with AttrNoOverride or AttrPrivate will not have an entry in this map.
Invariants verified: 1.
Invariants:  All arrays are either in a mode, or in zombie state.
Invert the P-box permutation, and convert into OR-masks for handling the output of the S-box arrays setup above.
Invert the S-boxes, reordering the input bits.
Invert the hoist group data structure to map from canonical check to a vector of checks.
Invert the key compression permutation.
Invert the key permutation and initialise the inverted key compression permutation.
Inverts the expected value of 'PotentialExpect' (if it is an expect / intrinsic) and returns this expected value apply to 'V'.
Investigate when to sink retains and / when to hoist releases and their ordering in the pass pipeline.
Invoke Extension::moduleLoad() callbacks
Invoke iterator() to get an iterator from the sequence.
Invoke the PHP extension function/method
Invoke the boost command line parser to parse the args for HHVM.
Invoke the conversion intrinsic to convert to the destination type.
Invoke the conversion intrinsic, which will produce an owner-pointer pair.
Invoke the conversion intrinsic.
Invoke the given PHP, possibly specialized to match the type of the current function on the stack, optionally passing a this pointer or class used to execute the current function.
Invoke the intrinsic, which returns a tuple.
Invoke the intrinsic.
Invoke the runtime to store the tag.
Invoking the accessor will expect a value of the formal type, so don't reabstract to that here.
Is last char * - charset encoding
Is the argument a type variable...
Is the array type a contextual type
Is the block reachable from the entry.
Is there an uncovered non-trivial type.
Is there is no usable command, cmd is null.
Is this a block that is interesting to the last iteration of the data flow.
Is this a check_bounds.
Is this a hoistable make_mutable call.
Is this a one iteration function.
Is this a unary transitive safe user instruction.
Is this a value that can be unambiguously identified as being defined at the / function level.
Is this basic block jump threadable.
Is this block interesting.
Is this interesting to the last iteration of the data flow.
Is this use outside the loop.
IsASCII is true only if IsASCII of both literals is true.
IsSelfOfNonDelegatingInitializer - This is true if we're looking at the / top level of a 'self' variable in a non-delegating init method.
Isn't expecting to get private static properties of super classes just yet.
Isset, Empty, and type querying instructions
Issue a warning on unsupported type in case of HH syntax.
Issue a warning when the returned expression is on a different line than the return keyword, but both have the same indentation.
It *may* have failed.
It *seems* better than clearing the msb.
It / also provides caching of certain analysis information that is used by all of / the passes.
It / buffers up diagnostics produced during compilation, then checks them / against expected-error markers in the source file.
It / should be a performance win for small constant values where the function / can be inlined, the loop unrolled and the memory accesses merged.
It / will be a tradeoff between utility of the attribute vs.
It abstracts away how this behavior is communicated within the generator.
It additionally performs dead code elimination when it initially adds instructions to the work queue in order to reduce compile time by not visiting trivially dead instructions.
It affects code generation on our platform.
It also can't change anything about an inner array type.
It also does not copy any extension-specific data.
It also enables loop canonicalizations to be tested via FileCheck.
It also has to be declared `class' because it's referenced as a friend class in the ICU headers.
It also ignores functions which return "small" things.
It also makes the proxy findable when a dummy sandbox thread needs to interrupt.
It also may simply have no data
It also means that reference counting operations on those references / have the same semantics.
It also performs some branch/setcc fusion as it goes.
It also prints a sorted table containing the contribution to the code size increase for all inlined functions.
It also records how many Shapes it saw.
It also runs the simplify() subroutine on every instruction in the unit, and can eliminate some conditional branches that test types of memory locations.
It also seems true for that case as well, since the resulting array is essentially metadata for the object.
It also seems true for that case as well, since the source array is essentially metadata for the object.
It also sets the guard-failure block, if any.
It also specified that there would be exactly 12 months per year and 365.25 days per year with every 4th year being a leap year.
It came out of the approach we used above, and it's not any worse than any other choice we could make.)  It is crucial that we don't do the same to the expanded key used in the main Eksblowfish loop.
It can also adopt class references of bridged error types directly.
It can also be used by generic specialization and existential devirtualization passes to promote witness_method and protocol_method instructions to static function_refs.
It can be acquired only when it is zero.
It can be an argument.
It can happen in phijmp or callargs.
It can happen with class constraints that Sema will consider a constraint to be abstract, but the minimized signature will eliminate it as concrete.
It can save some compile-time.
It can't be a trailing closure unless it has a specific form.
It can't be invalid, and it can't be the same thing twice in a row, so we just use a counter.
It can, in fact, do this -- except due to what is as far as I can tell a linker bug on OS X, ld doesn't actually lay this out with 16 byte alignment, and so the SSE instructions crash.
It cannot be defined by an extension or a derived class.
It cannot currently be used on let's since we don't have a mutability model that supports it.
It cannot have a guard expression and the pattern cannot be refutable.
It cannot in of itself extend the lifetime of an object (just like a phi-node) cannot.
It cannot increment ref counts.
It collects uses from / the address and the refcount result of the allocation.
It comes out of the context as an i8*.
It comes up during switch emission.
It consists of a base and a / projection path to the field accessed.
It consists of three parts.
It contains the total overhead of inlining / the function.
It converts a gd Image to bw using a threshold value
It could be a type or an expr.
It could be avoided on an instance---but we're not trying to notice those cases right now.
It could be much better.
It could be overridden by a computed property in a subclass, but that's not likely enough to be worth the strictness here.
It could be that the argument doesn't conform to an archetype.
It could cause a crash.
It could come from either at runtime.
It could decref the inner ref.
It decides which helpers/builtins should use eager vmreganchor based on profile information.
It defines an interface as to how the / code motion procedure should be.
It does its best to not search unnecessary subtrees, / although this is complicated by the fact that not all nodes have / source range information.
It does mean we will be loading and storing garbage m_data for Null values but that's fine since m_data is undefined for Null values.
It does not attempt to remove unnecessary evaluation stack manipulation spanning basic blocks, but it uses the same local DCE code and will eliminate intra-block stack manipulations.
It does not correspond to a native argument.
It does not mean that the replicaSet name is "1".
It does not support ExtHeaders as defined in the spec.
It does this by classifying the enum along two orthogonal axes: the loadability of the enum value, and the payload implementation strategy.
It does this by tracking all types which are allocated via the allocation functions via the type-index mechanism.
It does, however, entail an indirect jump.
It doesn't actually matter which DeclContext we use, so just use the imported header unit.
It doesn't affect name lookup.
It doesn't contribute.
It doesn't emit uncalled member functions in a template class, even when using ATTRIBUTE_USED.
It doesn't make sense to specify keys for Vectors.
It doesn't make sense to update the target block state at this point, so don't.
It doesn't matter if we ever actually clean up that retain though.
It dominates all other blocks in this CFG pattern.
It either sets the value to `v', or binds the value to `v', depending on whether `v' is "observably referenced"---i.e. if `v' is already KindOfRef and RefData::isReferenced is true.
It expects `tv' to be the address of a TypedValue with refcounted type `type' (though it may be static, and we will do nothing in that case).
It expects all variable values to be fully serialized across the wire.
It first checks / in the module.
It found Tishri 1 at the end of the year.
It found Tishri 1 at the start of the year.
It has been modified to return the converted value as a * parameter.
It has been processed, and there are no more children to process, so delete it and pop it off the stack.
It has space only for witnesses to the ErrorProtocol protocol.
It has to *syntactically* have a tuple type as its argument.
It holds the list of / basic blocks excluding all unreachable blocks.
It includes referencing this specific property (both reads and stores), as well as implicit stores by means of e.g. a struct instruction.
It is Adar II or later - don't need the year length.
It is Kislev - must find the year length.
It is OK if other threads still try to use the previous chunk before this point.
It is Tevet, Shevat or Adar I - don't need the year length.
It is Tishri or Heshvan - don't need the year length.
It is a common error to try to capture a nested field instead of just a local name, reject it with a specific error message.
It is a floating piece of text that inherits location information from its parent.
It is a list of offsets, along with a certain action to perform at that offset.
It is a little bit of a hack to use an AFDT request/response to shut down our accept socket, but it has to be done from within the main libevent thread.
It is a little bit of a hack to use libafdt to send the shutdown request, but we need to synchronously shut down the admin server, so we cannot use the admin server for it.
It is a plausibility check for the function parameters (requirements engineering).
It is a series of struct_element_addr followed by load.
It is a somewhat common error to try to access an instance method as a curried member on the type, instead of using an instance, e.g. the user wrote:
It is a warning message
It is also in a "could be" relationship with all its ancestors (including optional)
It is also possible to use just the second pass to map to an arbitrary externally-given color map.
It is always in the first argument position.
It is an invocation of a class method.
It is assumed in several places in IR-generation that the explosion schema of a tuple type is always equal to the appended explosion schemas of the component types.
It is assumed that each fault funclet handler extends from its entry offset until the next fault funclet entry offset (or end of the function).
It is assumed you will get that right in calling this.
It is at offset 0x08.
It is at offset 0x7c, and is up to 32-bytes, including the terminating NUL.
It is blacklisted, but it may have been a long time again and chances are we should give it another try
It is blocking and can take some time, so do it in a separate thread.
It is common to name a parameter and not use it (e.g. because you are an override or want the named keyword, etc).
It is essential to inline it for stack promotion of the array buffer.
It is fine to shadow names from the 'swift' namespace in 'swift::sma'.
It is fine to think of it that way for general understanding of the analysis here, but in this implementation we don't actually treat it that way when merging.
It is generally ok to resolve a method that won't actually be called as long, as we only do so in cases where it will fatal at runtime.
It is hard to tell whether the next clause is a pattern or an invalid expression, because 'case' patterns can have expressions embedded in them.
It is implemented as max(strideof, 1)
It is important that cond_br keeps an i1 type.
It is important that the run time of this function is dependent only on the length of the user-supplied string.
It is important that this transformation is done at the end of a pipeline, as it may break some optimizations.
It is important to check for IMAGE_FILETYPE_TIFF JPEG does not use absolute pointers instead its pointers are relative to the start of the TIFF header in APP1 section.
It is important to know this information when / you perform such optimizations like e.g. jump-threading.
It is important to pass nullptr so that the OS sets mtime and atime to the current time with maximum precision (more precise then seconds)
It is intended to be fast and catch / obvious cases so that SILCombine and other passes are more effective.
It is left uninitialized so that multiple parsers can coexist.
It is legal IR to have a LdCtx after this sort of decref, but it would be a semantically incorrect program if it does anything with the context after loading it that cares about whether it's freed.
It is maintained as an upper bound of the actual value during the transformation.
It is meant to be fast, but not as fast as possible.
It is my intent that you should be able to use this on your system, as part of a software package, or anywhere else to improve security, ensure compatibility, or for any other purpose.
It is necessary to clear leftovers, as EndNetworkProfile() can race with threads writing their status.
It is necessary to override this handler with zend_objects_store_clone_obj, which does call the bucket clone handler.
It is not a huge problem in practice because Xcode auto-saves constantly.
It is not a requirement, but we attempt to locate all the DV entry points after the rest of the primary function body.
It is not always possible to fold an instruction in case of error.
It is not clear when the current rule based calendar replaced the observation based calendar.
It is not necessary to fill the buffer entirely, only to obtain at least one more byte.
It is not type metadata in and of itself, but is referenced in the structure of existential type metadata records.
It is not used for the in-place / initialization of non-generic nominal type metadata.
It is ok if we store into the alloca pointer though.
It is ok to cache a non-AttrPersistent class here, because if it isn't loaded in the request we'll never hit the TC fast path.
It is ok to eliminate the Dup even if its second output u2 is used, because eliminating the Dup still leaves the second output u2 on stack.
It is ok to eliminate various retains/releases.
It is okay for an identified loop to have releases in between a retain and a release.
It is okay if it is set in a later option, as we first always free the value before setting it anyway.
It is okay to store into this AllocStack.
It is one of the last 6 months of the year.
It is only applied with constant shift counts.
It is only necessary because of the poor representation of clang enum aliases and should be removed when rdar://20879992 is addressed.
It is only safe to perform this operation when there exists a dominating edge E' of IVE for which FirstIV also takes on a non-payloaded enum value.
It is only used for sorting.
It is ordered *after* the locks in s_linkTable.
It is our duty to add a chunk.
It is painful to recover from incorrectly-computed hashes - merely fixing whatever broke is not enough.
It is perfectly fine to eliminate various retains and releases of this object: we are zapping all accesses or none.
It is possible and likely that another statically initialized object will call methods on it to create counters.
It is possible if a derived class is defined that does not call this class' constructor.
It is possible in some requests that things like 'instanceof Foo' will not mean the same thing.
It is possible that locals have already been decref'd.
It is possible that one module has a declaration of a SILFunction, while another has the full definition.
It is possible that the instruction still has uses, because it could be used as the replacement Value, i.e. F.second, for some other RLE pairs.
It is possible that the last member lookup can return multiple lookup results.
It is possible that we had processed this user already.
It is possible that we won't find a bridging type (e.g. String) when we're parsing the stdlib itself.
It is possible to cast the address of a smaller InputType to the address of a larger OutputType (the actual memory object must be large enough to hold both types).
It is possibly a compile-time slowdown only, but we haven't investigated yet.)
It is pretty common to select between zero and 1 as the result of the select.
It is priming, and there might not be the right class definitions for unserialization.
It is probably fairly close to allowing you to access most of the metadata associated with hhvm's compiled unit format, although it's possible something has been overlooked.
It is processed if the pointer is non-NULL, and it is either at the `GMT', or at the end of the string.
It is provided "as is" without express or implied warranty of any kind.
It is reset to ' ' by non-numeric formats
It is restored below.
It is safe to hoist array.props / calls if the array does not escape such that the array container could be / overwritten in the hoisted region.
It is significantly bigger than what we need but hard to control all the info that we may want to add here.
It is specifically NOT correct to do something like this:
It is sufficient to register m_currentFrame for this treatment, because if any of its parent frames are destroyed it will be destroyed too.
It is supposed to run very / late in the pipeline, after devirtualization, inlining and specialization / passes.
It is tempting to try to free the ExtraArgs structure here, but it's ok to not to:  o We're about to raise an uncatchable fatal, which will end the request.
It is the start of a block if it is:  - A jump target  - Immediatelly following a control flow instruction, other than a call.
It is the summarized numbers of all nodes referring to the / function minus the size of the original function (which is not inlined).
It is the unit of register allocation.
It is therefore not useful for programs intended to be portable to DOS machines.
It is unfortunate that C does not provide an operator for cyclic rotation.
It is used by the XML callback that destroys a context.
It is used to know when loads can provide memory support.
It is useful to show inout for function parameters.
It is valid for a JP2 file to contain multiple individual codestreams.
It is very common for a contextual type to disagree with the argument list built into the closure expr.
It isn't valid to fall off into the normal flow.
It just can't be resilient at the top level: we have to know its immediate members, or we can't even begin to approach the problem of emitting metadata for it.)
It just means that it might, and that our lower bound may have been "kept higher for longer" using that knowledge at some point.
It looks like php5 xdebug used to consider "temporary" as a state.
It looks strange at the first glance, but this / is OK, because this function is invoked only internally when processing / tuple_extract instructions.
It looks up the predicted type for the value in cur().predictedTypes and ensures both locations have the most refined predicted type possible.
It loses source information.
It makes sure you don't walk off the string.
It may be cheaper to pass one of their operands / to the successor instead of the whole instruction.
It may be ok to remove pops on objects with destructors in some scenarios (where it won't change the observable point at which a destructor runs).
It may even have written uninits deeper than the stack base (but we limit it to sSurprisePageSize, so it's harmless).
It may happen that other thread has already updated the diagnostics to the version *after* NewSnapshot.
It may happen that this request was waiting in async queue for too long so another thread has already updated this sema with ast generation bigger than ASTGeneration
It may not--for example in the case that `swiftc -target x86_64-unknown-linux-gnu -emit-ir` is invoked using a Swift compiler not built for Linux targets.
It may only be used on class members.
It may return a new array if the array needed to grow, or if it needed to COW because cowCheck() was true.
It may still be dynamically the same object though.
It means ptr isn't really a pointer, so return AEmpty to avoid unnecessarily pessimizing any optimizations.
It might be an invalid encoding of some sort, but garbage in garbage out is ok.
It might be an object, or we might want to support type aliases in HNI at some point.
It might be an uninitialized property/constant.
It might be more appropriate to include it in the 8859 set instead of the ASCII set, but it's got to be included in *something* we recognize or EBCDIC files aren't going to be considered textual.
It might be worth adding a mechanism for the external emitter to emit a line number when it fails that we can use when available.
It might clarify this a little to list the reasons that a must-alias-set's lower bounds can be increased: o An explicit IncRef instruction in the instruction stream of a tmp in the must-alias-set.
It might get replaced later.
It might have been loaded in a parent frame, though, so we have to find the appropriate FrameState.
It might throw, or loop forever.
It must be a class method.
It must be some other problem, such as failing to infer a generic argument on the enum type.
It must be the entry block See if it is reached over Success or Failure path.
It must be the same type as LoadTy if available.
It must have a valid raw type.
It must make sure that no write and no increment to the array / reference has happened such that hoisting is not valid.
It needs to allocate and free its Array per request, because Array lifetime is per-request.
It needs to be closer to other bytecode.cpp data.
It never promotes emptyish types, however.
It only applies to object properties.
It only handles load, store and deallocation instructions.
It only makes sense to constrain tc with a class that's related to its existing class, and we want to preserve the more derived of the two.
It only performs one step of inlining: it does / not recursively inline functions called by the callee.
It only splits new critical edges it creates by jump threading.
It only works with stored properties.
It probably doesn't make sense to always guard on an object class when we have one.
It remains to check the validity of comments (2.) since it's referred to an "old" OS/2 version.
It replaces an indirect class_method-based call by a code to perform a direct call of the method implementation based on the dynamic class of the instance.
It represents the state of the spill space as a whole and is computed before each individual instruction.
It requires a TupleType to compute the mapping from argExpr.
It returns a +1 value with one.
It returns a pointer to the property's address, or init_null_variant if the property was Uninit and doWarn is true.
It seems like we shouldn't see FunctionType at that point.
It seems that parts of LLVM are using the flexibility of having a context.
It seems that the underlying binary representation is same with swift utf16 representation.
It serves two purposes at once:  1.
It should / be kept in sync with importEnumCaseAlias in the ClangImporter library.
It should always still be a placeholder, because it was created as an anonymous symbol and nobody should ever be randomly messing with those.
It should be a constant in most cases.
It should be an integer, but copyTruncatedAsciiChars will automatically convert it to a string.
It should be impossible to have two operands with different encodings at this point.
It should be impossible to reach a prologue that has been reclaimed through an immutable stub, as this would imply the function is still reachable.
It should be never called.
It should be only an integer literal instruction.
It should be pretty fast.
It should be removed when fixed.
It should be safe to free the string we previously allocated, since we have not got to the end of the request when the MemoryManager will free these strings.
It should have pushed LdMem and IncRef to each successor block, with the narrowed type on the fallthrough block.
It should replace them with ErrorExpr.
It should run before ClosureSpecialization, because constant propagation is more effective.
It shouldn't affect correctness but it can cause us to miss out on some perf.
It shouldn't be deleted when the NetworkAccessManager is deleted, but only when close is called on the cookie jar.
It simply invokes the actual implementation of the runtime entry by means of indirect call through a pointer stored in the global variable.
It sometimes happens that we get r-value bases here, e.g. when calling a mutating setter on a materialized temporary.
It still might contribute to 'rethrows', but treat it as an opaque source.
It then calls / reduce, in hope to get the original memory location back.
It then calls IRBuilder optimizeInst, which may or may not insert it depending on a variety of factors.
It then folds offsets in memory operands to try to require fewer registers.
It then procedes to block for up to 'timeout' seconds, waiting for the first actionable descriptor(s), which it then returns in the form of the original arrays passed in.
It then removes all / the old retain and release instructions and create the new ones.
It tries to be faster by giving up on functions quickly, and making a quick test to ignore them later.
It tries to pass all variadic arguments by reference, but it also allow expressions that cannot be taken by reference (ex. SORT_REGULAR flag).
It turns out that the actual msgsnd() and msgrcv() calls work fine with the same structure that other OSes use.
It turns out to be safe to sink in this case, and it fits the idea that we "know about two references".
It was designed with consideration of the flaws in various other generators.
It was determined by inspection of the character codes stored in Microsoft font symbol.
It was not always the first of January.
It will NOT be run when the VarDecl is merely used from another file.
It will adjust all references into the original src ranges to point into the corresponding relocated ranges.
It will also have to remove unreachable blocks when it's finished to maintain IR invariants (e.g. through DCE::Minimal), which will mean the uses of the no-longer-defined tmp will go away.
It will also return an empty array if the values for a valid collection-like configuration has not been set.
It will be INT32_MAX on exits from the compilation unit.
It will be added later if needed.
It will be cleaned up and destroyed later by another thread.
It will be diagnosed elsewhere.
It will decref it and put the class on the actrec before entering the "real" cloned closure body.
It will group the / available value's by the LSValue base, i.e. the LSValues come from the / same instruction, and then use extraction to obtain the needed components / of the base.
It will have to go away once we're properly differentiating bound generic types based on the protocol conformances visible from a given module.
It will likely be destroyed when the caller's reference goes out of scope.
It will list only the parameter types as guards.
It will move what's at yytext (if anything) to the beginning of the buffer and fill the rest with new data.
It will return early after parsing any top level code in a main module, or in SIL mode when there are chunks of swift decls (e.g. imports and types) interspersed with 'sil' definitions.
It will return early after parsing any top level code in a main module.
It works with the latter because both ANSI C and C++ allow castless assignment from any pointer type to void*, and deal with argument conversions as though doing an assignment.
It would be better to use print, but we need a PrintingPolicy for that, for which we need a clang LangOptions, and...
It would be better, IMHO, to skip the C from the S part of the encoding.
It would be good to eventually be able to analyze these.
It would be good to make these the same too, since we're fuzzy matching.
It would be nice if this weren't discarded.
It would be nice to extend the front of the range to show where inout is, but we don't have that location info.
It would be nice to print the offending signal name here, but strsignal() isn't reliably available.
It would be nicer to re-use them.
It would fail right now for exit traces.
It would have been cleverer if we'd used 'f' for thin functions and something else for uncurried functions, but oh well.
It would not be ok to reuse the Context's address buffer though, since our base value will a different type than the element.
It wouldn't be unreasonable for this method to just ignore OTK_None if we made code more convenient to write.
It'd probably be cleaner to model as `where Self: ...` constraints when we have those.
It's a block algorithm
It's a builtin which has the same value in its first and second operand.
It's a collection, so either ThrowInvalidOperation, or return a constant depending on the type of comparison being done.
It's a hole in this if we don't check unserialization doesn't violate what we've seen, which we handle by throwing if the repo was built with this option.
It's a known attribute, so treat it as a syntactic attribute node for syntax coloring.
It's a right parenthesis in a string literal.
It's also necessary because we might run destructors as part of parameter coersions, which we don't want to clobber our spilled stack.
It's also possible it was loaded in the frame of a previously inlined callee that we've already popped.
It's always a metatype type, so use the instance type name.
It's always either the generic parameter type 'Self' or a metatype thereof.
It's an "exit" edge from the lifetime region.
It's an array buffer allocation.
It's an object allocation.
It's because of std::pair (and is still the case if you return a custom struct).
It's better to leak memory here than to have random crashes on shutdown.
It's binary if either both sides are bound or both sides are not bound.
It's changed everywhere except here in xdebug's code.
It's closer to the LibEventServer behavior
It's compressed, so it'll be different.
It's conceptually the same as if it was storing an Uninit over each of the locals, but the stores of uninits would be dead so we're not actually doing that.
It's directly exposed within the webpage JS context, and indirectly in the phantom JS context.
It's easier to do this unconditionally here and then overwrite in the exception case (when we turn the inout into an UnsafePointer) than to try to discover that we're in that case right now.
It's easier to know how many 16bits of data the immediate uses by counting how many nops there are inside of the code
It's important for good code layout that the insertion point be left in the original function section after this.
It's important that the EndBlock is at the head of the WorkList so that we handle it after all other blocks.
It's important to update this traversal whenever the AST is changed, whether by adding a new node class or adding a new child to an existing node.
It's important to use a shared linkage for the specialized function and not the original linkage.
It's in this source file.
It's just a DI annotation.
It's length from the segment is the shorter of the lengths from the endpoints, but call the distance -1, so as not to compute the alpha nor draw the pixel.
It's logically `publishing' a pointer to a pre-live ActRec, making it live.
It's logically const, because we're using DataTypeGeneric.
It's more maintainable to just white-list the instructions that do* have mandatory arguments.
It's necessary because properties can get types before validateDecl is called.
It's not a block algorithm
It's not clear what transformations (if any) on naive SILGen output would ever produce that, but still, don't do it.
It's not clear where the IncomingBranch should go to if cb is frozen.
It's not clear why writing an object file does.
It's not harmful per se, but it's indicative of redundant logic in the frontend.
It's not incorrect to leave things out of the kills set, but this assertion is here because we shouldn't do it on purpose, so this is here until we have a reason not to assert it.
It's not live when we enter the helper.
It's not normally ok to directly use tracelet abi registers in codegen, unless you're directly dealing with an instruction that does near-end-of-tracelet glue.
It's not ok to just ignore this.
It's not plausible that we need a full 64bits to hold memory stats, no matter what the collection mode.
It's not possible to mangle the context of the builtin module.
It's not quite clear how in practice we'll be able to conclude that something is known-POD without knowing its size, but it's (1) conceivable and (2) needed as a general export anyway.
It's not really the closest* molad that we want here.
It's not safe to cache the non-private results because we didn't search private imports there, but in most non-private cases the result will be cached in the final lookup.
It's not safe to call this function more than once
It's not semantically necessary to preserve SIL block order, but we really should.
It's not usually an interesting difference.
It's ok not to make a new definition of this tmp, because the code running simplify is going to have to track unreachable blocks and avoid looking at them.
It's okay if this estimate is wrong as we will grow or shrink as needed.
It's okay if we passed fewer arguments than there are parameters as long as the gap can be filled in by DV funclets.
It's okay to deactivate a cleanup for a / TakeOnSuccess value and then introduce new cleanups for all of its / subobjects.
It's okay to grow etc.
It's okay to have these in side exits
It's only supported on 64 bit architectures.
It's pointless to match character encodings here.
It's possible that in some requests nsName might succeed, while in others fallbackName must succeed.
It's possible that this happened because the user just pointed yyin at a new source and called hphplex().
It's possible that this happened because the user just pointed yyin at a new source and called yylex().
It's possible that we could drive pushes from somewhere other than the VM thread, in which case we'll need a different saftey mechanism
It's possible to get a ReflectionProperty for a property which no longer exists.
It's possible to have no insertion point here if the end of the true case was unreachable.
It's possible to subtype RAT::Array types, but it's potentially O(n), so we just don't do it.
It's possible we could assert the intersection of the types, but it's not entirely clear what situations this would happen in, so let's just not do it in this case for now.
It's probably due to an incorrect prediction.
It's probably only possible in code that's already otherwise provable to be unreachable.
It's reasonable to expect that the replacement won't be completely unrelated to the original, but try to avoid making assumptions about the exact representation type.
It's safe to assume they're init because you can never have a reference to uninit.
It's safe to copy all 16 bytes of the TV because packed arrays don't use m_aux.
It's safe to side-exit still because we only do these profiled array gets on the first element, with simple bases and single-element dims.
It's the caller's responsibility to ensure that the old function exists.
It's the first one in the list...
It's the first time we found a call to InitF in this function, so we try to hoist it out of any loop.
It's the first time we see the destination node, so we add it to the mapping.
It's the top-most declaration (not a module).
It's there without values, and gone with values, so it is too large.
It's type needs to be convertible to the function's return type.
It's unlikely that the user is interested in binding a variable of type (foo: Int).
It's unsafe to reset() m_path2Node / m_lpath2Node while concurrent accessors might be touching it.
It's up to the callee to constrain further if needed.
It's up to the caller to make sure it is a legal literal.
Items with string arguments.
Items with version arguments.
IterFree must come after VerifyRetType, because VerifyRetType may throw, in which case any Iters will be freed by the fault funclet.
IterInit and IterNext can be called directly from the JIT for specialized iterators.
IterInit* and IterNext*, Both implicitly free their iterator variable on the loop-exit path.
IterNext/IterNextK helpers
Iterate in reverse order so the first page is the last one scheduled for deletion.
Iterate on live out states until we reach a fixed point.
Iterate on the antIn/antOut states until we reach a fixed point.
Iterate on the ppIn/ppOut states until we reach a fixed point.
Iterate over all AST modules.
Iterate over all attributes of the given DIE, calling the given callable for each.
Iterate over all children of this DIE, calling the given callable for each.
Iterate over all dependent types in the generic signature, which will match the specialized attribute's substitution list.
Iterate over all immediate predecessors of the target basic block.
Iterate over all loads and replace them by values.
Iterate over all numbers and mark each one found.
Iterate over all the compilation-units in the file, calling the given callable for each.
Iterate over all uses of a given partial_apply and check / if any of those uses are apply instructions.
Iterate over all uses of the partial_apply and look for applies that use it as a callee.
Iterate over arguments and dump their epilogue releases.
Iterate over children
Iterate over input and store wait handles for all elements in a new array.
Iterate over instructions in forward order.
Iterate over path components in `left'.
Iterate over results and store in array.
Iterate over the "hosts" document
Iterate over the declarations and infer required availability on a per-platform basis.
Iterate over the format string filling in the result objects until we reach the end of input, the end of the format string, or there is a mismatch.
Iterate over the instructions in the basic block in forward order and / process them w.r.t.
Iterate over the instructions post-order and find final releases associated with each arguments.
Iterate over the instructions post-order and find retains associated with return value.
Iterate over the leafs of the tree...
Iterate over the non self arguments and add them to the new argument list, upcasting when required.
Iterate over the potential witnesses for this requirement, looking for solutions involving each one.
Iterate over the tuple type fields, corresponding to each parameter.
Iterate the IdMap to find the argument type of the given param name.
Iterate through all files in the cert directory.
Iterate through the function's opcodes and place breakpoints on each RetC
Iterate through the globals, filtering out non-superglobals
Iterate through the region, checking its suitability for inlining.
Iterate through the remaining bytes.
Iterate to a fix point, two times for a topological DAG.
Iterate to forward through chains of copies.
Iterate until a fixed point.
Iterate up the stack.
Iterating invariant_tmps goes in insertion order, which means it is already guaranteed to be topologically sorted by any dependencies between the instructions.
Iteration is stopped early if any of the calls return false.
Iterative forward data flow.
Iteratively invoke 86pinit() methods upward through the inheritance chain.
Iteratively mark cleanups dead and pop them.
Iteratively simplify while there is still work to do.
Iterator bytecodes have multiple local immediates but not the Local flag, so they should never flow through this function.
Iterator for PHI operands.
Iterator for input string
Iterator for output string
Iterator instructions
Iterator into the lookup table.
Iterator over the arguments (phis) of a basic block.
Iterator which iterates over all basic blocks of a function which are not / terminated by an unreachable inst.
Iterators over collections are never by-ref so there is no reason to unbox any value.
Its a dynamic constant, that doesn't correspond to an already allocated handle.
Its advantage is that it is guaranteed to return a color index in one search over the color table.
Its arguments are the direct results.
Its contents will be uninitialized by the point it executes.
Its important to distinguish the actions that are inherent to a type (embodied in the Action class), with the actions assigned inside an indexed type.
Its legal to ref a list...
Its live-out properties are whatever are trivially locally inferred by the loop above.
Its main purpose is for performing small combining operations/peepholes at the SIL level.
Its not an error for an abstract function to have zero size.
Its not safe to destroy the globals, or run atexit handlers.
Its not safe to do recursively delete here as some of the SILInstruction maybe tracked by this set.
Its not the final release.
Its now too late to run the requestShutdown functions, but if we carry on, requestInit and requestShutdown will never be called again.
Its ok to process the live ones more than once.
Its operand must be an i1 that has a different lifetime from any ref counted object.
Its run as a treadmill job, because old requests might continue to execute the old code, even after we finish the relocation step.
Its straightforward to prove that / retain sinking is correct.
Its subexpression should be convertible to a tuple ((T.Key,T.Value)...).
Its subexpression should be convertible to a tuple (T.Element...).
Its uses will be replaced by the promoted address.
Ivars need to be collected in the ivars list, and they also / affect flags.
JCE: Arrange HAVE_LIBPNG so that it can be set in gd.h
JCE: arrange HAVE_LIBJPEG so that it can be set in gd.h
JEWISH DATE TO SERIAL DAY NUMBER  The year number is used to find which 19 year metonic cycle contains the date and which year within the cycle (this is a division and modulus).
JIS should be tanslated to MB or we leave it to the user
JITing pseudo-mains requires extra checks that blow the IR.
JP2 is a wrapper format for JPEG 2000.
JPEG 2000 Marker Codes
JPEG 2000 components can be vastly different from one another.
JPEG do we have the data area and what to do with it
JS Code to evaluate User Input and prettify the expression result
JS Code to find possible completions
JavaScript/CSS/etc...
Jmp to the two-argument prologue, or emit it if it doesn't exist yet.
JmpZero/JmpNZero is handled separately.
Join the CheckType to itself in case this is the first time we've seen it (i.e. it's not in the hoist group forest yet).
Jump directly to parsing another operator.
Jump immediately to the continuation.
Jump instructions use an Offset relative to the start of the jump instruction.
Jump is unreachable, nothing to do here
Jump over any class attribute mangling
Jump over the self parameter in the Clang type.
Jump tables are lists of labels.
Jump threading is expensive so we don't always do it.
Jump to the break label and free any pending iterators on the way.
Jump to the continue label and free any pending iterators
Jump to the failure block.
Jump to the finally block and free any pending iterators on the way.
Jump to the func prologue.
Jump to the label and free any pending iterators.
Jump-threading was not possible.
Jumps outside of the decision tree entirely will be / fine: the jump will simply destroy the subobjects instead of the / aggregate.
Junk the truecolor pixels
Just / apply the substitution on the AST level and then lower that.
Just a dumb implementation for now.
Just accept 'source.request.buildsettings.register' for now, don't do anything else.
Just accept the ")" and build the tuple as we usually do.
Just add the suffix back on.
Just allow the profile length to implicitly distinguish the presence of an error result.
Just bail and return false.
Just bail out on variadic tuples for now.
Just be lazy and reload the error there.
Just before the output option, allow GenericUnix toolchains to add additional inputs.
Just borrow the previous self value, since it will be guaranteed up until the 'super.init' or 'self.init' call.
Just branch on the condition.
Just compare the value decl pointers.
Just consider it to be a clobber.
Just construct the enum directly in the context.
Just consume the incoming argument.
Just convert the opcode to a Nop, because this could create an empty block and we have an invariant that no blocks are empty.
Just convert the seconds field to a string.
Just copy the out-of-line storage pointers.
Just create a new type variable for the decl that isn't bound to anything.
Just create the objc_to_thick_metatype instruction.
Just create the thick_to_objc_metatype instruction.
Just decode all IR pointers to unsafe pointer type.
Just delete the source.
Just diagnose this as an ambiguity.
Just don't claim the value.
Just drop the attribute.
Just dump the superglobals as specified via ini
Just emit a generic message here.
Just emit a let with cleanup.
Just emit its value directly.
Just fall back to emitting a switch.
Just fill in null here if the type can't be statically laid out.
Just for completeness.
Just force the result to unconsumed so that clients don't have to handle this.
Just force the unset element to yes so that clients don't have to handle this.
Just forward the incoming argument.
Just forward the input as the result.
Just handle this types as opaque integers.
Just holders for the value
Just ignore it, it will be cleaned up by simplify-cfg.
Just ignore the call result if we're suppressing the error check.
Just in case TRACE_RB changes errno
Just in case it is not.
Just in case the algo has internally allocated resources
Just in case the callee is a noreturn function.
Just in case we actually have a definition, use it to infer member-ness.
Just initialize the options for the subsequent request.
Just invoke its accessor function to get its address.
Just keep inserting / being unreachable right where we are.
Just leave this as an unresolved member reference.
Just leave this as whatever type of member reference it already is.
Just look at the first character.
Just look through l-valueness.
Just make a guess about the import kind, we cannot do better.
Just make sure that the actual conventions match up.
Just mangle the decl's DC.
Just move to MightBeDecremented.
Just need to hook up the new phis.
Just one of the two is a protocol.
Just pass in the address to fix lifetime if we have one.
Just perform normal dot lookup on the type see if we find extensions or anything else.
Just push by default.
Just pushing a retain(x) past a retain(y) doesn't change the program.
Just re-typecheck it.
Just replace the base name.
Just reprint the original mangled name if it didn't demangle.
Just retain a by-val let.
Just return SILValue().
Just return the existing one.
Just return the spot to continue.
Just say the vague 'cannot use' diagnostic.
Just send the class name instead.
Just set global escaping in the caller node and that's it.
Just smash m_dbgBranchGuardSrc.
Just stop if we've already applied this attribute.
Just stop if we've already processed this declaration.
Just to make sure the prototypes match the actual definitions
Just to silence warnings until we remove them from various config files
Just treat all members of self as uses of the single non-field-sensitive value.
Just use id for the receiver type.
Just use the argument registers instead.
Just use the first '#define' to allow all the prints...
Just use the generic signature from the context.
Just use the most feature-rich C language mode.
Just use the reference type as a primitive pointer.
Just using setter/accessor functions to get around that.
Just zap the incorrect explicit specialization.
Keep GC from asserting on freed string in debug mode.
Keep a map we can use to check for duplicate case values.
Keep a stack of the currently-live optional evaluations.
Keep all nodes with a points-to edge in the WorkList and remove all other nodes.
Keep anything from the last spot we've checked to the start of the fixit.
Keep around the dependence on the open instruction unless we've actually eliminated the use.
Keep clrBack as color index if required
Keep continuing the identifier.
Keep drilling down to the first element type.
Keep expanding the location.
Keep generated code identical without randomness
Keep going up as long as this expression is the parent's base.
Keep in sync with DiagnosticsSIL.def.
Keep in sync with order in hphp/runtime/ext/asio/wait-handle.h
Keep iterating if the worklist is not empty.
Keep looking at subsequent arguments.
Keep on comparing from the current point.
Keep only up to, but not including, first paren
Keep reading if input is unfinished.
Keep rotating at most until we hit the original latch.
Keep running until we reach one.
Keep scanning in case the copy_addr appears multiple times.
Keep skipping uppercase letters.
Keep the data and stag from this, but change its bits.
Keep the diagnostics array in source order.
Keep the number of LSLocations in the LocationVault.
Keep the operand, not the instruction in the visited set.
Keep the original source.
Keep the other store.
Keep the same prediction as the src local.
Keep the service alive even when idle.
Keep these as assertions instead of early exits to ensure that we are not doing extra work.
Keep these two in sync.
Keep this assert even if you change the representation above.
Keep this string fixed in case the option used by the compiler itself changes.
Keep to zero when no symbol should be popped.
Keep track of InOutExprs
Keep track of acceptable DiscardAssignmentExpr's.
Keep track of all the uses that aren't loads or escapes.
Keep track of all the uses that aren't loads.
Keep track of an association between vardecls and the StmtCondition that they are bound in for IfStmt, GuardStmt, WhileStmt, etc.
Keep track of argument failure information if the entire matching candidate set agrees.
Keep track of backend options so we can embed them in a separate data section and use them when building from the bitcode.
Keep track of blocks where the contents of the self box are not valid / because we're in an error path dominated by a self.init or super.init / delegation.
Keep track of cold blocks.
Keep track of full inlined functions so we don't waste time recursively reprocessing them.
Keep track of how many nested refinement contexts we have pushed on the context stack so we can pop them when we're done building the context for the StmtCondition.
Keep track of inline function bodies so that we can generate IR from them using Clang's IR generator.
Keep track of loop headers - we don't want to jump-thread through them.
Keep track of some information about a variable.
Keep track of that successfully inserted chunk id
Keep track of the fact that V is live and add it to our worklist so that we can process the values it depends on.
Keep track of the fact that we're inside of a var/let pattern.
Keep track of the fact that we're inside of an enum.
Keep track of the innermost closure we see that we're jumping into.
Keep track of the last StoreInst that we found.
Keep track of the new instructions emitted.
Keep track of the parameter we're matching and what argument indices got bound to each parameter.
Keep track of the start offsets for all fault funclets.
Keep track of this expression for later backpatching If it doesn't get backpatched (because there was no HALT_COMPILER then the constant will return (int)"__COMPILER_HALT_OFFSET__" (zero)
Keep track of this so that we don't emit multiple diagnostics.
Keep track of what subelement is being referenced.
Keep track of where and whether we see a contextual keyword on the decl.
Keep track of whether there is a Store, InOutUse, or Escape locally in / this block.
Keep track of whether we found a better path than the previous best.
Keep track of whether we've emitted an error.
Keep track of which arguments we have claimed from the argument tuple.
Keep track of which elements have been "merged".
Keep type metadata around for all types, although the runtime can currently only perform name lookup of non-generic types.
Keep types for stack and frame locations, and throw away the values.
Keep witness markers.
Keep working on the current block until no further changes are made.
Keeping / the info about which branch folding had produced the unreachable block makes / it possible.
Keeping a value live across a Call requires spilling, so we avoid it.
Keeping the ArrE for now just because we would need to check the key.type is not an invalid key (array or object) to prove it's non-empty now.
Keeping this seen set avoids consulting the dominator tree for every edge.
Keeps a list of basic blocks that have LoadInsts.
Keeps a list of basic blocks that have StoreInsts.
Keeps a list of replaceable instructions in the current basic block as / well as their SILValue replacement.
Keeps a map between the accessed SILValue and the location.
Keeps all the loadstorevalues for the current function.
Keeps all the locations for the current function.
Keeps track of the comments that were printed from the file and resumes printing for the next node from the same file.
Keeps track of the mapping of source variables to -O0 shadow copy allocas.
Keeps track of what blocks we change the terminator instruction.
Keeps track of what blocks we clone.
Keeps track of what stores to generate after the data flow stabilizes.
Kegacy hphpd code expects no failure if no hook is attached.
Key doesn't exist---we're still packed.
Key is no longer valid as we cleared the AliasValueBaseToIndex.
Key is no longer valid as we cleared the MemoryBehaviorValueBaseToIndex.
Key related variables
Keyed by function name
Keyed by serialized args
Keys have been copied, so don't need that part any more.
Kill calls to conditionallyUnreachable if we've folded assert configuration calls.
Kill the abort cleanup.
Kill the branch to the now-dead epilog BB.
Kill the continuation block if it's not being used.
Kill the existing lowered value for the bb arg and its phi nodes.
Kill the server if there's an error.
Killing the fp if there are still uses would be --bad--
KindOfObject (specific type)
KindOfUninit is a dynamic system constant.
Knott's relatively-prime secondary probe.
Known generalized cases that don't really need pointer kind
Known information about a particular possible instantiation of a PHP class.
Known mapping of archetypes in all arguments so far.
Known target, Zero LB: Unlike the above, this case is not that uncommon.
L * R already known to not trap at this point in the program and the following rules apply:
L * R already known to not trap at this point in the program.
L + R already known to not trap at this point in the program.
L - R already known to not trap at this point in the program.
L and R are the righthand and lefthand sides of the constraint.
L is positive (because double negative can overflow) 2.
LAYERMETHOD constants
LIBC_SCCS and not lint
LICM is a work in progress, disabled for now.
LINTED bug in header macro
LLDB creates implicit BraceStmts which contain a mix of generated/user-written code.
LLVM can replace relative references to this variable with / relative references to the GOT entry for the variable in the object file.
LLVM can treat this as equivalent to the global's GOT entry.
LLVM will eventually remove unused declarations.
LLVM's ABI rules for I.O.U.S.
LLVM's object-file emission collects a fixed set of keys for the image info.
LSLocation read or written has been extracted, expanded and mapped to the / B position in the Bvector.
LSLocation read or written has been extracted, expanded and mapped to the / bit position in the bitvector.
LSLocation written has been extracted, expanded and mapped to the bit / position in the bitvector.
LValues are captured as both the box owning the value and the address of the value.
LZ4 functions Varint helper functions for lz4
Label source of conditional branches with "T" or "F"
Label source of switch edges with the associated value.
Labeled elements can't be adopted into varargs even if they're non-mandatory.
Labels are function-local, and therefore never imported.
Lambda to check if CGetL and StaticLocInit refer to the same local.
Lane's stdio versions.
Language and Misc Configuration Options
Language-specific filtering.
Large allocations go directly to malloc without discarding our current chunk.
Large blocks are immediately passed back to libc via free.
Last item was encoded
Last loop to jumpt out of.
Last operand is the metatype that should be used for dispatching.
Last reference to the Zend resource is gone, so destroy the resource if it hasn't already been destroyed.
Last row, or no row yet available.
Last sector might be truncated
Last unhandled case: strings.
Last vector element is the default case
Last walked character
Lastly update the BBSetIn, only necessary when we are running a single iteration dataflow.
Lastly update the BBSetOut, only necessary when we are running a single iteration dataflow.
Lastly, BC markers are updated in all callee blocks.
Lastly, check whether all the successor blocks are retain-free.
Lastly, forward value to the load.
Lastly, mark the old store as dead.
Late addition:  construct the table according to file size for noticeable speed improvement on small files.
Later on if someone wants the real definition, / lookUpWitnessTable will deserialize it for us if we can.
Later phases will handle scopes like module-scope, etc.
Later we'll add more, like file and line, hopefully function args, wait handle status, etc.
Later, readSILFunction tries to force module scope.
Later, readVTable requests an enclosing scope.
Later, we should add more array optimizations, which would allow us to optimize the generated code once the scalar expressions are resolved
Lay out the field, but don't fill it in, we will copy it from the superclass.
Lay out the field, but don't provide the fill op, which we'll get from the superclass.
Lay out the template data.
Lay out this element.
Layout has to be done when the value witness table is instantiated, during initializeMetadata.
Layout information for class types.
LayoutError will be thrown if an ambiguous construct is encountered.
Lazily compute blocks that may reach the loop.
Lazily compute reachability, so we only have to do it in the case of an error.
Lazily create EntryPointFn.
Lazily create the standard fixed-buffer type.
Lazily declare a fake-looking class to represent an ObjC runtime base class.
Lazily declare the ObjC runtime base class for a Swift root class.
Lazily generate the record for the file.
Lazily initialize so that if StatCache never gets used, no kernel resources are consumed.
Lazily initialize the Blocks-to-IDs mapping.
Lazily print any debug locations used in this value.
Lazy allocation of heap
Lazy properties require special handling.
Lazy var should not have explicit getter/setter.
LdContActRec and LdAFWHActRec, loading a generator's AR, is the only time we have a pointer to an AR that is not in rvmfp().
LdObjInvoke t1:Cls doesn't simplify
LdObjInvoke t1:Cls(C), where C is persistent but has no __invoke doesn't simplify.
LdStk is the one exception, so we compensate for that here.
Leading separators, if any
Leaf patterns have no recursion.
Leak the params and the ActRec, and tell the unwinder that there's nothing left to do in this "entry".
Leap years are every fourth year (year 3, 7, 11, etc.)  TESTING  This algorithm has been tested from the year 1 to 14.
Leap years can be from 383 to 385 days and common years can be from 353 to 355 days.
Leap years occur in a fixed pattern of 19 years called the metonic cycle.
Leave a cleanup to deinit the existential container.
Leave a null pointer placeholder to be filled at runtime
Leave a null pointer placeholder to be filled by in-place initialization.
Leave a placeholder in the position.
Leave a scope, with all its cleanups.
Leave a zero placeholder to be filled at runtime
Leave an empty space in the ManagedValue sequence and remember that we had an inout argument.
Leave at 0x00 for releases.
Leave it untransformed.
Leave non-transparent functions alone.
Leave only attribute name without *
Leave only the first / load and the last store.
Leave result array on the stack.
Leave room for the header.
Leave space for `self` to be filled in later.
Leave space for register spilling and MInstrState.
Leave space in the buffer for both, but make sure we set it up later.
Leave the RHS on the stack
Leave the argument unfulfilled.
Leave the cleanup on the argument, if any, in place to consume the argument if we're responsible for it.
Leave the cleanup on the original value since we don't know anything about it's type.
Leave the cleanup on the original value.
Leave the constraint around if the first variable is still opaque.
Leave the direct results alone.
Leave the name alone.
Leave the original and 'hoist' a clone.
Leave the outer scope in place.
Leave the parameter empty.
Leave the scope immediately.
Leaving one of the preds.
Leaving out of bounds to be thrown by the vector in case needed
Leaving the debugger hook attached encurs a large performance cost.
Lee, all rights reserved.
Left and right operands of a string concatenation operation.
Left operand is a double.
Left operand is a resource.
Left operand is a string.
Left operand is an array.
Left operand is an object.
Left operand is null.
Left string literal operand of a string concatenation.
Legacy optimization functions
Length is in code units.
Length of needed storage
Length of replacement string
Length of string literals as reported by string.make functions.
Length of the concatenated literal according to its encoding.
Length of the current match
Length of the eval'ed or function-returned string
Length of the function name
Length of the quote-escaped match
Length of the result of the evaluation
Lengths can be sent as either bytes or double words.
Less commonly used but valid nonetheless.
Let ClangCodeGen emit its global data structures (llvm.used, debug info, etc.)
Let IVE be the edge for the non-payloaded enum.
Let caller sort them out.
Let dlopen determine the best search paths.
Let it be known that we are drawing a polygon so that the opacity mask doesn't get cleared after each line.
Let the C++ exception propagate.
Let the caller remove the allocation itself to avoid iterator invalidation.
Let the debugger initialize.
Let the empty rule remove it.
Let the instance remove the node.
Let the server do initialization
Let through all arguments not related to a promotable box.
Let's check for this.
Let's check the perf map.
Let's do alias checking based on projections.
Let's extend our lifetime region.
Let's hope all strptime-s use ` ' to skipp *all* whitespace instead of just one (it works that way on all the systems I've tested it on).
Let's invalidate everything else.
Let's not blow up our map.
Let's not differ from C99 6.8.5.2: "The evaluation of the controlling expression takes place after each execution of the loop body."
Let's not have "ur_ls"
Let's relax and pretend they said they were mime 1.0 compatible
Let's remove the retain/unsafeGuaranteed/release combo.
Let's see if we can find a previous loaded, stored value to use instead of this load.
Let's see if we should serialize the body or just the declaration.
Let's try inferring associated types.
Let's try to zap this AllocStackInst.
Let's use the IGM from which the function is referenced the first time.
Lets declare those here.
Lets diagnose it as a conversion or ambiguity failure.
Lets pretend we are the same version as PHP.
Lex any digits after the decimal point.
Lex things like 4.x as '4' followed by a tok::period.
Lex tokens until we find the token that contains the source location.
Libraries are not sorted in the topological order of dependencies, and we don't know the dependencies in advance.
License is also granted to make and use derivative works provided that such works are identified as "derived from the RSA Data Security, Inc.
License to copy and use this software is granted provided that it is identified as the "RSA Data Security, Inc.
Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.
Licensed under MIT License https://github.com/phidelta/fsevents.git
Life would be much easier if we could just use a FixedTypeRepr for the parent.
Lifetime continuity resolution.
Lifetime endpoints that don't allow the address to escape.
Lifetime-extend 'self' by sending it to the autorelease pool if need be.
LifetimeChecker - This is the main heavy lifting for definite / initialization checking of a memory object.
Lifted from the clang driver.
Like C++ using declarations, name lookup simply looks through Objective-C compatibility aliases.
Like FRedundant, but the load is impure---rather than killing it, we can factor out the load.
Like UnsafeRefBitCast, allow class existentials to be truncated to single-pointer references.
Like ValueIsPHI but also check if the PHI has no source / operands, i.e., it was just added.
Like YYERROR except do call yyerror.
Like choose_closest_after(), but iterates through `pos_vec'.
Like find_range, but copy them into a temporary buffer instead of returning iterators, so you can still mutate the underlying multimap.
Like printf, only we append to a buffer.
Like the Prop* instructions, but for array elements.
Like the Ret* instructions, its manipulation of the runtime stack are outside the boundaries of the tracelet abstraction.
Like the other angle in libGD, in which increasing y moves downward, this is a counterclockwise rotation.
Likely case is that there was no break command.
Likewise when it removes an element it always removes the corresponding hash entry.
Likewise, DWARF as no concept of linkage, but the linkage is needed to know which types are actually equivalent.
Likewise, if the candidate is inaccessible from the scope it is being accessed from, mark it as inaccessible or a general mismatch.
Likewise, if the indexed type is still marked for conservative scanning, it cannot be ignored.
Liking in sanitizers will add rpaths, which might negatively interact when other rpaths are involved, so we should make sure we add the rpaths after all user-specified rpaths.
Limit the error using transfer function set by init_error_limit.
Limit the number of recursions.
Limit the total number of iterations.
Limit tree to search based on the DeclContext of the reference.
Limits of integral types.
Line and column where highlight should start and end
Line breakpoints add a file, line, and possibly a condition
Line separation as a factor of font height.
LineModule will get destroy by the following link process.
Linear lookup here is lame.
Linear search from end of m_nestedVMs.
Linear searching the tracking list doesn't hurt because usually it only contains a few elements.
Lines where source listing should start and end
Link a specialization for generating prespecialized code.
Link all the jumps from the current tail translation to this new guy.
Link anonymous closure params of the same index. TODO: As stated above, we should bucket these whilst collecting the exprs to avoid quadratic behavior.
Link back to something to create a data dependency if we have an opened type.
Link float literal tyvars.
Link in all protocol conformances that this touches.
Link integer literal tyvars.
Link ordinary blocks with ordinary edges and set their last instruction and end offsets
Link primary body blocks to exception handler blocks as follows: 1.
Link string literal tyvars.
Link the standard library.
Link the static initializer for global variables.
LinkInfo should be able to refer to the allocating constructor rather than inferring it here.
Linkage specifications are not imported.
Links between loaded and stored values.
Linux (tested on core from 2.4.x, short name)
Linux 2.0.36 (short name)
Linux apparently appends a space at the end of the command line: remove it.
Linux doesn't have a limit, but it will fill in the first 256 chars of hostname even if the actual hostname is longer.
List of Authoritative Name Servers
List of EHEnt's that should have m_fault bound to the Offset of this label.
List of Objective-C member conflicts we have found during type checking.
List of Objective-C methods created by the type checker (and not / by the Clang importer or deserialized), which is used for / checking unintended Objective-C overrides.
List of a parameter ids that use this label for its DV initializer.
List of all indexed types in the debug information.
List of arrays in memory which are unsafe.
List of base classes to apply the custom bases scan to.
List of fields in the object which should always be conservative scanned.
List of fields in the object which should be ignored.
List of immediate base classes which should be ignored.
List of immediate bases which the "forbidden template" check should not be applied to.
List of predecessors.
List of templates which should not be used to store request heap allocated values (because scanner aware variants exist).
List of types which should be ignored (including any bases) by the generated scanners.
List up slots, signals, and invokable methods
Listen for Phantom exit(ing)
Literal and constant instructions
Literal content nodes never have start/end column line information.
Literal exprs are contextually typed, so store them off as well.
Literals cloned from the caller drop their location so the debug line / tables don't senselessly jump around.
Literals cloned from the caller take on the new function's debug scope.
Live ranges and use positions.
LiveOutBlockState - Keep track of information about blocks that have / already been analyzed.
Liveness analysis:  The global algorithm first performs a liveness analysis to propagate live out sets to each block.
Load a clang argument expansion from a buffer.
Load a loadable data value.
Load a module referenced by an import statement.
Load a specific witness from a known table.
Load a value of the type-of-reference out of the given address / and into the destination address.
Load a value of the type-of-rvalue out of the given address as a / scalar.
Load an r-value out of the given address.
Load and check whether it was null.
Load and copy from the address value, passing the result as an argument to the new closure.
Load and parse one file.
Load and retain the destination value if it's loadable.
Load and store the PHP return registers from/to the top of the VM stack.
Load and store the VM registers from/to RDS.
Load any abbrev records at the start of the block.
Load argc and argv from the entry point arguments.
Load data and emit a new vasm depending if the Immed fits a direct ppc64 instruction.
Load from the lvalue.
Load from the optional.
Load generator's FP and resume address.
Load if the result isn't address-only.
Load in bitcode file.
Load it into a temporary 'let' so we have it for later.
Load it to a register
Load magic initialization constants.
Load property and check for uninit.
Load standard library so that Clang importer can use it.
Load the 'alignmentMask' value witness from the given table as a size_t.
Load the 'hasExtraInhabitants' valueWitness from the given table as an i1.
Load the 'isBitwiseTakable' valueWitness from the given table as an i1.
Load the 'isInline' valueWitness from the given table as an i1.
Load the 'isPOD' valueWitness from the given table as an i1.
Load the 'out' value as the destination type.
Load the 'out' values.
Load the 'self' argument.
Load the 'size' value witness from the given table as a size_t.
Load the 'stride' value witness from the given table as a size_t.
Load the 'super' argument.
Load the Class's propInitVec from the targetcache
Load the DIE at the given offset, and call the given callable on it, returning whatever the callable returns.
Load the RTF EULA control with text if the control exists.
Load the SIL if we have a module.
Load the WaitHandle*.
Load the address of the inout parameter.
Load the correct virtual function for the given class method.
Load the destination value.
Load the error (taking responsibility for it).
Load the error value.
Load the existing storage and store it into the 'tmp1' temporary.
Load the fixed-size representation and derive the tags.
Load the fixed-size representation and switch directly.
Load the input module...
Load the instance pointer, which is unknown-refcounted.
Load the instance pointer.
Load the loadable value, and retain it if we aren't taking it.
Load the metadata reference at the given index.
Load the metadata tables.
Load the metatype kind.
Load the next parent in the chain, and unblock the whole chain.
Load the old pointer at the destination.
Load the original value.
Load the parent chain.
Load the payload area.
Load the payload tag.
Load the payload value, to distinguish no-payload cases.
Load the pointer and turn it back into a pointer.
Load the protocol reference.
Load the protocol witness table reference at the given index.
Load the saved frame pointer from the ActRec.
Load the settings passed in environment variables
Load the systemlib unit to build the Class objects
Load the update XML from a location url and parse it for an update.
Load the value as swift.refcounted, then hand to swift_release.
Load the value at +0.
Load the value from the stack and store into the array.
Load the value from the temporary unless the type is address-only and this is the final use, in which case we can just consume the value as-is.
Load the value of VD.
Load the witness table pointers.
Load the witness tables and copy them into the new object.
Load these parameters directly.
Load type metadata for the source's static type and the target type.
Load up any dynamic extensions from dynamic extensions options
Load up any dynamic extensions from extension_dir
Load up the state for the new block.
Load used traits of PreClass `preClass', and append the trait Class*'s to 'usedTraits'.
Load, store, memcpy etc can't do a release.
Loadable with payload
Loading a set of default colors for better display.
Loading classes or metatypes doesn't require their metadata.
Loading from the reference type emits a bitcast to the proper reference type first.
Loads .so PrimeLibrary, writes snapshot output to this file, then exits.
Loads are a use of the value.
Loads cannot affect the retain.
Loads of a struct_element_addr of an argument get replaced with struct_extract of the new object type argument.
Loads of loop invariant memory locations.
Loads of the box produce self, so collect uses from them.
Loads that have invariant memory locations still don't define SSATmps that are loop invariant (without further analysis).
Loads the "XDEBUG_CONFIG" environment variables.
Loads, rvalue adjustment, and scalar-to-tuple conversions are implicit.
Loc is in this context's range but not in any child's, so this context must be the inner-most context.
Local function that (recursively) adds inherited types.
Local function that actually emits the dynamic member reference.
Local function that adds the constructor syntax around string literals implicitly treated as a Selector.
Local function that adds the given declaration if it is a reasonable choice.
Local function that attempts to bind the given parameter to arguments in the list.
Local function that folds dependent member types with non-dependent bases into actual member references.
Local function that handles the "inherited" list for a type.
Local function that lowercases all of the base names and / argument names before returning.
Local function that performs lookup.
Local function that produces the canonical parameter type of the given initializer.
Local function that recurses on the given set of type variables.
Local function that releases the source and returns false.
Local function that retrieves the next unclaimed argument with the given name (which may be empty).
Local function that retrieves the requirement with the same name as the provided requirement, but within the given known protocol.
Local function that simply produces a failing result.
Local function that skips over any claimed arguments.
Local function to add a type with the given name and module as trivially-representable.
Local function to add properties from the given set.
Local function to attempt to diagnose potential type witnesses that failed requirements.
Local function to combine the result of a recursive invocation.
Local function to compare two solutions.
Local function to compute the default type of an associated type.
Local function to compute the derived type of an associated type, for protocols known to the compiler.
Local function to create a pattern for a single parameter.
Local function to create the alias, if needed.
Local function to determine if the given declaration is an accessor.
Local function to determine whether the given declaration is subject to a swift_private attribute.
Local function to extract the ith argument expression, which papers over some of the weirdness with tuples vs.
Local function to extract the ith argument label, which papers over some of the weirdness with tuples vs.
Local function to finalize the witness.
Local function to handle the parsing of the base name + context.
Local function to handle the update of superclass conformances when the superclass constraint changes.
Local function to mark the given associated type as recursive, diagnosing it if this is the first such occurrence.
Local function to mark the setter unavailable.
Local function to perform the depth-first search of the solution space.
Local function to populate the lookup table.
Local function to produce a locator to refer to the ith element of the argument tuple.
Local function to record a missing associated type.
Local function to retrieve the value witness for the current associated type within the given solution.
Local function to return the location of the superclass.
Local function to visit a potential archetype, enumerating its requirements.
Local function to visit the nested potential archetypes of the given potential archetype.
Local function used to finish up processing before returning.
Local function used to infer requirements from the extended type.
Local function used to remove this entry when the reader goes away.
Local generic functions could probably be modeled better at the SIL level.
Local nicknames or unqualified names MUST NOT be used.
Local symbolic flavor
Local variables don't otherwise get accessors.
Local variables: tab-width: 4 c-basic-offset: 4 End:
Local variables: tab-width: 4 c-basic-offset: 4 indent-tabs-mode: t End:
LocalValues are updated in setLocalValue where / the ID passed in assumes the same ordering as in serializer: in-order / for each basic block argument and each SILInstruction that has a value.
Localize the address access.
Locals known to be live at a point in a DCE walk.
Locals, iterators, and parameters.
Locals, iterators, and stack.
Locals:  While a block is iterated backward, the set of live locals is tracked.
Locate all the basic blocks associated with fault funclets, and mark them as such.
Locate the colormap entries close enough to an update box to be candidates for the nearest entry to some cell(s) in the update box.
Locate the next offset that is not 0xffff.
Location data for the lookahead symbol.
Location of current replacement in the result
Location of last match
Locations here have a projection path from their Base, but this particular instruction may not be accessing the base, so we need to rebase* the locations w.r.t.
Locations in the stores set may be stored to with a 'normal write barrier', decreffing the pointer that used to be there.
Locations may-moved always should also count as may-loads.
Locations other than the frame and stack (e.g. object properties and whatnot) are always live on a function return---so mark everything read before we start killing things.
Locations that are killed don't need to be tracked as memory support anymore, because nothing can load that pointer (and then decref it) anymore without storing over the location first.
Locations that refer to ranges of the eval stack or multiple frame locals are expanded into individual locations only if smaller than this threshold.
Locators used in this expression.
Lock a mutex. A return value of 0 indicates success
Lock in this index chain and deal with this exp.
Lock the proxy during the switch
Log handler which does nothing
Log handler which uses printf
Log random, interesting events in the client.
Log the passed in command
Log the translation's size, creation time, SrcKey, and size
LogFile debugger setting
Logger flushes itself---we don't need to run any atexit handlers (historically we've mostly just SEGV'd while trying) ...
Logic based on zend_operators.c::convert_scalar_to_number()  Note that this needs to work the same as some similar logic in the JIT for optimized versions of some of the following functions.
Logical components always re-abstract back to the substituted type.
Logical error (i.e. conflicting options)
Long enough for the magic number read and check to happen (and fail).
Long enough to get past the "mmap punts at 0 bytes" thing, but short enough to trip an attempted read of the magic number.
Look ahead to parse the parenthesized expression.
Look at all of the VarDecls being bound.
Look at all of the initializers of the subclass to gather the initializers they override from the superclass.
Look at all of the suspicious optional injections
Look at all users of agg and see if we can simplify any of them.
Look at block arguments.
Look at lines above and below and start paints
Look at method entries only.
Look at subsequent tokens to determine if the '(' character is the start of a lambda expression
Look at the current letter in the word
Look at the definition, if there is one.
Look at the failed constraint and the general constraint list.
Look at the function type and iterate through the function parameters.
Look at the get_element calls and match them to values by index.
Look at the input types.
Look at the next letter in the word
Look at the origin/user ValueBase of V to see if any of them are / TypedAccessOracle which enable one to ascertain via undefined behavior the / "true" type of the instruction.
Look at the parameter.
Look at the parent node in the AST to find the Apply to give a better diagnostic.
Look at the protocols to see what representation is appropriate.
Look at the replacement type.
Look at the result type.
Look at the uses of the load to find out more information.
Look at the witness table for the conformance.
Look at this function as an iterator on the mbi integers it spits out.
Look at what's locally bound.
Look back a split edge.
Look backwards through the predecessor for the first ref count increment on EnumValue.
Look before the "unsafeGuaranteedEnd".
Look for 'typealias' here and diagnose a fixit because parseDeclTypeAlias can ask us to fix up leftover Swift 2 code intending to be an associatedtype.
Look for Boolean types.
Look for Foo::Foo() (old style constructor) declared in this class and deprecate warning if we are in PHP 7 mode
Look for InlineReturn instructions that are the only "non-weak" use of a DefInlineFP.
Look for Objective-C members with each base name.
Look for __construct() declared in either this class or a trait
Look for _bridgeToObjectiveC().
Look for a Clang module with this name.
Look for a __swift2_proto section.
Look for a __swift2_types section.
Look for a base of 'self' or 'super'.
Look for a branch on EQ around the Preheader.
Look for a builtin "unsafeGuaranteed" instruction.
Look for a builtin "unsafeGuaranteedEnd" instruction that uses the token.
Look for a class static singleton pattern.
Look for a compare of induction variable + 1.
Look for a conformance to _ObjectiveCBridgeable.
Look for a context with the given Swift name.
Look for a generic function.
Look for a matching imported or deserialized member.
Look for a member type with the same name as the associated type.
Look for a method that we have overridden in one of our superclasses.
Look for a method that will import to have the same name as the / given method after importing the Nth parameter as an elided error / parameter.
Look for a module with the given name.
Look for a protocol type info.
Look for a repo that contains a unit with matching MD5.
Look for a safe mark_dependence instruction use.
Look for a single instance method with the magic name.
Look for a single other element on this enum.
Look for a static local singleton pattern.
Look for a typedef that successfully classifies as a CF typedef with the same underlying record.
Look for all methods in the module file with this selector.
Look for an Objective-C method in this class.
Look for an entry with this base name.
Look for an entry with this context name.
Look for an exact match first
Look for an exact match.
Look for an existing entry.
Look for an instance property of the given nominal type that's / known to be stored.
Look for an objc method call.
Look for an operator declaration in the current module.
Look for any free type variables.
Look for any instructions accessing let properties.
Look for any property references in closures that lack a "self." qualifier.
Look for anything at all that's fulfilled by this.
Look for bridging attributes on the clang record.
Look for calls of a constructor on self or super.
Look for checks that guarantee that start is less than or equal to end.
Look for conformances to this protocol.
Look for copy_addr instructions.
Look for existing adjacency information.
Look for imported operator decls.
Look for induction variables.
Look for known substitutions.
Look for leading number by itself
Look for macros imported with the same name.
Look for member types with the given name.
Look for members with the given name.
Look for members with the same name and matching types as this one.
Look for members within the base.
Look for methods with this selector.
Look for mismatched enter and exit events, and try to correct if we can.
Look for module references.
Look for moves into r10 and keep r10val updated
Look for namespace-scope entities with each base name.
Look for other imported constructors that occur in this context with the same name.
Look for other uses of DominatingCondition that are either: dominated by the DominatingSuccBB
Look for parent constructor other than 86ctor().
Look for potential type variable bindings.
Look for precomputed callees based on vtables.
Look for results within the current nominal type and its extensions.
Look for special top-level lists
Look for the "begin " sequence that identifies a uuencoded file
Look for the breakpoint's unit.
Look for the builtin name.
Look for the closing ')'.
Look for the constructor or enum element to use.
Look for the declarations with this name.
Look for the disjunction that binds the overload set.
Look for the extension for the given nominal type within the Clang submodule of the declaration.
Look for the first phi hint.
Look for the function.
Look for the key in the cache.
Look for this protocol within the existential's list of conformances.
Look in each extension of this type.
Look in for members of a nominal type.
Look in the cache first.
Look in the current trait.
Look in the generic parameters after checking our local declaration.
Look in the protocols to which the archetype conforms (always).
Look inside one-element exploded tuples, but not if both input and output types are *both* one-element tuples.
Look inside the binary 'Bin' and append any linker flags found in its ".swift1_autolink_entries" section to 'LinkerFlags'.
Look into children traits.
Look into the value for the given LSLocation at end of the basic block, / return one of the three ValueState type.
Look through "a.b" to "b".
Look through DotSyntaxCallExpr, since the literal functions are curried.
Look through DynamicSelf.
Look through DynamicSelfType.
Look through Optional unwraps
Look through ParenExpr's.
Look through RebindSelfInConstructorExpr to avoid weird sema issues.
Look through TryExpr or ForceValueExpr, but not both.
Look through a TypedPattern if present.
Look through a named 1-tuple.
Look through a possible l-value type, returning true if it was / an l-value.
Look through all of the associated types of all of the protocols to which the parent conforms.
Look through all try expressions.
Look through an implicit force-value.
Look through an implicitly unwrapped optional.
Look through an inout type.
Look through argument list tuples.
Look through artificial subclasses.
Look through attributed type representations.
Look through attributes.
Look through base-ignored exprs to get to the function ref.
Look through closures, initial values.
Look through explicit coercions.
Look through force-value expressions.
Look through function conversions.
Look through identity expressions, like parens.
Look through identity expressions.
Look through identity, force-value, and 'try' expressions.
Look through ignored bases too.
Look through implicit conversions.
Look through implicit open-existential operations.
Look through implicitly unwrapped optionals.
Look through inout types.
Look through it because we know it isn't actually doing a load/store.
Look through local contexts.
Look through lvalue and inout types.
Look through lvalue types.
Look through lvalues in tuples.
Look through lvalues.
Look through mark_uninitialized.
Look through metatypes
Look through metatypes.
Look through most attributes.
Look through named types.
Look through non-generic nominal types.
Look through one layer of optionality when considering the class- Referring to a class-constrained generic or metatype doesn't require its type metadata.
Look through one level of optional type, but remember that we did.
Look through one level of optional.
Look through one level of optionality on the source.
Look through one level of optionality.
Look through optional or IUO to get the underlying type the decl was found in.
Look through optional types.
Look through optionals.
Look through our predecessors for a set of ref count increments on our enum value for every payloaded case that *could* be sunk.
Look through ownership types, and optionals.
Look through parentheses.
Look through pointer types.
Look through property references.
Look through reference types.
Look through reference-storage types.
Look through self-rebind expression.
Look through substituted types to diagnose when the original type is marked unavailable.
Look through the cases for this tag.
Look through the conversions and find the real callee.
Look through the declarations, keeping only the unique type declarations.
Look through the destination base type.
Look through the destination key and value types.
Look through the metatype.
Look through the overload locators that have overload choices in all of the solutions, and add those that have differences to the diff.
Look through the paren expression, if there is one.
Look through the type variables that have bindings in all of the solutions, and add those that have differences to the diff.
Look through this pattern.
Look through typealiases.
Look through uses of the alloc box the load is loading from to find up to one store and up to one strong release.
Look to see if the candidates found could possibly match.
Look to see if the conflicting decl is unavailable, either because it's been marked NS_SWIFT_UNAVAILABLE, because it's actually marked unavailable, or because it was deprecated before our API sunset.
Look to see if we've already emitted this type under a different set of arguments.
Look to the referenced member in a self-application.
Look two letters down.
Look up UIApplicationMain.
Look up ValueDecl from a dotted path.
Look up a TypeAliasReq for the supplied NamedEntity (which must be the NamedEntity for `name'), invoking autoload if necessary for types but not for classes.
Look up a TypeAliasReq or a Class for the supplied NamedEntity (which must be the NamedEntity for `name'), invoking autoload if necessary.
Look up a catch trace for `rip', returning nullptr if none was found.
Look up conformance in the module.
Look up each protocol conformance we want.
Look up profiling data for the Switch at the end of tid and decide which outgoing arcs, if any, to include in the region.
Look up the Func* in the targetcache.
Look up the NSCopying protocol from the Foundation module, if present.
Look up the Swift metadata from context.
Look up the address of a witness table.
Look up the associated type witness.
Look up the behavior protocol's "value" property, or bail if it doesn't have one.
Look up the breakpoint, ensure it's hittable.
Look up the case inside the enum.
Look up the catch trace for the return address in `ctx', and install it by updating the unwind RDS info, as well as the IP in `ctx'.
Look up the corresponding FunctionScope and ClassScope for this function call
Look up the default witness table associated with our protocol from the SILModule.
Look up the destructor of ClsDecl.
Look up the generated template class for this particular subclass of Closure.
Look up the global variable.
Look up the header in the ASTReader.
Look up the header in the includes of the bridging header.
Look up the inherited conformance.
Look up the interfaces implemented by traits used by the class, and add them to the provided builder.
Look up the local type by its mangling.
Look up the method in the target class.
Look up the method specified by methodName from the class specified by cls and enforce accessibility.
Look up the name in the module.
Look up the node for this type variable.
Look up the precomputed callees for an abstract function and return it as a CalleeList.
Look up the proxy's breakpoints and add needed breakpoints to the passed unit
Look up the state associated with I's operand...
Look up the state associated with its operand...
Look up the static property.
Look up the top-level module first, to see if it exists at all.
Look up the top-level module first.
Look up the type alias (autoloading if necessary) and fail if we can't find it
Look up the types to verify.
Look up the witness for the archetype.
Look up the witness for the constructor.
Look up the witness table associated with our protocol conformance from the SILModule.
Look up the witness table for protocols that need them.
Look up witness tables for the protocols that need them and get references to the ObjC Protocol* values for the objc protocols.
Look up witness tables for the protocols that need them.
Look within a module context.
Look within a type context.
Lookahead one token to decide what kind of call completions to provide.
Lookahead token as an internal (translated) token number.
Looking through the pattern, go to each arg_start part type.
Looks like an FPushCtor call, but it could still have been called directly.
Lookup a function from the stdlib.
Lookup an unresolved context name and resolve it to a Clang / declaration context or typedef name.
Lookup element #0 through our current scope chains in case it is some thing local (this returns null if nothing is found).
Lookup for an Objective-C method with the given selector in the / given class type or any of its superclasses.
Lookup hash and destroy it
Lookup module references, as on some_module.some_member.
Lookup table mapping names to the set of declarations with that name.
Lookup table used to store members of a nominal type (and its extensions) / for fast retrieval.
Lookup the _ObjectiveCBridgeable protocol.
Lookup the conformance of the superclass to this protocol.
Lookup the decl in the top-level module.
Lookup the index of the property based on ctx and baseClass
Lookup the required function in the Target type.
Lookup the swift module.
Lookup this base name in the module extension file.
Lookup this base name in the module file.
Lookup using dladdr() failed, so this is probably a PHP symbol.
Lookups need to check if it's empty() and if so compute it from sourceLocTable.
Loop back to the header.
Loop over all mutations to possibly invalidate captures.
Loop over all unmatched breakpoints
Loop over container1, only copying over key/value pairs where the key is not present in the Set.
Loop over container1, only copying over key/value pairs where the key is present in the Set.
Loop over container1, only copying over key/value pairs where the value is not present in the Set.
Loop over container1, only copying over key/value pairs where the value is present in the Set.
Loop over each of the new decls, processing them, adding them back to the Decls list.
Loop over existing connections and compare hashes
Loop starting after the space until the end of the string
Loop through all the checkbox controls (or buttons with BS_AUTORADIOBUTTON) with names and set a Burn variable with that name to true or false.
Loop through all the editbox controls with names and set a Burn variable with that name to the contents.
Loop through all the program headers.
Loop through the chunks.
Loop through the elements.
Loop through the unmatched breakpoints
Loop through unmatched function breakpoints
Loop until request has completed or there is an error.
Loop until the end of the basic block inclusively.
Loops in fault funclets could cause us to revisit the same block, so we track the ones we've seen.
Lose a static `self` parameter.
Lots of layout will get screwed up if our structure claims more storage than we allocated to it.
Lots of random cases to skip just to keep this simple for now.
Low bits are made available by heap object alignment.
Low-level receive functions.
Low-level send function.
Low-numbered payload tags correspond to payload cases.
Lower 'Self' as if it were the base type.
Lower Assign instructions if needed.
Lower `block' from HHIR to vasm.
Lower a few abstractions to facilitate straightforward PPC64 codegen.
Lower a few abstractions to facilitate straightforward x64 codegen.
Lower all the floating-point values by their semantics.
Lower away type trait builtins when they're trivially solvable.
Lower bound for this type variable.
Lower bound on # of colors ...
Lower comparison to cmpq
Lower comparison with immediate to cmpqi
Lower each of the elements of the substituted type according to / the abstraction pattern of the given original type.
Lower it, being careful to use the right generic signature.
Lower raw-sil only instructions used by this pass, like "assign".
Lower subtraction to subq
Lower the RegionDesc to an IRUnit, then lower that to a Vunit.
Lower the SIL arguments to IR arguments.
Lower the arguments and return value in the callee's generic context.
Lower the capture context parameters, if any.
Lower the captured arguments in the original function's generic context.
Lower the class's fields using substitutions from the TypeRef to make field types concrete.
Lower the formal AST type.
Lower the forwarded arguments in the original function's generic context.
Lower the immediate to a register in order to use ppc64 instructions that can change required Condition Register (on vasm world, that's the SF register).
Lower the interface type in a generic context.
Lower the parameters in the callee's generic context.
Lower the result type.
Lower the struct's fields using substitutions from the TypeRef to make field types concrete.
Lower the substituted result using the abstraction patterns of the original result.
Lower the type at the abstraction level of the existential.
Lower the type if it is not a legal type.
Lower the unabstracted result type.
Lower the witness type with the requirement's abstraction level.
Lower xor with immediate to xorqi
Lower-camel-case the incoming name
Lowercase the first letter, append the rest.
Lowercase the remaining argument name.
Lowercase until we hit the an uppercase letter followed by a non-uppercase letter.
Luckily this cannot happen since cond_br is the only terminator that allows for critical edges and all other "interesting terminators" always having multiple successors.
Luckily, a type's linkage is closely related to its scope (except for templates, see below), so it can be inferred the same way.
Lvalues are captured as a box that owns the captured value.
MARK: Convenience functions for printing.
MARK: The ASTPrinter callback interface.
MBR must not be live across control flow edges.
MD4 block update operation.
MD5 Message-Digest Algorithm (RFC 1321).
MD5 Message-Digest Algorithm" in all material mentioning or referencing the derived work.
MD5 Message-Digest Algorithm" in all material mentioning or referencing this software or this function.
MD5 basic transformation.
MD5 block update operation.
MD5 password encryption.
MD5(pw,salt,pw), valid.
MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm Reference MD5 code (md5c.c) from rfc1321
MInstrTranslator helpers
MInstrs can throw in between each op, so the states of locals need to be propagated across factored exit edges.
MMC values must match pecl-memcache for compatibility
MONGODB-CR is the default authentication mechanism
MONTAGEMODE constants
MOpFlags::Unset Props doesn't promote "emptyish" things to stdClass, or affect arrays, however it can define a property on an object base.
MSIE doesn't delete a cookie when you set it to a null value so in order to force cookies to be deleted, even on MSIE, we pick an expiry date in the past
MSVC doesn't require the characters to be the last 6 in the string.
MSVC gets confused if we try to directly assign the template overload, so use a temporary and let the optimizer sort it out.
MULTI_QUERY support - eat up all unfetched result sets
Machine information that we collect just once.
Machine is running again.
Macro definition for EmitXOForm functions Format: X(name,   arg3,  oe,  xop) name: function name arg3: ARG if needed, otherwise NONE to skip oe:   parameter value xop:  parameter value
Macro expand out the defer into a closure and call, which we can typecheck and emit where needed.
Macro expansion for function parts
Macro happens to work with IGM, too.
Macro that does padding.
Macro to check whether a cursor is dead, and if so, bailout
Macros after this point can all be overridden by user definitions in section 1.
Macros are never stored within a non-translation-unit context in Clang.
Macros to free an array/object
Magic IV for 64 Blowfish encryptions that we do at the end.
Magic contexts I took from assignment expression
Magic entries with no description get a bonus because they depend on subsequent magic entries to print something.
Magic getters can be invoked both in define contexts and non-define contexts.
Magic getters/setters use tvRef if the property is unset.
Magic method flags should be consistent with the method table.
Main loop to parse JPEG2000 raw codestream structure
Main loop to read CSV fields
Main workhorse functions
MainExePath points to "lib/sourcekitd.framework/Versions/Current/XPCServices/ SourceKitService.xpc/Contents/MacOS/SourceKitService"
MainExePath points to "lib/sourcekitd.framework/XPCServices/ SourceKitService.xpc/SourceKitService"
Mainly for debugging.
Mainly used internally.
Maintain a set of whitelisted CF types.
Maintain profiles of a running stack.
Major version 0 does not have stable minor versions.
Make 'wa' a quick shortcut for 'where async'
Make T1 the representative of T2, merging the equivalence classes.
Make a 1-to-1 mapping of all arguments and the return value.
Make a DTNode for the preheader and make the header's immediate dominator, the immediate dominator of the pre-header.
Make a copy of it to be able to correct produce DumpModule.
Make a copy of the actual pattern.
Make a copy of the block list so it can be mutated by the visitor.
Make a copy of the const version of zend_ini_entry.
Make a copy of the current rvmfp(), which belongs to the callee, before syncing VM regs and return regs.
Make a copy of the fields list into ASTContext owned memory.
Make a copy of the string for use with strtok.
Make a duplicate copy of this parameter list.
Make a final pass to emit default arguments and move things into the outer arguments lists.
Make a first pass to get all the type metadata.
Make a flattened table of all the interfaces implemented by the class.
Make a generic type repr that's been resolved to this decl.
Make a given type pointer followable.
Make a local copy and adjust rve to be in terms of s
Make a new GOT equivalent referring to the new variable with its definition type.
Make a new caller node and link it into n's caller list.
Make a pass over all the dependent types.
Make a pass to find if we can kill any of the frames.
Make a plan that calls copyOrInitValueInto.
Make a plan to initialize into that.
Make a really fake-looking class.
Make a reference to the callback.
Make a second pass for all the protocol conformances.
Make a second pass to split the inner arguments correctly.
Make a setter if the behavior property has one.
Make a stack range big enough to contain both of them.
Make a stacktrace file to prove we were crashing.
Make a table of all the constants on this class.
Make a table of the methods on this class, excluding interface methods.
Make an APC table with some things primed for tests to use.
Make an ArgGroup for array elem instructions that takes: 1/ the ArrayData* (or pointer to a KindOfArray TV) 2/ the index key
Make an ArgGroup for elem instructions that takes: 1/ the pointer to a KindOfArray TV 2/ the index key, as a raw value or a TypedValue depending on whether the type is known
Make an ArgGroup for prop instructions that takes: 1/ the context Class* 2/ the ObjectData* (or pointer to a KindOfObject TV)
Make an exact copy of this AST node.
Make an exit trace to side exit to the next instruction, replacing our guess with the correct stack output.
Make any abstraction modifications necessary for casting.
Make any breakpoints that have passed breakable again.
Make any successors outside of the loop successors of the loop instead / of the exiting block.
Make copies of Funcs inherited from the parent class that have static locals
Make it public, so that others can refer to it.
Make mongo objects uncloneable
Make progress before side-exiting to the next instruction: raise a warning and push false.
Make progress through this instruction before side-exiting to the next instruction, by doing a slower lookup.
Make result independent of the hashtable implementation.
Make space in the direct-results array for all the entries we need.
Make sure "tokenizer" gets added to the list of extensions
Make sure BlotMapVector works with StringRef keys.
Make sure F has a linkage that we can optimize.
Make sure IPv6 or IPv4 are handled correctly
Make sure YYID is used.
Make sure a 'let' property is only overridden by 'let' properties.
Make sure a component (path, value, domain) of a cookie does not contain any illegal characters.
Make sure all offsets are in-bounds.
Make sure all the entries start out null.
Make sure all the expected diagnostics appeared.
Make sure all type parameters are safe.
Make sure cg.map has an entry for every interface - this simplifies some code later on.
Make sure chunk size is valid.
Make sure code completion is on the right hand side.
Make sure color count is acceptable
Make sure colormap indexes can be represented by JSAMPLEs
Make sure commands aren't be sent to slaves
Make sure constants for true and false exist before doing anything, so we can use them without having to create more Vregs.
Make sure cookie names do not contain any illegal characters.
Make sure corresponding realpath's are also allowed
Make sure each of the type variables referenced knows about this constraint.
Make sure eval stack is correct at start of each try region
Make sure function enter hook is called if needed.
Make sure immediate loc after loc is not before target loc.
Make sure it actually is an AsyncIterator.
Make sure it is, in fact, the best.
Make sure it's an object of a known class.
Make sure it's of an appropriate builtin type.
Make sure jdmaster didn't give me a case I can't handle
Make sure key and value are present.
Make sure lhs's ptr kind is a subtype of rhs's.
Make sure materializeForSet is available enough to access the storage (and its getters/setters if it has them).
Make sure no identifier has an offset of 0.
Make sure null pointers stay null.
Make sure opaque values are uniquely-referenced.
Make sure our end value is loop invariant.
Make sure our property init vectors are all set up.
Make sure target loc is after loc
Make sure that AI's self argument has the same RCID as our instruction.
Make sure that DestBB is in the worklist, as well as its remaining predecessors, since they may not be able to be simplified.
Make sure that adding '-update-code' will permit accepting all arguments '-c' accepts.
Make sure that all of the allocations were promoted into registers.
Make sure that all predecessors of our BB have either a br or cond_br terminator.
Make sure that all witness tables are in the witness table lookup cache.
Make sure that an observing property isn't observing something read-only.
Make sure that any VarDecl's contained within the pattern know about this PatternBindingDecl as their parent.
Make sure that any access of the witness through the protocol can only occur when the witness is available.
Make sure that any level 0 "default" line is last (if one exists).
Make sure that both base types are the same.
Make sure that column sizes has an entry for all our columns.
Make sure that each of the successors/predecessors of this basic block have this basic block in its predecessor/successor list.
Make sure that each one of our successors only has one predecessor, us.
Make sure that enums with different cases but the same value always compare different.
Make sure that enums with the same case and the same value compare equal.
Make sure that enums with the same case, but different values do not compare equal.
Make sure that even if we have an ini value, that if we also
Make sure that every predecessor ends with a Jmp that we can add arguments to, so we can create a new phi'd value.
Make sure that if FTy's calling convention implies that it must have a self parameter.
Make sure that if operand is generic that its primary archetypes match the function context.
Make sure that if we are a _adoptStorage call that our storage is uniquely referenced by us.
Make sure that it is a simple partial apply (i.e. its callee is a function_ref).
Make sure that name binding has been completed before doing any type checking.
Make sure that no bucket is at offset 0
Make sure that no bucket is at offset 0.
Make sure that none of the nested types are dependent.
Make sure that our SILFunction only has context generic params if our SILFunctionType is non-polymorphic.
Make sure that our current best is better than all of the solved systems.
Make sure that our parent tuple has only one non-trivial field.
Make sure that our region has a pred list without duplicates.
Make sure that setcc with no xor doesn't cause a buffer overrun.
Make sure that setcc/xor with an non-1 xor constant is skipped.
Make sure that setcc/xor with xor status flags being used is skipped.
Make sure that solution is better than any of the other solutions
Make sure that the Closure is invoked in the Apply's callee.
Make sure that the EndBlock is not inside a loop (which does not contain the StartBlock).
Make sure that the EndBlock post-dominates all blocks we are visiting.
Make sure that the IR unit contains a main exit corresponding to the last bytecode instruction in the region.
Make sure that the OEA instruction has exactly two expected users.
Make sure that the StructDecls match up.
Make sure that the WMI and AI match.
Make sure that the adjacencies we expect are the adjacencies we have.
Make sure that the derived type is sane.
Make sure that the function has a Void result type.
Make sure that the incoming edge bb is not the RCIdentityBB.
Make sure that the index types are equivalent.
Make sure that the number of parameters matches the "number of colons" in the name.
Make sure that the open_existential does not have any uses except destroy_addr.
Make sure that the overriding property doesn't have storage.
Make sure that the protocol conformances are complete.
Make sure that the protocol list is fully expanded.
Make sure that the raw type is Equatable.
Make sure that the replacement type only uses archetypes allowed in the context where the normal conformance exists.
Make sure that the return has the same type as the function.
Make sure that the substitution list of the PAI does not contain any archetypes.
Make sure that the tuple types match up.
Make sure that the type of the metatype matches the type that we are casting to so we stride by the correct amount.
Make sure that the types of the constraints match the types of the arithmetic operation.
Make sure that the value is in the map.
Make sure that the value is laid out correctly in memory.
Make sure that there are no archetypes in the interface type.
Make sure that there is an invalid 'override' attribute on the / given declaration.
Make sure that there's an index on chunks so we can sort by chunk num
Make sure that this reference does not get optimized away.
Make sure that this unreachable instruction is the last instruction in the basic block.
Make sure that we are only storing into our users, not storing our users which would be an escape.
Make sure that we are safe.
Make sure that we can look up the local region corresponding to this region's successor.
Make sure that we decided to emit its body the first time around.
Make sure that we didn't find more than one match at the best edit distance.
Make sure that we have no other non-trivial elts.
Make sure that we have space to round up to the start of a huge page
Make sure that we propagate out whether or not nesting was detected.
Make sure that we reprocess all operands now that we reduced their use counts.
Make sure that we skip past any dead successors.
Make sure the "getLastError" also gets send to a primary.
Make sure the FPushOp was in the region
Make sure the FPushOp wasn't interpreted, based on an FPushCuf, or spanned another call
Make sure the PM knows about this function.
Make sure the SynthesizeSugarOnTypes option is functioning.
Make sure the above parsing code is revisited when new tags are added (we'll get a warning for a missing case label):
Make sure the base type has registered itself as a provider of generic parameters.
Make sure the bind is to the OptionalEvaluationExpr we're emitting.
Make sure the block is at the end of the function so that forward references don't affect block layout.
Make sure the concrete type fulfills the requirements on the archetype.
Make sure the condition comes from a select_enum
Make sure the constructor is only as available as its superclass's constructor.
Make sure the constructor is within Selector.
Make sure the current process gets scheduled to the target cpu.
Make sure the didSet/willSet accessors are marked final if in a class.
Make sure the direct and indirect results are sane.
Make sure the directory path to extract to exists or can be created
Make sure the element is checked out before we poke at it.
Make sure the exponent has at least 2 digits
Make sure the file exists OR it can be created at the required path
Make sure the func loc is not the start of the function body, in which case the context sensitive keyword was implied.
Make sure the getter and setter have valid types, since they will be used by SILGen for any accesses to this subscript.
Make sure the getter and setter have valid types, since they will be used by SILGen for any accesses to this variable.
Make sure the increment we are looking at is also matched to our decrement.
Make sure the input pointer is the right type.
Make sure the instruction itself is tagged properly.
Make sure the instructions in this function are attached its debug scope.
Make sure the interface types are sane.
Make sure the main file is the first file in the module.
Make sure the new size of the string wouldn't overflow int32_t.
Make sure the offset from hot text is either odd or even number of huge pages.
Make sure the parent protocols have been fully validated.
Make sure the reference to 'self' occurs within an initializer.
Make sure the repo exists before attaching it, in order to avoid creating a read-only repo.
Make sure the signature can't match by dumb luck -- TBB
Make sure the sprop is accessible from the singleton method's context.
Make sure the terminal color gets restored when the REPL is quit.
Make sure the thread is gone after hphp_process_exit().
Make sure the whole thing is a valid identifier.
Make sure the witness is of the same kind as the requirement.
Make sure there is no iterator invalidation if the inspected instruction gets removed from the block.
Make sure there is room to insert an element.
Make sure there is something to read
Make sure there won't be 2 constructors after importing
Make sure there's a matching ':' after the middle expr.
Make sure there's no cyclic dependencies.
Make sure they pair up
Make sure this argument's sugar is consistent with the sugar we already found.
Make sure to apply the fix at the right application level.
Make sure to at least record the braces range in the AST.
Make sure to check bounds, if we haven't yet.
Make sure to keep handling of both of these errors in sync.
Make sure to pass in the same set of required elements for each pred.
Make sure to print type variables if we can get to ASTContext.
Make sure to print type variables.
Make sure to recontextualize any decls in the capture list as well.
Make sure to release and destroy any owned or in-arguments.
Make sure to reset our dst's inst pointer, if we have one.
Make sure to return something of the requested type.
Make sure to run at least one round of the ARC optimizer after this.
Make sure we /used/ the last module filter we got.
Make sure we always allocate spill space in multiples of 16 bytes, to keep alignment straightforward.
Make sure we always have a resolver to use.
Make sure we are calling the same method.
Make sure we are extracting the number value and not the overflow flag.
Make sure we are referring to a designated initializer.
Make sure we aren't duplicating history entries
Make sure we aren't trying to equate type variables with different lvalue-binding rules.
Make sure we at least set the 'is Swift class' bit, though.
Make sure we bracket all notes as "sub-diagnostics".
Make sure we can access the field without crashing.
Make sure we can claim this argument.
Make sure we can duplicate the header.
Make sure we can handle the inputs.
Make sure we can identify when the subregion has at least one dead non-local edge and no remaining live edges.
Make sure we can move potential decrements to the predecessors and collect retains we could match.
Make sure we can reference ObjectiveC.Selector.
Make sure we declare the referenced function.
Make sure we do ARC contraction under optimization.
Make sure we don't change that.
Make sure we don't do this checking again.
Make sure we don't invalidate our iterators by parking it on the instruction before I.
Make sure we don't print duplicate imports, due to getting imports for both a clang module and its overlay.
Make sure we don't return to it so we have a chance to honor breakpoints.
Make sure we don't search in Clang modules for this method.
Make sure we dont hit it
Make sure we end the region before trying to print the IRUnit.
Make sure we found the same operand as prior iterations.
Make sure we get consistent overrides for the accessors as well.
Make sure we have a case for every ValueDecl.
Make sure we have a compatible block.
Make sure we have a delegate
Make sure we have a proxy
Make sure we have a reabstraction thunk.
Make sure we have a single GlobalAddrInst and a single StoreInst.
Make sure we have a type declaration.
Make sure we have a valid class.
Make sure we have an acceptable FPush and non-null callee.
Make sure we have an identifier for the base name.
Make sure we have an up-to-date conformance table for the superclass.
Make sure we have loads for all of the stack elements.
Make sure we have not seen this witness table yet.
Make sure we have odd number of sequence exprs.
Make sure we have the appropriate bridging operations.
Make sure we have the complete list of extensions.
Make sure we have the complete list of members (in this nominal and in all extensions).
Make sure we have the right current working directory within the repo based on what server.source_root was set to (current process directory being the default)
Make sure we have the right number of generic arguments.
Make sure we have the value witness marker.
Make sure we know how to map the selector appropriately.
Make sure we leave the array in a consistent state
Make sure we map the archetypes if we haven't yet.
Make sure we only process instructions we know how to process.
Make sure we only unwrap at most one layer of optional.
Make sure we record any files that still need to be rebuilt.
Make sure we release later if we received at +1.
Make sure we skip adding the standard library imports if the source file is empty.
Make sure we still remove A.init from the set in this case.
Make sure we use the same value category for these so that we can hereafter just use simple equality checks to test for abstraction.
Make sure we validate the type again.
Make sure we're dealing with strings.
Make sure we're left with an identifier.
Make sure we're not overriding a settable property with a non-settable one.
Make sure we're using its address result, not its refcount result, and make sure that the box gets deallocated (not released) since the pointer it contains will be manually cleaned up.
Make sure we've loaded a valid underlying type.
Make sure we've resolved implicit constructors, if we need them.
Make sure we've validated the requirement.
Make terminator unreachable.
Make the actual call.
Make the alloca at least as aligned as the coercion struct, just so that the element accesses we make don't end up under-aligned.
Make the call and clear the arguments array.
Make the constructor declaration immediately visible in its class or protocol type.
Make the constructor transparent so we inline it away completely.
Make the context ready to start over
Make the debug information stored in the AllocBox explicit.
Make the destination directory if it doesn't exist already
Make the error-limit table if we didn't already.
Make the getter/setter methods unavailable.
Make the given name private.
Make the last case a default.
Make the name private.
Make the path relative to "." by flattening.
Make the pre-header a part of the parent loop of L if L has a parent loop.
Make the property decl
Make the property the alternate declaration for the getter.
Make the required changes to the call site.
Make this a computed property.
Make this a stub implementation.
Make this addressor transparent.
Make this barrier explicit when building for TSan to avoid false positives.
Make this definition a declaration by removing the body of a function.
Make up a key for readCachedModule.
Make use of the fact that some of these casts cannot fail.
Make year always a positive number.
Making FURC_SHIFT bigger also makes furc_hash modestly slower.
Making this larger will sacrifice a modest amount of performance.
Malformed or multiple newlines.
Manage the parameter.
Mandatory inlining: every instruction inherits scope/location from the call site.
Mangle ASCII operators directly.
Mangle DynamicSelf as Self within a protocol.
Mangle a StringRef as an identifier into a buffer.
Mangle a list of protocols.
Mangle a type into the buffer.
Mangle an identifier into the buffer.
Mangle local declarations with a numeric discriminator.
Mangle non-local private declarations with a textual discriminator based on their enclosing file.
Mangle normal identifiers as count identifier-char+ where the count is the number of characters in the identifier, and where individual identifier characters represent themselves.
Mangle normal identifiers as: count identifier-char+ where the count is the number of characters in the identifier, and where individual identifier characters represent themselves.
Mangle the constant with a _TTD header.
Mangle the containing module context.
Mangle the error result if present.
Mangle the generic signature, if any.
Mangle the module name if: - the extension is defined in a different module from the actual nominal type decl, - the extension is constrained, or - the extension is to a protocol.
Mangle the name of a protocol as a substitution candidate.
Mangle the name of a protocol or class for use in the Objective-C / runtime.
Mangle the name of a type.
Mangle the name of the witness thunk.
Mangle the number of parameters.
Mangle the parameters.
Mangle the reabstraction thunk.
Mangle the requirements.
Mangle this as if it were a closure within the requirement.
Mangle this as if it were a conformance thunk for a closure within the requirement.
Mangle this entity as a std::string.
Mangle this entity into the given buffer.
Mangle this entity into the given stream.
Mangling the archetypes in this case can be very misleading, so we just mangle the base name.
Manual re-construction of the instance.
Manually add any expected nominal types from imported modules so that they get their expected type relation.
Manually add status and reason.
Manually append the args for the PHP application.
Manually create the IO context to support custom stream wrappers.
Manually run the action, so that the TU stays open for additional parsing.
Manually search for the generator witness.
Manually trigger memory cleanup.
Many (perhaps most) of these colors will remain marked open.
Many cases are handled by the inliner/devirtualizer, but certain special cases are not covered there, e.g. partial_apply(witness_method)
Many of the things done by generic instantiation are unnecessary here: initializing the metaclass pointer initializing the ro-data pointer Initialize the superclass if we didn't do so as a constant.
Many walker implementations rely on being invoked with every node in the AST.
Map 'throws' to the appropriate error convention.
Map ConstructorDecls to the Allocator SILDeclRef of the constructor.
Map DestructorDecls to the Deallocator of the destructor.
Map EnumElementDecls to the EnumElement SILDeclRef of the element.
Map FuncDecls directly to Func SILDeclRefs.
Map __attribute__((const)).
Map __attribute__((pure)).
Map __attribute__((warn_unused_result)).
Map a Type to an interesting declaration whose source range we / should print.
Map a cache entry to a result for this specific
Map a dependent member to the corresponding nested archetype.
Map a generic parameter type to its archetype.
Map a signature type for a parameter.
Map a type within the signature of a declaration.
Map all address modes that Vptr can be so it can be handled.
Map all blocks to BBEnumTagDataflowState in RPO order.
Map all the outer initializations to their appropriate targets.
Map an ExtInfo for a function type.
Map an array to a hoisted make_mutable call for the current loop.
Map an indirect return for a type SIL considers loadable but still requires an indirect return at the IR level.
Map anonymous enums with no fixed underlying type to Int /if/ they fit in an Int32.
Map any projections of the box to the promoted argument.
Map back to IRInstruction from index.
Map case values to Labels, filling in the blanks as appropriate.
Map categories known to the reader.
Map contextual type to interface type.
Map down to the semantics-providing pattern.
Map each address projection of this object to a list of stores.
Map each global initializer to a list of call sites.
Map each global let variable to a set of loads from it.
Map each global let variable to the store instruction which initializes it.
Map each initializer-containing function to its final initializer call.
Map each let property to a set of instructions accessing it.
Map each let property to the instruction sequence which initializes it.
Map each of the declarations.
Map each of the results.
Map errors 1:1 up to +- MAXJSAMPLE/16
Map errors 1:2 up to +- 3*MAXJSAMPLE/16
Map every basic block to its location state.
Map from AliasClass ids to the must-alias-set that has it as memory_support, if any do.
Map from Closure names to the function(s) containing their associated CreateCl opcode(s).
Map from EHEnt to the ExnNode that will represent exception behavior in that region.
Map from PhysReg until the first position at which it is /not/ available.
Map from a different tuple element.
Map from class id to the function containing its DefCls instruction.
Map from dominator tree node to tree level.
Map from each block to its information.
Map from each class name to ClassInfo objects for all not-known-to-be-impossible resolutions of the class at runtime.
Map from each class to all the closures that are allocated in functions of that class.
Map from exception names to the list of EHEnt's that have a catch block jumping to this label for that name.
Map from interfaces to their assigned vtable slots, computed in compute_iface_vtables().
Map from normal protocol conformances to diagnostics that have / been delayed until the conformance is fully checked.
Map from offset to label names we should use for that offset.
Map from source lines to a collection of all the bytecode ranges the line encompasses.
Map it to a contextual type.
Map magic literal tokens such as #file to their / MagicIdentifierLiteralExpr kind.
Map native types back to bridged types.
Map of field names to symbols of custom scanners for that field.
Map outer initializations into a tuple of inner initializations: - fill out the initialization elements with null
Map over to the inferior design of the LLVM intrinsic.
Map parsed parameters to a ParameterList.
Map property getters/setters.
Map protocol conformances to their root normal conformance.
Map some rows of pixels to the output colormapped representation.
Map the Clang attributes onto Swift attributes.
Map the Clang swift_bridge attribute to a specific type.
Map the LLVM arguments to arguments on the entry point BB.
Map the Objective-C selector directly.
Map the SIL dest bbs to their LLVM bbs.
Map the argument number into an argument expression.
Map the base value to its substituted representation.
Map the callee argument effects to parameters of this function.
Map the character sequence onto
Map the convention to a runtime metadata value.
Map the error result.
Map the former into the latter.
Map the generic parameters to their corresponding type variables.
Map the given element to the appropriate value in the / discriminator type.
Map the increment's operand to a newly initialized or reinitialized ref count state and continue...
Map the indices of array element initialization stores to their values.
Map the indirect return if present.
Map the indirect returns if present.
Map the metatype representation.
Map the name and complete the import.
Map the parameter and expected types out of context to get the interface type of the thunk.
Map the parent of any non-generic nominal type.
Map the remaining SIL parameters to LLVM parameters.
Map the return value.
Map the selector into a Clang selector.
Map the type into the conformance's context.
Map the type to an interface type.
Map the upper portion of the RDS to a shared area.
Map the value to the original pattern.
Map the values for the duplicated header block.
Map this indirect field to a Swift variable.
Map to a nominal type declaration.
Map type parameter names with their instantiating arguments.
Map unbound types into their defining context.
Map up to our superclass's type.
Map values in predecessor blocks to argument indices of the successor block.
Map various attributes differently depending on if we're looking at the declaration, or a function parameter type.
Map vector types to the corresponding C vectors.
MapViewOfFileEx() requires "the specified memory region is not already in use by the calling process" when mapping the shared area below.
Mapping for the top level functions.
Mapping from BB responsible for a specific case value to the result it produces.
Mapping from archetypes with lazily-resolved nested types to the / archetype builder and potential archetype corresponding to that / archetype.
Mapping from case values to the results corresponding to this case value.
Mapping from names to targetcache locations.
Mapping from the original argument of partial_apply to the temporary containing its copy.
Mapping of object types to their computed actions.
Maps an ASCII character to a collation element priority as would be / returned by a call to ucol_next().
Maps class name to a VTable ID.
Maps default witness table identifier to an ID.
Maps from BlockIds to accumulated post conditions for that block.
Maps functions to contexts that depend on information about that function, with information about the type of dependency.
Maps global variable name to an ID.
Maps instructions which produce a failing condition (like overflow builtins) to the actual cond_fail instructions which handle the failure.
Maps manipulated by getObject().
Maps normalized QP (quality) to VP8 QP
Maps region block ids to their RPO ids.
Maps witness table identifier to an ID.
Mark 0 again -- should be no change.
Mark a given object type pointer followable.
Mark a value-dependence on the base.
Mark all CFG arcs within the region as covered.
Mark all associatedtypes in this protocol as recursive (and error-type) to avoid later crashes dealing with this invalid protocol in other contexts.
Mark all our options with this category, everything else (except for -version and -help) will be hidden.
Mark all outgoing arcs from the region to a head node as covered.
Mark all predecessor blocks with the sentinel undef value.
Mark all region's nodes as covered.
Mark all remaining deferred commands as skipped.
Mark any _ObjectiveCBridgeable conformances as 'used'.
Mark any _ObjectiveCBridgeable conformances in the given type as "used".
Mark any block that this pass has determined to be inside a loop.
Mark any functions for which loops have been analyzed.
Mark any unset elements as not available.
Mark as covered all incoming arcs from already covered nodes into the entry of the region or one of its retranslations/merged blocks.
Mark as live the terminator argument at index ArgIndex in Pred that targets Succ.
Mark blocks where the self value has been consumed.
Mark box addresses as captured for DI purposes.
Mark children as invalid.
Mark class methods as static.
Mark dependence as necessary.
Mark each of the listed parameters as non-null.
Mark each reg assigned to an inactive interval as only free until the first position at which `current' intersects that interval.
Mark each unresolved associated type witness as erroneous.
Mark end of requirements.
Mark everything that is not visible from the source code (i.e., does not have a Swift name) as artificial, so the debugger can ignore it.
Mark files that are referenced from the autoload map so they get preloaded via preloadRepo.
Mark it live across the instruction so its lifetime conflicts with the destination, which ensures it will be assigned a different register than the destination.
Mark metaclasses as appropriate.
Mark oldAd as having 0 elements so that the array release logic doesn't decRef the elements (since we teleported the elements to a new array)
Mark reachable, essential, instructions live and enqueue them.
Mark regs that fit our constraints as free up until the point of conflict, unless they're owned by active intervals---then mark them used.
Mark self as being uninitialized so that DI knows where it is and how to check for it.
Mark some classes as volatile since the name is used in switch
Mark that the current context is covered by a 'try', as / appropriate for a debugger function.
Mark that the current context is top-level code with / throw-without-try enabled.
Mark that the function type throws.
Mark that this is a computed property.
Mark that this is an observing property.
Mark the EndCatch safe, since we're eager syncing.
Mark the accessor as transparent if we can.
Mark the async function as succeeded and store the return value.
Mark the async generator as finished.
Mark the bits we'll use as occupied in both bitsets.
Mark the block as a failure path, indicating the self value has been / consumed.
Mark the constructor transparent so that we inline it away completely.
Mark the current thread as being in the process of completing an io, and record the time that the io started.
Mark the function transparent so that we inline it away completely.
Mark the generator as finished and store the return value.
Mark the generator as finished.
Mark the given declaration as being Objective-C compatible (or / not) as appropriate.
Mark the hash entry as "deleted".
Mark the imported class method "unavailable", with a useful error message.
Mark the memory as uninitialized, so DI will track it for us.
Mark the method to be final, implicit, and private.
Mark the needed conformances as used.
Mark the original source as redundant.
Mark the protocol as having missing requirements.
Mark the typealias as an error and don't inject it into any DeclContext.
Mark the value as a tombstone.
Mark the vardecl to be final, implicit, and private.
Mark the variable as used if doesn't have external linkage.
Mark the wait handle as failed due to PHP exception.
Mark the wait handle as failed due to unexpected abrupt interrupt.
Mark the writeback as auto-generated so that we don't get warnings if we manage to devirtualize materializeForSet.
Mark them as unknown control flow boundaries.
Mark this as the cached metatype for Self.
Mark this as the cached witness table for Self.
Mark this basic block as processed.
Mark this node as part of this connected component, then recurse.
Mark this test a failure
Mark through the parameters, binding them to their arguments.
Marker that instances of the type with this type index do not represent actual heap allocations (we only want the scanner).
Marker that shows that this was an obj so it doesn't collide with strings
Marker, not a real user token ID
Markers in callee main blocks are modified to reference the parent FP, sp offsets are recomputed relative to this FP, and the fixup source key is set to the call source key from the caller.
Marking it as TF would mess up any bytecodes that want to consume its output value, so we can't do that.
Marking the boxed value as escaping is OK.
Marks a function as alive if it is not alive yet.
Marks a function as alive.
Marks flexible array field.
Marshal the data we actually care about into fields on this object, then remarshal them into smart_ptr structures during unserialize()
Mask in junk to make sure the runtime correctly ignores it.
Mask off the spare bits (if they exist).
Mask off the spare bits.
Mask off the upper 16-bits to handle things like DiscriminatedPtr which stores things up there.
Mask out the selected bits.
Mask the bits into the pointer representation.
Mask the spare bits into the payload area.
Mask the tag bits out of the payload, if any.
Master copy of the tokenizer object.
Master routine for color selection
Match a Value associated type requirement to the property type.
Match a call to a trap BB with no ARC relevant side effects.
Match a hoistable make_mutable call.
Match a name against another name, ignoring the template parameter portion.
Match a requirement and witness type.
Match a storage requirement.
Match a type in the requirement to a type in the witness.
Match a word within a name to a word within a type.
Match an add 1 recurrence.
Match an index pointer that is fed by a sizeof(T)*Distance offset.
Match array semantic calls.
Match each of the parameters.
Match each of the witnesses to the requirement.
Match get_element_addr call.
Match how the memlocation print tests expect us to print projection paths.
Match in order, but allowing interjected words
Match initialization stores.
Match on the alternate.
Match pattern components until there are none left
Match the actual induction variable buried in the integer struct.
Match the argument of a call to the parameter.
Match the beginning of the name to the given type name.
Match the camelCase beginning of the name to the ending of the type name.
Match the last words in the type name to the last words in the name.
Match the reference and token result.
Match the result type to the beginning of the name.
Match the subsequence if we have one.
Match the taken block, if there is one.
Match up any named elements.
Match up the call arguments to the parameters.
Match up the generic arguments, exactly.
Match up the parents, exactly, if there are parents.
Match up the parents, exactly.
Match various reserved words.
Match will be set true once there is a match.
Matches the php5 extension in that this case doesn't use ANSI color codes...
Matching zend again: incDecProp does an unbox before the operation, but setop doesn't need to here.
Materialize the element.
Materialize the input.
Matters if exporter.debug_zval is set.
MaxStoreSet is optimistically set to true initially.
Maximum number of default-value parameter initializations to unroll.
Maximum number of local initializations to unroll.
Maximum number of rounds.
Maximum number tries for in-range result before just returning 0.
Maximum salt string length.
May be TBottom if the function is known to never return (e.g. always throws).
May be a scalar on iOS/watchOS (because of WatchKit).
May be an array mutation.
May be polymorphic at the SIL level, but no type metadata is actually passed.
May be top bit is not set in the value being shifted.
May mutate the IRInstruction in place (and return nullptr) or return an SSATmp*.
May not be initialized.
May or may not be boxing it, depending on the refiness.
May return nullptr if it is currently impossible to create a translation.
May throw C++ exception that may leave some events unprocessed.
MayAlias, invalidate the location and value.
MayAlias, invalidate the location.
Maybe L*a*b* and Delta-E will give better results (and a better granularity).
Maybe LLVM will be able to simplify it further.
Maybe revert to the original cleanups during failure branches.
Maybe the literal was in hex. Reject that.
Maybe this should also require the scalars to have a fixed offset.
Maybe we were equated to a concrete type...
Maybe we're lucky and this is an easy case
Meanwhile the second sees that its been bound, finishes up, and then tries to read the property, but sees uninit-null for the value (and asserts in a dbg build)
Meanwhile, we don't need to worry about finding unwanted hidden declarations from different modules because we do a module check before deciding that there's a conflict.
Measures the size of the array and referenced objects without going into ObjectData* references.
Measures the size of the typed value and referenced objects without going into ObjectData* references.
Mem2reg/load forwarding will clean things up for us.
MemRefAnalysis availability state.
Member functions need some special validation logic.
Member subscripts need some special validation logic.
Member syntax 'T.Element' forms a pattern if 'T' is an enum and the member name is a member of the enum.
Member types don't get any representation.
MemberRefExpr can refer to type and function members, but the only case that can be an lvalue is a VarDecl.
Members cannot be both dynamic and final.
Members of a nominal type often try to refer back to the type.
Members of protocol extensions have special overloading rules.
Members which are AbstractFunctionDecls but not FuncDecls cannot / mutate self.
Memoization Opportunity Profiler
Memoize throws in the emitter if any function parameters are references, so we can just assert that the param is cell here
Memorize the last retain.
Memory Threhsold callback should also be fired here
Memory instructions which can be made stack relative if DefInlineFP is pushed past them.
Memory locations the loop provably cannot modify on any route to a back edge.
Memory usage is stored on function begin if tracing, or if collect_memory is enabled, or on function end if computerized tracing output is enabled
Merge "duplicate" indexed types together using some definition of duplicate, returning the merged types.
Merge LocationStates, returning whether anything changed.
Merge TypeSourceSets, returning whether anything changed.
Merge all nominal types from the structural type.
Merge an attribute's availability with an existing inferred availability / so that the new inferred availability is at least as available as / the attribute requires.
Merge any concrete constraints.
Merge comments if they are on same or consecutive lines.
Merge cond_fail instructions if there is no side-effect or read in between them.
Merge cond_fail instructions.
Merge conditions and remove the merged cond_fail instructions.
Merge duplicate loads, and forward stores to loads.
Merge equivalence class from the non-representative type variable.
Merge equivalence classes until a fixed point is reached.
Merge from the predecessor blocks.
Merge in our predecessor states.
Merge in the predecessor state.
Merge in the state of the predecessor basic block.
Merge in the state of the successor basic block.
Merge initialAttrs with attrs.
Merge initialAttrs with outAttrs.
Merge inputs and generic parameters from the uncurry levels.
Merge nodes in the constraint graph.
Merge one FrameState into another, returning whether it changed.
Merge src into dst, returning true iff dst was changed.
Merge the a set of imported names produced for the overridden / declarations of a given method or property.
Merge the basic block with its successor if possible.
Merge the contexts from the respective spills
Merge the data flow states.
Merge the edges and remove the constraint.
Merge the entries into null-separated string.
Merge the equivalence classes corresponding to these two variables.
Merge the liveIn into the liveOut of each normal predecessor.
Merge the liveIn into the liveOutExn state for each exceptional precessor.
Merge the old latch with the old header if possible.
Merge the predecessors.
Merge the property type.
Merge the state from a predecessor block into the OutAvailability.
Merge the summary graph into all callers.
Merge the trailing where clause into the generic parameter list.
Merge the two states together.
Merge to ensure namedentity creation, according to emitTypedef in emitter.cpp
Merge two state-stacks.
Merge with actual extensions.
Merge/intersection is very frequently performed, so it is important to / make it as cheap as possible.
Merges two overlapping ranges and splits the first range into two / ranges before and after the overlapping range.
Merging InitCell is correct, but very conservative, for now.
Merging actually creates the summary graph.
Merging option types tries to preserve subtype information where it's possible.
Meta info on the key local will confuse the translator (and wouldn't be useful anyway)
Meta info on the value local will confuse the translator (and wouldn't be useful anyway)
Metadata *(*CreateFunction)(GenericMetadata*, const void * const *)
Metadata about a variable which is the object of register allocation.
Metadata accessors for fully-substituted generic types are emitted with shared linkage.
Metadata caches are stored at negative offsets.
Metadata for Clang types should be uniqued like foreign classes.
Metadata for Self is derived inside the partial application thunk and doesn't need to be stored in the outer context.
Metadata with a non-trivial parent node always requires an accessor.
Metaprogram to verify that every concrete class implements 'SourceRange getSourceRange()'.
Metaprogram to verify that every concrete class implements a 'static bool classof(const Pattern*)'.
Metaprogramming-friendly base class.
Metatype conversion casts in the AST might not be reflected as such in the SIL type system, for example, a cast from DynamicSelf.Type directly to its own Self.Type.
Metatype is already an ObjC object.
Metatype self captures don't extend the lifetime of an object.
Metatype to object conversion.
Metatype-to-object conversions are free.
Metatypes and bases of non-mutating setters on value types are always rvalues.
Metatypes are (mostly) singleton type descriptors, often without storage.
Metatypes are ABI-compatible if they have the same representation.
Metatypes are always trivial.
Metatypes are interchangeable with metatypes with the same representation.
Metatypes containing classes, or where the original unsubstituted / type contains a type parameter, must be represented as pointers / to metadata structures.
Metatypes have instance types.
Metatypes of nominal types and archetypes have instance methods and static members, but not instance properties.
Metatypes preserve their instance type through lowering.
Metatypes preserve variance.
Metatypes that can be represented as ObjC trivially cast to AnyObject.
Metatypes that can be thin would never be classes.
Method calls through ObjC protocols require ObjC dispatch.
Method ids reported to Vtune JIT API should not be less than 1000 (see the comment in iJIT_Method_Load structure definition.) We use 1000 for trampolines and larger values for normal functions.
Method lookup did not find anything.
Methods from extensions don't go into vtables (yet).
Methods need to be collected into the appropriate methods list.
Methods of non-final classes can only contain a covariant 'Self' as a function result type.
Methods returning bool/UChar32 and taking a single UChar32 argument
Methods with unique signatures
Michael's regex carries this copyright:  Copyright Michael Rushton 2009-10 http://squiloople.com/ Feel free to use and redistribute this code.
Might as well create the error-limiting table too.
Might as well spill on a block boundary, as early as possible.
Might as well store it as a map
Might be defined in sys/types.h.
Might be different from the substituted argument type by abstraction and/or bridging.
Might be not valid in this position, though.
Might be possible to only merge a TArrE, but for now this is ok.
Might change any array.
Might learn more from the magic(4) entry
Might throw an exception
Migrate the tests to this format eventually.
Minified versions of nativeDataInstanceCtor/Dtor
Minimal recovery: if there's a single token and then an r_paren, consume them both.
Minimize the set of protocols composed together.
Minimize trashed registers
Minimum number of rounds.
Misc stubs for functions which should be defined in the core standard library, but are difficult or impossible to write in Swift at the moment.
Miscellaneous instructions
Missing /tmp or similar directory
Missing a keyword argument name.
Missing features (partial list):  - line number information.
Missing: RuntimeOption::RepoAuthoritative's physical location is perf-sensitive.
Mitchell filter, default radius 2.0
Mix class subs with method specific subs from the AI substitutions.
MixedArray guarantees that when it adds a hash table entry that it always sets it to refer to a valid element.
MixedArray needs a higher threshold to avoid false-positives.
MixedArray::Grow can only handle non-empty cases where the buffer's refcount is 1.
MixedArray::compact can only handle cases where the buffer's refcount is 1.
Mock up a value witness table for Builtin.Int8 will 254 and 255 as extra inhabitants.
Model this like an escape of the elements of the array and a capture of anything captured by the closure.
Modelled after http://nodejs.org/docs/latest/api/http.html#http.ServerRequest
Modifications to the Linux kernel to support shutting down a listen socket for new connections only, but anything which has completed the TCP handshake will still be accepted.
Modified 9 Jan 2002 by Makoto Matsumoto.
Modified to use Winsock (NOVSOCK2.H), at least for now
Modifies (and returns) passed url parameter to be used for additional parameter appending
Modifies passed url based on the location header that was received in the response headers, depending on whether the redirection was relative or absolute
Modify a GeneralEffects to take potential VM re-entry into account.
Modify return terminators to branch to the return-to BB, rather than trying to clone the ReturnInst.
Modify should only ever be called once with a non-null new_value.
Modify state to conservative values given an unprocessed predecessor.
Modify throw terminators to branch to the error-return BB, rather than trying to clone the ThrowInst.
Modifying an array or string element, even when COW doesn't kick in, produces a new SSATmp for the base.
Modifying one phi node can invalidate another unrelated phi nodes operands through the common branch instruction (that has to be modified).
Module implementation Helper for requestInit that returns the initial value for the given config option.
Module initialization routine for 2-pass color quantization.
Module inputs are okay if generating a module.
Module printing options.
Module types are always fully resolved.
Module types get an M prefix, but module contexts don't.
ModuleFilename can be empty if something strange happened during module loading, for example, the module file is corrupted.
ModuleWrapInvocation should share its implementation.
Modules and file units can always handle name lookup.
Modules are never instance members.
Modules can consist of more than one file.
Modules failing to load are commented-out.
Mongo class constants
MongoDB 1.8.x doesn't have the "me" field.
MongoGridFSFile Object
MongoMaxKey and MongoMinKey are completely non-interactive: they have no method, fields, or constants.
MongoTimestamp (17) 8 bytes total: - sec: 4 bytes - inc: 4 bytes
More complex expressions get stashed into an unnamed local so we can evaluate them at the proper time.
More complicated way of expressing exposure time, so only use this value if we don't already have it from somewhere else.
More efficient value semantics implementations for certain enum layouts.
More information at: http://en.wikipedia.org/wiki/YCbCr
More information on: https://goo.gl/F1wrbO
More over, for classes, only the class itself can initialize its let properties.
More relevant info always comes earlier, so only use this field if we don't have appropriate aperture information yet.
More subtle is that we need to block auto-typechecking until the VM is fully initalized, and systemlib is fully merged.
More than one arc with unknown weight, so can't infer
More than one element, must use bitset mode.
More than one trait contains the method.
More type variable sharing (when it's sane) would help us do much better here.
More-or-less horizontal.
More-or-less vertical.
Moreover the strings must be static
Moreover, it doesn't reliably emit function declarations if it thinks the function isn't used.
Moreover, since global DCE makes use of type information to determine whether a store is dead, we need to be careful that this never changes whether the assumptions used to perform DCE were correct.
Moreover, these types usually aren't very interesting, so we deliberately ignore them for efficiency.
Most European countries used the Julian calendar prior to the Gregorian.
Most exprs remain exprs and should be wrapped in ExprPatterns.
Most functions are just 'wrappers' for standard file functions.
Most importantly, it might have pulled args /off/ the eval stack and shoved them into an ExtraArgs on the calleeAR, or into an array for a variadic capture param.
Most likely one of: init_enum_data_addr open_existential_addr partial_apply struct_element_addr unchecked_take_enum_data_addr
Most local type data kinds are already canonical.
Most of the analysis code in this module is about computing the information we need to build these flowgraphs, before we do the actual optimizations on them.
Most of the clients treat subscript reference the same way as a regular reference when called on the open bracket and ignore the closing one.
Most of the complexity in this analysis is related to instructions that load or store from memory, and therefore interacts with memory support.
Most of the ideas used here can be traced back to Heckbert's seminal paper Heckbert, Paul.
Most of the time the default value is scalar, so we can avoid evaling in the common case
Most of the time we want to adjust to a corresponding "before" address with the exception of the start of the range where "before" can point to the end of a previous range.
Most of these are HTTP garbage (400 Bad Request) or client timeouts (408).
Most of this code will be removed once the SIL level ARC optimizer causes it to no longer be needed.
Most of this function is about tuples: tuples can be represented as one or many values, with varying levels of indirection.
Most output kinds want a formatted output stream.
Most return void, though a few return a jit::TCA.
Most single-refcounted types will use the standard value witness tables for NativeObject or UnknownObject.
Most type metadata depend on the formal linkage of their type.
Mostly useful for platforms where the debug info typically stays in the executable.
Mostly useful for platforms where the linker doesn't natively support autolinking (ie.
Movable, but not copyable.
Move CFs to right before Inst.
Move II down the block until it hits TargetInst or the first SummarizedInterestingInst.
Move all needed operands to a place where they dominate the select_value.
Move all of the specified instructions from the original basic block into the new basic block.
Move an instruction which is an operand to the new SelectValueInst to its / correct place.
Move any instructions from the EpilogBB to the end of the 'pred' block.
Move any remaining active constraints into the inactive list.
Move argArray to where the second argument belongs.
Move cond_fail down if it can potentially help register promotion later.
Move elements that came after the deleted elements (if there are any)
Move index to genericParams.
Move invName to where the first argument belongs, no need to incRef/decRef since we are transferring ownership
Move items with non-zero hotness to the end...
Move lexer to the start of the current line.
Move new declarations out.
Move on to the next one
Move on to the options
Move over the escape char
Move remaining bytes into internal buffer.
Move result keeping the higher 32bits
Move the appropriate inner arguments over as outer arguments.
Move the cond_fail to the predecessor blocks.
Move the constraints back.
Move the current projection and memorize it for the next iteration.
Move the epilog block to the end of the ordinary section.
Move the existing elements to make element 0 available.
Move the existing elements to make element slot 0 available.
Move the fallthrough case to specialized.
Move the foreign "self" argument into position.
Move the function to a different name.
Move the function to its proper place within the module.
Move the function to this position in the module.
Move the insertion point to the 'body' block temporarily and emit it.
Move the insertion point to the throw destination.
Move the instruction from the successor block to the current block.
Move the iterator before we remove instructions to avoid iterator invalidation issues.
Move the iterator to the next instruction because we may sink the current instruction.
Move the loadable value into a "source temp".
Move the new record to the placeholder's position.
Move the old header to after the old latch as it is now the latch.
Move the pointer back to EOF.
Move the trap basic blocks to the end of the function.
Move the wait handle to the parent context.
Move them to the check block.
Move this call to the outermost loop preheader.
Move to the first non-deprecated enumerator, or non-swift_name'd enumerator, if present.
Move to the next dominating block.
Move to the next piece.
Move under the type-checking.
Move up to the innermost generic context.
Move us to the parent context.
Moving a buffer allocation call is not trivial because we would need to move all the parameter calculations as well.
Mtime for module file KEY We don't need the stored key to load the results, but it is useful if we want to debug the cache itself.
Much like deallocation, destroy addr is safe.
Multi-threaded compilation: A single frontend command produces multiple output file: one for each input files.
Multi-threading compilation has multiple outputs, except those outputs which are produced before the llvm passes (e.g. emit-sil).
Multiple character line break or forced cut Estimate how big the output string will be.
Multiple counter object to the same underlying counter.
Multiple defaults are not allowed
Multiple empty elements are packed into the payload for each tag value.
Multiple levels of struct_extract / may exist between the operand and the user instruction.
Multiple preds define different FPs which will require a DefLabel to phi them in succ
Multiple return values are returned as a struct.
Multiple threads might create and store the resolved type structure here, but that's fine since they'll all store the same thing thanks to GetScalarArray().
Multiple values, must use a bitset.
Multiply a fixed by a fixed
MurmurHash2, 64-bit versions, by Austin Appleby  The same caveats as 32-bit MurmurHash2 apply here - beware of alignment and endian-ness issues if used across multiple platforms.
Must always be called / before destruction.
Must be 'const' or nothing.
Must be a method within a class or extension thereof.
Must be a tuple literal, function arg list, collection, etc.
Must be a value that dominates the start basic block.
Must be called for each instruction visited in dominance order.
Must be on the same source line.
Must be processed after any other language options that could affect platform conditions.
Must be the pseudo-type.
Must come after include of Tokens.def.
Must ensure there is a type prior to calling this
Must have a where clause.
Must have at least one protocol to be class-bounded.
Must hold when updating m_last
Must load this before FreeActRec, which adjusts fp(env).
Must not be called until its safe to run the relocated code.
Must provide the nothrow guarantee
Must spill `current' or another victim.
Must use bitset mode for single integers below BitsetMax.
Must use gd_strtok_r becasuse strtok() isn't thread safe
Must use resilient access patterns.
Must-alias base and identical projection path.
Mutable lvalue and address-only 'let's are LValues.
Mutate the Vinstr stream by inserting copies.
Mutating methods are always passed inout so we can receive the side effect.
Mutation would not / prevent make_mutable hoisting, but it would interfere with / isRetainReleasedBeforeMutate.
Mutex, ConditionVariable, Read/Write lock, and Scoped lock implementations using PThreads.
My attempt to incorporate alpha channel into the result worked poorly and degraded the quality of palette conversion even when the source contained no alpha channel data.
N argument types (with inout bit set),
N indicates which compression process
N is usually small ...
N.B.: This is already taken care of for us if EnableObjDestructCall is on
N1518: Recommendations for extended identifier characters for C and C++ Proposed Annex X.1: Ranges of characters allowed
N1518: Recommendations for extended identifier characters for C and C++ Proposed Annex X.2: Ranges of characters disallowed initially
NB this routine will return a single null entry for a blank line
NB: Although gd RGB values are ints, their max value is 255 (see the documentation for gdImageColorAllocate()) -- perfect for 8-bit JPEG encoding (which is the norm)
NB: BreakPointReached really means we've got control of a VM thread from the opcode hook.
NB: Don't forward the cleanup, because consuming a boxed value won't consume the box reference.
NB: If there are any pending writes they will all be failed.
NB: THREAD SAFETY (this comment also exists at Countable.java)  This method deletes the corresponding native object on whatever thread the method is called on.
NB: This doesn't work for IndirectFixup situations.
NB: This is clearly an x64-ism, and likely needs to be done differently for other architectures.
NB: This maps the region entry block to a new IR block, even though we've already constructed an IR entry block.
NB: VerifyParamType of a reference parameter can kill any references if it re-enters, even if Option::HardTypeHints is on.
NB: We assume that the witness table slots are zero if an extra inhabitant is stored in the container.
NB: We can't directly mutate the register-mapped `reg_fp'.
NB: We collect the arguments under the substituted type.
NB: We don't report the SweepNode size in the stats.
NB: a StepDestination also manages an internal breakpoint at the given location.
NB: after we know the value of RepoAuthoritative.
NB: always correctly aligned for uint32_t.
NB: always correctly aligned for uint64_t.
NB: an unnamed socket has no path, and sun_path should not be inspected.
NB: codes C4 and CC are NOT SOF markers
NB: don't want to include the data_source in the error message as it might contain a password
NB: exceptions derived from DebuggerException or DebuggerClientExeption indicate the machine remains paused.
NB: fname needs to be long-lived if generating a bytecode repo because it can be cached via a Location ultimately contained by ErrorInfo for printing code errors.
NB: if we've just executed a return from pseudomain, then there's no PC and no more code to interpret.
NB: join boundaries are represented by an empty array.
NB: locking is important when accessing m_bodyQueue as the session will also write into that structure via onBody.
NB: may update m_stack.
NB: on the failure path, these C++ helpers do a fixup and read frame locals before they throw.
NB: onSendEnd() is only sent when the VM is finished with the transport.
NB: parser assumes that the header has two bytes of NUL terminator
NB: the ActRec and function within the AR may have different classes.
NB: the arguments were just popped from the VM stack above, so the VM stack-pointer is conceptually pointing to the callee's ActRec at this point.
NB: the command may throw a variety of exceptions derived from DebuggerClientException.
NB: the m_evaledFiles map is only for the debugger, and could be omitted in RepoAuthoritative mode, but currently isn't.
NB: the machine is running, so can't send a real CmdQuit.
NB: the new-unit creation path is here, and is done while holding the tbb lock on s_nonRepoUnitCache.
NB: the order we convert to strings is observable (because of __toString methods), and the order we run DecRefs of the input cells is also observable.
NB: this also checks whether we should be stopping at special interrupt sites, like SessionStarted, RequestEnded, ExceptionThrown, etc.
NB: this function can't yet be used for unset or isset contexts.
NB: this function must be nothrow when `seconds' is zero.
NB: this is called with a read lock on the corresponding entry in the sandbox map.
NB: this may miss a race with deleting a Func.
NB: unlike most other commands, the client expects that more interrupts can occur while we're doing the server-side work for a print.
NB: unlike most other commands, the client expects that more interrupts can occur while we're doing the server-side work for an eval.
NB: we don't have a function type flag to match what we got in onFunctionEnter.
NB: we're holding the CHM lock on this bucket while we're doing this.
NB: when this returns, the Debugger class no longer has any references to the given proxy.
NDEBUG / verify - Run the SIL verifier to make sure that the SILFunction follows / invariants.
NOTE(cjiang): use hash code to fend off most of call-stack traversal
NOTE, PHP array_unique accepts ArrayAccess objects as well, which is not supported here.
NOTE: At this point, the DoAtScopeExit object is destroyed and the PBD is added to the program.
NOTE: Evaluation of the c argument should not have any side-effects
NOTE: If more checks are to be added, place the most expensive in the end, this function is called many times.
NOTE: If more checks are to be added, place the most expensive in the end.
NOTE: If this occurs frequently, maybe we can have a release(Obj, N) API to drop multiple retain counts at once.
NOTE: If we allow protocol extensions in the future, this conditional statement should be removed.
NOTE: If you make changes to how serialization and unserialization work, make sure to update reserialize() here and test_apc_reserialize() in "test/ext/test_ext_apc.cpp".
NOTE: It is required that '##' is not a valid substring of display-string or type-string.
NOTE: It's generally not safe to ignore private decls in nominal types.
NOTE: Legacy punctuator for old object literal syntax.
NOTE: Making these specializations public at this point breaks some optimizations.
NOTE: PHP's implementation of natsort and natcasesort accepts ArrayAccess objects as well, which does not make much sense, and which is not supported here.
NOTE: The base will point to the actual object this inst is accessing, not this particular field.
NOTE: The type checker is scoped to be torn down before AST verification.
NOTE: The type loc may be there but have failed to validate, in which case we return the null type.
NOTE: This code has been written in an "extended form" to make it easy to understand.
NOTE: This does not match php5 xdebug.
NOTE: This function may refer to non-public symbols, which may lead to problems, if you ever try to inline this function.
NOTE: This is for migrating the old object literal syntax.
NOTE: Unlike other bits of the metadata that should later be removed, this one is important because things check this value's flags to determine what kind of object it is.
NOTE: Using Filename.data() here relies on SourceMgr using const char* as buffer identifiers.
NOTE: We do not expect to have too many levels of nesting, so recursion should be fine.
NOTE: We only allow single-quote string literals so we can emit useful diagnostics about changing them to double quotes.
NOTE: before 7.17.0 strings were not copied.
NOTE: below you can see that between all the event handlers we listen for, "SLOT(setupFrame())" is connected to 2 signals: 1.
NOTE: called from FastCGIAcceptor::onConnectionsDrained()
NOTE: clang also does check for shared instances.
NOTE: currently they can't modify anything other than the bytecode/Blocks, because other threads may be doing unlocked queries to php::Func and php::Class structures.
NOTE: depth is always 0 for ObjC generic type arguments, since only classes may have generic types in ObjC, and ObjC classes cannot be nested.
NOTE: do not use primary file NOTE: do not use files
NOTE: if you change the layout of this type, you'll also need to update tuple_getValueWitnesses().
NOTE: if you change this, change Type::usesNativeReferenceCounting.
NOTE: if you change this, change irgen::getReferenceCountingForClass.
NOTE: legacy punctuator.
NOTE: name, hoistable, and a few other fields currently serialized outside of this.
NOTE: name, top, and a few other fields currently serialized outside of this.
NOTE: no check on duplication because we assume the original array has no duplication
NOTE: no need to lock with light processes.
NOTE: on windows gethostbyname is "thread safe" the hostent is allocated once per thread by winsock2 and cleaned up by winsock when the thread ends
NOTE: pad_char may be set to '0' because of the 0 flag.
NOTE: performSema() may end up with some gruesome error preventing it from setting primary file correctly
NOTE: simplifyCheckedCastConstraint() may return Unsolved, e.g. if the subexpression's type is unresolved.
NOTE: the purposes are added as integer keys - the keys match up to the X509_PURPOSE_SSL_XXX defines in x509v3.h
NOTE: this also allows us to NOT modify the results of an analysis pass.
NOTE: this is a conservative approximation, because some releases may be blocked before it reaches this block.
NOTE: this is a conservative approximation, because some retains may be blocked before it reaches this block.
NOTE: this is to detect the old object literal syntax.
NOTE: we do not perform the RLE right here because doing so could introduce new LSLocations.
NOTE: we never pool copied curl handles, because all spots in the pool are pre-populated
NOTE: when ignore_cert_expiration is true, a custom certificate validation callback is set up.
NSError (TODO: and CFError) can be bridged.
NSError or CFError references can be adopted directly as ErrorProtocol existentials.
NSManaged properties on classes require special handling.
NSString * must be bridged to String.
NSUInteger might be imported as Int rather than UInt depending on where the import lives.
NSZone parameters default to 'nil'.
NS_OPTIONS members that have a value of 0 (typically named "None") do not operate as a set-like member.
NUL terminate, as every buffer is handled here.
NUL-terminated: Scan for length and supplementary characters
NULL *IS* the value, without we get undefined warnings
NULL has a special meaning for each field
NULL is automatically added
NULL will be returned if no document matches.
NULL-terminate modifications
NULL-terminate the argument array.
NULL-terminate values
NVTs live inside VarEnv, and GlobalsArray has an interior ptr to one.
Name is something like: add_Int64
Name is something like: trunc_Int64_Int8
Name lookup was ambiguous.
Name lookup will disambiguate.
Name not null and name differs with new name
NamedEntity* np.second
Names of integer types.
Namespace logic is separate and only when uri passed in to insure no BC breakage
Namespace resolution specially recognizes "self" and "parent" and doesn't prepend a prefix, we don't have to worry about stripping prefixes.
Native Swift class metadata is also the class object.
Native Swift function types bridge to block types.
Native Swift super calls to final methods are direct.
Native accessor properties of mysqli.
Native accessor properties of mysqli_result.
Native calls end inlining before CallBuiltin
Native func prologue.
Native function-local declarations have shared linkage.
Native functions don't need bridging.
Native ppc64 instructions can't handle an immediate bigger than 16 bits and need to be loaded into a register in order to be used.
Native prop handlers never kick in for declared properties, even if they're unset.
Native unowned references are just a pointer.
NativeData definitions
NativeData is sizeof(NativeData) (NativeDataInfo.sz) bytes for the custom struct.
NativeData types might leak these
NativeNode is a link in the NativeData sweep list for this ND block
Naturally we would be emitting them as DW_TAG_reference_type types, but LLDB can deal better with pointer-sized struct that has the appropriate mangled name.
Nav the tree evey time as this is LIVE
Nearly all callers of setValue() for stack slots represent a modification of the stack, so it sets stackModified.
Need a 'self' argument otherwise this is not a semantic call that we recognize.
Need a conditional branch that guards the entry into the loop.
Need some type of error here
Need the previous frame in order to get the call line.
Need this to prevent "bad pass by reference" errors.
Need to add element number to name
Need to add maybeRef to the `store' set.
Need to be wary of old-style ctors.
Need to bitcast to an integer in order to use 'icmp eq' if the piece isn't already an int or pointer, or in order to apply a mask.
Need to check if extendedTy is ErrorType
Need to coerce to integer for 'icmp eq' if it's not already an integer or pointer.
Need to ensure we don't delete breakpoints on the same line
Need to grab the breakpoint to send back the breakpoint info
Need to have a matching 'f'.
Need to have a parent try for opts so I can use opts in the catch of one of the sub-tries below.
Need to have a valid installation of the transliteration data in /lib64.
Need to let pgm process this and the following args
Need to make sure keys and values are all uncounted.
Need to normalize of this commands succeeds
Need to normalize to Windows directory separators, as the underlying system calls don't like unix path separators.
Need to raise a warning
Need to raise an error
Need to recheck now we have the lock
Need to reverse the backtrace to match php5 xdebug.
Need to store the direct results to the original indirect address.
Need to strip slashes before adding option
Need to turn on debugging regardless of the remote mode in order to capture exceptions/errors.
Needed because folly::symbolizer assumes it can find files via /proc/self/maps, but that's not true when we remap the text section with huge pages.
Needed if it's a public base method declared in another compilation unit (for this we have no SILFunction).
Needed so that the new elements are accounted for when GC scanning.
Needed to handle closures which are no longer applied, but are left behind as dead code.
Needle doesn't occur, shortcircuit the actual replacement.
Needs a special argument.
Needs to be a sorted map so we can divide funcs into contiguous sections.
Needs to be at least 3 chars for private/protected properties.
Needs to be under the lock, because multiple threads could call destroy, or want to manipulate the class list.
Needs to have a known semantics.
Needs to modify locals after doing effectful operations like converting things to strings, so we can't guard on their types.
Negative means first character is start'th code point from end.
Negative means omit last abs(length) code points.
Negative offset counts from the end of the string.
Negative offset to the CIE, relative to this field.
Negative phoneme length is meaningless
Neither GCC nor Clang record a name for a variable which is a static definition, so ignore any that do have a name.
Neither loop contains the other.
Neither the name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
Neither the name of the author nor the names of other contributors may be used to endorse or promote products derived from this software without specific prior written permission.
Neither they are in "could be" relationships.
Nested type declarations can be accessed only with unqualified lookup or on metatypes.
Nesting is set to the current VM nesting.
Netscape Bug: Messenger sometimes omits the semi when wrapping the the header.
Never 'use namespace swift::sma'.
Never add materializeForSet to readonly declarations.
Never change refcount of 0 to refcount of 1, impossible to revive a dying SharedStringData.
Never consider removing the first argument for a "set" method with an unnamed first argument.
Never do a +0 load together with a take.
Never do this if it's the first parameter of a constructor.
Never generate layout for countable types.
Never inline, to ensure that the alloca of the pattern buffer is always safe.
Never perform local lookup for operators.
Never print anything for stored properties.
Never walk into statements.
Nevertheless, you likely need to adjust Server.RequestTimeoutSeconds to get a full request processed.
New Rule: never repair potential malicious user input
New and include/require
New block is reachable from old block so link it.
New instructions were generated.
New item or continuous
New minstrs are handled extremely conservatively.
New prop, go ahead and add it
New sprintf implementation for PHP.
New substitution for this callee.
New version of subfile tag
NewInst can grow as this iterates, so we can't use a foreach loop.
NewStructArray is reading elements from the stack, but writes to a completely new array, so we can treat the store set as empty.
Newline before label will be subtracted from returned text, but raw text will include it, for zend_highlight/strip, tokenizer, etc.
Next block in dominator tree.
Next character to consider is at the end of the fixit.
Next check if we are the target of a default switch_enum case.
Next command is active and we stepped in.
Next command is active but we didn't step in.
Next command is active, but it is done.
Next command is not active, just break.
Next command not active, break
Next go over all instructions after I in the basic block.
Next is set to an invalid block that will be fixed up once we're done iterating through the original block.
Next opcode is unreachable on this path.
Next priority is favored constraints.
Next read in the generic requirements, if any.
Next step is to display the completion list.
Next step: delete all dead functions.
Next time start relexing from the beginning of the comment so that we can attach it to the token.
Next token is a comment, which counts as whitespace.
Next token should be the attribute name.
Next try calling user-level `__get` if it's used.
Next we have the really interesting routines: selection of a colormap given the completed histogram.
Next we need to add in any arguments that are not captured as arguments to the cloned function.
Next, add the Phi values and promote all of the loads and stores into the new locations.
Next, add the fields for the given class.
Next, call the failure callback for 'type' if we didn't do so above
Next, callee main blocks are processed to transform frame relative access into stack relative access and adjust certain instructions to use the parent frame.
Next, do a pass with a couple of optimizations: 1) release() motion, eliminating retain/release pairs when it turns out that a pair is not protecting anything that accesses the guarded heap object.
Next, initialize s_instanceBitsMap with the top 127 most checked classes.
Next, open any new protected regions that start at this offset.
Next, remove the copy_addr itself.
Next, see if include path was set in the ini settings.
Next, sort by full description text.
Next, the color-selection step begins with a box representing the whole color space, and repeatedly splits the "largest" remaining box until we have as many boxes as desired colors.
Next, the generic signature.
Next, the partial apply args.
Next, try consulting the 'type' map.
Next, we're going to regenerate each prologue along with its DV funclet.
Next, write the protocol witness tables.
Next: Base is an object.
Next: LdCns hit in TC
Next: Property isn't Uninit.
Next: ask escape analysis.
Next: property or global exists
Next: src is an object
Next: the static local is already initialized
Next: the wait handle is not finished, we need to suspend
Next: tvRef is Uninit.
NextToken is the soon to be previous token Therefore: x.0.1 is sub-tuple access, not x.float_literal
Nice for thumbnails but there's no support for fussy adjustment of the assumed properties of inks and paper.
Nice interface, but slow.
Nishimura, "Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator", ACM Transactions on Modeling and Computer Simulation, Vol.
No "real" compiler mode has to go through this path, but it's an option we toggle for testing.
No "visit" since TypeLocs are not a class hierarchy.
No Array object to delete.
No E box is used, as it's replaced by some ANDs, shifts, and ORs.
No URL provided: delete ALL the cookies in the CookieJar
No `ini` binding yet.
No action is needed here.
No action required if the function returns 'Void' or that the function is marked 'noreturn'.
No actual getter or setter, pass 'pseudo' accessors.
No additional bridging needed for native functions.
No additional target locator information.
No adjustment required.
No arc use to the beginning of this block.
No assignment from LRUCache::ConstAccessor since it is non-copyable Use resetToLRU instead
No attempt was made to determine the language in which files of this type were written.
No bb args should be passed
No behavior, no problems.
No bridging needed for native CCs.
No bridging needed for native functions.
No builtin to disable
No bytecode control flow in exits.
No cached results found.
No callee means we're resuming in the middle of a TC function.
No cast is required if types are the same.
No change to src necessary.
No change to the argument.
No children of this tuple, make an empty tuple
No closure signature.
No cls field in Resource
No coercion or cast for Variants.
No connections at all yet
No context for arg, so make assupmtion based on value
No conversion needed.
No conversion: re-use the original parameter info.
No conversion: re-use the original result info.
No cookie name provided: delete all the cookies visible by this URL
No copyright info was found in the original bdf.
No copyright is claimed, and the software is hereby placed in the public domain.
No data before the label means we just go right to ST_END_HEREDOC without forming a new token.
No data is always more general.
No debug info is emitted for refcounts.
No debug messages are output if it is set to NULL.
No deprecation filter on watchOS
No digits have been scanned.
No direct matches in our internal maps, so we need to retrieve it from the type parser.
No dispatch necessary.
No explicit __construct
No explicit name and no linkage name to use, so we have to try to infer one ourself.
No explicitly defined function, no __call() magic method Give up.
No extra indentation level for getters without explicit names.
No global variable is needed.
No handlers were yet examined for this fault.
No hidden escapes: check if the Node is reachable from the UsePoint.
No hit value means the breakpoint is always hit
No idea which type of event it needs, ask for everything
No idea why, but zend does this..
No implicit arguments.
No instruction can "kill" flags, since flags are SSA variables.
No instructions in the middle of a block should have taken edges, or be an unconditional Jmp.
No integer keys so nothing to do.
No interesting let properties in this struct.
No jump-threading is possible in this case.
No label found, consume this character.
No mangled parameters means we have exactly one.
No matter what error path we take, make sure the PatternBindingDecl/TopLevel code block are added.
No more client operation is possible, so drop the connection.
No more responses coming from worker threads
No multi-threading: the compilation only produces a single output file.
No need for BC HHVM-style whitelist check, since the check isn't enabled.
No need for a separate node for the load instruction: just reuse the content node.
No need to actually create the refinement context if we know it is useless.
No need to add storage for zero-size fields (e.g. incomplete array decls).
No need to add storage for zero-width bitfields.
No need to apply this to existentials.
No need to check further.
No need to check if there is a dynamic property with this name.
No need to check nParams.
No need to check this for structs, as they do not have any superclasses.
No need to coerce when passed a null for a nullable type
No need to continue scanning after deallocation.
No need to do anything, it was freed from the persistent_list
No need to eagerly emit Swift metadata for external types.
No need to flush a file descriptor.
No need to generate any global symbols for entries that do not provide their own symbols.
No need to inc-ref here because we're a newly created object and our ref-count starts at 1.
No need to introduce a context if the declaration does not have an availability attribute.
No need to keep going.
No need to keep track of the clang module dependencies.
No need to loop over the elements, we're done
No need to perform special logic for "ReturnAllTokens", we already accounted for that when the tokens were inserted into m_lookahead
No need to propagate anything into the callee operand.
No need to recheck permissions, since we already checked them first time around.
No need to report symbols.
No need to run Prop destructors.
No need to setLocalDiscriminator because subscripts cannot validly appear outside of type decls.
No need to setLocalDiscriminator.
No need to setLocalDiscriminator: protocols can't appear in local contexts.
No need to store specific arrays in this case.
No need to to retrieve source line information for this kind of site.
No need to worry about races, this all happens during pre-main initialization
No new arguments are created.
No new instructions were generated.
No opcodes have more than four immediates
No optimization was possible.
No options require a module, so don't generate one.
No origPCs have more than four immediates
No other expression kinds are permitted.
No other kind for now.
No other transforms necessary.
No other types are permitted.
No other types have superclasses.
No other types include throwing functions for now.
No output filename was specified, or an output directory was specified.
No parallelism, verify all declarations.
No parameter passed, this means we should autodetect
No phi for this value in this block means that the value flowing out of the immediate dominator reaches here.
No platform allows an action signature with more than two arguments.
No point in continuing with this one if we already have a LayoutError.
No point in hoisting generic code.
No received events means the next-to-wake sleeper timed us out.
No room for more colors
No self, must be static
No signs or inner parentheses are allowed here.
No simplification happened.
No size was provided.
No slash found, therefore return '.'
No special treatment needed
No split DWARF on Darwin.
No splits found, can't produce this diagnostic.
No store besides the initialization of a "let"-variable can have any effect on the value of this "let" variable.
No support for switch, etc, right now.
No tag bits, there's only one payload.
No tag, nothing to do.
No transformation is applied to the name.
No translations, nothing to do.
No two interfaces implemented by the same class will share the same vtable slot.
No type specified, treat it as a string
No url provided: return all the cookies in this CookieJar
No use of Eval in our ini strings
No user code after this point.
No visible/accessible property, and no applicable magic method: create a new dynamic property.
No warning is given here, just return null
No warning takes precedence over nullsafe.
No witness for typealiases.
No witness necessary for type aliases
No witness table for AnyObject
No written agreement, license, or royalty fee is required for any of the authorized uses.
No zero digits have been scanned.
No, so try to allocate it
No-escaping stored declarations are captured as the address of the value.
No-op on bool, array, resource, object.
No-op we are supposed to ignore the keys that we don't understand.
No-payload cases are represented with the remaining payload tags.
No-payload elements do not affect address-only-ness.
No-payload enums are always POD, so we can always initialize by primitive copy.
No-payload enums are always fixed-size so never need dynamic value witness table initialization.
No-payload enums have all values above their greatest discriminator value that fit inside their storage size available as extra inhabitants.
NoEscape - The destructor potentially has some side effects, but the / address of the destroyed object never escapes (in the LLVM IR sense).
NoSideEffects - The destructor does nothing, or just touches the local / object in a non-observable way after it is destroyed.
Node weights are not required to be accurate and, since arc weights are derived from nodes' weights, they aren't accurate either.
NodeScope - almost a POD, but needs to call the constructors for the scoped hash tables so that a new scope gets pushed on.
Nodes in the RC flowgraphs.
Nodes that form the root of lvalue paths
Nodes that make up components of lvalue paths
Nominal Type Descriptor Emission
Nominal kinds are always sorted before non-nominal kinds.
Nominal steps between cell centers ("x" in Thomas article)
Nominal types add no generic arguments themselves, but they may have the arguments of their parents.
Nominal types are always preserved through SIL lowering.
Nominal types might have parents.
Non elem/prop/W part of M-vector
Non mutating array calls are safe.
Non-'derived' flags (thisHas) about magic methods imply the derived ones.
Non-C99 systems may or may not.
Non-Darwin platforms don't use the Objective-C runtime, so they can not import Objective-C modules.
Non-ObjC existentials don't have a single-refcounted-pointer representation.
Non-Objective-C declarations in extensions cannot override or be overridden.
Non-async generators always return Generator object.
Non-atomic reference counting tests // /
Non-bind config options and edge-cases
Non-class existentials consist of a three-word buffer and value metadata, followed by witness tables.
Non-class heap objects should be pure Swift, so we can access their isas directly.
Non-closure parameters require a type.
Non-copy_addr uses of the inout should only occur in canonical SIL, so fail the analysis if we see one.
Non-decl entry points are never natively foreign, so they would never have a foreign-to-native thunk.
Non-dependent types in a same-type requirement don't affect whether we mangle the requirement.
Non-escaping lvalues are captured as the address of the value.
Non-escaping stored decls are captured as the address of the value.
Non-existent property.
Non-external global variables are definitions by default.
Non-function witnesses all have type size_t.
Non-generic extension.
Non-generic structs, enums, and classes are special cases.
Non-lvalue types (references, values, metatypes, etc) form the root of a logical l-value.
Non-materializable input and materializable output occurs when witness method thunks re-abstract a non-mutating witness for a mutating requirement.
Non-materializable tuple types cannot be bound as generic arguments, so none of the remaining transformations apply.
Non-member observing properties need an initializer.
Non-metaclasses need us to record things whether primitive construction/destructor is trivial.
Non-native types are just wrapped in various ways.
Non-nominal metadata (e.g. for builtins) is provided by the runtime and doesn't need lazy instantiation.
Non-null if the entry represents a struct or class field.
Non-null if the entry represents an array value, a tuple with an array / or an AllocStack of an array.
Non-nullable pointers can't be zero-initialized.
Non-obvious off-by-one fun: if the *return address* points into the TC, then the frame we were running on in the TC is actually the previous frame.
Non-optional conversions are better than optional-to-optional conversions.
Non-optional to non-optional.
Non-optional to optional.
Non-payload cases project to an empty explosion.
Non-payload cases use extra inhabitants, if any, or are discriminated by setting the tag bits.
Non-pointer and nativeArg args, are passed by value.
Non-polymorphic types.
Non-repo mode unit caching
Non-required constructors may not be not inherited.
Non-scalar constant initializers require 86cinit() for run-time initialization support.
Non-scalar property initializers require 86pinit() for run-time initialization support.
Non-scalar property initializers require 86sinit() for run-time initialization support.
Non-scalar, so we have to output PHP from the AST node
Non-semantic patterns.
Non-simple names are also stored under their simple name, so make sure to only report them once.
Non-standard and thus disable for the time being.
Non-static methods are instance members.
Non-static set/willSet/didSet/materializeForSet/mutableAddress default to mutating.
Non-static variables are instance members.
Non-stored properties are fine.
Non-subscript decls don't match.
Non-trivial C++ types would be Indirect_Inout (at least in Itanium).
Non-trivial and not loadable.
Non-truecolor case, restored to its more or less original form
Non-tuples don't need to be imploded.
Non-typealias type declarations are okay.
Non-variadic arguments may follow the variadic one.
Non-void values get registered in the value table.
Non-wildcard patterns.
Non-zero on any differences
NonPackedArrayProfile data counts how many times a non-packed array was observed.
None of the above worked, so try to make the smallest union we can based on the pointer type.
None of the candidates were viable.
None of the children had solutions, enumerate supertypes and try again.
None of the operations we do here can fail, so we can atomically disable the tuple's cleanup and then create cleanups for all the elements.
None of the rest of these require deallocation.
None of the sanitizers work on Linux right now.
None of the transformations done by getTypeOfRValue are necessary for subscripts.
None of the users capture the AllocStack.
None of these kinds should be encountered because they're either not interesting to begin with, or are mapped to different headers, so we shouldn't get these from the pointer map.
None of these should have native-data, because if they do, the mapped header should be for the NativeData prefix.
None of these tests should use any data.
None of these types have sugar at the outer level.
Nonetheless, NRVO is a simple pattern that can be detected using a / different technique from propagation.
Nonmutating methods on structs and enums pass the receiver by value.
Nontrivial kind /and/ type unions would imply equal kinds and types.
Nontrivial ones can though, because the overwritten value drops a retain.
Nonzero means print parse trace.
Nope, just whine to the user and let it through
Nor does a stub implementation.
Nor does casting to a more optional type.
Normal ("hhbc-semantics") operations on php values in memory all preserve balanced reference counts (i.e. a pointer in memory corresponds to one value in the count field of the pointee).
Normal DV funclets don't have type guards, and thus have a single translation.
Normal HHVM extensions have the luxury of only when such a thing will be attempted, but we have no way to know in advance.
Normal accessibility attribute.
Normal case, where the base is an object (and not a pointer to something)---just do a lea with the type information we got from static analysis.
Normal cases should continue, KindDone returns
Normal form variable, safe to read all data into memory
Normal function references.
Normal lets (e.g. globals) are only mutable in the context of the declaration.
Normal method calls are curried, so they are: (call_expr (dot_syntax_call_expr (decl_ref_expr METHOD)))
Normal nodes that we just keep
Normal token character.
Normalize a unicode string depending on its type.
Normalize incoming arc weights and compute avgCallOffset for each node.
Normalize incoming arc weights for each node.
Normalize the event "type" to lowercase
Normalized weights of neighboring pixels
Normally putting a public member in an internal extension is harmless, because that member can never be used elsewhere.
Normally this means that we'll just insert the epilogue in the current block, but if the current IP is unreachable then so is the entire epilogue.
Normally to forward declare these, we would have to forward declare a lot of other types, but we employ a dirty trick to avoid this.
Normally we don't care about variables since we're only looking for types.
Normally we wouldn't need an explicit copy/move-constructors, or copy/move-assignment operators, but we have to make sure m_key isn't copied.
Normally we'd just use the consumption of the source because the difference between TakeOnSuccess and TakeAlways doesn't matter for irrefutable rows.
Normally, an argument list is a TupleExpr or a ParenExpr, though sometimes the ParenExpr goes missing.
Normally, for a given block of memory, the layout will be applied contiguously until the entire block is processed.
Normally, this is just the Class*s that might not be hoistable.
Not a collection, just emit the code given by the callable.
Not a constructor call.
Not a decl or type attribute.
Not a formal parameter.
Not a known platform.
Not a mangled name Copy the result to an output buffer.
Not a pattern we recognize, conservatively generate a generic diagnostic.
Not a protocol conformance.
Not a shared library.
Not a typo: Zend defines OFFSET as ONSET
Not a union type and not a special case: 1 register.
Not a valid start character
Not a well-formed placeholder.
Not all commands are here, as not all commands need to be sent over wire.
Not all git versions we use know --show-toplevel, if it was just echoed back (this version doesn't know it), fall back to another method
Not all protocols use witness tables.
Not at the end - add a separator
Not available on windows, the query is possible but there is no DNS_HINFO_DATA structure
Not clear that being smart is worth any trouble anyway --- large skips are infrequent.
Not default initializable.
Not directly calling argsv.toFollyDynamic() as that creates a folly dynamic object, not list
Not done by PHP5/7, but using SSL nowadays is a very bad idea.
Not enough for block, just pass into buffer
Not enough room in dst, add NUL and traverse rest of src
Not enough room in the buffer - grow it.
Not exposed in header files.
Not found - try it as a special keyword.
Not found within a type.
Not fully covered switches will be diagnosed later.
Not ideal but better than weird space alignment.
Not imported as an initializer.
Not in a context being exited.
Not in a method context.
Not in any loop identified by loop info.
Not inserted, caller needs to own the pointer
Not interested in going outside a basic expression.
Not interested in these instructions yet.
Not likely to be a match if users provide more arguments than expected.
Not localhost or empty host
Not missing because filtered out, assume the value is too large.
Not necessarily /   an appropriate caching key.
Not necessary for some builtin calls, but it depends which builtin...
Not needed for mangling.
Not needed for the moment
Not nothrow even if both are strings: can throw for strings that are too large.
Not overlapping, just add the new token to the end
Not possible: no this.
Not reachable since HHVM_FN(pow) deals with these base cases first.
Not really essential, but these routines were used extensively in GD, so they were moved here.
Not really sugar, but the actual diagnostic text is fine.
Not really thread-safe, but in practice this happens at process startup before any threads are spun up.
Not recursion, just cut short of print
Not supported at all.
Not supported except in __Native functions
Not supported yet (not easily computable for APInt).
Not supporting local_infile yet.
Not sure if there's a better one, though.
Not sure if this is correct (never seen float used in Exif format)
Not sure if we should pop here.
Not that FunctionRefInsts may be shared by multiple ApplyInsts.
Not the best thing, but in practice it should be good-enough
Not too pretty, but it works.
Not worth presizing or otherwise optimizing for.
Not yet handling nested archetypes.
Note - in some partial liveness cases, we can push the destroy_addr up the CFG, instead of immediately generating dynamic control flow checks.
Note / that this only applies to irrefutable patterns.
Note HHProf::HandlePProfSymbol() dependency.
Note about nested array types in the builder:  The serialization we use for the ArrayTypeTable doesn't currently allow the possibility of recursive array types.
Note also that the closure function still has a valid DW_AT_decl_line.
Note also that we might be in a situation where one of the STags is representing a union of more primitive STags.
Note carefully: we're emitting a warning in the /Clang/ buffer.
Note here that a string type stays a string (with a changed character, and loss of staticness), unless it was the empty string, where it becomes an array.
Note however, that this is a *pointer* to a scanner, as it will be allocated by this call (and is the reason, too, why this function also must handle its own declaration).
Note however, the slab allocator adds to m_stats.jemallocDebt when it calls malloc(), so that this function can avoid double-counting the malloced memory.
Note if shutting the VM down took non-zero time it's possible that the alarm will fire first and kill this process.
Note is a letter is a 'break' in the word
Note it won't have any source info in it, because this event is raised with no PHP on the stack.
Note it's not necessary to check whether the test class is defined: if it doesn't exist than the candidate can't be an instance of it and will fail this check.
Note resolve_phis can add blocks, which can cause a resize of env.blockInfo---don't reuse pointers/references to any block state structures across here.
Note serialize can only run user-defined code if its argument is an object, which will never be a constant type, so this is safe.
Note slight error in 16-bit case:  up to 256 16-bit shades may get mapped to a single 8-bit shade, and only one of them is supposed to be transparent.
Note synthesized protocols
Note that "array" and "callable" are disallowed by the grammar, so they never reach here.
Note that "continue" is not valid out of a labeled 'if'.
Note that 'self' has been fully initialized at this point.
Note that APCLocalArray can never return KindOfRefs.
Note that Adar II is assigned the month number 7 and Elul is always 13.
Note that ArrayUserSet does not included uses of elements within the Array.
Note that AttrStatic on a closure's __invoke Func* means it is a static closure---but the call to __invoke still works as if it were a non-static method call---so they are excluded from that here.
Note that DestUserInsts is likely empty when the dest is an 'out' argument, allowing us to go straight to backward propagation.
Note that File + Dir need not result in a valid path.
Note that MSVC's rand is actually thread-safe to begin with so no changes are actually needed to make it so.
Note that a classname does not have to exist as the user can specify method bar on class Foo with "Foo::bar"
Note that access of undefined class constants can cause the eval() to fatal.
Note that accesses to this set are not synchronized, so it must not be modified after module initialization.
Note that an ObjC class subclassing from a Swift class, may still be able to override its non-computed-property-accessors via a method.
Note that an explicit 'infix' is not required.
Note that an implicit getter may not have the body synthesized in case the owning PatternBindingDecl is invalid.
Note that both function arguments must be identified.
Note that confusingly there are two different implementations of zend_strtod.
Note that convenience factories return instancetype and can be inherited.
Note that conversions to and from block require a thunk
Note that doing this tends to strand the false code after everything else in the function, so maybe it's not a great idea.
Note that due to protocol extensions, GenericRequirements may be non-empty while GenericParams is empty.
Note that escape analysis must work with the original pointers and not the underlying objects because it treats projections differently.
Note that failureInfo is already set correctly for that case.
Note that fields of the class could be tuples, so they may be tracked as independent elements.
Note that for String before you return to PHP you need to copy it into HPHP::String.
Note that for metaclass stubs, we can always ignore parent contexts and generic arguments.
Note that frame_free_locals expects to be able to free return_value in the event of an exception, so we have to take it out of our Variant /before/ calling that.
Note that if D is a global in script mode (which are not lazy) then we will already have returned a diagnosis above.
Note that if `key' actually is an integer-ish string, we'd fail this check (and most likely would have failed the previous check also), but this false negative is allowed.
Note that if any class derives from a class and adds magic methods, it can change still change dispatch to call that method instead of fatalling.
Note that if elements are added or removed from the array, the value of the array's canonical invalid position may change.
Note that if intercept skips the callee, it tears down its frame but guarantees that m_savedRip remains valid, so this is safe (and is the only way to get the return address).
Note that if the first createInstance fails, the status will cause the second createInstance to also fail.
Note that if the receiver is 'super' that does not mean that the call is statically determined (an extension method may have injected itself in the super hierarchy).
Note that if the same VarEnv is used across multiple frames, the most recent FP must be used.
Note that in practice we only expect there to be one file, but this is general and is what the diagnostic file expects.
Note that in some cases reusing the return value can be (very slightly) worse.
Note that in that book's description of DES the lookups for the initial, pbox, and final permutations are inverted (this has been brought to the attention of the author).
Note that in this case, we do not want to propagate the 'throws' bit to the closure type, as the closure has already been analyzed for throwing subexpressions.
Note that it doesn't count the space for itself.
Note that it is always safe to read one over the end of "Bytes" because we know that there is a terminating " character.
Note that it is illegal for the driver to take a reference to param, as it resides in transient storage only at this time.
Note that it is ok to have a purpose without a convertType (which is used for call return types).
Note that it is okay for there to be a race involving a weak release* which happens after the strong reference count drops to 0.
Note that it never hurts to merge more types than a thisProp could actually be, so this is fine.
Note that it's still possible for the race condition to happen if we are creating and starting threads statically before main() starts.
Note that libclang does the same thing.
Note that loads do not kill a location.
Note that main code may be generated in the cold code range (see emitBlock in code-gen-x64 genCodeImpl()) so we need to explicitly check the aStart value.
Note that name_len is actually the length plus one, so that it can be conveniently derived from sizeof().
Note that on 80x86 machines, the pointer row is in near memory but the actual arrays are in far memory (same arrangement as we use for image arrays).
Note that only the magic values have 1s in the low 3 bits since StringData's are at least 8-aligned.
Note that order is important here, we process calls from most to least nested so that we can expose as many such opportunities as possible.
Note that ordering is maintained of retains within this BB.
Note that ordinary metatypes of / existential types are still singleton.
Note that outside functions must be visited before nested functions for type-checking to work correctly.
Note that partial_apply instructions always close over their argument.
Note that semantic components will generally preserve the syntactic order of their children because doing something else could illegally change order of evaluation.
Note that since this function is supposed to return all _declared_ variables in scope, which includes variables that have been unset.
Note that since we don't know the lifetime of the returned node all added breakpoint info is duplicated.
Note that some of these stack slots overlap with the frame locals of the callee-- those slots are inacessible in the inlined call as frame and stack locations may not alias.
Note that specifically require a class or class-constrained archetype here, because archetypes cannot be bridged.
Note that such modules may be heterogeneous.
Note that the 'entryArDelta' parameter specifies the delta between sp at the beginning of the tracelet and ar.
Note that the / original value may not belong to the same function as the one being cloned / by cloneBlocks() (they may be from the partial apply caller).
Note that the ConcatFoo opcode consumed the reference on its first argument, so we only need to decref the second one.
Note that the IncRef must happen first, for correctness in a pseudo-main: the destructor could decref the value again after we've stored it into the local.
Note that the Pred iterator may be invalidated (because we may add edges in the loop).
Note that the canonical mangling signature will sometimes use different dependent type from Generics, apparently for no good reason.
Note that the constructor leaves this uninitialized.
Note that the current accepted value for the tropical year is 365.242199 days, not 365.25.
Note that the current pre_header jump may have arguments.
Note that the decl was imported from Clang.
Note that the derived class' sweep() is responsible for closing m_fd and any other non-request resources it might have allocated.
Note that the destructor may not be in any particular canonical form.
Note that the empty tuple type is assignable but usually isn't an l-value, so we have to be conservative there.
Note that the foreign error convention affects the selector, so we perform this before inferring a selector.
Note that the function also may not contain any retains.
Note that the function has a dynamic Self return type and set the return type component to the dynamic self type.
Note that the header fields are all pointer-sized.
Note that the instructions with popConds are relying on the consumer of the values they push to check whether lifetime changes can have side-effects.
Note that the label here is unimportant, so we choose something descriptive to make the IR readable.
Note that the length can span multiple lines.
Note that the new decls may be ambiguous with respect to each other, just not any existing decls.
Note that the new value is already considered to be retained (by the semantics of the storage type), and we're transferring that ownership count into the destination.
Note that the number of predecessors of both types (backedge or normal) on a Phi node in last or pred is conserved under this operation.
Note that the parameter and result must also have type i8*.
Note that the semantic pass also includes parser diagnostics so this avoids duplicates.
Note that the source file is fully parsed and verify it.
Note that the stack is aligned since we called to this helper from an stack-unaligned stub.
Note that there are some "wasted" slots where locals/iterators would be in the vector right now.
Note that there are substantial restrictions on the use of suspension --- see the documentation.
Note that these are in parallel with 'prefixes', below.
Note that these includes are shared between PHP and HHVM
Note that these instructions make stores to a pre-live actrec on the eval stack.
Note that these stream callbacks may re-enter the VM via a user-defined stream wrapper.
Note that this InlineReturn counts as a weak use, but we haven't incremented for it yet, which is where the "+ 1" comes from below.
Note that this also begins the formal accesses in evaluation order.
Note that this can invalidate the Uses vector and delete the instruction.
Note that this can't affect self props, because static properties can never be unset.
Note that this cannot be the start of a new line.
Note that this check has to happen before the call to truncateLiterals() because that updates the region but not the IR unit.
Note that this does not currently encode anything for interface methods.
Note that this does not include the first operand (the condition).
Note that this effectively ignores a
Note that this equivalence relation does /not/ capture the idea that we probably want the same register for x4 as we do for x6 and x7.
Note that this file has had moderate changes to make it compile as C++, and under MSVC.
Note that this function could be called concurrently.
Note that this handles the case in initializers where there is actually a stack allocation for it as well.
Note that this has no support for resolving generic types yet.
Note that this index / clause is actually the outermost (first-indexed) clause.
Note that this is a blacklist rather than a whitelist.
Note that this is a special case of a more general race we have in this unit merging code right now.
Note that this is a stub implementation.
Note that this is an initializer.
Note that this is expected to be sorted in / quasi-lexicographic order.
Note that this is not just an optimization - the update below would produce the wrong results.
Note that this is only a simplified model and not correct in all cases.
Note that this is suppressed for certain accessibility declarations, which are imported as getter/setter pairs and not properties.
Note that this is the primary source of false negative for this diagnostic.
Note that this is the reverse of what we do in pre-checking.
Note that this map serves a different purpose than the AnnotType map in "runtime/base/annot-type.cpp".
Note that this may be an under estimate because there are 6939.6896 days in a metonic cycle not 6940, but it will never be an over estimate.
Note that this method is not used for all decl kinds.
Note that this node is part of this component, then visit it.
Note that this should not use a for-each loop, as the Uses list can grow and reallocate as we iterate over it.
Note that this typedef-name is special.
Note that this will implicitly unique if the .unique name is also taken.
Note that unlike the above we're going to assign location ids to the individual stack slots in AStack portions of AliasClasses that are unions of AStack ranges with other classes.
Note that unserialize can run arbitrary php code via a __wakeup routine, which could try to access this same key, and we're holding various locks here.
Note that version 1 is the same format as version 0, so old receivers will not break when receiving a version 1 message.
Note that we / only want to report the first statement on the unreachable path.
Note that we are checking this conformance now.
Note that we arrange blocks so that we fall through into this.
Note that we assume that this projection is safe for the particular case of an optional class-reference or metatype value.
Note that we bury the inout locator within the named locator.
Note that we can only get this case if there is a same-named (private or not) function deeper in the class hierarchy.
Note that we can't actually compute the type here until Sema.
Note that we can't assert the type if this isn't the only predecessor, but also, it's currently not the case that it would ever be useful to do so.
Note that we can't just call m_expMap.erase(intptr_t(vpkey)) here.
Note that we cannot get a value of inout type as an lvalue though.
Note that we cannot use the BASE64 alphabet here, because it contains "/" and "+": both are unacceptable for simple inclusion into URLs.
Note that we check the module name to smooth over the difference between an imported Objective-C module and its overlay.
Note that we could do this in a later SILDiagnostics pass as well: this would be stronger (more equivalences exposed) but would have worse source location information.
Note that we diagnose this here instead of letting diagnoseGeneralMemberFailure handle it, because it doesn't know how to handle lookup into a contextual type for an URME.
Note that we do *not* apply substitutions from a bound generic instance yet.
Note that we do not currently use thin representations in the AST for the types of function decls.
Note that we do this after the accessors are set up, because we don't want the setter for the lazy property to inherit these properties from the storage.
Note that we don't have to add operators that are already in the top-level list.
Note that we don't have to ask IRGen about element 0 because we know its size is zero.
Note that we don't need to sync the return registers to memory.
Note that we don't push break/continue locations since they aren't valid in this statement.
Note that we don't recurse into any child DIEs here.
Note that we don't update the original block, but instead make a copy and update it instead.
Note that we have a literal constraint with this protocol.
Note that we have already claimed an argument with the same name.
Note that we have resolved this overload.
Note that we haven't resolved this associated type yet.
Note that we ignore the initialization behavior of PatternBindingDecls, but we do want to walk into them, because we want to see any uses or other things going on in the initializer expressions.
Note that we ignore this check for type(), because we don't subtype RAT types precisely.
Note that we intentionally don't support forwarding of weak pointers, because the underlying value may drop be deallocated at any time.
Note that we might have cached a null marker, and that's fine.
Note that we only support C's for CVU so far (this only comes up with FCallBuiltin)---we'll fail the verifier if something changes to send V's or U's through here.
Note that we only tell the server to break once.
Note that we pass down the original bit-width.
Note that we rely on the semaphores being zeroed when they are created.
Note that we should always have a catch trace for the special runtime helper exceptions above.
Note that we should only end up in this path in cases where simply forwarding the outer result address wasn't possible.
Note that we wait to update m_used until after we've updated the strong iterators because we need to consult what the _old_ value of m_used before compaction was performed.
Note that we'll be doing a shuffle involving default arguments.
Note that we'll have walked the members now.
Note that we'll revisit this instruction and add it to Uses twice if it is both a load and store to the same aggregate.
Note that we're assuming that it's safe to call a function that returns a pointer at a site that assumes the function returns void.
Note that we're parsing a declaration.
Note that we're parsing a statement.
Note that we're removing this argument.
Note that we're resolving this witness.
Note that we've been superseded.
Note that we've created this subscript.
Note that we've formed this property.
Note that while protocol types don't have a metadata pattern, we still require an accessor since we actually want to get the metadata for the existential type.
Note that while this pass may insert multiple DefInlineFP instructions for a particular inlined region it will never insert new InlineReturn instructions.
Note that, / unlike fetching the type info and asking it for the storage type, / this operation will succeed for forward-declarations.
Note that, as instructions are cloned into the new blocks, the dest SSATmps of these instructions also need to be renamed, so they're added to `tmpRenames' along the way.
Note that, unlike / fetching the type info and asking it for the storage type, this / operation will succeed for forward-declarations.
Note the constraint within the node for that type variable.
Note the dependent VWT offset.
Note this case must never return 0.
Note this will also hit for unreachable code, but presumably we'll run DCE at some point after removing unreachable code.
Note though that previously we tried targeting specific options considered semantically relevant but it proved too fragile (very easy to miss some new compiler invocation option).
Note we need not unload belowerrN because it is for the dummy column before or after the actual array.
Note, for example, that this means an array doesn't have to copy if it was asked to remove an element that doesn't exist.
Note, however, that we will override this decision below if the only thing we have to forward is already a context pointer.
Note, the basic block here could be a reference to an undefined basic block, which will be parsed later on.
Note, this instruction can re-enter, but doesn't need the may_reenter() treatmeant because of the special kill semantics for locals and stack.
Note, this will not always be a constant, for example, when analyzing _convertFromBuiltinIntegerLiteral function itself.
Note, unlike baseList, the order of the elements in this vector is unspecified.
Note, we don't support objects with vtables here (if they may need a this pointer adjustment).
Note, we intentionally diagnose the end quote before the start quote, so that the IDE suggests fixing the end quote before the start quote.
Note: Amount of  allocation per character to be encoded may have to be increased as larger HTML Entities are implemented.
Note: Arbiters don't contain any data, including auth stuff, so you cannot authenticate on an arbiter
Note: At this point, we dont have a function scope, so we set the flags on the FileScope.
Note: CallContext contains the caller Context primarily to reduce the contention in this tbb.
Note: Copied from object-data.cpp
Note: DarwinBoolean is odd because it's bridged to Bool in APIs, but can also be trivially bridged.
Note: Do not provide any SILLocation.
Note: FILE_SEARCH and FILE_REGEX do not actually copy anything, but setup pointers into the source
Note: If indirect fixups happen frequently enough, we could just compare savedRip to be less than some threshold where stubs in a.code stop.
Note: If we ever use this to undo the actual variable binding, we'll need to store the change along the early-exit path as well.
Note: InstanceOfD can do autoload if the type might be a type alias, so it's not nothrow unless we know it's an object type.
Note: It is not standards-compliant to compare function pointers for equality, so we just use fake addresses instead.
Note: LdLocPseudoMain is both a guard and a load, so it must not be a PureLoad.
Note: MInstrEffects wants to manipulate pointer types in some situations for historical reasons.
Note: ObjCBool is odd because it's bridged to Bool in APIs, but can also be trivially bridged.
Note: PHP returns "tcp_socket/ssl" for this query, even though the socket is clearly not an SSL socket.
Note: This is a lookup into another module.
Note: This number should generally not be modified as it depends on the CPU's ABI.
Note: This should be treated as a lookup for intra-module dependency purposes, but a subclass already depends on its superclasses and any extensions for many other reasons.
Note: We can't use TryLoc here because it's outside the PBD source range.
Note: We can't use tryLoc here because that's outside the ReturnStmt's source range.
Note: We can't use tryLoc here because that's outside the ThrowStmt's source range.
Note: We may push the publishing of the inline frame below the start of the inline function so that we can avoid spilling the inline frame in the common case.
Note: We need to mark the cursor as failed _after_ prepping the exception, otherwise the exception won't include the servername it hit for example.
Note: a Continue cmd is a bit special.
Note: a block can have an unprocessed predecessor even if the region is acyclic, e.g. if the IR was able to prove a path was unfeasible due to incompatible types.
Note: a cyclic inheritance chain will blow this up, but right now we'll never get here in that case because hphpc currently just modifies classes not to have that situation.
Note: anything else is an error, to be diagnosed later.
Note: be careful, the TFoo objects aren't all constructed yet in this function.
Note: chunk data must be padded to multiple of 2 in size
Note: currently caller is responsible for calling renumber after this.
Note: currently this is visiting inner loops first, but not for any strong reason for the types of optimizations it currently performs.
Note: currently we're limiting all represented types to predefined bit patterns (instead of arbitrary unions), so this function is around for assertions.
Note: dynamically-dispatched properties have their getter and setter added to the vtable when they are visited.
Note: errorptr points to *previous* column's array entry.
Note: exclude s_Pair if we re-enable this.
Note: for jumps this also conceptually needs to execute any side effects a conversion to bool can have.
Note: for now this is an invariant, but if we start pruning factoredExits this might need to change.
Note: for now we're merging counted arrays into whatever type it used to have in the following set functions, and returning arr_*'s in some cases where we could know it was a carr_*.
Note: functions made with this currently only make sense to call if it's already known that the opcode has extra data.
Note: hphpc doesn't include inherited constants in get_class_constants(), so mimic that behavior
Note: if the local is already TRef, we could try to leave it alone, but not for now.
Note: if we ever start putting extension members in vtables, we'll need to validate those members too.
Note: if you add more cases here, hhbbc/class-util.cpp also needs to be changed.
Note: if you add new supported type tests, you should update negativeCheckType() to indicate whether it is precise or not.
Note: if you change this, you need to change similar logic in apc-object.
Note: if you make changes to the behavior here you may need to update negativeCheckType().
Note: if you try to tail-call these helper routines, gcc will unfortunately still generate functions with frames and and makes a call instead of a jump.
Note: in this case, we don't call the emitter at all -- doing so just runs the risk of tripping up asserts in SILGenBridging.cpp
Note: it doesn't matter what order we visit the blocks for this pass.
Note: it is indeed a bit odd that interrupts due to single stepping come in as "BreakPointReached".
Note: it may seem like we should need a precondition on this rule that each incoming node is distinct, since Phi nodes don't necessarily have unique predecessor pointers.
Note: it will clobber the Aux area of a TypedValueAux.
Note: it would be nice to give them more info about the process we think is debugging this sandbox: what machine it's on, what it's pid is, etc.
Note: it's important that the unwinder makes a copy of the Fault it's currently operating on, as the underlying faults vector may reallocate due to nested exception handling.
Note: it's ok not to zero new allocations, because we've never done anything with this part of the page yet, so it must still be zero.
Note: it's silly to try to reconnect when stopping, or if we have a problem while quitting.
Note: it's tempting to say every unique ClassInfo object has an AttrUnique class, but that may or may not apply right now.
Note: it's useful to do dead block removal before DCE, so it can remove code relating to the branch to the dead block.
Note: keep previous modifiers if none specified when importing the trait
Note: m_methods includes methods from parents/traits recursively.
Note: no support for reading array types.
Note: only occurs in templates.
Note: preserving behavior, but I think this can leak the copy if the user error handler throws.
Note: recursion into old type checker is okay when passing in an unsatisfied-dependency callback.
Note: recursive type-checking implies that AllConformances may be reallocated during this traversal, so pay the lookup cost during each iteration.
Note: right now abstract functions are part of the family.
Note: right now this state is per-ASetInfo, but we must pessimize everything at once if we pessimize anything, because of how the analyzer will lose track of aliasing effects.
Note: right now we're only asserting about normal successors, but there can be exception-only successors for catch blocks inside of fault funclets for finally handlers.
Note: templates are not imported.
Note: the call sites of this function all assume that no user code will run and no recoverable exceptions will occur while running this code.
Note: the couldBe comparisons here with sempty() are asking "can this string be a non-reference counted empty string".
Note: the effective type we can assume a given static property may hold is not just the value in these maps.
Note: the ivar destroyer is responsible for destroying the instance variables before the object is actually deallocated.
Note: the key is not already incref'd, but the value must be.
Note: the logic relating to how to grow in this function is coupled to PackedArray::PlusEq.
Note: the normal object destruction path does not actually call this destructor.
Note: the odd check for one generic parameter copes with protocols nested within other generic contexts, which is ill-formed.
Note: the only flag which is implemented is FLUSHABLE
Note: the parent list contains no nulls.
Note: the result of Await does not matter.
Note: the tvUnboxIfNeeded comes *after* the setop on purpose here, even though it comes before the IncDecOp in the analogous situation in incDecProp.
Note: there is a gap in between that we use for keywords.
Note: there is a general problem with the spillStack mechanism, in that it may sink stores that are not profitable to sink, but in this case we can work around it easily.
Note: there must not be a mixture of XPG3 specs and non-XPG3 specs in the same format string.
Note: these miThrows probably can be left out if base is folly::none (i.e. we're on the last dim).
Note: this can't use std::move, because pauseBlock must leave the current state alone so startBlock can use it as the in state for another block.
Note: this currently isn't exhaustively checking accessibility, except in cases where we must do a little bit of it for correctness.
Note: this differs from Zend right now in the case of a failed recursive __set.
Note: this doesn't take commutativity or associativity into account, but it might be nice to do so for the opcodes where it makes sense.
Note: this entire scheme assumes that all pointer followable types can be reached via some indexed type.
Note: this error case is difficult to test.
Note: this error case is easily tested, and we have a test for it.
Note: this is a hack to improve performance when we're dealing with overloaded operators.
Note: this is currently separate from typeFromRAT for now, just because we don't want to enable every single type for assertions yet.
Note: this is not the case e.g. if the apply is in a then-branch of an if-then-else in the caller and the else-branch is the short path.
Note: this is part of a performance hack to prefer non-generic operators to generic operators, because the former is far more efficient to check.
Note: this is probably more complex than it needs to be, because we're iterating the stk_expand_map for each location.
Note: this is the minimum set of things to point the CURL* to this CurlHandle
Note: this may trigger merging of content nodes.
Note: this mimics ImportHint::canImportAsOptional.
Note: this should typically only be used when invoking the frontend directly, as the driver will always pass -o with an appropriate filename if output is required for the requested action.
Note: this stops any flow control command we might have in-flight.
Note: translation units are handled specially by importDeclContext.
Note: unlike class constants, these can be dynamic system constants, so this doesn't have to be TInitUnc.
Note: we could use the gen set here to remove support entries when we step the mrinfo, but it's not useful because only CallEffects causes it right now, and SSATmps can't span calls.
Note: we don't always get TypeAnnotations (e.g. for shape types currently).
Note: we don't check whether all of the elements of the overload set have different argument types.
Note: we don't need to handle possible emptiness explicitly, because if the array was empty we won't ever pull anything out while iterating.
Note: we don't redirect the defer-edges because we don't want to trigger updatePointsTo (which is called by addDeferEdge) right now.
Note: we must handle the string-related cases before doing the general handleBaseElemD, since operates on strings as if this was an intermediate ElemD.
Note: we need to check the isImplicit() bit here to make sure that we don't classify explicit parameters declared with `self` as the self param.
Note: we never destruct APC, currently.
Note: we should not destroy user save handler here (if the session is restarted during request, the handler should be alive), it's destroyed only in the request shutdown.
Note: we skip catch clauses if we have a pending C++ exception as part of our efforts to avoid running more PHP code in the face of such exceptions.
Note: we're leaving non-overridden privates in their subclass method table, here.
Note: when unwinding from an exception the callee may not be the first AR on the stack, however, with the exception of Call, and CallArray, the next frame will always be native.
Note: whenever you update this function, also update DerivedConformance::getDerivableRequirement.
Note: whenever you update this function, also update TypeChecker::deriveProtocolRequirement.
Notes Any string in repo can be null.
Notes about instructions for which we're supposed to perform some / sort of non-standard emission.
Notes about preserving SSA form:  This pass can add new uses of SSATmp*'s to replace accesses to memory.
Notes:  - You can crash hhvm very easily with this.
Nothing can write to the uninit null variant either, so the inner type here is also always true.
Nothing else for now.
Nothing else is allowed in the name.
Nothing else is statically just a class reference.
Nothing else needs to be placed here.
Nothing follows the number
Nothing in this structure can ever be untrue.
Nothing interesting from the source expression.
Nothing is allowed to write anything to the init null variant, so this inner type is always true.
Nothing matched the range, stop processing
Nothing more to do here
Nothing more to solve.
Nothing other than reusedStubs should have data, and those don't need any processing for liveRelocate().
Nothing to check at the moment.
Nothing to clean up after taking the class reference.
Nothing to do for these kinds of decls - anything active has been added to the enclosing declaration.
Nothing to do for this profiler since all work is done as we go.
Nothing to do here because the default stream type is empty_string_ref.
Nothing to do if the current module has a required function with a proper linkage already.
Nothing to do if the type is concrete.
Nothing to do if there's already a descriptor.
Nothing to do if this wasn't a normal conformance.
Nothing to do if we can't write the file
Nothing to do if we got an empty string
Nothing to do in SILGen for other external types.
Nothing to do in default case because the default stream type is empty_string_ref.
Nothing to do: cleanup is handled by QObject relationships
Nothing to do: these have the curried 'self' already.
Nothing to inspect: use the global "window" object
Nothing to store for empty singletons.
Nothing uses WIterNext so we intentionally don't support it here to avoid a null check in the witer_next_key helper.
Nothing was stripped off.
Nothing we can do in other cases that could be strings (without statically known values)---they may behave like integers at runtime.
Nothing will break if it doesn't work.
Notice that any callee main block must have a callee main block successor or be the terminal callee main block.
Notice that any use of an inlined frame not occurring within the callee main blocks is necessarily on a side exit.
Notice that the block containing InlineReturn may have other instructions whose marker does not match fp as InlineReturn is non-terminal.
Notice that this scan is only block local because at this point we don't use post-dominators.
Notice that we need to check all of the values of the object.
Notice that we need to handle control-flow programs such as the one below.
Notice that we need to handle underflow and overflow.
Notice that we will skip all of the newly inlined ApplyInsts.
Notice: we scan the basic block in reverse.
Notify HttpServer that we've shutdown
Notify MM that surprise flag should be set upon reaching the threshold
Notify our parent declaration that we have added the member, which can be used to update the lookup tables.
Notify the callback, if any.
Notify the client that semantic functionality is disabled.
Notify the constraint graph.
Notify the debugger that this thread is executing a request in the given sandbox.
Notify the delete handlers that the instructions in this block are being deleted.
Notify the delete handlers that this BB argument is going away.
Notify the delete handlers that this argument is being deleted.
Notify the delete handlers that this instruction is going away.
Notify the listener that we've built the constraint system.
Notwithstanding the foregoing, the authors grant the U.S.
Now `shift' the result of the reduction.
Now add any names the DebugClient knows about to the lookup.
Now add the files that haven't changed, so that they'll get built in parallel if possible and after the first set of files if it's not.
Now add the inherited methods.
Now add the new argument to each incoming Jmp.
Now add typerefs of all of the captures.
Now apply any adjustments for control flow.
Now attempt to simplify the remaining blocks.
Now bridge the return value.
Now build the character set.
Now check that the only uses of the protocol are witness_method, open_existential_addr and destroy_addr.
Now consider the rest of the parameters.
Now convert the parameters to Clang types.
Now copy each candidate callee that has a small enough number of call sites into the final set of call sites.
Now count remaining bytes.
Now create the new partial_apply using the cloned function.
Now delete the clone as we only needed it operand.
Now do thin-to-thick if necessary.
Now emit the a cast from the casted ObjC object into a target type.
Now emit the colormap index for this cell
Now encode the result...
Now erase the old argument since it does not have any uses.
Now examine each block we saw a use in.
Now examine the action component:
Now finalize the match.
Now find all uses of Call.
Now fix up the type based on we're concretely using it.
Now generate code for the suffix portion.
Now get dynamic properties.
Now get last part - the description
Now get result of this (32 bytes) and add it to the other context.
Now get result of this (64 bytes) and add it to the other context.
Now get the time zone
Now go through all new blocks and reset their next/taken blocks to their corresponding new blocks.
Now grab the RCID of this instruction.
Now grab the increment matched up with the decrement from the bottom up map.
Now handle the effects of the store on the aset for the value being stored.
Now if we are asked to link all, link all.
Now insert the region for tid in the front of m_region.
Now into new section that parses buf for delimiter/enclosure fields
Now iterate over all the compilation units again.
Now iterate over the BBs and fix up the terminators.
Now iterate over the callee BBs and fix up the terminators.
Now just find the ones that are ready, and copy the corresponding arrays from our input array into our return value.
Now load the top-level module, so that we can check if the submodule exists without triggering a fatal error.
Now look for the method.
Now loop over all cells in box, updating distance per Thomas method
Now loop over all the hosts that were found
Now make the output string
Now mark all of these functions as public and remove their bodies.
Now parse an optional type annotation.
Now pass our field back to php
Now propagate liveness backwards from each instruction in our worklist, adding new instructions to the worklist as we discover more that we need to keep.
Now propagate liveness backwards until we hit the alloc_box.
Now propagate liveness backwards until we hit the block that defines the value.
Now provide the results along with whether the name is duplicate or not.
Now remove any edge that looks like it will unconditionally fail type predictions, and completely remove any block that can't be reached.
Now remove instructions whose state is DEAD.
Now scan remaining volume of box and compute population
Now see if the source also has one.
Now see if we need to raise any warnings because of not having a valid callback function
Now sort the group itself.
Now store the fixed extra inhabitant and ask the runtime to identify it.
Now summarize our blocks so that we only visit interesting instructions.
Now that a deinit was found, it is safe to substitute all recorded uses with the copy's source.
Now that all of the uses are fixed we can fix the branches that point to the blocks with the added arguments.
Now that an init was found, it is safe to substitute all recorded uses with the copy's dest.
Now that constants have been bound we can update options using constants in ini files (e.g., E_ALL) and sync some other options
Now that definite initialization / checking is done, remove them.
Now that the BB is empty, eliminate it.
Now that the IR is correct, see if we can remove dead callee computations (e.g. dead partial_apply closures).
Now that the block has been inserted into the function, create PHI nodes in the backedge block which correspond to any PHI nodes in the header block.
Now that the indexed types are fixed up to be more consistent, merge duplicates together.
Now that the instruction has a concrete "init" form, update it to reflect that.
Now that the job is running we need to wait for a call to onComplete()
Now that the pattern has been initialized, check any where condition.
Now that tvCbRet is live, make sure to decref even if we throw.
Now that type witnesses are done, satisfy property and method requirements.
Now that we do, this CFI is a lie.
Now that we have a SILFunction parse the body, if present.
Now that we have a boolean test as a Builtin.i1, emit the branch.
Now that we have a sorted precedence of constraints to diagnose, charge through them.
Now that we have all the types, do so here.
Now that we have an argument type we can set the element's declared type.
Now that we have finished processing the loop, summarize the loop.
Now that we have finished processing this loop, sort its subregions so that they are now in RPO order.
Now that we have our destinations, insert a conditional branch on the condition.
Now that we have our result as an optional, we can use an enum projection to do all the work.
Now that we have our vector of Label*'s ready, we can emit a Switch instruction and/or conditional branches, and we can emit the body of each case.
Now that we have the candidate list, figure out what the best matches from the candidate list are, and remove all the ones that aren't at that level.
Now that we have them, mark them as being initialized without a PBD.
Now that we know the minimum closeness, remove all the elements that aren't as close.
Now that we know the substFnType, check if we assumed that we were passing self at +0.
Now that we know we can perform the rotation - move the instructions that need moving.
Now that we know we have an inst, grab the decrement.
Now that we know we have an instruction we understand see if the instruction has an available value.
Now that we're at a fixed point, use the propagated states to remove instructions that don't need to be there.
Now that we're done with it, remove the delegate.
Now that we've emitted a bunch of instructions, including a load and store but also including other stuff, update the internal state of LifetimeChecker to reflect them.
Now that we've got the storage squared away, synthesize the getter.
Now that we've inlined some functions, clean up.
Now that we've parsed all of our patterns, initializers and accessors, we can finally create our PatternBindingDecl to represent the pattern/initializer pairs.
Now that we've permuted things, complete f().
Now that we've scalarized some stuff, recurse down into the newly created element address computations to recursively process it.
Now that we've smashed all the IBs for these translations they should be unreachable-- to prevent a race we treadmill here and then reclaim their associated TC space
Now that we've type checked the explicit argument type, see if it agrees with the contextual type.
Now that we've walked all of the immediate uses, scalarize any operations working on tuples if we need to for canonicalization or analysis reasons.
Now the effects on the set being stored.
Now the hard part -- adjusting rv to the correct value.
Now the original preheader dominates all of headers children and the original latch dominates the header.
Now the partial apply /    will own those ref counts.
Now they shouldn't change either direction:
Now to build the path
Now try to break the cycle.
Now try to bring it into the AST.
Now try to discover other details about the file.
Now tuneable thanks to Wez Furlong
Now visit each one of our predecessor regions and see if any are blocks that can use reference counted values.
Now visit the loop nest in a DFS.
Now walk the children looking for nodes that have controlling predecessors that have the same or lower level number in the post-dominator tree.
Now we are done with code completion.
Now we can construct the result string.
Now we can generate a new BB for preds reaching BB over the success path and a new BB for preds reaching BB over the failure path.
Now we can get on with it
Now we can go ahead and add in the right number of extra bits.
Now we can go into a command loop.
Now we climb up use-def chains and attempt to do tricks based off of GEPs.
Now we get the full value, and show the rest.
Now we have a +1 value.
Now we have a namespace and class name.
Now we have a namespace, class and func name.
Now we have nd0 digits, starting at s0, followed by a decimal point, followed by nd-nd0 digits.
Now we have to determine the lifetime of the allocated object in its function.
Now we know that CSDesc is profitable to specialize.
Now we know that FirstIV is an enum and that all payloaded enum cases after just stripping off instructions are FirstIV.
Now we know that I should not have any uses...
Now we know that RCIdentityBB and IncomingEdgeBB are different.
Now we know that Right is None and Left has a value.
Now we know that both Left and Right must have a value.
Now we know that no cell in the update box is more than minmaxdist away from some colormap entry.
Now we know that the block is in a loop and is a loop header.
Now we know that we were able to determine the sign bit for at least one of Left/Right.
Now we need to build up the list of function records.
Now we need to get the index of the captured value with that type so we know where to start the search at runtime.
Now we need to make sure that each non-payloaded enum value is safe to ignore.
Now we need to make the setenv 'stick', which it may not do since the env is flakey before main() is called.
Now we need to see if we can suggest trailing closure expansion, and if the call parens can be removed in that case.
Now we should read the response
Now write function declarations for every function we've emitted a reference to without emitting a function body for.
Now, attempt to diagnose the failure from the info we've collected.
Now, check the inheritance clauses of each parameter.
Now, copy over the partial apply args.
Now, each interval in blockStarts delinates a basic block.
Now, if the destination has no payload, check if the source has one.
Now, match from the first word up until the end of the type name.
Now, take care of CLI options and then officially load and bind things
Now, we just ignore it.
Null converts to the empty string when being compared against a string.
Null exit block for 'ldrefExit' because we won't actually need to reload the inner cell since we are doing a stLocNRC.
Null for unbounded calls that will look for the method in / the dynamic type of the object.
Null goes to 1 on ++, stays null on --.
Null guard block for globals because we always punt on pseudomains
Null if the switch / scope depth is zero or if we are checking the final 'case' of the current / switch.
Null out each element before decreffing it.
Null out or initialize the frame's ExtraArgs.
Null out temp local, to invoke any needed refcounting
Null out this_ for static methods, unless it's a closure.
Null terminate and eat *trailing* return
Null-terminate the UTF-16 string.
NullSafe (Q) props do not promote an emptyish base to stdClass instance.
NullSafe Property marker
Nullable trailing closure parameters default to 'nil'.
Nullary methods still take a formal () parameter clause.
Nullify the pointers to be safe since this is a captured heap
Number of Blowfish rounds, this is also hardcoded into a few places
Number of args of one generic archetype which are mismatched because isSubstitutableFor() has failed.
Number of bits in the value, ignoring leading zeros.
Number of bytes for any private storage used by the conformance itself.
Number of captured subpatterns
Number of characters read into yy_ch_buf, not including EOB characters.
Number of characters so far in this 'packet'
Number of elements along histogram axes.
Number of elements in the entry array
Number of entries by which start-condition stack grows.
Number of inlined instructions of this function in its caller.
Number of intervals spilled.
Number of keys position to allocate
Number of spill slots used.
Number of subclasses which cannot be handled by checked_cast_br checks.
Number of syntax errors so far.
Number of tokens to shift before error messages enabled.
Number of uses of each Vreg.
Number to return, has to be -1 for admin commands
Numeric strings will complicate matters because the loose comparisons done with array keys are not quite the same as loose comparisons done by in_array.
O(N) checks are available if you want them for debugging, but they are too slow for general use in debug builds.
O(n + m log m) for n keys total and m in the hotlist.
O1, O2 are getUnderlyingObject of V1, V2 respectively.
OK in the invoking frame when running a destructor.
OK, ask the runtime for the class pointer of this potentially-ObjC object.
OK, now we are ready to create a new one.
OK, this value is a potential candidate
OK, we allocated SIZE+1
OK, we don't have enough memory, let's do something.
OK, we've exhausted the entire actRec chain.
ONE(IVA),     CMANY,   ONE(CV)
ONE(VSA),     SMANY,   ONE(CV)
OR in the Bits per Pixel
ORIENTATION constants
OS X defines msgbuf, but it is defined with extra fields and some weird types.
OSS builds read tzdata from the system location (eg /usr/share/zoneinfo) as this format must be stable, we're keeping timelib stable too
OTOH, if we do have a contextual type, we can provide a more specific error.
ObjC class pointers look like unmanaged (untagged) object references.
ObjC classes are type erased.
ObjC classes mangle as being in the magic "__ObjC" module.
ObjC decls don't go in vtables.
ObjC doesn't have a notion of class properties, so we'd only do this for instance properties.
ObjC entry points are always externally usable, so can't be delay-emitted.
ObjC entry points are always externally usable, so emitting can't be delayed.
ObjC enums have already had their raw values checked, but pure Swift enums haven't.
ObjC forwards references.
ObjC functions are called through the runtime and are therefore alive even if not referenced inside SIL.
ObjC generic type parameters don't have a runtime representation, so they don't count as captures.
ObjC initializing constructors and factories are foreign.
ObjC metatypes are represented with an objc_class pointer.
ObjC methods take their 'self' argument first, followed by an implicit _cmd argument.
ObjC protocol names aren't mangled.
ObjC protocols do not have witnesses.
ObjC protocols don't have associated types so only the Self archetype is present.
ObjC protocols need no layout or witness table info.
ObjC super calls require dynamic dispatch.
ObjC thunks should also not show up in the linetable, because we never want to set a breakpoint there.
ObjC-compatible existential metatypes.
Object comparisons can produce arbitrary side-effects, so we can only eliminate the comparison if its checking for sameness.
Object inputs are only okay if linking.
Object is always greater than array, but we need a collection check first.
Object that frees a buffer when it goes out of scope.
Object types with no linkage are only the same if they have identical keys.
Object/Ref loads/stores
ObjectData* or Class*
Objective-C "BOOL" type.
Objective-C "Class" type.
Objective-C "id" type.
Objective-C categories and extensions don't have names, despite being "named" declarations.
Objective-C categories and extensions map to Swift extensions.
Objective-C class context.
Objective-C class metadata are objects, so an AnyObject (or NSObject) may refer to a class object.
Objective-C class objects are referenced by their Swift metadata wrapper.
Objective-C class references go in a variable with a meaningless name but a magic section.
Objective-C classes use the ObjC class object.
Objective-C existential types.
Objective-C expects us to have generated a correct ivar layout, which it will simply slide if it needs to.
Objective-C generics don't preserve their generic parameters at runtime, so they aren't able to fulfill type metadata requirements.
Objective-C initializers are tracked by their context type and / full name.
Objective-C metaclasses are subclasses of NSObject in the ObjC runtime, so casts from NSObject to potentially-class metatypes may succeed.
Objective-C metatypes are trivially representable.
Objective-C object pointers.
Objective-C object types, including metatypes.
Objective-C partial applications require a different path.
Objective-C properties.
Objective-C protocol context.
Objective-C protocols do not have any witness tables.
Objective-C protocols may have the suffix "Protocol" appended if the non-suffixed name would conflict with another entity in the same top-level module.
Objective-C retain and release can have arbitrary side effects.
Objective-C selector string literals cannot be used in static initializers.
Objective-C selector type.
Objective-C subscript setters are imported with a function type such as:
Objective-C thunks for generic methods also always derive all polymorphic parameter information from the Self argument.
Objective-c bridging helpers.
Objects are always greater than arrays.
Objects can contain a property with NaN, so only equality comparisons can be negated.
Objects can raise a warning about converting to int.
Objects held in m_faults are not refcounted, therefore we need to increase the ref count here.
Objects that are allocated at global scope instead of on the heap, and statically initialized to avoid synchronization costs, are defined here.
Objects types with internal linkage with the same name are only the same if they're in the same compile unit.
Observe that we are processing REPL input.
Observers don't get separate vtable entries.
Observing accessors (and their generated regular accessors) may have the type of the var inferred.
Observing member are accessed directly from within their didSet/willSet specifiers.
Observing properties will have getters and setters synthesized by sema.
Obtain aggregation object
Obtain target to be set.
Obtain the current thread id
Obtain the protocol whose which should be used by the conformance.
Obtain the unbound variant of the current superclass
Obvious cases that do not need pointer type
Obviously, this must not happen at the top level, or the algorithm would not terminate.
Odds are, the code is not trying to find a member of it.
Of course, such / a vector couldn't be passed to 'satisfiesAll'.
Off by default to keep the test running fast normally ...
Offset 0 is used for empty strings.
Offset could be treated as a long
Offset is part of newly inserted text.
Offset is part of removed text.
Offset must be treated as a string
Offset of a different type this type refers to.
Offset of the bytecode stack top relative to the IR stack pointer.
Offset of the callee's return value relative to the frame pointer.
Offset the index to skip the extra inhabitants we used.
Offset the payload extra inhabitant index by the number of inhabitants we used.
Offset where the suffix begins.
Offsets of key fields in the metadata records.
Offsets, value witness tables, and protocol witnesses.
Often the only reference to a proxy is in the debugger's proxy map, which we're about to alter below.
Often type checking will create new AST nodes and replace old ones / (e.g. by turning an UnresolvedDotExpr into a MemberRefExpr).
Often, the rules will want to "reprocess" by backing up a node.
Ok now we make our transformation.
Ok so we're in a `yield from` situation, we know our ar is garbage.
Ok we found a value in the cache.
Ok we found our VTable.
Ok we have a function ref inst, grab the callee.
Ok, TargetInst is after all of the interesting insts.
Ok, V2 is not an address projection.
Ok, at this point we know that we can construct our aggregate projections from our list of address projections.
Ok, at this point we know we have a terminator.
Ok, either O1, O2 are the same or we could not prove anything based off of their inequality.
Ok, it better be an opcode now.
Ok, it is a closure we support, set Callee.
Ok, it is a valid attribute, eat it, and then process it.
Ok, it is legal for us to sink this increment to our successors.
Ok, it's a big allocation.
Ok, now we know that our tuple has non-trivial fields.
Ok, now we know that the merged set can safely represent a set of of instructions which together semantically act as one ref count increment.
Ok, now we know that we are able to emit our base at guaranteed plus zero emit base.
Ok, now we know that we have a back edge region.
Ok, our state is in the map, copy in the predecessors value to case map.
Ok, so now we know that the ref counted value we are tracking was not blotted on either side.
Ok, this instruction may have ref counts.
Ok, this is something loadable.
Ok, this is the first time that we have visited this BB.
Ok, this type is non-trivial.
Ok, we are visiting a non-trivial field.
Ok, we can now perform our transformation.
Ok, we found a constructor that can be invoked with an empty tuple.
Ok, we found a payloaded predecessor.
Ok, we found the case for our BB.
Ok, we have a VTable.
Ok, we have a field that is not equal to the field we are extracting.
Ok, we have a full apply site.
Ok, we have a matching BB and a matching enum tag.
Ok, we have a payload enum, make sure that we have a store previous to us...
Ok, we have a predecessor inside the loop.
Ok, we have a ref count instruction that *could* be sunk.
Ok, we have a release on a SILArgument that is direct owned.
Ok, we have a release_value or strong_release.
Ok, we have a retain_value or strong_retain.
Ok, we have all loads.
Ok, we have an alloc_ref.
Ok, we have an apply site with arguments.
Ok, we have an archetype, make sure it is in the nested archetypes of our caller.
Ok, we have multiple predecessors.
Ok, we have some available values.
Ok, we have started to visit the range of instructions associated with a new projection.
Ok, we have succeeded.
Ok, we just need to emit a declaration.
Ok, we know that the elt we are extracting is non-trivial.
Ok, we know that we can perform the optimization but not whether or not the optimization is profitable.
Ok, we need to actually compute an Alias Analysis result for V1, V2.
Ok, we need to use the projection tree.
Ok, we now know that one of the paths is a subsequence of the other.
Ok, we now know that the type of Base and the type represented by the base of this projection match and that this projection can be represented as value.
Ok, we were able to prove that all arguments to the apply that were guaranteed do not alias Ptr.
Ok, we're converting a C function pointer value to another C function pointer.
Okay we found a post dominating release.
Okay, allow the binding (with the simplified type).
Okay, ask the runtime for the type metadata of this potentially-ObjC object.
Okay, bind everything else from the context.
Okay, can't solve forward.
Okay, define the accessor.
Okay, disable all the individual element cleanups and collect the values for a potential tuple aggregate.
Okay, emit any definitions that we suddenly need.
Okay, everything else is built from a Swift metadata object.
Okay, everything else should be forwarded, build the expression.
Okay, everything else will be passed as a single value, one way or another.
Okay, everything is fine.
Okay, first thing, check the cache variable.
Okay, given that we have a proper setup, we walk the use chains of the self box to find any accesses to it.
Okay, if all we need to do is drop the value in an address, this is easy.
Okay, if the original parameter is passed directly, then we just need to handle abstraction differences and bridging.
Okay, if the special code-completion didn't kick in, parse a matching pattern.
Okay, if we got here, the instruction can be eaten so-long as all of its uses can be.
Okay, insert a new row.
Okay, it looks like this value doesn't escape.
Okay, it looks like we want to do this and we can.
Okay, iteratively build up from there.
Okay, just erase the function from the module.
Okay, make a new entry.
Okay, move to the address point.
Okay, now emit all the cases.
Okay, now it should be safe to coerce the pattern.
Okay, now that we've classified all the constraints, sort them by their priority and privilege the favored constraints.
Okay, now we know we can remove the calls.
Okay, otherwise we pull one destination off the queue.
Okay, pull the next result off the list of results.
Okay, remember this substitution.
Okay, reproduce tuple layout.
Okay, resolve the pattern.
Okay, specialize on the argument.
Okay, start building up the result list.
Okay, start processing the parameters explosion.
Okay, that's everything we know how to try.
Okay, the function has some side effects, if it doesn't capture the object argument, at least that is something.
Okay, the getter is done, create the setter now.
Okay, the lowered type didn't change anything from the subst type.
Okay, the rest of the bindings are irrefutable if there isn't a guard.
Okay, the result is a single value, which will either be an indirect result or not.
Okay, the type is passed indirectly in SIL, so we need to map it to an address.
Okay, the wrong number of arguments was used, complain about that.
Okay, this is the first time we've seen this instruction, proceed.
Okay, this is where the callee context goes.
Okay, we are now working with a single value turning into a single value.
Okay, we found a match.
Okay, we found the correct default witness table.
Okay, we found the correct witness table.
Okay, we have a body, and we can trust it.
Okay, we have a closure signature.
Okay, we have a failed lookup of a multicharacter operator.
Okay, we have a tuple.
Okay, we have a varargs tuple element.
Okay, we have an initialization for the tuple that we need to emit into.
Okay, we have both the getter and setter.
Okay, we have non-trivial initialization to do.
Okay, we need a cache.
Okay, we need to insert the continuation block.
Okay, we need to perform one or more conversions.
Okay, we need to print this expression.
Okay, we need to walk the types and re-lower.
Okay, we'll replace the BB arg with one with the right type, replace the uses in this block, and then rewrite the branch operands.
Okay, we're doing a conditional cast.
Okay, we're naturally emitting to an explosion.
Okay, we're naturally emitting to memory.
Okay, we're now positioned to make the NUL transition.
Okay, we're ready for packages now.
Okay, we've found a better path, and ReversePath contains a path leading from base to Dest.
Okay, we've found the best entry available.
Okay: there is enough in the base name.
Old fashioned tar archive
Old senders will set version to 0.
Old style option, that needs to be removed.
Old version of subfile tag
Older OSs' libobjcs can't handle class property data.
Older ObjCs didn't guarantee _objc_empty_vtable to be nil, but Swift doesn't deploy far enough back for that to be a concern.
Older versions of the runtime library may not contain the entries using the new calling convention.
Olympus has this padded with trailing spaces.
Olympus specific tags
Omit PCs which have opcodes that don't pass the given opcode filter.
Omit invalid sequence
Omit needless words based on parameter types.
Omit needless words based on the type of the parameter.
Omit needless words from the beginning of a name.
Omit needless words from the name.
Omit needless words stats
On Apple platforms, we implement "once" using dispatch_once, which exposes -1 as ABI for the "done" value.
On Clang, the DW_AT_object_pointer is only present in a function's definition, not its declaration.
On Darwin the linker ignores the __LLVM segment.
On Darwin, Clang uses -isysroot to specify the include system root.
On ELF platforms there's no built in autolinking mechanism, so we pull the info we need from the .o files directly and pass them as an argument input file to the linker.
On Linux and FreeBSD (really, ELF binaries) we need to add objects to provide markers and size for the metadata sections.
On OS X and iOS, swift_once is implemented using GCD.
On OSX 10.9, we are lied to about the main thread's stack size.
On Success use the allocated memory for the thread's stack
On Win32 locked files that are closed without being explicitly unlocked will be unlocked only when "system resources become available".
On a 2's complement machine, negating the most negative integer results in a number that cannot be represented as a signed integer.
On a 60 MHz Pentium this takes 34 msec, so you would need 30 seconds to build a 1000 entry dictionary...
On a backtrace, gdb tries to locate the calling frame at address returnRIP-1.
On any path out of this function, make sure to mark the binding as done being type checked.
On destruction, before saving, clear all the session cookies
On destruction, if a type got wiped out, reset it from null to its original type.
On each subsequent predecessor, check the arguments.
On error, get our closeness from whatever problem the listener saw.
On exit from the switch, s points to the string that must be printed, s_len has the length of the string The precision requirements, if any, are reflected in s_len.
On exit, internal references (references into the source range) will have been adjusted (ie they are still references into the relocated code).
On failure, / this leaves the candidate list empty.
On failure, emit the specified error diagnostic, and a / note at the specified note location.
On failure, jump to BreakBB.
On failure, returns 1 and populates error_message
On failure, sets errmsg to errno string and returns -1.
On failure, the calling function is responsible for disconnecting
On failure, we unwind any active cleanups, on success we fall through to a new block.
On failure, we'll clean up everything (except self, which should have been cleaned up before jumping here) and return nil instead.
On failure, we'll clean up everything and return nil instead.
On illegal sequences we may get it wrong, but in that case we necessarily have a matching failure anyway.
On interrupt, it presents a command prompt, and continues pumping interrupts when a command lets the machine run again.
On logical errors, the error_message will be populated with the reason.
On loop exit, the terminating value will be in the buffer.
On most systems, this would mean that any file consisting only of characters in the range 0x00 ...
On non-objc platforms just fill it with a null, there is no objective-c metaclass.
On non-x64, fall back to calling uname
On other targets, it seems to use --sysroot.
On package install complete, if WIXSTDBA_VARIABLE_LOGSPATH is defined / then will move bundle installation log to the specified path.
On package install complete, if WIXSTDBA_VARIABLE_LOGSPATH is defined / then will move the package installation log to the specified path.
On subsequent iterations we only need to update this map with the values from the new iteration's clone.
On success *data_buffer is set and must be free()d
On success scanning the expression body, the real lexer will be used to relex the body when parsing the expressions.
On success, returns number of bytes read.
On success, returns number of bytes sent.
On the failure case, we don't need to clean up the 'self' returned by the call to the other constructor, since we know it is nil and therefore dynamically trivial.
On the first iteration we populate the map from original loop to cloned loop.
On the install page set the focus to the install button or the next enabled control if install is disabled
On the last iteration change the conditional exit to an unconditional one.
On the next scan, YY_INPUT will be called.
On the off chance we were given nothing but crap...
On the other hand if the takeover was started, we don't want to call shutdown because the new server might be listening on that socket and we would cause it to never work.
On the other hand, casts can decrease optionality monadically.
On the other hand, for a PureStore with a known destination, we don't need to reduce the lower bound of any set that was supported by that location, since it never implies a DecRef.
On the other hand, if one or both of them has more memory support bits than lower bound, we just pessimize everything.
On the other hand, if the old set has a lower bound of zero, so we can't compensate for removing it, we leave everything alone.
On the other hand, if this unit was just created by parsing a php file (or whatnot) which was not committed to the repo, we'll have a m_sourceLocTab.
On the other hand, the new "copy" partial apply in the /    specialized function now needs to be balanced lest we leak.
On the other hand, the sub-pattern can be explicit or implicit.
On the other side, the implementation indexer should be registering the getter/setter USRs independently of how they're actually implemented.
On the promote-to-mixed path, we can use addVal since we know the key can't exist.
On these platforms convenience functions from xlocale.h interpret nullptr as C locale.
On this error, the receiver side returns dummy errno, use the sender side errno here.
On to the metaphoning
On way to solve this is to just re-allocate the buffer size.
On windows, the max length is 256.
On x64, concurrent modification and execution of instructions is safe if all of the following hold:  1/  The modification is done with a single processor store.
OnApply - apply the packages.
OnChangeState - change state.
OnClickAcceptCheckbox - allow the install to continue.
OnClickCloseButton - close the application.
OnClickEulaLink - show the end user license agreement.
OnClickInstallPostgressCheckbox - we will set defaults value and disable controls if checkbox was checked.
OnClickInstallScope - allow user to choose between a perMachine and perUser install
OnClickLaunchButton - launch the app from the success page.
OnClickLogFileLink - show the log file.
OnClickOptionsBrowseButton - browse for install folder on the options page.
OnClickOptionsButton - show the options page.
OnClickOptionsCancelButton - discard the changes made by the options page.
OnClickOptionsOkButton - accept the changes made by the options page.
OnClickRepairButton - start the repair.
OnClickRestartButton - allows the restart and closes the app.
OnClickUninstallButton - start the uninstall.
OnClickUpgradeLink - download the upgrade.
OnClose - called when the window is trying to be closed.
OnCreate - finishes loading the theme.
OnDetect - start the processing of packages.
OnDetectUpdateBegin - called when the engine begins detection for bundle update.
OnPlan - plan the detected changes.
OnShowHelp - display the help page.
Once GCC version 2 has supplanted version 1, this can go.
Once Swift has a native notion of submodules, this can go away.
Once a witness has been found, there are several reasons it may / not be usable.
Once all the instructions are copied, we can nuke BI itself.
Once computed, the indexed types will have an index into this table for its associated layout.
Once constructed, we never destroy it.
Once installed, this continues until it is either explicitly uninstalled, or if there is no longer an xdebug server.
Once intervals have been walked and split, every interval has an assigned operand (register or spill location) for all positions where its alive.
Once it does, we / will need to distinguish outer and inner type parameters here.
Once it's published, it's a live activation record, and doesn't get written to as if it were a stack slot anymore (we've effectively converted AStack locations into a frame until the InlineReturn).
Once open sourced, the client will be detectable via its own ifdef.
Once submodules are designed, this needs to support suffix matching and a search path.
Once that's no longer true (because we're serializing everything appropriately in the module), we should assert that this does not happen.
Once the / depth of the expression stack is equal to this value, the / existential can be closed.
Once the Callee and CallSites have been prepared by SILGenApply, / generate SIL for a fully-formed call.
Once the absolute depth at the jump becomes known, its StackDepth instance calls the setBase method of the StackDepth instance of the label.
Once the following block runs the guards should be unreachable.
Once the guards have been evaluated, ignore will either be cleared (if any guards pass), or conservative will be cleared (if none pass).
Once the integration completes, I'll play around with it some more and potentially change this implementation to use std::isnan() if it is exactly commensurate with our usage.
Once the molad that starts a year is determined the actual start of the year (Tishri 1) can be determined.
Once the parser handles this correctly, the R and C cases can go.
Once this flag is set, it remains set.
Once those lists no longer exist or are no longer "the truth", we can simplify this algorithm considerably.
Once we are done with EHs for the current frame we restore default values for the fields inside Fault.
Once we get rid of all the callsites, make this an error
Once we have analyzed it, set Behavior to that value and insert the value into the Cache.
Once we have done all of the easy work, try to see if we can strip off any RCIdentityPreserving args.
Once we have found such a node, there is no need to traverse any deeper.
Once we have found the target node, look for the innermost ancestor / matching our criteria on the way back up the spine of the tree.
Once we know if this process does not have debugger support, we'll clear it.
Once we see one dv-initializer, every parameter after that must have a dv-initializer.
Once we've collected all of the conditional init/assigns, we can insert a single control variable for the memory object for the whole function.
Once we've found all of the instructions to add to the worklist, add them in reverse order.
One additional check: 'let' properties may never be passed inout, because they are only allowed to have their initial value set, not a subsequent overwrite.
One break level has been taken care of by this region.
One candidate: produce an error with a fixit on it.
One case and a default.
One content node for going from the array buffer pointer to the element address (like ref_element_addr).
One continue level has been taken care of by this region.
One ends before the other starts.
One entry in the log, representing a function enter or exit event
One example is the overloaded member functions.
One example is two decls when searching for Generator of Sequence: one from Sequence, the other from _Sequence_Type.
One final note: because of the exclusivity rule on lower bounds, we cannot assume a lower bound of one for a LdCtx unless it comes from the main frame.
One iop* function exists for every bytecode.
One loop level has been taken care of.
One member is in a protocol extension, the other is in a concrete type.
One note about StaticLoc: we're literally always going to generate a fallthrough trace here that is cold (the code that initializes the static local).
One of the identifiers is empty.
One of the new instructions produced the new dst.
One possible solution would be to turn them into members and add conversion functions.
One problem with getServiceDataInstance() is that it's not thread safe.
One represented using Y,U,V vectors and the other is webp image data.
One rule this pass relies on is that it is illegal to DecRef an object in a way that takes its refcount to zero, and then IncRef it again after that.
One that references a status register that is used elsewhere and one that references an otherwise unused status register.
One thing we have to be careful of is to make sure that we don't invalidate "BBI" (the iterator the outer walk of the optimization pass is using, and indicates the next instruction to process).
One valid split found, it is almost certainly the right answer.
One-to-many case insensitive map, where the keys are static strings and the values are some kind of borrowed_ptr.
One-to-one case insensitive map, where the keys are static strings and the values are some T.
One-to-one case insensitive map, where the keys are static strings and the values are some kind of borrowed_ptr.
Only 'objc' declarations use 'dynamic'.
Only Branch and CondBranch may have arguments.
Only C++ functions can inspect the caller frame, we know these are all loaded ahead of time and unique/persistent.
Only F-S dithering or no dithering is supported.
Only J-edges, whose target level is at most Root's level are added to the dominance frontier.
Only MIState is allowed to have no specialization and be a valid single location.
Only Objective-C classes can violate this assumption.
Only SOF0-SOF2 are now in common use
Only Struct and Enum extensions can be transparent.
Only UTF-8 and UTF-16 encoded string literals are supported by this optimization.
Only a PORT was provided
Only accept pointing to an identifier.
Only actually print out DIEs which begin in the range between the begin and end parameters.
Only actually print out compilation units if they lie within the begin/end parameter range.
Only actually recurse if this child DIE is the above computed first DIE, or one following it, and begins before the end parameter.
Only add a fulfillment if we don't have any previous fulfillment for that value or if it 's cheaper than the existing fulfillment.
Only allow CFA opcodes when we're writing an entry.
Only allow OP opcodes when we're writing an expression.
Only allow about one typo for every two properly-typed characters, which prevents completely-wacky suggestions in many cases.
Only allow allocation of AvailabilitySpecs using the allocator in ASTContext.
Only allow allocation of DeclContext using the allocator in ASTContext.
Only allow allocation of Decls using the allocator in ASTContext.
Only allow allocation of Modules using the allocator in ASTContext.
Only allow allocation of TypeRefinementContext using the allocator in ASTContext.
Only allow allocation of Types using the allocator in ASTContext.
Only allow allocation of attributes using the allocator in ASTContext.
Only allow allocation of member lookup tables using the allocator in ASTContext or by doing a placement new.
Only allow allocation of resolved overload set list items using the allocator in ASTContext.
Only allow enums forming an optional.
Only allow loads of projections, either directly or via struct_element_addr instructions.
Only allow one in the process at any time.
Only allow this method to be recursed on for a limited number of times to make sure we don't explode compile time.
Only allow this method to go up a fixed number of levels to make sure we don't explode compile time.
Only allowed to overrun the signature if we have somewhere to put it
Only an instance method of a non-class protocol is ever passed indirectly.
Only applies to method and it's always false for functions.
Only arrays that cannot be backed by NSArrays are safe.
Only attempt to validate the argument type or raw value if the element is not currently being validated.
Only bail out if the next token is at the start of a line.
Only blend with different colors that aren't the dont_blend color.
Only building the gen and kill sets for now.
Only building the gen and kill sets here.
Only call this if the variable has an initializer.
Only call this on CPP classes
Only called for fn defs not on the top level
Only capture var decls at global scope.
Only certain decls can be ObjC.
Only check individual variables if we didn't check an enclosing TypedPattern.
Only check the trailing 'where' requirements.
Only check whether the total memory limit was exceeded if this request is at a new high water mark.
Only class objects can be weak-retained and weak-released.
Only class protocols can have the attribute.
Only class types properly initialize their parent type.
Only classes can appear directly in "use" statements
Only classes can have required constructors.
Only clone the arguments that remain in the new function type.
Only close the connection if it matches the current PID
Only consider "with" or "using" to be potentially vacuous.
Only consider 'private' members, unless we are in whole-module compilation.
Only consider function calls.
Only consider standalone declarations in the Builtin module.
Only consider the rvalue type.
Only consider this a member function if this arg if the first and its artificial.
Only consider throwing function types.
Only consume non-toplevel decls.
Only consumes the reference to its input array
Only continue members in the same submodule as this extension.
Only deal with the case of a contiguous set of nodes where we can run/allocate memory on each node.
Only diagnose archetypes that don't have a parent, i.e., ones that correspond to generic parameters.
Only diagnose this once.
Only do a filehash if the file changed.
Only do anything special to methods.
Only do that here if we can't move the store to the error block.
Only do the storage for ref-counted type
Only do this for local values.
Only do this if we're parsing a pattern, to improve QoI on malformed expressions followed by (e.g.) let/var decls.
Only eagerly emit functions that are externally visible.
Only empty instances compare equal.
Only ever permit this if the source type is a reference type.
Only extract linkage information from the definition.
Only for archetypes, and not for opened archetypes.
Only for type metadata.
Only forward the current late bound class if it is the same or a descendent of cls
Only free the iterator for the current loop if this is NOT the last level to continue out of.
Only full apply sites can require a guaranteed lifetime.
Only full initializations make something live.
Only function types may be generic.
Only functions with an operator identifier can be declared with as an operator.
Only functions with bodies can be analyzed by the analysis.
Only generate the optimized version if the argument passed in is a static string with a constant literal value so we can get the string value at JIT time.
Only generic and protocol types are permitted to have trailing where clauses.
Only grab a new stack trace if we don't have one cached, or if the one cached does not match the type of stack trace being requested.
Only handle branch instructions.
Only handle branch or conditional branch instructions.
Only handle classes defined within the SILModule's associated context.
Only handle imported ObjC generics.
Only handle innermost loops for now.
Only handle innermost loops.
Only handle integer operations for now.
Only handle integer values
Only handle members defined within the SILModule's associated context.
Only handle reachable blocks.
Only handle single exit blocks for now.
Only handle single operands for simple recursion without a worklist.
Only handle struct and tuple type.
Only here if we ran out of data
Only hoist releases very late.
Only honor null_result if we actually imported as a non-optional type.
Only if debug info is enabled.
Only if it is the 3rd month is both the start and end of the year required.
Only if no flags are set (optimization)
Only if the current loop is actually the "main part" in the outer loop we add the full loop weight for the outer loop.
Only if the day number is actually found to be in the ambiguous period of 29 to 31 days is the other molad calculated.
Only if the definition is alive, the user itself is alive.
Only in the event that we are currently in the process of an io, will we output the iostatus, and ioInProcessDuationMicros
Only include callers which we are actually recomputing.
Only include free blocks if requested.
Only include functions that are definitions, and which have not been intentionally excluded from optimization.
Only increment NumOutputs if this is an output which must have its path specified using -o.
Only indent if it is pending and if it is not an empty line
Only inline trivial functions into thunks (which will not increase the code size).
Only insert an indexed type into the unique vector if its not equal (for the purposes of merging) as the last indexed type in the vector.
Only instance members of classes can be dynamic.
Only instance methods returning () can be IBActions.
Only instance methods.
Only instance properties can be 'IBInspectable'.
Only instance properties can be 'IBOutlet'.
Only intended for use by lookupOperatorDeclForName.
Only interested in macro definitions.
Only introduce 'dynamic' on declarations...
Only introduce for an AbstractStorageDecl if it is not local.
Only known protocols can be derived.
Only left in intern map.
Only load the HDF value if it was specified, don't use the defaults.
Only look at some conditional branches with no side effects.
Only look through the current module if it's not top-level.
Only makes sense for members of types.
Only methods in the 'init' family can become constructors.
Only methods, properties, subscripts and constructors can be NonObjC.
Only nodes with outdegree zero are put into the queue, which is how nodes in a cycle get excluded.
Only non-failing initializers can throw.
Only non-static members.
Only nothrow when we know it's a private declared property (and thus accessible here).
Only object types (which are recorded as being pointer followable) pass, as do void pointers (though we cannot generate layout for them).
Only one of the operands to XOR must have the top bit set.
Only one pointer-to-address is allowed for safety.
Only one witness table we should be able to return, which is the ErrorProtocol.
Only parameter adjustments.
Only perform the peephole if both operands are physical and there's no semantic conversion necessary.
Only pick methods declared in this class, in order to match Zend's order.
Only predict objectness, not the specific class type.
Only print the class if the property is private and declared in a parent class.
Only print the parentheses if there are some argument names, because "()" would indicate a call.
Only process partial apply if the callee is a known function.
Only process store insts.
Only properties of simple types can be optimized.
Only protocol members can be optional.
Only provide a TypeLoc if it makes sense to allow diagnostics.
Only purge if ratio-based purging is active.
Only purge if the thread's assigned arena is one of those created for use by request threads.
Only push if top exists.
Only qualified lookup ever finds anything in the builtin module.
Only record non-local USRs.
Only recurse if this node differs from the equivalent one in children, in order to keep recursion from being of exponential complexity.
Only reference cast to simple single pointer representations.
Only reference the witness if the protocol requires it.
Only remember the offset.
Only remove the first occurance of "n".
Only replace the disjunctive overload constraint.
Only report line terminators if we find one other than LF, or if we find none at all.
Only return a larger value if it wouldn't be truncating the precision.
Only returns nullptr if the callee is the top level pseudo-main
Only root classes can have the attribute.
Only searched a part of m_breakpoints.
Only serialize CPP extension type instances which can actually be deserialized.
Only set 'sret' if this is also the formal result.
Only set regstate back to dirty if an exception is not propagating.
Only set the class for static closures.
Only several types of modes are allowed
Only show colors if both stderr and stdout have colors.
Only some of these will / result in conformances that are attributed to this declaration / context.
Only specialize functions in their home module.
Only specify the module map if that file actually exists.
Only split critical edges for terminators that don't support block arguments.
Only supports a architecture-dependent binary dump format at the moment.
Only the empty tuple is a leaf.
Only the encoded type+index pair will be compared.
Only the first backend job owns the compilation job (to prevent multiple de-allocations of the compilation job).
Only the first error is ok
Only the function pointer value is used for extra inhabitants.
Only the payload case has anything to project.
Only the source's payload needs to be taken or destroyed.
Only thing we need to check is that the element is the same.
Only thread 'small blocks'.
Only top-level func decls are currently supported.
Only trace through backwards jumps if it's a JmpNS and we're inlining.
Only track one different operand for now
Only traverse into basic blocks that dominate all exits.
Only try and favor monomorphic initializers.
Only try to correct very simple imbalances...
Only unserialize CPP extension types which can actually support it.
Only unwrap the paren sugar, if it exists.
Only update and mark if we actually make the linkage more restrictive.
Only use a point that is in the image.
Only use simple types like 'std::string', 'std::vector', 'std::map' etc.
Only use the cache if it is not the current module.
Only use the new calling conventions on platforms that support it.
Only used for phi nodes, to avoid processing them more than once.
Only used to look for callers by function name.
Only uses non reference counted values.
Only valid for a result.
Only valid for reabstraction kinds.
Only valid if the IP is valid.
Only value declarations matter.
Only visit each archetype once.
Only visit each constraint once.
Only visit the members for a class defined natively.
Only wait ServerPreShutdownWait seconds for the page server.
Only walk into the 'do' clause of a do/catch statement if the catch isn't syntactically exhaustive.
Only white-listed flags below are allowed to be embedded.
Only with word characters, spaces and the dot ('.') we can still attempt to offer a completion to the user
Only work if the instruction does not have side effect.
Only works for a module interface document currently.
Only works for allocating initializers...
Only worry about classes that can be instantiated.
Ooops, the custom scanner function doesn't have a symbol, which probably means it doesn't have external linkage.
Oops, we have too many smaller stores generated, bail out.
Op must implement the interface described for cellIncDecOp.
Opaque existential containers uniquely own their contained value.
Opaque existentials are address-only.
Opcode arguments must be on the same line as the opcode itself, although certain argument types may contain internal newlines (see, for example, read_jmpvector or string literals).
Opcode located at the 6 most significant bits
Opcode, Func, Dest, SyncPoint, Args
Open a member constraint for constructor delegations on the subexpr type.
Open a new log file: determine the start of the current period, generate the log file name from the fileTemplate, determine the end of the period and open the new log file.
Open an existential value into a new, opaque value of / archetype type.
Open destination file
Open in "create" mode (writing only, create if needed, no truncate) so that the file is not modified before we attempt to aquire the requested lock.
Open in binary mode if we're doing binary output.
Open session handler first
Open the connection and get the first set of results.
Open the existential value into the opened archetype value.
Open the nominal type.
Open the type of the generic function or member of a generic type.
Open the type we're casting to.
Open up the existential.
Open up the generic parameter list for the container.
Open up the generic parameters and requirements.
Open up the generic type.
Open up the type of the member.
Open up the type of the requirement.
Open up the type we're checking.
Open up the witness type.
Open up unbound generic types, turning them into bound generic types with type variables for each parameter.
Open-code certain protocol witness "thunks".
Open-code the setMutating() calculation since we might run before the setter has been type checked.
OpenCL types that don't have Swift equivalents.
OpenMP types that don't have Swift equivalents.
OpenSSL cipher strings are case sensitive.
Opened existential types use a separate layout.
Operand is defined outside the loop.
Operand is outside the loop or marked invariant.
Operand of the existential_metatype instruction.
Operate on the representative.
Operate on the representatives
Operation previously started with startXXX has finished
Operator decls aren't needed for IRGen.
Operator identifiers aren't valid in the contexts that are building more specific identifiers.
Operator instructions
Operator lookup is always global.
Operators and closures cannot have API names.
Operators and normal function calls are just (CallExpr DRE)
Operators cannot use these implicit conversions.
Operators do not have argument labels.
Operators implementations may only be defined as functions.
Operators needed for Cookie Serialization
Optimistic case: the object might already be created.
Optimization for if no strip flags are set
Optimization that tries to hoist CheckType instructions so that we can specialize code earlier and avoid generic operations.
Optimize Copy-On-Write array checks based on high-level semantics.
Optimize FPushClsMethod when the method is a known static string and the input class is the context.
Optimize US-ASCII case
Optimize `region's retranslation chain rooted at block `rootId'.
Optimize access to the global variable, which is known / to have a constant value.
Optimize access to the let property, which is known / to have a constant value.
Optimize an array operation that has (index_raw_pointer b, sizeof(T) * Dist) / operands into one that use index_addr as operands.
Optimize away the pattern below that happens when exceptions are created and in some cases, due to inlining, are not needed.
Optimize branches of a conditional expression separately.
Optimize builtins which receive the same value in their first and second / operand.
Optimize overflow checks.
Optimize placement of initializer calls given a list of calls to the / same initializer.
Optimize readonly functions with no meaningful users.
Optimize retain/release pairs based on Builtin.unsafeGuaranteed
Optimize storage of the created TransRec.
Optimize structs that are generated from struct_extract instructions from the same struct.
Optimize the `region's guards, operating on one retranslation chain at a time.
Optimize the access to globals if possible.
Optimize the addressors if possible.
Optimize the checked_cast_br instructions in a function.
Optimize the constraints.
Optimize the placement of global initializers.
Optimize this case for unsigned and equality comparisons: cmp_*_T .
Optimize tuples that are generated from tuple_extract instructions from the same tuple.
OptimizeProtocolNames
Optimized for sequential read: see AssetManager.java for docs
Optimizes binary bit operations.
Option parser helpers
Optional and IUO are interchangeable if their elements are.
Optional class methods
Optional instance methods
Optional methods in protocols.
Optional subscripts in protocols.
Optional thick metatypes are ABI-interchangeable with non-optionals too.
Optional to optional.
Optional types are default-initializable.
Optional's payload is currently maximally abstracted.
Optional-to-optional conversion.
Optional-to-optional.
Optional-to-value, normally disallowed.
Optionally add .xt file extension
Optionally also by adding a constant offset.
Optionally drill down into an apply to see if the operand is captured in or returned from the apply.
Optionally examine the body of partial_apply / to see if there is an unexpected use inside.
Optionally, the connect can be made asynchronously, which will implicitly enable non-blocking mode on the socket.
Optionals preserve variance.
Options contain information about the developer's computer, so only serialize them if the module isn't going to be shipped to the public.
Options for PHP7 features which break BC.
Options passed to pcre_exec
Options that can be passed
Options through array
Opts.RuntimeImportPath is set by calls to setRuntimeIncludePath() or setMainExecutablePath() and  updated by calls to setTargetTriple() or parseArgs().
Opts.RuntimeIncludePath is set by calls to setRuntimeIncludePath() or setMainExecutablePath().
Or a conditional branch back to the header.
Or are part of an identified loop but are not a loop header.
Or if we get any error other than the file not existing
Or if we've got AllFuncsInterceptable we need to assume someone could rename a function to the new name.
Or it is somewhere above the entry block, then we can leave the / instruction there.
Or it was just too large.
Or kill it and reset the return value if the ping somehow failed
Or maybe we can change the mangling at the same time we make changes to better support thin functions.
Or the extension with fewer protocols.
Or the other type is a typedef,
Or two words, if it's vacuous.
Or, Mutable can occur in the type name only.
Or, if we see a conversion successfully applied to a string interpolation argument, we're done.
OrdStr depends on a string as input for its vasm implementation.
Order based on protocol name.
Order is important here: types must progress from more specific to less specific to return the most specific DataType.
Order is important in this enum: it's only legal to transition to states with higher values, and states are merged using std::max().
Order of subpattern matches
Order the blocks for bytecode emission.
Order the dependent types canonically.
Ordering is as follows: - Generic params
Ordinary Gen values with a known DataType only get one register.
Ordinary non-builtin object subclass, or IDL-style native object.
Organize conformance constraints, sifting out the base class requirement.
Original cache behavior: an empty entry is also a "file".
Other ASCII control characters should get escaped.
Other TypeDecls don't need their types mangled in.
Other accessors are never selector family members.
Other branch instructions send the same state to all successors.
Other cases could leave the base as anything (if nothing else, via ArrayAccess on an object).
Other cases we're not sure about (maybe some non-unique classes got in the way).
Other classifications below.
Other existentials have standard representations.
Other existentials use standard representation.
Other final member operations pop their first immediate + 1
Other function representation attributes are not normally supported at source level, but we want to support them there in SIL files.
Other functions have argument labels for all arguments
Other instructions are assumed to capture the AllocStack.
Other instructions can be duplicated.
Other instructions can be moved to the preheader.
Other kinds of metadata don't cast to AnyObject.
Other kinds of types don't have class objects.
Other lowers that didn't fit the macros above or are not so numerous.
Other metadata routines
Other notes: if there is a redirect the POST becomes a GET request, see curl_easy_setopt(3) and the CURLOPT_POSTREDIR option for more information
Other parameter lists cannot be uniqued because the decls / within them are always different anyway (they have different DeclContext's).
Other reference storage types all have the same layout for their storage qualification and the reference counting of their underlying object.
Other representations are reserved for future use by the stdlib.
Other requirements come from the extended type and have already been checked.
Other result types are not permitted.
Other smashable control flow instructions are three instructions plus inline 64-bit data, so it needs to be one instruction off from 8-byte alignment.
Other than inserting the end-of-lifetime, the deallocation is a no-op.
Other than loads from the unowned-referenced object we only accept speculatively executable instructions.
Other things can be captured if they are local.
Other things people escape, but shouldn't need to, so we disallow them
Other thread must have inc/dec ref'd since we got cur
Other threads can continue to use the current chunk, or block on the lock if they also find the need for a new chunk.
Other threads will stack up in blockUntilOwn() (depending on the thread mode).
Other tokens are already accounted for.
Other types (i.e. Int and Double) must be handled outside of this.
Other types are preserved through lowering.
Other types get substituted into context normally.
Other types must match exactly.
Other types should not structurally contain lvalues.
Other uses of the container are considered escapes of the value.
Otherwise LLVM would remove the definition (if it's not referenced in the same file).
Otherwise PHP-compare.
Otherwise PackedArrayInit can't be used because non-numeric keys are preserved even when preserve_keys is false
Otherwise add all non-debug uses of I to the worklist.
Otherwise add it to our leaf list.
Otherwise add the increment to the delete list.
Otherwise advance the sequence...
Otherwise attempt to strip off one layer of RC identical instructions from User.
Otherwise be conservative and return that the two types may alias.
Otherwise be conservative and return that we may have side effects.
Otherwise check for direct inheritance.
Otherwise check if the reference counted value we are tracking could be used by the given instruction.
Otherwise check if we have a non-trivial type.
Otherwise check to see if this is a ConstructorRefExpr on a TypeExpr with sugar on it.
Otherwise closure must be a thin_to_thick_function.
Otherwise compute it if we have a __toDebugDisplay method.
Otherwise consider it to be a general mismatch so we only list it in an overload set as a last resort.
Otherwise create a release value.
Otherwise create the release_value before the terminator of the predecessor.
Otherwise either create an aggregate builder for the parent or reuse one that has already been created for it.
Otherwise emit a class method.
Otherwise emit a diagnosis error and set ResultsInError to true.
Otherwise emit our diagnostics and then return nullptr.
Otherwise emit the appropriate diagnostic and set ResultsInError.
Otherwise emit the diagnostic, set ResultsInError to be true, and return nullptr.
Otherwise explode and re-implode.
Otherwise gcc notices that it is empty, and optimizes away the call.
Otherwise generate the thunk body just in case.
Otherwise give the entire call pattern.
Otherwise handle option sets.
Otherwise if Other is not nominal, return true since we always sort decls before indices.
Otherwise if it is the requirement we are looking for or we just want to deserialize everything, add the function to the list of functions to deserialize.
Otherwise if our payload is non-trivial but lacking reference semantics, insert the release_value.
Otherwise if the type has external linkage, look for any type elsewhere (with external linkage) with the same name and having a complete definition.
Otherwise if we have no witness table yet, create it.
Otherwise increment reverse iterators.
Otherwise it belongs to the body
Otherwise it is defined to perform the merge.
Otherwise it must be a pattern binding.
Otherwise it returns false.
Otherwise it will happen when the object is swept later
Otherwise it will return MAP_FAILED.
Otherwise it would be canonicalized to CWD, which is inconsistent with PHP and most filesystem utilities.
Otherwise it would clobber the ActRec we just pushed.
Otherwise just delegate to the parent.
Otherwise just propagate through the parameter info.
Otherwise just type check the subexpression independently.
Otherwise just use the given message.
Otherwise kInvalidOffset.
Otherwise leave the original cleanup and retain the cast value.
Otherwise look on disk.
Otherwise lookup by extension.
Otherwise make the ret instruction part of the cleanups.
Otherwise merge the current state into the existing snapshot.
Otherwise modify the state appropriately in preparation for removing the increment, decrement pair.
Otherwise pass in the Name and DeclKind and the / DebuggerClient will be asked whether to move it or not.
Otherwise pass it as Direct_Owned.
Otherwise perform the transformation.
Otherwise pop as a Use::Used.
Otherwise record the operand with the earliest use last in the list.
Otherwise record the operand.
Otherwise remove the commented code completely.
Otherwise remove the dead live range that is only copied into.
Otherwise replace all uses at this level of the tree with uses of the Leaf value.
Otherwise report the overflow error.
Otherwise return None.
Otherwise return an empty SILType
Otherwise return false.
Otherwise return nullptr.
Otherwise return the PBD in "Decls" to the caller.
Otherwise return the data associated with this successor.
Otherwise returns false.
Otherwise run the rest of diagnostics.
Otherwise see if we previously computed the callees based on witness tables.
Otherwise short-circut the connection attempt, and say we failed right away
Otherwise swap our true and false arguments.
Otherwise the STL allocator tries to avoid the high cost of doing allocations by pooling memory internally.
Otherwise the base will be left alone and we'll fatal.
Otherwise the dataflow solution could be too conservative.
Otherwise the destroy (which can invoke user code) could see invalid memory at this address.
Otherwise the local will start uninitialized, like normal.
Otherwise the location is untracked.
Otherwise the mode should contain 0 for unsetting and 1 for setting the flag.
Otherwise the new function could have an external linkage (in case the original function was de-serialized) and would not be code-gen'd.
Otherwise the payload is just the index.
Otherwise the static member lookup was invalid because it was called on an instance
Otherwise there will be one for each possible path through the inheritance hierarchy, potentially excluding cases that we know would definitely fatal when defined.
Otherwise this decl is invalid and the accessors have been rejected above.
Otherwise this is a getter/setter/etc for a variable.
Otherwise this is a read and write of the base.
Otherwise this is a valid decl attribute so they should have put it on the decl instead of the type.
Otherwise this is not a context-sensitive keyword.
Otherwise this is the start of a class declaration.
Otherwise ties are broken by biased rounding (add half and chop).
Otherwise try and lookup a witness table for C.
Otherwise try to deserialize it.
Otherwise use normal visitor, which clones the existing instruction but remaps basic blocks and values.
Otherwise we can just overwrite the most recent begin frame
Otherwise we clear all state.
Otherwise we conservatively treat all these cases as "possibly" being inside of an object property with "PostProp" with locType TTop.
Otherwise we continue processing the reference count decrement to see if the decrement can affect any other pointers that we are tracking.
Otherwise we do a linear search through the cases calling string conversion routines.
Otherwise we do not know how to handle this instruction.
Otherwise we do not understand this instruction, so bail.
Otherwise we have a live leaf, add its index to our LiveLeafIndices list.
Otherwise we just output as lower
Otherwise we need to split the current block at the insertion point.
Otherwise we need to store, bitcast, and load.
Otherwise we want to try and link in the callee...
Otherwise we will be jumping out of the current context, therefore if we are in a loop, we need to free the iterator.
Otherwise we'll get the previous TypeCheckData back so we can modify it.
Otherwise we'll promote this when we deal with hooking up phis.
Otherwise we're storing a ResourceData instance, so just release our reference to it.
Otherwise we're stuck and have to separately allocate.
Otherwise, 'materialized' holds an optional callback and the callback storage.
Otherwise, Left must be false and false AND'd with anything else yields false.
Otherwise, Left must be true and true OR'd with anything else yields true.
Otherwise, ObjC protocols use ObjC method dispatch, and Swift protocols use witness tables.
Otherwise, a boolean value is returned indicating whether the batch was successfully sent.
Otherwise, a self.init call must have location info, and must be an expr to be considered.
Otherwise, a store just writes.
Otherwise, access via indirect "resilient" interfaces.
Otherwise, add a BB arg to the continuation block to receive loadable result.
Otherwise, add a new entry.
Otherwise, add all of User's uses to our list to continue searching.
Otherwise, add all the vtable functions in Vtbl to the function processing list...
Otherwise, add an 's' and try again.
Otherwise, add it as an opaque blob.
Otherwise, add normal instructions to the worklist for processing.
Otherwise, add this case to our predecessor case list.
Otherwise, add this new removal range.
Otherwise, add up the elements.
Otherwise, add value names only if the final result is textual LLVM assembly.
Otherwise, adjust the argument index.
Otherwise, advance through the completion state machine.
Otherwise, all of our users are sane.
Otherwise, all the constraints look ok, diagnose this as an ambiguous expression.
Otherwise, all unsubstituted payload types are fixed-size and we have no constraints on what spare bits we can use.
Otherwise, all we need to do is register with the ObjC runtime.
Otherwise, allocate a fixed-size buffer and possibly heap-allocate a payload at runtime if the runtime size of the type does not fit in the buffer.
Otherwise, allocate one temporarily.
Otherwise, allocate using Swift's routines.
Otherwise, allow the CRTP substruct to update itself given we have a potential decrement.
Otherwise, any type is fine.
Otherwise, apply the default rules.
Otherwise, apply the mask to the existing value.
Otherwise, apply these arguments to the result of the previous call.
Otherwise, artifacting occurs.
Otherwise, ask the runtime to extract the dynamically-placed tag.
Otherwise, ask the transition state if this instruction causes a transition that can be matched with the transition in order to eliminate the transition.
Otherwise, assemble the tuple value and manage that.
Otherwise, assign this input to the next output element.
Otherwise, assume it is a single pipeline operator and allow it to be wrapped in an array.
Otherwise, assume that Inst can use Target.
Otherwise, assume we might break or continue.
Otherwise, attempt to find the tag associated with this BB in the switch enum...
Otherwise, avoid nuking whitespace that might be zapped through other means.
Otherwise, bitwise-or it in, brazenly assuming there are zeroes underneath.
Otherwise, boolean true is returned if the document is not empty.
Otherwise, boolean true is returned.
Otherwise, branch to it if the current IP is reachable.
Otherwise, branch to the continuation block and start inserting there.
Otherwise, branch to the next iteration's header.
Otherwise, break down the decision tree.
Otherwise, build a struct value directly from the elements.
Otherwise, call a lazy-cache function.
Otherwise, call emitCGet to convert the top of stack to cell
Otherwise, call the memoized func, store the result, and return it
Otherwise, carry out the command and return true.
Otherwise, check for an ambiguity.
Otherwise, check to see if the current byte is a control character.
Otherwise, check whether this macro is identical to a macro that has already been imported.
Otherwise, claim the next value from the input and store that in the field.
Otherwise, className will be used to look up a class.
Otherwise, classify the function implementation.
Otherwise, collect references to all of the inherited protocol descriptors.
Otherwise, collect the single scalar.
Otherwise, complain about use of instance value on type.
Otherwise, compute and cache it.
Otherwise, conservatively stick it at the beginning of the block.
Otherwise, consult the instruction map.
Otherwise, continue looking for more arc operations.
Otherwise, continue trying to load dependencies, so that we can list everything that's missing.
Otherwise, convert both sides to booleans (with null becoming false).
Otherwise, copy the value into a temporary.
Otherwise, create a fresh type variable.
Otherwise, create a new argument which copies the original argument
Otherwise, create a new clone.
Otherwise, create a new doc.
Otherwise, create a new function.
Otherwise, create a new potential archetype for this associated type and make it equivalent to the first potential archetype we encountered.
Otherwise, create a new string literal.
Otherwise, create a new witness table declaration.
Otherwise, create a type variable saying we know nothing about this expr.
Otherwise, create and emit a new block.
Otherwise, create it and remember that this is a forward reference
Otherwise, create it and remember that this is a forward reference so that we can diagnose use without definition problems.
Otherwise, create one and return it.
Otherwise, create the module
Otherwise, create the retain_value.
Otherwise, create the wrapping return.
Otherwise, ctx is derived from baseClass, so we know this protected property is accessible and we know ctx cannot have private property with the same name, so we're done.
Otherwise, data may be invalid when DecodeRfc1867 returns.
Otherwise, deallocate the original value wholesale if we couldn't take it.
Otherwise, decrement our iterator.
Otherwise, delegate to the parent.
Otherwise, destroy and copy-initialize.
Otherwise, desugar one level...
Otherwise, diagnose this as an invalid capture.
Otherwise, do a memcpy of the dynamic size of the type.
Otherwise, do a normal assignment.
Otherwise, do a recursive parse.
Otherwise, do a switch.
Otherwise, do the dynamic dispatch inline.
Otherwise, do the normal thing.
Otherwise, eat other characters.
Otherwise, either call a function or curry it.
Otherwise, emit a direct call.
Otherwise, emit a function_ref.
Otherwise, emit an access function.
Otherwise, emit an error and return true.
Otherwise, emit an error message on the expr we have, and emit a note about where the archetype came from.
Otherwise, emit as a single independent value.
Otherwise, emit the default initializer, then map that as a default argument.
Otherwise, emit the result (to get any side effects), but produce it at +0 if that allows simplification.
Otherwise, emit the scalar assignment.
Otherwise, emit the uncurried arguments now and perform the call.
Otherwise, emit the value into memory and use the optional intrinsic.
Otherwise, emit to a temporary.
Otherwise, evaluate the payload.
Otherwise, fake up an ErrorExpr.
Otherwise, fall back on the ARC annotations, which are part of the type.
Otherwise, fall back to UTF-8.
Otherwise, fall back to code.main and retry.
Otherwise, fall through into the 'other decl' case.
Otherwise, fall through.
Otherwise, favor native entry points for direct accesses.
Otherwise, figure out the type of the constructor function and coerce to it.
Otherwise, fill in with the appropriate number of invalid special dests.
Otherwise, find the best path from one of the protocols directly conformed to by the protocol, then get that conformance.
Otherwise, find the conformances.
Otherwise, finish the translation now.
Otherwise, flatten one level of struct elements on each side.
Otherwise, flatten one level of tuple elements on each side.
Otherwise, follow the Eval.JitAMaxUsage limit.
Otherwise, for now, always use an opaque indirect type.
Otherwise, forcibly emit into the initialization if it exists.
Otherwise, form an UnresolvedDotExpr and sema will resolve it based on type information.
Otherwise, get information from our superclass first.
Otherwise, get the fixed layout information from reflection / metadata.
Otherwise, get them from the metadata.
Otherwise, give up on adjusting the name.
Otherwise, go satisfy the derivable requirement, which can introduce a member that could in turn satisfy *this* requirement.
Otherwise, grab the next result.
Otherwise, if a comma exists consume it and succeed.
Otherwise, if it has trivial type, we can always just replace the assignment with a store.
Otherwise, if it is a remapping we can't handle, don't try to compute a substitution.
Otherwise, if iteration is finished we just return null.
Otherwise, if tc is an opt type and stackT cannot be InitNull, then we can safely use unopt(tcT).
Otherwise, if the callee function had sugar on the result type, but it got dropped, make sure to propagate it along.
Otherwise, if the epilog block is reachable, return the return value.
Otherwise, if the increments operand stripped of RC identity preserving ops matches EnumValue, it is the first increment we are interested in.
Otherwise, if the instruction has a fall-through, then insert a jump to the next offset, since it may not be the next block to be translated.
Otherwise, if the instruction uses the alloc_stack result, treat it as interfering.
Otherwise, if the origin gives rise to a better path, that's also cool.
Otherwise, if the original parameter type was not a throwing function type, it does not contribute to 'rethrows'.
Otherwise, if the requirement is settable, ensure that there's a materializeForSet function.
Otherwise, if the substituted type is a tuple, then we should emit the tuple in its most general form, because there's a substitution of an opaque archetype to a tuple or function type in play.
Otherwise, if the type is an unbound generic of the context type, use the context type to resolve the parameters.
Otherwise, if there is a closure in the subexpression, we can violate invariants.
Otherwise, if there is exactly one use of the return block, merge it into its predecessor.
Otherwise, if there is no fallthrough, then the next row is unreachable: emit a dead code diagnostic.
Otherwise, if there isn't a better path through this base, don't accumulate anything in the path.
Otherwise, if there's a dval or no need to check for a full match, stop when there are too many digits for a int64
Otherwise, if there's a linkage name, demangle it, and strip off everything except the last section, and use that as the base name.
Otherwise, if this function type has a guaranteed self parameter type, make sure that we have a +0 self param.
Otherwise, if this is a calling convention thunk we haven't emitted yet, emit it.
Otherwise, if this is a function candidate with an argument, we mismatch argument count.
Otherwise, if this is a subscript, validate that covariance is ok.
Otherwise, if this is some other pointer, we can only ignore it if we can prove that the two objects don't alias.
Otherwise, if we are in an extension there might be other associated types brought into the context through `extension ...
Otherwise, if we have a non-final class dispatch to a normal method, perform a dynamic dispatch.
Otherwise, if we see a jcc but only one of the branches is a normal exit, then convert the jcc to a bindexit with the jcc's condition and the original bindjmp's dest.
Otherwise, ignore the base and return the static thin metatype.
Otherwise, increment our iterator.
Otherwise, infer based on the method family.
Otherwise, insert a retain_value on the payload.
Otherwise, insert at the end of the current section.
Otherwise, insert it into the global cache.
Otherwise, insert it into the map by creating a new object on the heap using the supplied arguments.
Otherwise, intermediate props with define can promote a null, false, or "" to stdClass.
Otherwise, introduce a new vtable entry.
Otherwise, it can be referenced statically.
Otherwise, it failed, which emitted a diagnostic.
Otherwise, it is a leaf element.
Otherwise, it is a single element.
Otherwise, it is a structural problem, diagnose that.
Otherwise, it is a subscript, check the index values.
Otherwise, it is a use of the argument.
Otherwise, it is an RC user that our user wants.
Otherwise, it is an RValue let.
Otherwise, it is partially live, save it for later processing.
Otherwise, it is probably a missing member.
Otherwise, it may not dominate all uses of the source.
Otherwise, it might come from a default argument.
Otherwise, it must be a failure BB where we leak, continue.
Otherwise, it must be an index type.
Otherwise, it must match the corresponding expected argument type.
Otherwise, it really does look like this comma continues the pattern clause, so eat it and parse the next clause.
Otherwise, it should be one of the builtin functions.
Otherwise, it should be parented by the innermost function.
Otherwise, it throws unconditionally.
Otherwise, it was returned as a direct result.
Otherwise, it was the last thing we added to the layout.
Otherwise, it'll have been separately type-checked.
Otherwise, it's a CF return type, which unfortunately means we can't just trust getMethodFamily().
Otherwise, it's a concrete type.
Otherwise, it's a conformance.
Otherwise, it's a direct result.
Otherwise, it's an explosion, which we may need to translate, both in terms of explosion level and substitution levels.
Otherwise, it's bridged.
Otherwise, it's postfix if left-bound and prefix if right-bound.
Otherwise, it's scalar.
Otherwise, iterate over all the conservative guards, seeing if any are interesting.
Otherwise, just add the expression as a candidate.
Otherwise, just delete the copy_addr.
Otherwise, just diagnose starting at the storage declaration itself.
Otherwise, just emit the injected value directly into the result.
Otherwise, just fall back to emitting a switch to decide.
Otherwise, just fill in null here if the type can't be statically queried for extra inhabitants.
Otherwise, just forget we had a setter.
Otherwise, just insert the closing ")".
Otherwise, just move the IP to the return block.
Otherwise, just record the need for this metadata.
Otherwise, just release the error.
Otherwise, just remember that this value is available.
Otherwise, just remember the fact we used this conformance.
Otherwise, just remember the next non-fixed offset index.
Otherwise, just report that they are block special files and go on to the next file.
Otherwise, just respect genericity and Objective-C runtime visibility.
Otherwise, just return SILValue().
Otherwise, just return the info we have about the parameter.
Otherwise, just store it in our map.
Otherwise, just update the existing reachabilities in-place.
Otherwise, keep going up the VM stack for this nesting level.
Otherwise, keep going.
Otherwise, keep looking.
Otherwise, keep scanning the block.
Otherwise, keep scanning.
Otherwise, keep searching.
Otherwise, leave a placeholder for the runtime to populate at runtime.
Otherwise, leave it in the list.
Otherwise, leave zero as a placeholder.
Otherwise, linkage is determined by accessibility at the AST level.
Otherwise, load and return the final 'self' value.
Otherwise, load it from the metadata.
Otherwise, load the constant out of RDS.
Otherwise, look at the conformance list.
Otherwise, look at the operands.
Otherwise, look for a disjunction constraint explaining what the set is.
Otherwise, look for a function with this name in the module.
Otherwise, look for a global with this name in the module.
Otherwise, look for completions.
Otherwise, lookup the BBState associated with the successor and merge the successor in.
Otherwise, lookup the ID and Type and store them in the map.
Otherwise, lower the substituted type using the abstraction patterns of the original.
Otherwise, lowercasing will either be a no-op or we have ALL_CAPS.
Otherwise, make a GEP.
Otherwise, make a pass over the path looking for available concrete entries in the IGF's local type data cache.
Otherwise, make an Initialization that stores the value in the next element of the directResults array.
Otherwise, make sure the value is in the context.
Otherwise, make sure we emit into the slot.
Otherwise, map the dominator structure using the mapped block.
Otherwise, mark each of the loop latches as irreducible control flow edge tails so we are conservative around them.
Otherwise, mark it uninitialized for DI to resolve.
Otherwise, materialize to a temporary.
Otherwise, metatypes aren't class objects.
Otherwise, move F over to NewF.
Otherwise, move the block to after the first predecessor.
Otherwise, move the constant over to the right.
Otherwise, must be unary.
Otherwise, name not found.
Otherwise, normal instructions just go on the worklist for processing.
Otherwise, only public functions can be referenced.
Otherwise, order by buffer identifier.
Otherwise, parse the fully general form.
Otherwise, perform another iteration.
Otherwise, perform substitutions to create this witness now.
Otherwise, perform the heavy lifting now.
Otherwise, pick the earlier file unit.
Otherwise, preserve function type attributes from the substituted type.
Otherwise, preserve it.
Otherwise, print all the concrete defining accessors.
Otherwise, print the Builtin Types.
Otherwise, print the type, then each value.
Otherwise, process this by turning the values corresponding to the tuple into a single value (through an implosion) and then binding that value to our initialization.
Otherwise, process this loop.
Otherwise, produce a candidate set.
Otherwise, produce a more generic error.
Otherwise, produce a temporary and copy into that.
Otherwise, project from the base.
Otherwise, project out the value and carry on.
Otherwise, propagate upwards.
Otherwise, propagateLVAK will handle this.
Otherwise, pull the front value off the list.
Otherwise, put it next to the swiftmodule file.
Otherwise, put it there.
Otherwise, put the module next to the top-level output.
Otherwise, query specifically for the original type.
Otherwise, queue up a scalar assignment to an lvalue.
Otherwise, raise a warning and serialize null.
Otherwise, rebuild the type.
Otherwise, record it if we're supposed to accept default arguments here.
Otherwise, recurse on the underlying type in order to compute the hint correctly.
Otherwise, recursively descend into the tuples.
Otherwise, remember it for later.
Otherwise, remember this field number.
Otherwise, remove any local dead closures that are now dead since we specialized all of their uses.
Otherwise, replace top.
Otherwise, report the resolved overloads.
Otherwise, require the last parameter to be an out-parameter.
Otherwise, require the state exactly match.
Otherwise, resolve the declaration.
Otherwise, resolve the macro.
Otherwise, resume into the continuation block.
Otherwise, return SILValue() to bail.
Otherwise, return a dataflow result containing a +1.
Otherwise, return false with no effect.
Otherwise, return false.
Otherwise, return nullptr.
Otherwise, return the index.
Otherwise, return the return value.
Otherwise, return the rvalue type.
Otherwise, return the stored canonical signature.
Otherwise, see if a layout has been emitted with these characteristics already.
Otherwise, see if there are any instructions in between FirstPredInc and the end of the given basic block that could decrement first pred.
Otherwise, see if we can find a retain_value or strong_retain associated with that enum in the relevant predecessor.
Otherwise, see if we can introduce a cast pattern to get from an existential pattern type to the enum type.
Otherwise, see whether we had an enum type as the penultimate component, and look up an element inside it.
Otherwise, select a region for `callee' if one is not already present in `retry'.
Otherwise, select m_gpArgs or m_stkArgs depending on how many args we've already pushed.
Otherwise, send the buffered output to stderr, though only if we support getting buffered output.
Otherwise, set result to that value.
Otherwise, set the previous projections operand to the incoming argument.
Otherwise, simply substitute the parent type into the member.
Otherwise, simultaneously emit and reabstract.
Otherwise, since we do not have enough information, we can only emit at +0 for immediate clients.
Otherwise, skip forward by the size of the element.
Otherwise, skip the lookup to avoid infinite recursion.
Otherwise, some part of the copy_addr's value is demanded by a load, so we need to explode it to its component pieces.
Otherwise, sort by protocol.
Otherwise, sort by source order.
Otherwise, specialize on the necessary column.
Otherwise, splice it in to the parameters at the right position.
Otherwise, split the caller's basic block to create a return-to BB.
Otherwise, start all over with our new LHS.
Otherwise, stop traversing.
Otherwise, store the single scalar.
Otherwise, store to the destination and return true.
Otherwise, strip it off so that we can optimize the body more.
Otherwise, substitute the constrained types.
Otherwise, swift_initClassMetadata_UniversalStrategy() will point the Objective-C runtime into the field offset vector of the instantiated metadata.
Otherwise, switch on the type of the left operand to emit the right kind of comparison.
Otherwise, t.toString() will be used as the expected string.
Otherwise, the archetype needs to be from this scope.
Otherwise, the attribute is always ok on an operator.
Otherwise, the block with the unreachable terminator will be a non-local successor.
Otherwise, the bound value for the enum case is available.
Otherwise, the caller should call Tcl_UtfCharComplete() before calling this routine to ensure that enough bytes remain in the string.
Otherwise, the closure implicitly forms a call.
Otherwise, the destination is erroneous.
Otherwise, the error is that the result types mismatch.
Otherwise, the extension method might be favored if we're inside an extension context, since any archetypes in the parameter list could match exactly.
Otherwise, the final context is the reabstraction context.
Otherwise, the first declaration is shadowed by the second.
Otherwise, the following line sets YYVAL to garbage.
Otherwise, the given offset doesn't belong to the region, so we just create an exit block.
Otherwise, the inner result is direct.
Otherwise, the intersection is non-empty and has no specialized information inside the intersecting portion to consult.
Otherwise, the last line of the file does not have a newline.
Otherwise, the lvalue access is performed with a fragile element reference.
Otherwise, the member needs to be convertible to the base type.
Otherwise, the name is a new declaration.
Otherwise, the next outer result must be either opaque or optional.
Otherwise, the offset of the offset is stored in a global variable that will be set up by the runtime.
Otherwise, the only hard case left is the identifier case.
Otherwise, the other part of the discriminator is in the payload.
Otherwise, the outer type is a tuple.
Otherwise, the parent has a single parameter with no label.
Otherwise, the property is of a value type, so it is the default (assign).
Otherwise, the result is always Nullptr.
Otherwise, the result is conditional on a successful conversion and an accurate number of arguments.
Otherwise, the result is identical.
Otherwise, the result must be a Boolean.
Otherwise, the result will / have type WitnessTablePtrTy.
Otherwise, the result will / have type pointerToDefaultType and may involve bitcasts.
Otherwise, the return type had better be a retainable object pointer.
Otherwise, the set of solutions will at least have been minimized.
Otherwise, the static storage for the global consists of a fixed-size buffer.
Otherwise, the true/false result types must not be matching.
Otherwise, the types must be equivalent.
Otherwise, the use is something complicated, it escapes.
Otherwise, there are no subelements.
Otherwise, there may be an external retroactive conformance that allows the binding.
Otherwise, they intersect to either component if they are equal, else to Bottom.
Otherwise, they yield rvalues (and the access must be a load).
Otherwise, they're in the same block, and we just need to check whether A comes after B.
Otherwise, they're in the same block, and we just need to check whether B comes after A.
Otherwise, this attribute cannot be applied to this declaration.
Otherwise, this definition is the first use of this name.
Otherwise, this has to be a type.
Otherwise, this is a forward reference.
Otherwise, this is a metatype-to-object cast.
Otherwise, this is a retain of an object that is not statically known to be the same object.
Otherwise, this is a simple reference to "dynamicType", which is always fine, even if self is uninitialized.
Otherwise, this is an exact match, return false to diagnose this as an ambiguity.
Otherwise, this is an implicit optional binding "if let".
Otherwise, this is just a character.
Otherwise, this is not the semantic call we are looking for.
Otherwise, this is some other sort of incompatibility.
Otherwise, this is some sort of c-style for loop.
Otherwise, this is some unknown instruction, conservatively assume that all values are clobbered.
Otherwise, this is something else that is using the memory.
Otherwise, this is the first type attribute and we know where the declaration is.
Otherwise, this is the real end of the buffer.
Otherwise, this isn't a proper type alias, but it *might* be a first-class enum.
Otherwise, this must be a get/set property.
Otherwise, this must be a typedef mapped to a strong type.
Otherwise, this really is some unhandled instruction.
Otherwise, this result should be filtered out.
Otherwise, this word ends before the last uppercase letter if the next word is alphabetic (URL_Loader) or after the last uppercase letter if it's not (UTF_8).
Otherwise, this word starts with an uppercase letter if the next word is alphabetic (URL_Loader) or after the last uppercase letter if it's not (UTF_8).
Otherwise, transitively capture the accessors.
Otherwise, true is returned and / the safe arrays can be queried.
Otherwise, try finding it after the "unsafeGuaranteedEnd".
Otherwise, try hoisting sub-loops.
Otherwise, try inserting after the table we would transitively be inserted after.
Otherwise, try the first and last parameter.
Otherwise, try to insert after the function we would be transitively be inserted after.
Otherwise, try to look through an implicit _forceBridgeFromObjectiveC() call.
Otherwise, try to simplify the terminator.
Otherwise, turn to +1 and re-abstract.
Otherwise, unknown associated decl kind.
Otherwise, update our state given the potential decrement.
Otherwise, update our step given that we have a potential decrement.
Otherwise, update the ref count state given the guaranteed user.
Otherwise, use a global FunctionRefInst.
Otherwise, use a memcpy.
Otherwise, use a subtype constraint for classes to cope with inheritance.
Otherwise, use an indirect aggregate schema with our storage type.
Otherwise, use generic witnesses (when we can't pattern-match into something better).
Otherwise, use the ObjC-specific entrypoint.
Otherwise, use the class name.
Otherwise, use the default BFD linker.
Otherwise, use the default attributes for the dynamic type.
Otherwise, use the default failure.
Otherwise, use the default inlining setting on the theory that forcing inlining off should only effect the user's function, not otherwise invisible thunks.
Otherwise, use the generic path.
Otherwise, use the standard SwiftObject class.
Otherwise, use this archetype as the exemplar for future similar archetypes.
Otherwise, use value witnesses.
Otherwise, using the object as a source (or size) is an escape.
Otherwise, verify the body of the function.
Otherwise, visit the children.
Otherwise, visit the representative of the set.
Otherwise, walk the 'inherited' list to identify requirements.
Otherwise, walk the lookup table.
Otherwise, we are both index projections.
Otherwise, we are conservative and do not forward the EnumTag that we are tracking.
Otherwise, we bind the value.
Otherwise, we break down the initializer.
Otherwise, we can / potentially mismatch
Otherwise, we can access all instance members.
Otherwise, we can directly load the statically known superclass's metadata.
Otherwise, we can emit the final value at +0 (but only with a guarantee that the value will survive).
Otherwise, we can jump directly to the ultimate destination.
Otherwise, we can just take the exploded arguments.
Otherwise, we can not compare the projections as sequences.
Otherwise, we can type-check as the enum type, and insert a cast from the outer pattern type.
Otherwise, we can use a direct-referencing conformance.
Otherwise, we can't default initialize this binding.
Otherwise, we can't produce a specific diagnostic.
Otherwise, we can't remove the deallocation completely.
Otherwise, we can't support this.
Otherwise, we cannot give it a fixed offset, even if all the previous elements are non-fixed.
Otherwise, we cannot resolve this because the available setter candidates are all mutating and the base must be mutating.
Otherwise, we come from a single value.
Otherwise, we couldn't find a specific thing to complain about, so emit a generic error, depending on what kind of failure this is.
Otherwise, we couldn't tell structurally what is going on here, so try to dig something out of the constraint system.
Otherwise, we do a direct load of the value.
Otherwise, we do support specializing this closure.
Otherwise, we don't have a specific issue to diagnose.
Otherwise, we don't know if the current cast will succeed or fail.
Otherwise, we don't know what happened, be conservative and return none.
Otherwise, we don't know what happened, return none.
Otherwise, we don't know why this failed.
Otherwise, we don't know, and raw_ptr could point to an arbitrary type, counted or not, so scan it conservatively.
Otherwise, we evaluate it once and store it in an unnamed local.
Otherwise, we failed to find any interesting information, return false.
Otherwise, we found it, break out.
Otherwise, we found that the concrete type is recursive, complain and return an error.
Otherwise, we gather up sub-records that need to be checked for checking...
Otherwise, we have a common base and perhaps some common subpath.
Otherwise, we have a conditional branch to the header.
Otherwise, we have a default.
Otherwise, we have a definite init or assign.
Otherwise, we have a failure.
Otherwise, we have a generic failure.
Otherwise, we have a generic parameter.
Otherwise, we have a leaf node.
Otherwise, we have a metatype subtype conversion of thick metatypes.
Otherwise, we have a normal var or subscript declaration, parse the full complement of specifiers, along with their bodies.
Otherwise, we have a previous declaration or definition which we need to ensure has the right type.
Otherwise, we have a program argument.
Otherwise, we have a simple primitive.
Otherwise, we have a statically-dispatched call.
Otherwise, we have a variable.
Otherwise, we have always have a valid payload.
Otherwise, we have an abstract storage declaration.
Otherwise, we have an array literal.
Otherwise, we have an extra inhabitant.
Otherwise, we have an unexpected use.
Otherwise, we have an unreachable and every instruction is inert from an ARC perspective in an unreachable BB.
Otherwise, we have an unterminated /* comment.
Otherwise, we have another parameter.
Otherwise, we have at least one (and potentially many) viable candidates sort them out.
Otherwise, we have invalid code.
Otherwise, we have no idea if they are identical.
Otherwise, we have no way of knowing the original protocol or conformance, since the witness has a concrete self type.
Otherwise, we have reached something that we do not understand.
Otherwise, we have to be conservative (even with native reference-counting) in order to interoperate with code that might be working more generically with the memory/type.
Otherwise, we have to build SSA for the value defined in this block and / this block's predecessors.
Otherwise, we have to do lookahead.
Otherwise, we have to grow out the stored spare bits before we can intersect.
Otherwise, we have to produce a series of notes listing the various options.
Otherwise, we have total knowledge of the class and its fields, so walk them to compute the layout.
Otherwise, we have two direct results.
Otherwise, we have type metadata.
Otherwise, we imported a single parameter.
Otherwise, we inline a little operation here.
Otherwise, we just keep it around as our interface to Clang's ABI knowledge.
Otherwise, we just need to capture the failure-depth binding.
Otherwise, we know S is in L.
Otherwise, we know that MinPathSize must be RHS.size() and RHS must be a strict subsequence of LHS.
Otherwise, we know that at least one of our types is not a builtin type.
Otherwise, we leave a pointer to it in RDS so endCatchHelper can pass it to _Unwind_Resume when it's done.
Otherwise, we leave retType null.
Otherwise, we may be retaining something scary.
Otherwise, we may need to fill in the conformance.
Otherwise, we may not have a way to name all of the pieces of the pattern.
Otherwise, we might have a reference-counted context pointer.
Otherwise, we might need to establish the invariants.
Otherwise, we must be able to hoist the function call.
Otherwise, we must call the ultimate getter to get its potential side effect.
Otherwise, we must have imported a single parameter.
Otherwise, we need a cache entry.
Otherwise, we need a dynamic dispatch thunk.
Otherwise, we need to add the dynamic size to the fixed start offset.
Otherwise, we need to build up a new parameter list.
Otherwise, we need to cleanup subregion data.
Otherwise, we need to coerce through memory.
Otherwise, we need to compute it.
Otherwise, we need to construct a new bitset that doesn't include the bits we aren't using.
Otherwise, we need to create a try_apply.
Otherwise, we need to create it.
Otherwise, we need to destroy the argument.
Otherwise, we need to emit a get and set.
Otherwise, we need to emit it.
Otherwise, we need to emit some conditional jumps/switches to handle the different cases.
Otherwise, we need to move or copy values into a +1 tuple.
Otherwise, we need to overcorrect and set the adjustment to the main timezone + 3600 seconds.
Otherwise, we need to produce a unified return block.
Otherwise, we need to reabstract and store.
Otherwise, we need to reabstract.
Otherwise, we need to replace the assignment with the full load/store/release dance.
Otherwise, we need to scan up the CFG looking for available values.
Otherwise, we need to stop computing since we do not want to create lifetime gap.
Otherwise, we need to switch sourceKey.Kind to the appropriate conformance kind.
Otherwise, we need to traffic through memory.
Otherwise, we need to use a fixed-sized buffer.
Otherwise, we need to use the general indirect-cast functions.
Otherwise, we only run phase 4 and 5 on the function.
Otherwise, we produce a generic error.
Otherwise, we risk creating a CPP object without having it initialized completely.
Otherwise, we should have just one Unicode scalar.
Otherwise, we should have some sort of subcommand.
Otherwise, we shouldn't create a new constructor, because it will be no better than the existing one.
Otherwise, we split on the dots (if any) to see if we can get a real value
Otherwise, we switch directly to the payload case.
Otherwise, we treat it as unknown control flow.
Otherwise, we will only keep the last cookie for a given name-domain-path triplet.
Otherwise, we would be creating irreducible control flow.
Otherwise, we'll need a temporary.
Otherwise, we'll need to derive it at instantiation time.
Otherwise, we'll perform a lookup against the metatype of our contextual type.
Otherwise, we'll return to this function and reoptimize after processing the new functions that were added.
Otherwise, we're binding an open archetype.
Otherwise, we're canonical.
Otherwise, we're casting to SomeProtocol.Type.Type.
Otherwise, we're consuming this as a +1 value.
Otherwise, we're down to a scalar.
Otherwise, we're going to have to call copyOrInitValueInto, which only takes a single value.
Otherwise, we're not sure what is going on, but this doesn't smell like a parameter.
Otherwise, we're ok to type check the subexpr.
Otherwise, we're passing an opaque tuple expression, and we should treat it as contributing to 'rethrows' if the original parameter type included a throwing function type.
Otherwise, we're referring to a member of a type.
Otherwise, we're still consistently Yes or No.
Otherwise, we're talking about the formal parameter clause.
Otherwise, we're thin if the metatype is thinnable both substituted and in the abstraction pattern.
Otherwise, we're working with an expression.
Otherwise, we've found a definition, or something else that will require that the memory is initialized at this point.
Otherwise, we've got the r-value we want.
Otherwise, whatever the result type of the call happened to be must not have been what we were looking for.
Our 'let' binding can guarantee the lifetime for the callee, if we don't need to do anything more to it.
Our assumption on how many times a loop is executed.
Our best guess at the source root.
Our block-end instruction was eliminated (most likely a Jmp* converted to a Nop).
Our caller should always take responsibility for that decision (by doing the materialization itself).
Our cast succeeded and gave us this abstracted value.
Our current cleanup emission logic, where we don't try to re-use cleanup emissions between various branches, doesn't require any code to be emitted at transition points.
Our current rank is the most recent ranked lock we've acquired.
Our custom signal handler that calls the appropriate php_function
Our destructor has no side effects, so if we can prove that no loads escape, then we can completely remove the use graph of this alloc_ref.
Our error result conventions are designed to be ABI compatible with functions lacking error results.
Our general approach is to do a depth first traversal of the broken expression tree, type checking as we go.
Our handle may not be same as `svar' here because some other thread may have updated it already, check before updating.
Our insert point is going to be the terminator inst.
Our little 7-bit alpha channel trick costs us a bit here.
Our loop info is not really completely valid anymore since the cloner does not update it.
Our method of efficiently finding nearest colors is based on the "locally sorted search" idea described by Heckbert and on the incremental distance calculation described by Spencer W.
Our parent must be a call.
Our return address was smashed by the debugger.
Our safety measure is meant to protect from such many-buggy to one-correct collisions, by deviating from the correct algorithm in such cases.
Our specializations should have resolved the subexpr to the right type.
Our tracking list has been accumulating instructions created by the SILBuilder during this iteration.
Out of date, or doesn't exist.
Out of order on purpose
Out of order on purpose.
Out-of-line because std::unique_ptr wants LookupCache to be complete.
Outdent if the line looks like a 'case' label.
Outdent if the line looks like a label.
Outdent if the line looks like a setter.
Output DOT-format graph.
Output VPX string is placed in the *p_out buffer.
Output YUV data buffers
Output all the needed C++ forward declarations.
Output must be Builtin.Int1
Output must be a global type named Bool.
Output states for the next and taken edge.
Output string with quoted characters
Output the initialization of the metadata table mapping the type indices to the type name and scanner.
Output uses for BB arguments.
Outputs: Outputs code to the file.
Outside the cloned region.
Overlay/append this class's protected and public properties onto/to those of the parent, and append this class's private properties.
Overlay/append this class's public/protected methods onto/to those of the parent.
Overloaded and unresolved cases: find the resolved overload.
Override an existing method
Override cipher specs if necessary.
Override default language to correctly support UK English (this is not required in WiX 3.8)
Override function attributes based on CPUStr, FeaturesStr, and command line flags.
Override location for #file, #line etc.
Override simple behaviors where MayHaveSideEffects is too general and encompasses other behavior that is not read/write/ref count decrement behavior we care about.
Override the connected property like we do for the read_property handler
Override the maximum client TLS version if necessary.
Override the name on the attribute.
Override to always use a fill op instead of a relocation.
Overwrite the body of the existing TopLevelCodeDecl.
Overwrite the functiosn
Overwrite the l-value access kind to be read-only if we're converting to a non-mutable pointer type.
Overwrite the old witness table.
Overwrite the passed-in value for subpatterns with an empty array.
Overwrite the superclass field.
Overwrites are not permitted.
Owned parameters may call the destructor of the object which could violate the readonly-ness of the function.
Ownership attributes.
Ownership of the rvalue can be "forwarded" to disable the associated cleanup(s).
Owning a reference to a class existential is equivalent to owning a reference to the contained class instance.
Owns an ASTContext and the associated types.
P-box and S-box tables initialized with digits of Pi.
PATH_INFO wasn't filled by resolveURL() because m_originalURL didn't contain it.
PCRE specific options
PCRECache implementation
PCREglobals definition
PDO error (if any) has already been raised at this point.
PERF_TYPE_HARDWARE events
PERF_TYPE_HW_CACHE hw_cache_id
PERF_TYPE_HW_CACHE hw_cache_op, hw_cache_result
PGO can significantly increase the size of the regions, so disable it for pseudo-mains (so regions will be just tracelets).
PHIs are always emitted with maximal explosion.
PHP 5.x does different things when diffing against the same array, particularly when the comparison function is outside the norm of return -1, 0, 1 specification.
PHP 7 allows for a widening conversion from Int to Float, we still ban this in HH files.
PHP 7 allows user defined constants as parameter default values
PHP 7 allows widening conversions
PHP 7 requires IEEE compliance (+/- INF and NAN) with the result of dividing a value by zero.
PHP Exceptions and Classes
PHP classes that inherit from cpp builtins that have special clone functionality *may* also define a __clone method, but it's totally fine if a __clone doesn't exist.
PHP extension STANDARD: image.c
PHP extension STANDARD: iptc.c
PHP treats a carriage return beside a newline as the same break no matter what order they're in.
PHP treats both types of string the same, so if the distinction matters to you here, be careful.
PHP unescapes the URI here, but that should properly be done by the wrapper.
PHP's streams layer explicitly flushes on close Mimick that for user-wrappers by pushing the flush here without impacting other HPHP stream types.
PHP5 didn't formally define this, but observationally returns the truncated value (i.e., what dst1 currently holds).
PHP5 does list() assignments RTL, PHP7 does them LTR, so this loop can go either way and looks a little ugly.
PHP5 does not deduplicate cookies.
PHP5 xdebug returns "" for no class
PHP5 xdebug returns 0 when it can't determine the line number.
PHP5 xdebug returns false if the callee is top-level
PHP5 xdebug returns false if the callee is top-level.
PHP5 xdebug returns the top-level file if the callee is top-level.
PHP7 falls through to the IEEE division semantics below (and doesn't side exit since the type is still a double).
PHP7 formally defines this case to return 0.
PHP7 is off by default (false).
PHP7 uses the IEEE definition (+/- INF and NAN).
PHP7-style class whitelisting Allowed classes are allowed, all others result in __Incomplete_PHP_Class
PHP_INI_ALL has a weird encoding
PHP_OUTPUT_HANDLER_START is included by PHP5
PID (assume max size, a signed 32bit int)
PSFS_ERR_FATAL doesn't raise a fatal in Zend - appears to be treated the same as PSFS_FEED_ME
PTK_AutoreleasingUnsafeMutablePointer can be converted from an inout reference to a scalar.
Pacify GCC's `empty if-body' warning.
Pacify compilers like GCC when the user code never invokes YYERROR and the label yyerrorlab therefore never appears in user code.
Pack payload, if any.
Pack tag bits, if any.
Pack tag into spare bits and tagIndex into payload bits.
Pack the extra bits, if any.
Pack the passed args into an array, then store it as the second param.
Pack the payload, if any.
Pack the service request args into a svcreq::ReqInfo on the stack.
Package the Substitution list in the SpecializeAttr's ConcreteDeclRef.
Package up the result in an optional.
Package up the result.
Packed arrays don't need renumbering, so don't make a copy.
Packed packet headers, main header
Packed packet headers, tile part header
PackedArray always has a valid m_size so it's an error to get here.
Packet length, main header
Packet length, tile-part header
Packing the TV type and data into two registers.
Pad state to finalize
Page size does not need to take scrollbars into account.
Pagelet Server unit test
Palette based to palette based
Palette image, or something coerced to be one
ParamDecls never get PBD's.
Parameter types and kinds must match.
Parameters : format     The format string.
Parameters are / sliced off of the front as they're emitted.
Parameters are contravariant and our relation is not symmetric, so make sure to flip the relation around.
Parameters are explicitly specified, and could be used in the body, don't attempt recovery.
Parameters are handled specially in addParameters().
Parameters are never directly imported.
Parameters for push/pop and keep stack aligned
Parameters may be Uninit (i.e. no InitCell).
Parameters that can be directly passed through to hhvm.
Parameters with defaults can be unfulfilled.
Parameters: dst - Where to store the resulting affine transform  Returns: GD_SUCCESS on success or GD_FAILURE
Parameters: dst - Where to store the resulting affine transform angle - Rotation angle in degrees  Returns: GD_SUCCESS on success or GD_FAILURE
Parameters: dst - Where to store the resulting affine transform angle - Shear angle in degrees  Returns: GD_SUCCESS on success or GD_FAILURE
Parameters: dst - Where to store the resulting affine transform m1 - First affine matrix m2 - Second affine matrix  Returns: GD_SUCCESS on success or GD_FAILURE
Parameters: dst - Where to store the resulting affine transform offset_x - Horizontal translation amount offset_y - Vertical translation amount  Returns: GD_SUCCESS on success or GD_FAILURE
Parameters: m - The affine transformation  Returns: GD_TRUE if the affine is rectilinear or GD_FALSE
Parameters: m1 - The first affine transformation m2 - The first affine transformation  Returns: GD_SUCCESS on success or GD_FAILURE
Parameters: scale_x - X scale factor scale_y - Y scale factor  Returns: GD_SUCCESS on success or GD_FAILURE
Params' OuterParameters will point to contextParams.
Paren, Typed, and Var patterns are noops, just look through them.
Parent class constructor if it isn't named 86ctor.
Parent pointers should point to the node that has a given node as a child.
Parent should come before, and must enclose this guy.
Parentheses don't affect the type.
Parse 'case' sil-decl-ref ':' sil-identifier.
Parse 'case' sil-decl-ref ':' sil-value.
Parse 'case' value-ref ':' sil-identifier.
Parse 'catch' clauses
Parse 'default' sil-identifier.
Parse 'default' sil-value.
Parse 'throws' or 'rethrows'.
Parse Composite Document Files, the format used in Microsoft Office document files before they switched to zipped XML.
Parse Generic Parameters.
Parse a "(value)" specifier for "set" or "willSet" if present.
Parse a #available condition if present.
Parse a application/x-www-form-urlencoded data string
Parse a behavior block if present.
Parse a following trailing closure argument.
Parse a function definition signature.
Parse a generic parameter list if it is present.
Parse a leading #available condition if present.
Parse a list of SILValue.
Parse a list of Substitutions.
Parse a pattern with an optional type annotation.
Parse a single implicitly unwrapped optional suffix, given that we / are looking at the exclamation mark.
Parse a single optional suffix, given that we are looking at the / question mark.
Parse a single parameter-clause.
Parse a specialized attributed, building a parsed substitution list / and pushing a new ParsedSpecAttr on the SpecAttrs list.
Parse a throws specifier.
Parse a tuple of args
Parse a tuple pattern.
Parse a type after the 'is' token instead of an expression.
Parse a unary expression.
Parse additional expressions.
Parse all args until we see an input, and then collect the remaining arguments into a synthesized "--" option.
Parse all the elements.
Parse all the partial modules first.
Parse an element of a tuple pattern.
Parse an initializer if present.
Parse an optional modifier.
Parse an optional specifier after unowned.
Parse an optional type annotation on a pattern.
Parse an optional type annotation.
Parse and return this as an UnresolvedPatternExpr around a binding.
Parse and validate the configuration
Parse any leading attributes.
Parse any width specifier.
Parse attributes then a type.
Parse availability query specification.
Parse comma-separated enum elements.
Parse command line options using Options.td
Parse default values.
Parse each segment, find the closing '/'
Parse extraneous parentheses and remove them with a fixit.
Parse file extension from a path
Parse frontend command line options using Swift's option table.
Parse function arguments.
Parse generic params for the protocol conformance.
Parse getter and setter.
Parse identifier (',' identifier)*
Parse legacy array types for migration.
Parse optional inheritance clause within the context of the class.
Parse optional inheritance clause within the context of the enum.
Parse optional inheritance clause within the context of the struct.
Parse optional inheritance clause.
Parse out all the debug information out of the specified file and do the analysis generating the layouts.
Parse parameter-clauses.
Parse productions that can only be patterns.
Parse static initializer if exists.
Parse substitution as AST type.
Parse substitutions for specialized conformance.
Parse the ':' followed by a type.
Parse the 'class' keyword for a class requirement.
Parse the 'in' at the end.
Parse the 'super' reference.
Parse the 'where' expression if present.
Parse the Yaml file that contains the group information.
Parse the assert configuration identifier.
Parse the basic block list.
Parse the body of the file.
Parse the body, if any.
Parse the capture list and parameters.
Parse the class name.
Parse the closing ')'
Parse the closing ')'.
Parse the closure arguments.
Parse the closure-signature, if present.
Parse the comma, if the list continues.
Parse the command and store it as the last command
Parse the concrete nominal type.
Parse the condition of an 'if' or 'while'.
Parse the config variable.
Parse the contextual keywords for 'mutating' and 'nonmutating' before get and set.
Parse the covered name.
Parse the current line(s).
Parse the debug information, if any.
Parse the decl, stmt, or expression.
Parse the digit sequence into an argument index.
Parse the element type.
Parse the entry list.
Parse the environment for flags.
Parse the first argument.
Parse the first expression.
Parse the first part, either a var, let, expr, or stmt-assign.
Parse the func-signature-result, if present.
Parse the generic parameter list.
Parse the generic-params, if present.
Parse the inherited type (which must be a protocol).
Parse the input and get split tokens info
Parse the leading '('.
Parse the leading boolean condition if present.
Parse the leading type-identifier.
Parse the list of condition-bindings, each of which can have a 'where'.
Parse the list of name bindings within a let/var clauses.
Parse the local-name.
Parse the main file last.
Parse the matching ')'.
Parse the middle expression of the ternary.
Parse the name of the parameter.
Parse the names, with trailing colons (if there are present).
Parse the next value.
Parse the opcode name.
Parse the opened existential ID string in parens
Parse the opening left brace.
Parse the optimization level.
Parse the optional 'where' guard.
Parse the optional argument list for a modifier, which is brace-enclosed.
Parse the optional explicit return type.
Parse the optional where-clause.
Parse the parameter clause.
Parse the parameter list.
Parse the parameter-clause.
Parse the parameters.
Parse the pattern tuple element.
Parse the pieces of the fix-it.
Parse the protocol conformance.
Parse the protocol or composition.
Parse the second type.
Parse the subexpression.
Parse the substitution list for a specialized conformance.
Parse the substitution list for an apply instruction.
Parse the type annotation.
Parse the type being extended.
Parse the type for SILDeclRef.
Parse the type of the result operands.
Parse the type-composition-list.
Parse the type-identifier.
Parse the unqualified-decl-name.
Parse the whole part of the number - only if it wasn't 0
Parse them and produce a specific diagnostic if present.
Parse this textually to avoid Swift keywords (like 'return') from interfering with opcode recognition.
Parse through the leading whitespace, and display a warning if we get to the end without encountering a delimiter.
Parse through the options, setting appropriate flags.
Parse version constraint specification.
Parse, typecheck and temporarily insert the incomplete code into the AST.
ParseState indicates the value we just handled.
Parseable output was requested.
Parser::parseList() does a special check for a tok::EOF that is spelled with a ')'.
ParserPositionRAII needs a primed parser to restore to.
Parses a complete JSON encoded string This is just a wrapper around the UNICODE Parse().
Parses the current command line as a code execution command and carries out the command.
Parses the current command string.
Parsing succeeded as a multi-byte sequence
Parsing the debug information can take quite a bit of time right now, so only actually do it if someone has explicitly opted into it.
Parsing/scanning the heap (e.g., objprof) can cause us to get here before we've initialized the elms.
Part of the index building routines happens before the various asserted index invariants hold.
Partial DCE for DefInlineFP/InlineReturn Instructions This module implements a pass to sink DefInlineFP instructions off the critical path allowing us to eliminate InlineReturn instructions.
Partial application thunks.
Partial applications of delegated initializers aren't allowed, and don't really make sense to begin with.
Partial applications of functions that are not permitted.
Partial applications take ownership of the context parameters, so we'll need to pass ownership rather than merely guaranteeing parameters.
Partial dead store - stores to some locations are dead, but not all.
Partially apply the next uncurry level and return the result closure.
Partition by actual code area without changing relative order.
Partition into main, cold and frozen, without changing relative order.
Partition the set of conflicts to put the conflicts that involve this source file at the end.
Partition the set of unsatisfied requirements to put the conflicts that involve this source file at the end.
Pass 'nil' as the return value to the exit BB.
Pass Function / Method structure node.
Pass `null` as the second argument to remove a HTTP header
Pass a null locale to use the C locale.
Pass a placeholder for thin function calls.
Pass a pointer to the objc_super struct to the messenger.
Pass all the arguments necessary for the given function.
Pass along the indirect results.
Pass context sensitive keyword token.
Pass down the error result.
Pass down the variable function type attributes to the function-type creator.
Pass in both the TBAA types so we can perform typed access TBAA and the actual types of V1, V2 so we can perform class based TBAA.
Pass in just the setter.
Pass large arguments as indirect value parameters.
Pass manager, used to get various analysis.
Pass null to ContEnterDelegate initially.
Pass on any build config options
Pass the +1 value down into the sub initialization.
Pass the address of tvBuiltinReturn to the native function as the location it can construct the return Array, String, Object, or Variant.
Pass the argument explosion directly.
Pass the argument indirectly.
Pass the class to the type checker to create an implicit destructor.
Pass the diagnostic off to the consumer.
Pass the function signature to code completion.
Pass the generic arguments.
Pass the metatype of the subclass.
Pass the optimization level down to the frontend.
Pass the writeback scope on to CallEmission so it can thread scopes through nested calls.
Pass through Unicode characters.
Pass through any subsystem flags.
Pass through the values passed to -Xfrontend.
Passed to the ExecutionContext during Eval to add writes to stderr to the output buffer string.
Passed to the ExecutionContext during Eval to add writes to stdout to the output buffer string.
Passes should not merge invalidation kinds themselves.
Past this point we need not check for UNMATCHABLE in pat, because all of pat has already been parsed once.
Paste into dot -Txlib or similar.
Patch the FPI structures
Patch the PC range field.
Patch the length field.
Patches the Vptr, grab and save the data.
Patches the Vptr, retrieve the immediate and emmit a related direct vasm
Paths and Directories
Pattern Parsing and AST Building
Pattern bindings handle their own tests, we don't need a boolean test.
Pattern resolution occurs before sequence resolution, so the cast will appear as a SequenceExpr.
Pattern-bindings don't require anything special as long as / these initializations are performed in the constructor, not / .cxx_construct.
PatternMatchStmt - The 'switch', or do-catch statement that we're emitting / this pattern match for.
Patterns use the pattern type and no adjustment.
Pause the polling thread if it isn't already.
Payload and no-payload cases are counted and the enum is classified into the following categories:
Payloads are all placed at the beginning of the value.
Peek ahead to check the gzip magic header
Peek through an extract of Bool.value.
Peek through optionals.
Peel off metatypes, since if we can cast two types, we can cast their metatypes.
Peel off optionals metatypes from the types, because we might cast through them.
Peel off the bit at the current position
Peephole away complementary reabstractions.
Peephole cleanup pass.
Peephole expects input eval state.
Peephole simplification pass for a Vunit.
Peephole these by looking for a subexpression that is a BindOptionalExpr.
Peephole: instead of materializing and then assigning into a translation component, untransform the value first.
Penalty for skipping a token.
Pending fixups always point after the call instruction, so use the "before" address, since there may be nops before the next actual instruction.
Per above, only fully honor opaqueness in the abstraction pattern for thick or polymorphic functions.
Per basic block list of cond_fails to merge.
Per must-alias-set state information for rc_analyze.
Per-block live-in sets.
Per-dir INI settings are bound here, but that seems really questionable since they can change per request too.
Per-member field actions:
Perfect match seems common enough to be worth skipping the hash table lookup.
Perform "stable" optimizations that are invariant across compiler versions.
Perform (full) path compression.
Perform 1st shear (horizontal)
Perform CSE of existential and witness_method instructions.
Perform Copy Forwarding.
Perform CopyForwarding on the current Def.
Perform MiscDiagnostics on Switch Statements.
Perform SIL optimization passes if optimizations haven't been disabled.
Perform SROA on BB arguments.
Perform a BFS to expand the given type into projectionpath each of which contains 1 field from the type.
Perform a DFS starting at block `bid', storing the post-order in `outVec'.
Perform a clear operation.
Perform a conditional cast branch.
Perform a couple of sanity checks on scopes.
Perform a depth-first search from each type variable to identify what component it is in.
Perform a dynamic cast from an existential type to a / non-existential type.
Perform a dynamic cast from an existential type to some kind of / class type.
Perform a dynamic cast of a class value to a metatype type.
Perform a dynamic cast of a class value to an existential metatype type.
Perform a dynamic cast of a metatype to a metatype.
Perform a dynamic cast of a metatype to an existential metatype type.
Perform a dynamic cast to a metatype type.
Perform a dynamic cast to an arbitrary type.
Perform a dynamic cast to an existential metatype type.
Perform a dynamic cast to an existential type.
Perform a dynamic class of some sort of class instance to some / sort of class type.
Perform a few simple optimizations on DefLabels: - If a phi's dest has a type that represents a constant value, replace the phi with a Mov from a DefConst (to be copy-propagated by a later pass).
Perform a foreign error check by testing whether the call result is nil.
Perform a foreign error check by testing whether the call result is zero.
Perform a foreign error check by testing whether the error was nil.
Perform a forward scan and use control flow and previously detected overflow checks to remove the overflow checks.
Perform a module level lookup on the first component of the fully-qualified name.
Perform a naive memcpy of n tuples from src into dest.
Perform a naive memcpy of src into dest.
Perform a naive memmove of n tuples from src into dest.
Perform a native return.
Perform a speculative devirtualization of a method invocation.
Perform a strong_release instruction at the current location, attempting / to fold it locally into nearby retain instructions or emitting an explicit / strong release if necessary.
Perform abstract conversion, ignoring how the type is actually used.
Perform action un-disable
Perform all the bindings necessary to emit the given declaration.
Perform an analysis to determine memory locations that are known to hold "balanced" values with respect to reference counting.
Perform an operation for each field of two tuples.
Perform an operation on a type that requires dynamic packing.
Perform an upcast to convert self to the indicated super type.
Perform another check, this time in reverse and use future overflow checks that must be executed to eliminate earlier overflow checks.
Perform another round of general whitespace nuking to cleanup whitespace before the //.
Perform any adjustments needed to 'self'.
Perform any desired type simplifications for an entity in Simplified mode.
Perform any necessary requirement inference.
Perform automatic name transformations.
Perform backward copy-propagation.
Perform basic checking to determine whether a declaration can override a / declaration in a superclass.
Perform basic layout on the tuple.
Perform basic matching of the requirement and witness.
Perform basic sequential layout given a vector of metadata pointers, / calling a functor with the offset of each field, and returning the / final layout characteristics of the type.
Perform classic SSA optimizations for cleanup.
Perform classic SSA optimizations.
Perform definitive initialization analysis and promote alloc_box uses into / SSA registers for later SSA-based dataflow passes.
Perform diagnostics for func/init/deinit declarations.
Perform dominator based value simplifications and jump threading on all users / of the operand of 'DominatingBB's terminator.
Perform final cleanup passes to collapse any critical edges that were split, and simplify our instructions before shipping off to codegen.
Perform forward copy-propagation.
Perform iterations until we do not make any changes.
Perform lowering optimizations.
Perform median-cut to produce final box list
Perform name lookup for the first and second pieces.
Perform name lookup into the global scope.
Perform one of the predefined actions.
Perform optimizations based on flags liveness, then do some cleanup.
Perform optimizations on instructions in `unit' at which no flags registers are live.
Perform peephole simplification at instruction `i' of block `b'.
Perform prechecking of a ClosureExpr before we dive into it.
Perform preoptimization and simplification on the input instruction.
Perform print only in case what's left is not an empty string
Perform register allocation.
Perform retain/release code motion and run the first ARC optimizer.
Perform scalar inits.
Perform semantic annotation/loop base optimizations.
Perform some cleanups such as:
Perform specialized dispatch for a sequence of EnumElementPattern or an / OptionalSomePattern.
Perform specialized dispatch for a sequence of IsPatterns.
Perform specialized dispatch for a sequence of NominalTypePatterns.
Perform specialized dispatch for tuples.
Perform specialized dispatch on the particular column.
Perform standard value name lookup.
Perform string literal encodings adjustments if needed.
Perform structure layout on the given types.
Perform substitutions into the superclass type to yield the substituted superclass type.
Perform subtype check on the possibly-bridged-through key type.
Perform subtype check on the possibly-bridged-through value type.
Perform the CSE for the open_existential_addr instruction and their dominating instruction.
Perform the RRN Optimization given the current state that we are / tracking.
Perform the RRNOptimization.
Perform the actual redundant load elimination.
Perform the actual replacement of the get_element call by its value.
Perform the bridging operation.
Perform the conversion.
Perform the evaluation at the given depth.
Perform the final lowering transformations.
Perform the following simplification:
Perform the layout required for a heap object.
Perform the lookup again.
Perform the lookup in all imports of this module.
Perform the modification .
Perform the pre-check.
Perform the proper conversions and then add it to the new parameter list for the type.
Perform the requested scanning operation.
Perform the root -dealloc operation for a class instance.
Perform the same checks as conformance witness matching, but silently ignore the candidate instead of diagnosing anything.
Perform the second pass now.
Perform the server-side work for this command.
Perform the substitution.
Perform the substitutions.
Perform the traditional CSE.
Perform the transformation on each load.
Perform the translation.
Perform this lookup only if a function with a given name is present in the current module.
Perform top-down type coercion on the given pattern.
Perform typo correction on the given nested type, producing the / corrected name (if successful).
Perform unqualified name lookup to find out what the UDRE is.
Perform whole-module type checking.
Perform xorq Place only byte result into d and do not touch higher 32bits
Perform xorq Place only byte result into d and do not touch higher 56bits
Perform xorqi move only the byte result to the destination, keeping the higher 56bits
Performa direct jump to the break lable and free any pending iterators left.
Performance inlining.
Performance is in the sub-500ns range to over 100,000 shards with 13-byte keys.
Performing a RPO walk over the control flow graph, tracking any / LSLocations that are read from or stored into in each basic block.
Performing a post-order walk over the control flow graph, tracking any / LSLocations that are read from or stored into in each basic block.
Performing these substitutions gets libiconv closer to the glibc behavior.
Performs a qualified lookup into the given module and, if necessary, its / reexports, observing proper shadowing rules.
Performs an insert operation and tests that the result matches what we get from the std::map.
Performs the compile requested by the user.
Performs various analyses on V1, V2 in an attempt / to disambiguate the two values.
Perhaps file or fullPath is a symlink.
Perhaps init() synth should be moved later.
Perhaps the caller will want to call strcmp to break the tie.
Perhaps this is something that shouldn't be done, and is a bandaid over some other lower-level architecture issue that I'm missing.
Perhaps we should just compute leading 28 bits of S once and for all and pass them and a shift to quorem, so it can do shifts and ors to compute the numerator for q.
Perl compatible options
Permission granted to use, copy, modify, distribute and sell so long as the above copyright and this permission statement are retained in all copies.
Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: 1.
Permit '()' when this method overrides a method with a foreign error convention that replaces NSErrorPointer with () and this is the replaced parameter.
Persistent font cache until explicitly cleared
Personality routine address format and address.
Pettis-Hansen code layout algorithm reference: K.
Phase 1 - 3 are only performed when we know the data flow will not converge in a single iteration.
Pick a runtime entry point and target metadata based on what kind of representation we're casting.
Pick a value witness table appropriate to the function convention.
Pick an arbitrary result from each module.
Pick one of the arguments that are expected as an exemplar.
Pick one variable of the pattern.
Pick the ValueDecl that has the right type.
Pick the cast function based on the cast mode and on whether we're casting a Swift metatype or ObjC object.
Pick the hotter phidef as the hint, else prefer `next'.
Pick the nearest break target that matches the specified name.
Pick the smallest disjunction.
Pick up CondCode arguments first---vasm may optimize immediate loads into operations which clobber status flags.
Pick up where we left off
Piece the modified direct result information back into the all-results list.
Pierre: crop everything sounds bad
Pimpl implementation of SwiftARCContractPass.
Place internal breakpoints to get out of the current function.
Place the '.dynamicType' right before the init.
Place the next struct field at its appropriate offset.
Place the proxy onto the retired proxy queue.
Place the return-to BB after all the other mapped BBs.
Place this new proxy into the proxy map keyed on the dummy sandbox id.
Placement initialize the ParameterList and the Parameter's.
Plan the emission of a call result as a single outer direct result, / given that the inner abstraction pattern is a tuple.
Plan the emission of a call result as a single outer direct result, / given that the inner abstraction pattern is not a tuple.
Plan the emission of a call result as a single outer direct result.
Plan the emission of a call result from an inner result address, / given that the outer abstraction pattern is not a tuple.
Plan the emission of a call result from an inner result address, given / that the outer abstraction pattern is a tuple.
Plan the emission of a call result from an inner result address.
Plan the emission of a call result into an outer result address, / given that the inner abstraction pattern is a tuple.
Plan the emission of a call result into an outer result address, / given that the inner abstraction pattern is not a tuple.
Plan the emission of a call result into an outer result address.
Plan to emit into that location.
Plan to expand from that location.
Plan to leave the tuple elements as a single direct outer result.
Plant spare bit tag bits, if any, into the new value.
Platform-specific sources can override this.
Please be aware of this if you modify the function to allow other certificate validation behaviors
Please follow these general rules when implementing traversal for a node:
Please preserve the runtime self-test.
Please put all checks in visitSILFunction in SILVerifier, not here.
Please send bug reports to David M.
Point out the requirement that wasn't met.
Point the increment call to the right function name variable.
Point to the beginning of the (possibly new) buffer.
Point to the first real instruction.
Pointer arguments can be converted from pointer-compatible types.
Pointer manipulation is traditionally done with lea, and it's safe to insert even where flags might be live.
Pointer ownership is shared between container and caller
Pointer to DNS_RECORD structure
Pointer to current parsing position
Pointer to the log entry which pushed this frame
Pointer to the next subinterval.
Pointer to the underlying php::Func this has information about.
Pointer-based loads and stores
Pointers are safe, do the real comparison.
Pointers may be representable in ObjC.
Pointers to either the frame or object will be mapped to the frame.
Pointers to either the native data or the object will be mapped to the native data.
Pointers to member functions aren't represented in DWARF.
Pointers to non-pointer followable types are ignored.
Pointers to pointer followable types are enqueued inside scanners.
Points to current character in buffer.
Poll a socket seeing if there is any input waiting to be received.
Poll, but with a 100ms timeout so that this thread doesn't spin wildly if it gets ahead of the workers.
Polling is disabled while a thread is stopped at an interrupt and responding to messages from the client.
Polymorphic function types carry their own generic parameters and manglePolymorphicType will bind them.
Polymorphic function types should never be explicitly spelled.
Poor mans attempt to get as many threads ready as possible before dropping spinWait, it doesn't have to be perfect.
Pop Node off the back of the worklist.
Pop a value off of the evaluation stack, and verify that it matches the specified symbolic flavor
Pop any remaining functions that have been optimized (at least through some portion of the pipeline).
Pop changes off the stack until we hit the change could we had prior to introducing this scope.
Pop functions off the worklist, and run all function transforms on each of them.
Pop nDiscard elements from the stack, push the result (if present), DecRef tvRef(2), and mark the member operation as complete.
Pop of virtual "locs" on the stack that turn into immediates.
Pop off the last member type.
Pop off the null terminator.
Pop off the top of the list.
Pop off the top type, value, and node.
Pop off the top value.
Pop off the underscore since it serves as the end of our mangling list.
Pop out of the anonymous closure variables scope.
Pop the InWritebackScope bit.
Pop the ReqInfo off the stack.
Pop the SIL TypeConverter's generic context too.
Pop the address projections of the store from the stack.
Pop the blocked dependency.
Pop the buffer stack, destroying each element.
Pop the capture if we made one.
Pop the current (potentially not-yet-optimized) function off.
Pop the current state because it cannot handle the error token.
Pop the inlined frame in our IRGS.
Pop the inputs, and push the constants.
Pop the matching bracket and keep going.
Pop the next parameter info.
Pop the return value.
Pop the signal polling thread, and any interrupting threads, out of their event loops and cause them to exit.
Pop the stack, assuring that the current mode matches the expectation.
Populate "os" "osarchitecture" word size
Populate AllValues, AddressProjectionTrie, and StoredLocations.
Populate most fields of the NormalizedInstruction, assuming its sk has already been set.
Populate our cache on the first name lookup.
Populate the argument list for a new partial_apply instruction, taking into consideration any captures.
Populate the generator's value with retval to support `getReturn`
Populate the int-based release and build, if we have all digits in them
Populate the lookup table.
Populate the may-alias-sets for each must-alias-set.
Populate the overload choices with the first solution.
Populate the superclass members, if any.
Populate the type bindings with the first solution.
Populates AllUsers, AddressProjectionTrie, and StoredLocations.
Populates `imm' on `inst'.
Position of this use or def.
Positions between instructions are used to insert copies and spills.
Possible Content-Type:
Possibly add more indexes in the future, like "log_queries", "log_commands", "log_failures", "log_metadata"...
Possibly bitcast the C function pointer to account for ABI-compatible parameter and result type conversions
Possibly have all compiler invocation options auto-generated from a tablegen definition file, thus forcing a decision for each option if it is ok to share ASTs with the option differing.
Possibly send a response.
Possibly shrink the string, then add it to the node
Possibly, skip spaces/tabs at the end of line
Post and process events
Post data may be binary, but if parsePostParams() is called, it is correct to handle it as a null-terminated string
Post-1.0, we'll need to remove this hack in favor of richer constraint declarations.
PostConditions of a block are our local transfer functions.
Postcondition: Builder's insertion block is a new block that defines the specialized call argument and has not been terminated.
Postfix expression is located on a different line than the code completion token, and thus they are not related.
Postfix operators cannot start a subexpression, but can happen syntactically because the operator may just follow whatever precedes this expression (and that may not always be an expression).
Postfix: replace the ++ or --.
Postpone complaining about this error till we see if the  DCC wants to move it below.
Potentially add a leading sigil for the value category.
Potentially attach the xdebug profiler
Potentially kill the profiler
Potentially upgrade the error to E_USER_ERROR
Powers of two are not biased
Pragma writes must be executed outside transactions, since they may change transaction behavior.
Pre- and post-allocations.
Pre-allocate an ArrayData of the given size, to avoid escalation in the middle, which breaks references.
Pre-allocate the component vectors so that we can form references into them safely.
Pre-allocate the result.
Pre-check the expression, validating any types that occur in the / expression and folding sequence expressions.
Pre-live frames are slightly different from other pure stores, because eventually they may become live frames even within our region (via DefInlineFP).
Pre-populate the foreign-representable cache with known types.
Pre-process partial_apply arguments only once, lazily.
Pre-req BA should only show help or do an install (to launch the Managed BA which can then do the right action).
Pre-scan operator arguments for nil literals.
Pre-sort the completions.
Pre:  direct_successor(pred, middle) direct_successor(middle, last)  Post: direct_successor(pred, last) and middle is unlinked entirely
Pre: direct_successor(pred, succ)
Pre: isPredefined(bits)
Pre: mutex already held, or no other threads may be able to access this (i.e. it's the ctor).
PreClass::TraitAliasRule.
Preallocate index buffer
Preallocate more of the same in order to amortize entry into this method.
Preallocate sort keys buffer
Preceding item must not.
Precompute full function name
Precompute some information from the post-dominator tree to aid us in determining control dependence without generating a complete control dependence graph.
Precondition: Builder's current insertion block is not terminated.
Precondition: m_originalURL and m_queryString are set Postcondition: Output is false and we are redirecting OR m_rewrittenURL is set and m_queryString is updated if needed
Precondition: m_rewrittenURL is set Postcondition: Output is true and m_path and m_absolutePath are set OR output is false and no file was found
Predecessors reached only via a path along the failure branch of the dominating checked_cast_br.
Predecessors reached only via a path along the success branch of the dominating checked_cast_br.
Predecessors which do not satisfy these conditions are not included in the BBToValue map (but we don't bail in this case).
Prefer Convenience over ConvenienceFactory, but otherwise prefer leaving things as they are.
Prefer a path from the OutputMap.
Prefer declarations in the current module over those in another module.
Prefer frameworks over plain headers.
Prefer loads and stores if we won't make a million of them.
Prefer scoped imports (import func Swift.max) to whole-module imports.
Prefer the actual storage size over the DbgTy.
Prefer the declaration that comes first in the source file.
Prefer the member in the concrete type.
Prefer the original, potentially sugared version of the type if the type hasn't been mucked with by an optimization pass.
Prefer the unlabeled form of a type.
Prefer to place the FuncRef immediately before the call.
Prefer to use a hint from a corresponding phi node.
Prefer value decls to extensions.
Preferred locale codes for the first N entries of g_grandfathered Must be kept in sync with above.
Prefix address such that it can be distinguished as residing within an unresolved PHP function.
Prefix for optional rounds specification.
Prefix the character ch to the string str Increase length Set the has_prefix flag
Prefix: remove the ++ or --.
Preflight to avoid allocation if the entire input is valid.
Preincrement iterator to avoid iteration issues in the loop.
Preincrement the iterator to avoid invalidation and out trouble.
Preliminary support for .sil debug information.
Prep work before beginning the compaction process
Prepare `arg' for a call by shifting or zero-extending as appropriate, then append its Vreg to `vargs'.
Prepare a binary op that is commutative.
Prepare a binary op that is not commutative.
Prepare a call using ObjC method dispatch without applying the 'self' and / '_cmd' arguments.
Prepare a jump destination here.
Prepare a new tuple to hold the shuffled result.
Prepare an Initialization that will initialize the result of the / current function.
Prepare buffer (dirname never changes)
Prepare buffer for writing
Prepare child for establishing dependency.
Prepare for input from a gdIOCtx stream.
Prepare for output to a stdio stream.
Prepare for the next round of checks.
Prepare for the next round.
Prepare for the real work.
Prepare generic target information.
Prepare the Apply args.
Prepare the Mouse event
Prepare the actual arguments to the CallBuiltin instruction, by converting a ParamPrep into a vector of SSATmps to pass to CallBuiltin.
Prepare the call to the underlying method.
Prepare the configuration object based on the command line arguments.
Prepare the context menu event
Prepare the end of initializer location.
Prepare the option character and the argument string.
Prepare the value slot in the optional value.
Prepare the variadic "arguments" as single +1 indirect parameters with the array's desired abstraction pattern.
Prepare to SILCombine.
Prepare to read the next record.
Prepare to start translating this region block.
Prepare to start translation of the first region block.
Prepare type substitution map.
Prepend "llvm." and change _ to .
Prepend the class that declared the private property if it isn't us.
Prepopulate the set of module prefixes.
Preprocess format into formatcodes and formatargs
Prescan some rows of pixels.
Preserve module expr type data to prevent further lookups.
Preserve origTc's weak property.
Preserve original filename (as this varies per-function and not per-unit in the case of methods imported from flattened traits)
Preserve parens when opening types.
Preserve specialization through this operation by peeling off the substitutions from a specialized conformance so we can apply them later.
Preserve the "toInspect" portion of the string to complete
Preserve the Clang type in the resulting abstraction pattern.
Preserve the depth of generic arguments by adding an empty outer generic param list if the conformance is concrete.
Preserve the optional type's original spelling if the interface type is the same as the original.
Preserve the original result type on a zero_result unless we imported it as Bool.
Preserve the sugar of the scalar field.
Preserve type information from the original type if possible.
Preserve whether the curry thunks lead to a direct reference to the method implementation.
Preset error values: no error propagated to first pixel from left
Presumably because that context was added later, as the constant context is left out in other arbitrary places as well.
Presumably we would not have gotten this far if the request_method or http_version were syntactically invalid.
Pretend it's a bit shorter.
Pretend that there was no error.
Pretty large but small enough to add something without overflowing.
Pretty printer for debuggin'.
Pretty-print a global variable to the designated stream.
Pretty-print the SILBasicBlock to errs.
Pretty-print the SILBasicBlock to the designated stream.
Pretty-print the SILFunction to errs.
Pretty-print the SILFunction to the designated stream.
Pretty-print the SILModule to errs.
Pretty-print the SILModule to the designated stream.
Pretty-print the declaration so we can point to it.
Pretty-print the declaration we've picked.
Pretty-print the superclass initializer into a string.
Pretty-print the vector.
Prevent against checking against the same bound generic type over and over again.
Prevent attempt to circularly inline.
Prevent bit 6 (CURSOR_FLAG_EXHAUST) from being set.
Prevent circular referenced objects/arrays or deep ones.
Prevent other's destructor from asserting.
Prevent saving config while reading it These are system settings, but can be loaded after the core runtime options are loaded.
Prevent spurious printir traces.
Prevent the signal polling thread from sending CmdSignal messages to the client.
Prevent warnings from -Wmissing-prototypes.
Prevents another thread from forking at the same time, before FD_CLOEXEC is set on the fds.
Previous RBP is at CFA - 2 .
Previous RIP is at CFA - 1 .
Previous instruction was unreachable
Previous parameters are definitely in scope, but we don't really know how to type-check them.
Previous revisions of the code would do explicit cleanups, but simply running the self-test after hash computation is more reliable.
Previously, this class was backed by an imap.
Primarily tests iteration.
Primary entrypoint for the debugger from the VM.
Primary entrypoint from the set of "debugger hooks", which the VM calls in response to various events.
Prime the new lexer with a '(' as the first token.
Primitive heuristics to get the user-written type.
Print CFG in dot format, coloring the blocks based on hotness.
Print Ext and add sub-types of Ext.
Print a TypeRepr if instructed to do so by options, or if the type is null.
Print a collection element type using Objective-C generics syntax.
Print a constraint value.
Print a field with a value.
Print a single flag if it is set.
Print a stored context to the given output stream for debugging purposes.
Print a stored entry (Clang macro or declaration) for debugging purposes.
Print a string containing C character escapes.
Print a string of the form "LLVM xxxxx, Clang yyyyy, Swift zzzzz", / where each placeholder is the revision for the associated repository.
Print a type variable value.
Print all the blocks first.
Print all translations in original order, filtered by unit if desired.
Print an error with magic line number.
Print an identifier value.
Print an unsigned value.
Print arcs in dot format.
Print equivalence class.
Print everything else.
Print in 8 clusters of 8 bits per row.
Print inlined-at location, if any.
Print it to the output file.
Print its message, with a blank before it if the previous item printed and this item isn't empty.
Print line and column number.
Print other types as their Swift representation.
Print out stats about what we ended up using
Print out the comment.
Print out the given DIE (including children) in textual format to the given ostream.
Print out the information for each loop.
Print out the lookup tables for the various modules.
Print protocol 'Self' as a generic parameter so that it gets annotated in cursor info.
Print reachable blocks first.
Print the (for now) non-null terminated string s.
Print the argument names.
Print the block CFG above the actual code.
Print the cases as the concatenation of the enum name with the case name.
Print the class type.
Print the content of the constraint.
Print the declarations and types from the origin module, unless we're not in whole-module mode.
Print the explicit raw value expression.
Print the generic parameters.
Print the given declaration context (with its parents).
Print the header and body
Print the inline tree.
Print the memory behavior in relation to all other values in the function.
Print the module where extension is defined.
Print the ownership semantics, if relevant.
Print the part of a function type that appears after where the variable / name would go.
Print the part that should be merged with the type decl.
Print the relevant parameters and return the new index.
Print the requirements.
Print the rest as synthesized extensions.
Print the summary table.
Print the type arguments, if present.
Print the type by substituting our context parameter names for the dependent parameters.
Print the type of location.
Print the type using our print options.
Print translations (all or for a given funcId) in the order they were created.
Print unreachable blocks last.
Print users, or id for valueless instructions.
Print var declarations separately, one variable per decl.
PrintDecl - Visitor implementation of Decl::print.
PrintExpr - Visitor implementation of Expr::print.
PrintStmt - Visitor implementation of Expr::print.
Printers for the underlying stream.
Printing substrings requires an additional copy operation, so do it only if necessary
Prints out information suitable for checking with filecheck.
Prints regular comments from clang module headers.
Prints regular comments of the header the clang node comes from, until the location of the node.
Prints the members of a class, extension, or protocol.
Prints the metadata, bytecode, and disassembly for the given translation
Prior to calling this routine, `uses' should contain the direct (non-transitive) use counts of each DefInlineFP instruction.
Prior to making any changes to the evaluation stack in between instructions, this function should be called.
Priority queue where the smaller elements come first.
Private and (unversioned) internal types always have a fixed layout.
Private and (unversioned) internal variables always have a fixed layout.
Private imports from this module.
Private instance and static properties are initialized using InitProp.
Private instance and static property types are stored separately from ClassInfo, because you don't need to resolve a class to get at them.
Private migration help for overrides of Objective-C methods.
Private utf8_strlen implementation.
Proactively populate, in order to increase cache locality for sequential access patterns.
Proactively set the destination metatype so that we can tail-recur, unless we've already done so.
Probably not actually autoreleased.
Probably only useful when the def instruction only has a single dst, but that's all we need right now.
Probably we don't have the right abstraction boundaries.
Probe for localised license file
Problem is, we don't have a ZendResourceData handy, as we should only get here if they've all been released.
Problem reported by Andreas Pfaller.
Proceed only if we were able to read the "Content-Length"
Process Action-specific output-specifying options next, since we didn't find anything applicable in the OutputMap.
Process Decl, recursively deserializing any thing Decl may reference.
Process Instruction which writes to memory in an unknown way.
Process LEN bytes of BUFFER, accumulating context into CTX.
Process UnresolvedDeclRefExpr by doing an unqualified lookup.
Process UserComment in IFD.
Process a COM marker.
Process a SOFn marker.
Process a TIFF header in a JPEG file
Process all bytes in the buffer with 128 bytes in each round of the loop.
Process all bytes in the buffer with 64 bytes in each round of the loop.
Process all external thread events that have completed their operation.
Process all instructions in the current block.
Process all received finished events.
Process all sleep handles that have completed their sleep.
Process all the continuations of that match before returning.
Process all the non-self parameters.
Process all types implementing protocols.
Process an JPEG APP1 block marker Describes all the drivel that most digital cameras include...
Process an JPEG APP12 block marker used by OLYMPUS
Process an apply instruction which uses a partial_apply / as its callee.
Process any destroy_addr and strong_release instructions that are invoked on / a partially initialized value.
Process any remaining cond_fail instructions in the current basic block.
Process as many whole blocks as remain
Process attributes in passes.
Process available complete blocks.
Process basic blocks in RPO.
Process basic blocks to perform the redundant load elimination.
Process conditional branches with constant conditions.
Process each basic block with the gen and kill set.
Process each basic block with the genset and killset.
Process each control for special handling in the new page.
Process each function, and consider merging its cluster with the one containing its most likely predecessor.
Process each of the IncRefs, including new ones that are created along the way.
Process each of the currently-unresolved entries.
Process everything transitively referenced by one of the functions in the worklist.
Process functions in any order.
Process instructions in post-order fashion.
Process instructions in the basic block in reverse post-order fashion.
Process instructions.
Process intervals in order of start position, maintaining the set of active (live) and inactive (not live, but with live ranges that start after the current interval).
Process key and retrieve type
Process loops bottom up in the loop tree.
Process loops recursively bottom-up in the loop tree.
Process nested IFDs directories in Maker Note.
Process one of the nested IFDs directories.
Process only non-static let properties here.
Process opcode's effects on the EvalStack and emit it
Process releases to adjust for this.
Process special builtins that are designed to check for overflows in integer conversions.
Process specialized loop-nests in loop-tree post-order (bottom-up).
Process string output to make it nicer...
Process string values only.
Process string, get positions and replace
Process the base classes first to maintain rough offset ordering.
Process the basic block for values generated in the current basic / block.
Process the basic blocks for the gen and kill set.
Process the basic blocks with the gen and kill set.
Process the callee convention.
Process the clang arguments last and allow them to override previously set options.
Process the current basic block with the genset and killset.
Process the error result.
Process the generic signature parameters.
Process the header info
Process the inner and outer types separately and then recombine them, since the minstr operations all operate on the inner cell of boxed bases.
Process the instructions in the basic block to find what refcounted roots are released.
Process the instructions in the basic block to find what refcounted roots are retained.
Process the names we found.
Process the parameters.
Process the remaining bytes in the internal buffer and the usual prolog according to the standard and write the result to RESBUF.
Process the rest of truncations.
Process the root node.
Process the self parameter.
Process this potential match.
Process this requirement, enumerating dependencies if anything else needs to be handled first.
Process truncation from unsigned to signed.
Process unicode field in IFD.
Process unknown read instructions.
Process until we run out of items in our worklist.
ProcessCommandLine - process the provided command line arguments.
Processes a single option/value pair.
Processing the failed constraint first slightly biases it in the ranking ahead of other failed constraints at the same level.
Produce a Fix-It replacing 'Self' with the nominal type name.
Produce a Substitution for a type that conforms to the standard library / _Pointer protocol.
Produce a class_method when thunking imported ObjC methods.
Produce a constant to place in a metatype's isa field / corresponding to the given metadata kind.
Produce a correct order of instructions.
Produce a correctly managed value.
Produce a deterministic ordering of the given declarations with / a bias that favors declarations in the given source file and / members of a class.
Produce a deterministic ordering of the given declarations.
Produce a diagnostic for a general conversion failure (irrespective of the / exact expression kind).
Produce a diagnostic for a general member-lookup failure (irrespective of / the exact expression kind).
Produce a diagnostic for a general overload resolution failure / (irrespective of the exact expression kind).
Produce a diagnostic if it doesn't make sense to ignore it.
Produce a diff of the solutions.
Produce a fixit hint to remove it.
Produce a flattened queue of LValues.
Produce a function pointer, suitable for invocation by / objc_msgSend, for the given constructor implementation.
Produce a function pointer, suitable for invocation by / objc_msgSend, for the given destructor implementation.
Produce a function pointer, suitable for invocation by / objc_msgSend, for the given method implementation.
Produce a function pointer, suitable for invocation by / objc_msgSend, for the given property's getter method implementation.
Produce a function pointer, suitable for invocation by / objc_msgSend, for the given property's setter method implementation.
Produce a nice diagnostic for this case.
Produce a physical address that corresponds to the given l-value / component.
Produce a reference to the C-compatible entry point for the function.
Produce a reference to the member, the type of the container it resides in, and the type produced by the reference itself.
Produce a score (smaller is better) comparing a parameter name and / potentially-typo'd argument name.
Produce a singular RValue for a load from the specified property.
Produce a specific diagnostic + fixit for this situation.
Produce a specific diagnostic about this.
Produce a tailored box metadata for the type.
Produce a tailored diagnostic for structs and enums.
Produce a tailored diagnostic since this comes up and is otherwise non-obvious what is going on.
Produce a tracelet for the callee.
Produce a witness_method when thunking ObjC protocol methods.
Produce all combinations of partial solutions.
Produce an error that this generic parameter cannot be bound.
Produce an unreachable code warning for this basic block if it contains user code (only if we are not within an inlined function or a template instantiation).
Produce diagnostic info if we are not within an inlined function or template instantiation.
Produce substitutions from the generic parameters to the actual arguments.
Produce tailored diagnostic for if/let and other conditions.
Produce the caller-side default argument for this default argument, or / null if the default argument will be provided by the callee.
Produce the concrete form of the opened type.
Produce the current fields as an anonymous structure.
Produce the foreign error convention from the imported error info, / error parameter type, and original result type.
Produce the heap metadata pointer for the given class type.
Produce the initializer for the private-data field of the / template header.
Produce the initializer value.
Produce the mangled name for this class.
Produce the mangled name for this protocol.
Produce the multibyte output
Produce the new generic function type.
Produce the result as an integer literal constant.
Produce the resulting function type.
Produce the type metadata pointer for the given type.
Produce the type when matching a witness.
Produce the value at +1.
Products derived from this software may not be called "Apache" nor may "Apache" appear in their names without prior written permission of the Apache Group.
Profile takes precedence over hot.
Profile the archetype constraints that may affect type layout into a / folding set node ID.
Profiler config options
Profiler factory- for starting and stopping the profiler
Profiler which makes a log of all function enter and exit events, then processes that into per-function statistics.
Program flow is not changed by this pass.
Program responsible for taking the parsed debug-information from TypeParser, analyzing it (along with user-provided annotations), and generating C++ code for GC type-scanners.
Progression order change
Progressively perform lookup into matching containers.
Prohibit strengthening.
Project down to the buffers and ask the witnesses to do a copy-initialize.
Project down to the buffers and ask the witnesses to do a take-initialize.
Project down to the buffers.
Project down to the destination fixed-size buffer.
Project down to the field.
Project out individual elements if necessary.
Project out the 'Some' payload.
Project out the materialized address.
Project out the optional callback.
Project out the payload area.
Project out the payload on the success branch.
Project out the payload.
Project the address of the contained value from a box.
Project the address of the element.
Project the address of the value inside a boxed existential container, / and open an archetype to its contained type.
Project the address of the value inside a boxed existential container.
Project the buffer and apply the 'typeof' value witness.
Project the ownership semantics of 'self' to the super argument.
Project the value out of a box of this type.
Project the value out, loading if necessary, and take ownership of it.
Projection path will indicate which field is accessed.
Projections are fine as well.
Promote a DebugValueAddr to a DebugValue of the given value.
Promote box allocations to stack allocations.
Promote memory to registers
Promote select_enum_addr to select_enum if the enum is loadable.
Promote stack allocations to values and eliminate redundant loads.
Promote stack allocations to values.
Promote switch_enum_addr to switch_enum if the enum is loadable.
Promote the Allocation.
Promote the arguments that need promotion.
Promote this alloc_box to an alloc_stack.
Promote this allocation.
Promote values of non-static let properties initialized by means / of constant values of simple types into their uses.
Promote-to-mixed path, we know the key is new and should be using findForNewInsert but aren't yet TODO(#2606310).
Promotes a single AllocStackInst into registers..
Promotes heap allocated objects to the stack.
Prop handler for mysqli.
Prop handler for mysqli_result.
Propagate 'required' to subclass initializers.
Propagate DestroyLoc for any destroy hoisted above a block.
Propagate across the taken edge if there is one, first doing any may-decrefs that only occur if the taken edge is traversed.
Propagate back types for simple patterns, like "var A, B : T".
Propagate constants into closures and convert to static dispatch.
Propagate constants through closure captures by specializing the partially / applied function.
Propagate copies through stack locations.
Propagate dead-in blocks upward via PostOrder traversal.
Propagate information about a concrete type from init_existential_addr / or init_existential_ref into witness_method conformances and into / apply instructions.
Propagate it to the in set.
Propagate l-value use information to children.
Propagate liveness and users through the tree.
Propagate liveness back from Arg to the terminator arguments that supply its value.
Propagate liveness backwards from an initial set of blocks in our LiveIn set.
Propagate relevant compiler-specific options to the runtime.
Propagate the "reaches-a-points-to-edge" backwards in the defer-edge sub-graph by adding those nodes to the WorkList.
Propagate the C++ exception to the outer VM nesting
Propagate the bits to all successor nodes.
Propagate the concrete type into a callee-operand, which is a witness_method instruction.
Propagate the concrete type into the callee-operand if required.
Propagate the count of an array created to count method calls on the same / array.
Propagate the count of array allocations to array.count users.
Propagate the count of array values to calls of the array's count method.
Propagate the current late bound class if there is one,
Propagate the element abstraction pattern.
Propagate the elements an of array value to its users.
Propagate the elements of an array literal to get_element method calls on / the same array.
Propagate the elements of array values to calls of the array's get_element / method.
Propagate the exit edges to the containing fault/try handlers, if there were any.
Propagate the false-value to the dependent entries.
Propagate the new access kind from the OVE to the original existential if we just set or changed it on the OVE.
Propagate the reachability up the control flow graph.
Propagate the side-effects to all callers.
Propagate the state to all successor nodes.
Propagate this to sub-expressions.
Propagate to parents so we can link inherited static props.
Propagate type-resolution errors out.
Propagate values of branched upon values along the outgoing edges down the / dominator tree.
Propagates the properties through the graph.
Propagating the bits in might have satisfied the entire conversion.
Propagation of liveness needs to use this (always more conservative) set instead of kill when crossing a factored exit edge.
Properties don't need anything here since they are always checked by name.
Properties in protocols use sufficiently limited syntax that we have a special parsing loop for them.
Properties in structs/classes are only ever mutable in their designated initializer(s).
Properties in this set cannot be removed.
Properties in this set should not be processed by this pass anymore.
Properties need some special validation logic.
Properties need to be collected in the properties list.
Properties of non-optional reference type that were imported from Objective-C.
Properties on the closure object are either use vars, or storage for static locals.
Properties that have storage and accessors are frequently accessed through accessors.
Property access is from within a parent class's method, which is allowed for protected properties.
Property access within this Class's context.
Property accessors should be generated alongside the property.
Property already exist - make array
Property decls in type context must bind variables.
Property exists, but it is either protected or private since accessible is false.
Property exists, is accessible, and is not unset.
Property information.
Property initialization.
Property is new or override, so add it
Property is non-NULL if we reach here.
Property is not accessible, try __get.
Property is not declared, and not dynamically created yet.
Property is not trivially backed by storage, do not perform direct access.
Property is unset, try __get.
Property lookup and accessibility.
Property types for public static properties, declared on this exact class (i.e. not flattened in the hierarchy).
Prospectively add a source.
Protect against corrupt headers
Protect against setting a non-tuple argument expression for a binop, which may occur as a result of error recovery.
Protected constructor for subclasses to override the kind passed to the / super class.
Protected properties may be weakened to public below, but otherwise, the parent's properties will stay the same for this class.
Protocol composition types are / structural in the swift type system, but LLVM's type system / doesn't really care about this distinction, and it's nice to / distinguish different cases.
Protocol composition types are not nominal, but we name them anyway.
Protocol compositions are currently never special.
Protocol compositions do not contain type parameters.
Protocol compositions have component types.
Protocol compositions.
Protocol conformance requirements.
Protocol constraints are the common case, so mangle them more efficiently.
Protocol declarations cannot be transparent.
Protocol descriptor references are free.
Protocol extensions cannot have inheritance clauses.
Protocol extensions do not contribute protocol conformances.
Protocol initializer arguments may not have default values.
Protocol method arguments may not have default values.
Protocol methods have no impl.
Protocol names are emitted with the _Tt prefix so that ObjC can recognize them as mangled Swift names.
Protocol properties have no impl.
Protocol requirement.
Protocol type manglings have a variable number of protocol names follow the 'P' sigil, so a trailing underscore is needed after the type name, unlike protocols as contexts.
Protocol types are existential and do not have witness tables.
Protocol types are nominal.
Protocol witness tables
Protocol witnesses always derive all polymorphic parameter information from the Self argument.
Protocol witnesses are called using the witness calling convention.
Protocols / Get the runtime identifier for a special protocol, if any.
Protocols don't have conformances.
Protocols don't support generic parameters, but people often want them and we want to have good error recovery if they try them out.
Protocols never have a stored properties.
Protocols serve two masters: generic algorithms and existential types.
Prove that RCIdentityBB dominates IncomingEdgeBB.
Prove that there are not array value mutating or capturing operations in the / loop and hoist make_mutable.
Provide a fixed type for the type variable.
Provide a list of template parameters to be filled in case this is a template.
Provide a working directory to Clang as well if there are any -Xcc options, in case some of them are search-related.
Provide an empty 'args' array to be consistent with hphpc.
Provide context as note diagnostics.
Provide custom implementations of the init(rawValue:) and rawValue conversions that just do a bitcast.
Provide helpful diagnostics like a shadow copy in the function body to fix the 'var' attribute.
Provide output indicating this command was skipped if parseable output was requested.
Provide some common bindings to complement editline's defaults.
Provide special indent/completion behavior for tab.
Provide specific diagnostics for assignment to subscripts whose base expr is known to be an rvalue.
Provide the text for the call parameter, including constructing a typed / editor placeholder for it.
ProxyArray also always involves virtual size, because of the possibility that it could be proxying a GlobalsArray.
ProxygenTransport must be released in worker thread
ProxygenTransportTraits
Prune out cases where it is acceptable to have a conflict.
Pseudo-functions for (de-)allocating array buffers on the stack.
Pseudo-main returns the integer value 1 by default.
Pseudomains inherit the context of their caller
Pseudomains inherit the variable environment of their caller, so don't assert anything in them.
Public classes can always be extended
Public interface and helper functions
Public is always accessible.
Public method, no private ancestor, no need for further checks (common)
Public methods are always visible.
Public properties are always accessible.
Public static property information.
Public visibility depends on the target object format.
Pull 32bit Big Endian words from an in6_addr
Pull SIMD types of size 2...4 from the SIMD module, if it exists.
Pull a 32-bit integer from the generator state Every other access function simply transforms the numbers extracted here
Pull off the next indirect result argument.
Pull out the body parameters, which we should have cloned previously to be forwardable.
Pull out the elements.
Pull out the generic signature.
Pull out the next binary operator.
Pull out the parameter value and its formal type.
Pull out the prospective RHS and slice off the first two elements.
Pull the class and property names.
Pull the generic param decl out of the imported class.
Pull the old value out of the address.
Pull the r-value apart.
Pull the top-level pattern back out.
Pump the parser multiple times if necessary.
Punt for now until we can figure out a fix.
Punt if path is relative.
Punt if the given base type isn't known to be boxed or unboxed.
Pure Clang modules are tied to their dependencies, no need to look into its imports.
Pure loads, stores, and IrrelevantEffects do not read or write any object reference counts.
Pure red always maps to 6 in this implementation.
Pure stores potentially (temporarily) break the heap's reference count invariants on a memory location, but only if the value being stored is possibly counted.
Pure-ObjC existential types.
Purge all dirty unused pages.
Purposefully fake name to avoid confusion with an actual type.
Push a cleanup to deallocate the local variable.
Push a cleanup to destroy the let declaration.
Push a cleanup to destroy the local variable.
Push a cleanup to execute the writeback consistently.
Push a mode onto the stack.
Push a new cleanup to deallocate the array.
Push a value from the evaluation stack with the specified symbolic flavor
Push a writeback for the temporary.
Push a writeback onto the current LValueWriteback stack.
Push an empty projection path to get started.
Push an empty string to get an xslt result.
Push an empty string, so that we at least have an xslt result...
Push an extra zero index node for a store to noninterior address.
Push an extra zero index node for the first interior address.
Push autoload, defaulting to true
Push in a special number to say that IDs are indices to the Archetypes.
Push in all the predecessors to get started.
Push into reverse post order so that we can pop from the back and get post order.
Push into the worklist in post order so that we can pop from the back and get reverse post order.
Push new activation record.
Push our null return value onto the stack
Push out the count and leave garbage behind.
Push return value of next()/send()/raise().
Push stack arguments, in reverse order.
Push state and update the marker before emitting any instructions so they're all given markers in the callee.
Push the address projections of the load onto the stack.
Push the current segment.
Push the generic context down to the SIL TypeConverter, so we can share archetypes with SIL.
Push the link register onto the stack.
Push the new instruction and any users onto the worklist.
Push the new throw destination.
Push the next child onto the stack.
Push the return value of next()/send()/raise().
Push the successor blocks to the WorkList.
Push the symbolic path name to the specified element number onto the / specified std::string.
Push to the innermost stream.
Push uninitialized instance.
Push uninitialized nulls for missing arguments.
Push/pop mechanism is as simple as X64: it stores 8 bytes below the SP.
Pushes the ids onto the passed vector.
Pushes the new state onto the stack.
Pushing for object method when we don't know the Func* statically.
Put CurPtr back into buffer bounds.
Put all of the keys from all the containers (except container1) into a Set.
Put all of the values from all the containers (except container1 into a Set.
Put all the unique and sorted layouts into the m_layouts list.
Put an invalid 'override' attribute here.
Put back the remaining cookies
Put buffered data together with inbound for a single block
Put checksum in context given as argument.
Put in an assert just in case.
Put in the correct context
Put out the final code.
Put result from CTX in first 32 bytes following RESBUF.
Put result from CTX in first 64 bytes following RESBUF.
Put socket in non-blocking mode so we can use poll() for timeouts.
Put the 128-bit file length in *bits* at the end of the buffer.
Put the 64-bit file length in *bits* at the end of the buffer.
Put the auxiliary output file next to the primary output file.
Put the block back at the end of workQ, since it may become reachable after processing some of the other blocks.
Put the call's return address in the link register.
Put the constraints back into their original bucket.
Put the disjunction constraint back in its place.
Put the framework search paths first so that they'll be preferred upon deserialization.
Put the header next to the primary output file.
Put the inputs in the order expected by the calling convention.
Put the module next to the top-level output.
Put the predecessors of BB into the Preds vector.
Put the result into cache.
Put the serialized diagnostics file next to the output file.
Put the thread to sleep.
Put the tokens into the symbol table, so that GDB and other debuggers know about them.
Put the value into a stack slot at -Onone.
Put the value's address into a stack slot at -Onone and emit a debug intrinsic.
Python-style long strings.
Quadratic filter, default radius 1.5
Qualified lookup case.
Qualify storage declarations with an lvalue when appropriate.
Qualify the filename so that DosQueryAppType does not do extraneous searches.
Quantization component
Quasi-lexicographic order: string length first, then string data.
Query whether the original type is address-only given complete / lowering information about its substitution.
Query whether the original type is returned indirectly given complete / lowering information about its substitution.
QueryMNewElem will always throw without doing any work.
Queue may contain received unprocessed events from failed runUntil().
Queue up all of the diagnostics, allowing us to sort them and emit them in file order.
Quick and dirty attempt at dtrace -F style function nesting.
Quick and dirty octal conversion.
Quickly determine if a debugger is attached to the current thread.
Quickly dump HHVM_VERSION.
Quickly skip to the first character that matches.
Quickly test if any further fix-ups for the argument types are necessary.
R/W lock for caching scopings of closures.
RAII based coloring of SIL output.
RAII class for printing multi-part C types, such as functions and arrays.
RAII guard for function creation.
RAII guard for temporarily overriding an Emitter's location
RAII helper for incrementing/decrementing indent levels.
RAII helper for tracking seen arrays and objects.
RAII object that prints with the given color, if color is supported on the / given stream.
RAUW the entry point function forward declaration with the real thing.
RC identity is more than a guarantee that references refer to the same / object.
RCIdentityBB must have a valid dominator tree node.
REFERENCES  Conversions Between Calendar Date and Julian Day Number by Robert J.
REFERENCES  I have found no detailed, authoritative reference on this calendar.
REMEMBER HDF WINS OVER INI UNTIL WE WIPE HDF
RENDERINGINTENT constants
REPL is only valid for javascript
REPL mode expects no input files, so suppress the error.
REPL mode requires no inputs.
REPL mode should always use the REPL module.
RESILIENCE: this could be an opaque conformance
RESOURCETYPE constants
REVERSE sort the decls, since we are going to copy them onto a stack.
RFC 2397 specifies 'data:' as the prefix, but zend's PHP supports 'data://' as well
RFC 3492 Section 5: Parameter values for Punycode
RGBAToYUV420: Generates Y, U, V data (with color subsampling) from 32 bits per pixel RGBA data buffer.
RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct for either sign of the error value.
ROTATE_LEFT rotates x left n bits.
RPCRequestHandler makes use of this.
RPCServer: Server + RPCRequestHandler
RSA Data Security, Inc.
RSP is unchanged in VM frames, except for some rare cases with calls to functions that we assume don't throw.
RValue has an invariant that loadable values have been loaded.
RaceTest(code) runs code in many threads simultaneously,  / and returns a vector of all returned results.
RaceTest_ExpectEqual(code) runs code in many threads simultaneously,  / verifies that they all returned the same value, and returns that value.
Raise a diagnostic if we run into a prohibited IUO.
Raise a fatal unless the existing class definition is identical to the one this invocation would create.
Raise a warning and return a pointer to init_null_variant.
Raise error if we parse an IUO type in an illegal position.
Raise frame is set to the current frame
Raise offset is set to the offset of the current PC.
Raise warnings/errors and return InitNull.
Raises an error on failure.
Ran out of spill slots.
Random examples to stress option types, values, etc:
Randomly choose which half to keep.
Ranges and uses were generated in reverse order.
Rank things by their kind as the highest priority.
Rather than bitcasting, we make an effort to do something that should explode if we get something mistyped.
Rather than deal with yet another case (which only happens when we disable jemalloc), just emit a smashable mov followed by a register cmp.
Rather than lose this distinction in vixl (it's really helpful for avoiding stupid mistakes), we sacrifice the ability to represent all 32 SIMD regs, and pretend there are 33 GP regs.
Rather than work through the various cases here, though, we've just decided to just play it safe and mark all the names involved as redeclaring for now.
Rather, the type is mapped to the underlying type.
Rather, they are understood from the module itself.
Rationale: this is partially intended to make it trivial to catch wrong-number-of-arguments errors, although it probably could be done without this if you feel like changing it.
Raw values cannot be automatically generated.
RawPointers do not have ownership semantics, so the cleanup on the argument remains.
RawRepresentable.RawValue
RawRepresentable.rawValue
Re-abstract if necessary.
Re-add it back unless this is a chunked response.
Re-calculate the stride
Re-enter the lexical scope.
Re-enter the top-level decl context.
Re-order the blocks to make sure they're in topological order if possible.
Re-register if still in a context.
Re-register the object with the cache to update its memory cost.
Re-simplify AssertType if we produced any.
Re-type-check the argument with the expected type of the candidate set.
Re-type-check the given subexpression even if the expression has already / been checked already.
Re-use an existing initializer context if possible.
Re-use an existing thunk.
Re-using uncurry level 0 is reasonable because our uncurrying transforms are idempotent at this level.
Re-write the single-expression closure to return '()'
Reabstract back to the requirement pattern.
Reabstract input value to the type expected by the enum.
Reabstract it if necessary.
Reabstract it to the substituted form, if necessary.
Reabstract the arguments.
Reabstract the base type against the array element type.
Reabstract the result value.
Reabstract the result.
Reabstract the return.
Reabstract the subscripts from the requirement pattern to the formal type.
Reabstract the value if the types don't match.
Reabstract to the most general abstraction, and put it into a temporary if necessary.
Reabstract to the substituted type, if needed.
Reabstraction information.
Reachable catch blocks and fault funclets have an empty stack.
Reached end of input for '*' repeater
Reached the end of the basic block, update the ForwardValOut with the / ForwardValIn.
Reached the end of the projection tree, this field can not be expanded anymore.
Reaching the outermost loop, we use the CallerWeight to get the outer length+loopweight.
Reactivate the result cleanup.
Read a dummy bool until we rev the protocol.
Read a lookahead token if we need one and don't already have one.
Read a numeric value from a pointer, into the value union of a magic pointer, according to the magic type.
Read all of the entries.
Read all trailing elements.
Read an unsigned value.
Read and instantiate the specialize attributes.
Read and uncompress an entire chunk.
Read and validate the continuation bytes.
Read back into another cache.
Read cwd symlink directly if it leads to the deleted path.
Read failed, error message populated by recv_header
Read field, leaving bptr pointing at start of next field
Read function properties only, e.g. its linkage and other attributes.
Read generic params before reading the type, because the type may reference generic parameters, and we want them to have a dummy DeclContext for now.
Read in the raw-archetypes buffer, but don't try to consume it yet.
Read inherited conformances.
Read it back from the cache.
Read preferences types
Read request body ONLY for POST and PUT, and ONLY if the "Content-Length" is provided
Read the associated type ids.
Read the associated type names.
Read the attributes (if any).
Read the cached results, failing if they are out of date.
Read the cached results.
Read the class name from between the two NUL bytes.
Read the declarations and macros.
Read the default_* properties from the link
Read the end-of-requirements record.
Read the extra info in the gd2 header.
Read the first path piece.
Read the generic parameters.
Read the generic requirements, if any.
Read the generic requirements.
Read the generic signature, if we have one.
Read the length of the section.
Read the number of high bits set, which indicates the number of bytes in the character.
Read the optional opened existential.
Read the raw archetype IDs into a different scratch buffer because we need to keep this alive for longer.
Read the rest of the data
Read the sector allocation table.
Read the substitution list and construct a SILSpecializeAttr.
Read the substitutions.
Read through some attributes
Read through typedefs until we get to a CF typedef or a non-typedef-ed type
Read typed data from an offset relative to a base address
Read whether the associated types are dependent archetypes.
Read-only lookup failed to find item, we may need to create it.
Reading the RC is as "bad" as releasing.
Reads a cursors body Returns -31 on failure, -80 on timeout, -32 on EOF, or an int indicating the number of bytes read
Reads a file into the OS page cache, with rate limiting.
Reads a python-style longstring, or returns false if we don't have one.
Reads a quoted string with typical escaping rules.
Real and reported length should be the same.
Real length of string literals computed based on its contents.
Reality check casts between concrete types.
Reallocate a file section returns 0 on success and -1 on failure
Reallocate string and return it
Really no point optimizing here as there is no dead stores.
Really no point optimizing here as there is no forwardable loads.
Really we don't care about /any/ of the type's members, only that it conforms to the protocol.
Really we should move that one optimization out of simplifyArgs ...
Reason about whether all parts are released.
Reassign the +1 storage with it.
Rebuild inherited conformances based on the root normal conformance.
Rebuild the ParenTypes for the given expression, whose underlying expression / should be set to the given type.
Rebuild the cache, then search again.
Rebuild the resulting function type.
Rebuild the sequence from the type-checked version.
Rebuild the uncurried accessor type.
Rebuilds the given 'self' type using the given object type as the / replacement for the object type of self.
Recalculating apcStr from mcret avoids a spill.
Recalculating ret from mcret avoids a spill.
Recall that the / Pattern may be involved in initializing more than just this one vardecl / though.
Recall that we can in general have more memory support locations for one aset than the tracked lower bound---this is one situation that can cause that.
Recast strcpy to handle unsigned chars used below.
Receive at least one finished event, or until waketime (a steady_clock time) is reached.
Receive at least one finished event.
Received malformed record data- bail out
Receives a +1 reference of the connection.
Rechain prev's forward pointer from pred to last.
Rechain the predecessors to go to the new preHeader.
Reclaim all translations associated with a SrcRec including the anchor translation.
Reclaim an autoreleased return value.
Recognize _BridgedNSError, which must pull in its witness table for dynamic casts to work
Recognize applications.
Recognize flags: -, #, BLANK, +
Recognize result conventions.
Recognize the unresolved constructor expression and determine where to place the RebindSelfInConstructorExpr node.
Recognize this and produce a fixit.
Recognize used conformances from an imported type when we must emit / the witness table.
Recommended practice is still to execute a rollback statement and ignore the error.
Recompute a predicted type for when the proven type changes (or when a new prediction is made and we want to discard the old one).
Recompute elms, in case resizeIfNeeded() had side effects.
Recompute the summary flags if we had any to begin with.
Reconstitute type sugar, e.g., for array types, dictionary / types, optionals, etc.
Reconstruct AST substitutions from parsed substitutions using archetypes / from a SILFunctionType.
Reconstruct the address of the call from the saved RIP.
Reconstructing branch operands.
Recontextualize any closure declcontexts nested in the initializer to realize that they are in the getter function.
Recontextualize any closure declcontexts nested in the initializer to realize that they are in the initialization context.
Recontextualize any closure declcontexts nested in the initializer to realize that they are in the parameter function.
Record Objective-C methods.
Record a (non-type) witness for the given requirement.
Record a bunch of parsed accessors into the given abstract storage decl.
Record a store into this object.
Record a type witness.
Record additional weight increases.
Record all generated layouts in m_layouts (ignoring ignored or conservative ones since those have hard-coded scanners).
Record all of the explicit conformances.
Record and return the simple conformance.
Record any generic parameters that come from this decl, so that we can use the decl to refer to the parameters later.
Record any optional adjustment that occurred.
Record archetype contexts.
Record each of the deduced witnesses.
Record either the canonical signature or an indication that this is the canonical signature.
Record explicit conformances and import inherited conformances before expanding.
Record identifier for the file.
Record info about the current thread for the debugger client to use when listing all threads which are interrupted.
Record inherited protocols.
Record new generic parameter.
Record number of times a globalinit_func is called by "once".
Record optional adjustment, if any.
Record releases of the box.
Record return statements.
Record solved constraint.
Record stores into the box.
Record that contains the list of Objective-C category/extension IDs.
Record that contains the mapping from base names to entities with that / name.
Record that contains the mapping from contexts to the list of / globals that will be injected as members into those contexts.
Record that the given optional requirement has no witness.
Record that there is no witness.
Record that this type conforms to the given protocol.
Record that we are assuming that the eval stack is empty
Record that we depend on the type's conformance.
Record that we have ended the request so any further output is discarded.
Record that we want to emit its body, and add it to the worklist.
Record that we've reported this unreachable block to avoid duplicates in the future.
Record that we've traversed this dependency.
Record the Objective-C class to which this CF type is toll-free bridged.
Record the SILValue to location mapping.
Record the TRC for this storage declaration so that when we process the accessor, we can use this TRC as the parent.
Record the adjacent type variables.
Record the appropriate offset into m_layouts for each indexed type to refer to its layout.
Record the arc if dstBlockId was included in the region.
Record the attributes.
Record the block of the first user and move on to other users.
Record the caller-side default argument expression.
Record the change, if there are active scopes.
Record the children cost, then push it onto the children list
Record the component of each of the constraints.
Record the component of this type variable.
Record the conformance.
Record the constructor for future re-use.
Record the curly braces but nothing inside.
Record the current line number of the instruction.
Record the deallocation instruction.
Record the default witness for a requirement.
Record the diagnostic info.
Record the end of a translation, storing the size of cold and frozen, returns a TransLoc representing the translation.
Record the error convention.
Record the fact that we're opening this existential.
Record the failure, if we haven't seen one already.
Record the first argument for the variadic.
Record the first method that has this selector.
Record the frame if we are collecting
Record the function or initializer overridden by the given Swift method.
Record the generic type parameter types and the requirements.
Record the implementation type.
Record the incrementally constructed reffiness predictions.
Record the index and continue.
Record the inherited conformance.
Record the initial set of search paths.
Record the initializer as an alternative declaration for the / member.
Record the interface type.
Record the location of the 'class' keyword.
Record the name of a block.
Record the name of a record within a block.
Record the name of this Objective-C method in its class.
Record the namespace in the scope and recurse.
Record the object under the original type.
Record the opened existential.
Record the overflow check and try to optimize other checks.
Record the owner of the default argument.
Record the problem in the conformance table.
Record the remapping using the name of the Clang declaration.
Record the requirement.
Record the start of a translation, and reserve space at the top of cold and frozen (if they aren't the same) to record sizes.
Record the subscript as an alternative declaration.
Record the substitutions in a bound generic type.
Record the sugared field name.
Record the summary for the current function and continue with the new function.
Record the superclass.
Record the type as soon as possible.
Record the type witness.
Record the unsatisfied dependency.
Record the users of a value or an element within that value along with the / operand that directly uses the value.
Record the variables that we're trying to initialize.
Record the variables that we're trying to set up.
Record this argument name.
Record this as a conformance within the given declaration context.
Record this as a generated constraint.
Record this as the alternate declaration.
Record this component.
Record this conformance.
Record this extension so we can find it later.
Record this method in the source-file-specific Objective-C method table.
Record this object type, with fully qualified name, key, and linkage.
Record this overload set.
Record this parameter.
Record this raw type.
Record this requirement.
Record this same-type requirement.
Record this substitution.
Record this type variable.
Record this value witness, popping it when we exit the current scope.
Record this witness in the conformance.
Record what we want to change.
Record whether they come from re-exported modules.
Records a reverse dependency.
Records any type/reffiness predictions we depend on in the region.
Records the beginning and end of a translation and stores the size of the cold and frozen regions in the first 4 bytes of their respective regions.
Records the last store instruction in each block for a specific / AllocStackInst.
Recover 'self' from the context.
Recover by arbitrarily binding the first two.
Recover by creating AnyPattern.
Recover by creating a "_" pattern.
Recover by injecting the force operation (the first option).
Recover by just ignoring the label.
Recover by propagating an undef result.
Recover by searching for the next decl except variable decls and cutting off before that point.
Recover by setting the raw type as this element's type.
Recover by using the brace statement as a 'for' body.
Recover by using the original expression as the condition and brace statement as a 'for' body.
Recover from a 'case' or 'default' outside of a 'switch' by consuming up to / the next ':'.
Recover from all of the clauses failing to parse by returning a normal do-statement.
Recover from erroneous extension.
Recover from the 'if let case' typo gracefully.
Recover the decl reference.
Recover the original type if needed.
Recover with an infinite-precedence left-associative operator.
Recreate as a borrowed value.
Rectify the (possibly different) types determined by the / getter and setter for a subscript.
Rectify the setter element type with the getter's element type.
Recur into simple wrapping patterns.
Recurse into implied protocols.
Recurse into nested declarations.
Recurse into optional types.
Recurse into protocol compositions.
Recurse into the autoclosure body using the same sequence, but parenting to the autoclosure instead of the outer closure.
Recurse into the superclass.
Recurse on the type of the destination, pulling LValues as needed from the queue we built up before.
Recurse to check the parent type, if there is one.
Recurse to mark adjacent nodes as part of this connected component.
Recurse to satisfy any unsatisfied dependencies.
Recurse with all combinations of bases and interfaces in the naming environment.
Recursion level for this function
Recursion of magic property accessors is allowed, but if you recurse on the same object, for the same property, for the same kind of magic method, it doesn't actually enter the magic method anymore.
Recursive call already diagnosed this problem, but tack on a note to establish the relationship.
Recursive calls to irGenRegionImpl will reset the successor block mapping
Recursive function to check if a given object has a countable base somewhere in its type hierarchy.
Recursive into children of this type.
Recursively add the child
Recursively add the given protocol and its inherited protocols to the / given vector, guarded by the known set of protocols.
Recursively cast into the layout compatible payload area.
Recursively check all successors.
Recursively check for users after stripping this component from the access path.
Recursively check that the uses of the instruction don't escape.
Recursively check the transitive captures.
Recursively collect transitive captures from captured local functions.
Recursively collect uses of the fields.
Recursively construct the xml
Recursively decompose tuple types.
Recursively emit a decision tree from the given pattern matrix.
Recursively follow projections.
Recursively gather the set of type variables referenced by this constraint.
Recursively generate layout for the base.
Recursively invalidate the cached paths rooted at "node/name".
Recursively letting them remove themselves via expiry will remove them one by one via erase().
Recursively look at all uses of this definition.
Recursively merge the associated types of T2 into T1.
Recursively move all the parents to the parent context.
Recursively move all wait handles blocked by us.
Recursively move struct_element_addr.
Recursively process its uses with the adjusted element number.
Recursively profile nested archetypes.
Recursively put parents first.
Recursively remove all instructions hanging off the allocation instruction, then return success.
Recursively resolve the associated types to their concrete types.
Recursively satisfied.
Recursively search for other (non-)loads in the instruction's uses.
Recursively search for other loads in the instruction's uses.
Recursively see through struct_element_addr, tuple_element_addr, and open_existential_addr instructions.
Recursively specialize and emit the clause matrix.
Recursively visit all our ancestors.
Recursively visit all the descendants of Parent.
Recursively visit b and its successors.
Recursively visit callee's BB in depth-first preorder, starting with the entry block, cloning all instructions other than terminators.
Recursively visit original BBs in depth-first preorder, starting with the entry block, cloning all instructions other than terminators.
Recursively visit successors.
Recursively visit the called function.
Recursively walk into the given formal index type, expanding tuples, / in order to form the arguments to a subscript accessor.
Recursively walk the SIL value being assigned to the SILG.
Recursively walk the operand chain through cast / instructions to ensure that all dependents are cloned.
Recursively walk the result types.
Recursively walk tuple arguments.
Recursively write the child
Recursively write the this property.
Redeclared prop, make sure it matches previous declaration
Redeclared prop, make sure it matches previous declarations
Redefine yyless() so it works in section 3 code.
Redefining the struct here is technically an aliasing violation, but we can just tell the compilers that actually use TBAA that this is okay.
Redirect all FailurePreds to the copy of BB.
Redirect all SuccessPreds to the copy of BB.
Redirect f's result's retains/releases to affect x.
Redirect standard files to /dev/null
Redirect the HeaderBlock target to the unrolled successor.
Redirect the backedge blocks to BEBlock instead of Header.
Redirect the incoming defer edges.
Redirect the outgoing defer edges, which may also trigger other node merges.
Redirect the terminator of the current loop iteration's latch to the next / iterations header or if this is the last iteration remove the backedge to / the header.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  1.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1.
Redistributions of source code must retain the above copyright notice immediately at the beginning of the file, without modification, this list of conditions, and the following disclaimer.
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Reduce conventions for trivial types to an unowned convention.
Reduce the available values into a single SILValue we can use to forward
Reduce the available values into a single SILValue we can use to forward.
Reduce the number of load/stores in the function to minimum.
Reduction should not care about the order of the memory locations in the set.
Redundant keyword arguments.
Redundant specifiers are fairly common, recognize, reject, and recover from this gracefully.
Reemit the capture params as unsubstituted.
Reemit the parameters as unsubstituted.
Reenable the cleanup for the optional on the normal path.
Reencode well-formed UTF-8 as UTF-32.
Reestablish our iterator if it wrapped.
Ref count already incremented in Create
Ref count checks do not have side effects, but are barriers for retains.
Ref inner cells are at worst InitCell, so don't bother checking for that.
Ref to raw pointer consumption of other ref casts.
Ref: ftp://ftp.ora.com/pub/examples/nutshell/ujip/doc/japan.inf-032092.sjs
RefCounting operations on Self are ok since we are already in the destructor.
RefCountingOperations on other instructions could have side effects though.
RefData objects contain at most one ptr, scan it eagerly.
Refcount initialized to 1.
Refer to 'self' as the base of the lvalue.
Refer to a member of the archetype directly.
Refer to the stacks thru separate pointers, to allow yyoverflow to reallocate them elsewhere.
Reference cast from representations with single pointer low bits.
Reference semantics: need to preserve the cleanup handle.
Reference storage types propagate the decision.
Reference storage types with witness tables need open-coded layouts.
Reference storage types.
Reference the next uncurrying level of the function.
Reference to an unbound instance method.
Reference to super.init.
Reference types are only permitted as function parameter types.
Reference types have 'self' of type T.
References to Self in a position where subclasses cannot do the right thing.
References to boxed existential containers may be shared.
References to properties with accessors and storage usually go through the accessors, but sometimes are direct.
References to the param should have lvalue type instead.
Reffiness guards are always at the beginning of the trace for now, so calculate the delta from the original sp to the ar.
Refine the else branch if we're given a version range for that branch.
Refine the salt first
Refine the value for `state' to `newVal' if it was set to `oldVal'.
Reform the original structure
Reformat the specified line with the calculated indent.
Refresh stats to reflect directly malloc()ed memory, and determine whether the request memory limit has been exceeded.
Refs can never contain Uninit, so this lets us return UncountedInit rather than Uncounted, and InitCell rather than Cell.
Refuse if the cost exceeds our thresholds.
Refuse if the variadic parameter actually captures something.
Refuse to draw if no style is set.
Refuse to fill to a non-solid border
Refutable patterns occur when checking the PatternBindingDecls in an if/let or while/let condition.
Refutable patterns occur when checking the PatternBindingDecls in if/let, while/let, and let/else conditions.
Refutable patterns shouldn't ever come up.
Refutable patterns that we'll handle in a later pass.
Regardless of ParamCoerceMode, native functions can return null if too many arguments are passed.
Regardless of refCount, this Class is now unusable.
Regardless of the command loop result, we exit.
Regardless of thinness, metatypes are always trivial.
Regardless of whether or not promotion happens, we know the base cannot be Null after the operation.
Regardless of whether the inline cache was populated, smash the call to start doing real dispatch.
Regardless, the return value is the result of the commuted comparison.
Regardless, the storage size goes up.
Regenerate all prologues of func that were previously generated.
Regenerate the prologue.
Regenerate the prologues and DV funclets before the actual function body.
Regex instance for empty matches
Regex matchers for spaces and numbers.
Region exits These exits don't leave the current php function, and could head to code that could read or write anything as far as we know (including frame locals).
Region-selector that unintelligently takes a whole method at a time.
Regionize a func, so that each node and each arc in its TransCFG is "covered".
Regionize func and translate all its regions.
Regions to not inline
Register ObjC protocol conformances.
Register ObjC protocols, classes, and extensions we added.
Register PHP function given in string argument.
Register PHP functions given in array argument.
Register Swift Only Passes.
Register Swift protocol conformances if we added any.
Register a "StreamOperator" for this Meta Type, so we can easily serialize/deserialize the cookies
Register a busy handler to avoid spurious SQLITE_BUSY errors.
Register a cleanup to invoke the closure on any exit paths.
Register a cleanup with the ASTContext to call the conformance table destructor.
Register a cleanup with the ASTContext to call the lookup table destructor.
Register a forward declaration before we look at any of the child types.
Register a null catch trace to indicate this to the unwinder.
Register all available PHP functions.
Register all the FDEs.
Register allocation state.
Register any fixes produced along this path.
Register any necessary patches by creating fake labels for the stubs.
Register constraint restrictions.
Register copy resolutions for livein sets and phis.
Register dirtiness: thread-private.
Register global functions
Register namespaces in the node
Register our info with the runtime if needed.
Register overload choices.
Register that we are no longer writing.
Register that we're no longer writing.
Register the abbreviation codes so these layouts can exist in both decl blocks and sil blocks.
Register the accessor as an external decl if the storage was imported.
Register the class as the main class in the module.
Register the connection on successful pinging
Register the end of the init as the end of the delayed parsing.
Register the memory buffer.
Register the new block as the start of the postmatter if needed.
Register the new line
Register the opaque value for the projected existential.
Register the solution's disjunction choices.
Register the solution's opened existential types.
Register the solution's opened types.
Register the window class and create the window.
Register these types for testing.
Register this class with the runtime.
Register this pass...
Register this thread as being debugged
Register this thunk as an external definition.
Register trace consumer
Register with the active ConditionalDominanceScope if necessary.
Register with the conditional dominance scope if necessary.
Registering an alternative Message Handler
Registers that can safely be used for scratch purposes in-between traces.
Regular locations are allowed on all instructions.
Reinitialize with the new value.
Reject 'destructor' functions outside of classes
Reject 'subscript' functions outside of type decls
Reject a where clause.
Reject accessors on 'let's after parsing them (for better recovery).
Reject an empty 'switch'.
Reject attempts to define builtin operators.
Reject cases where this is a variable that has storage but it isn't allowed.
Reject constructors outside of types.
Reject generic parameters with a specific error.
Reject it on global functions, structs, enums, etc.
Reject non-default address space pointers.
Reject over-large code points.
Reject requirements other than constraints with an subject other than `Self`
Reject shifting all significant bits
Reject static functions at global scope.
Reject them unless this is a SIL input.
Reject things like 0.1e5 and hex literals.
Reject this with a circularity diagnostic.
Reject use of "T.dynamicType", it should be written as "T.self".
Relabel R/G/B as components 0/1/2, respecting the RGB ordering defined in jmorecfg.h.
Relabel the indices according to the subscript name.
Related decls are generally overloads, so print parameter types to differentiate them.
Relational constraints: break out to look for types above/below.
Relative addresses can be 32-bit even on 64-bit platforms.
Relax guards and record the ones that survived.
Relax the region guards.
Relax the type to something guardable.
Relax typeParam with its current constraint.
Release of ThinToThickFunction is a no-op.
Release on a functionref is a noop.
Release the connection
Release the non-consumed parameters.
Release the old value.
Release the provider handle.
Release the semaphore if it has been acquired but not released.
Release the value that was stored into the existential box.
ReleaseCodeMotionContext - Context to perform release code motion.
ReleaseValueInst of a reference type is a strong_release.
ReleaseValueInst of a trivial type is a no-op.
ReleaseValueInst of an unowned type is an unowned_release.
Releases are always safe.
Releases are blocked by MayInterfere.
Releases must be matched by a retain otherwise a destructor could run.
Releases of the box arguments get replaced with ReleaseValue of the new object type argument.
Relies on the fact that only one SessionModule will be active in a given thread at any one moment.
Relocate STACK from its old location to the new one.
Relocate code in the range start, end into dest, and record information about what was done to rel.
Relocate the metadata if necessary.
Relocation is not implemented on ppc64.
Relocation is not supported on arm.
Rely on irgen to rewrite the function name.
Remaining cases should only come up when we're re-typechecking.
Remaining code will be emitted to the next block.
Remaining references to the FP must be from nested DefInlineFP instructions that were already moved off the main execution path
Remangle generic params.
Remangle that into a new type mangling string.
Remap an lvalue referencing a concrete type to an lvalue of a / generically-reabstracted type.
Remap an lvalue referencing a generic type to an lvalue of its / substituted type in a concrete context.
Remap the PNG palette to put the entries with interesting alpha channel values first.
Remap the ParamDecls inside of the ParameterList.
Remap this to use the InOutArg directly instead of using the allocation.
Remap to the palette available in the destination image.
Remap vardecls that the case body is expecting to the pattern var locations for the given pattern, emit whatever, and switch back.
Rematerialize the projection if needed by simply moving it.
Remeber this thread's VM ThreadInfo so we can find it later via isThreadDebugging().
Remember all direct subclasses of the current one.
Remember all the access kinds we needed along the path.
Remember all the disjunction choices we made.
Remember all the extra ways we have of reaching the parameter archetypes due to type equality constraints.
Remember current page
Remember file position of image data.
Remember if this pass didn't change anything.
Remember that any new constraints generated by opening this generic are due to the opening.
Remember that this alloc_ref allocates the object on the stack.
Remember that this is the memory location that we're emitting the / decl to.
Remember that we have this type metadata concretely.
Remember that we're mangling a context.
Remember the GEP to the first element.
Remember the binding, and succeed.
Remember the blocks we are going to change.
Remember the cleanup that will be activated.
Remember the current depth and level.
Remember the element cleanup.
Remember the first type decl context in the hierarchy for later use
Remember the global ivar offset if present.
Remember the new SSATmps (the dests) which will need to be renamed.
Remember the opened existential types.
Remember the opened types.
Remember the property-calls for later.
Remember the result value used to branch to this instruction.
Remember the start of the token so we can form the text range.
Remember the statically known value.
Remember the unique result in the invasive cache.
Remember these for the binary ringbuffer.
Remember this as the exemplar to use.
Remember this in our cache in case it's a recursive function.
Remember this init for the PatternBindingDecl.
Remember this pattern/init pair for our ultimate PatternBindingDecl.
Remember to deallocate later.
Remember we formed a C function pointer so we can diagnose later if necessary.
Remember where the "data offset" will go.
Remember where this file data is going.
Remember where this property is accessed.
Remember where we started so that we can find the comment range.
Remember whether this is a function parameter.
Remember, it's a colour circle
Remember, preserve vowels at the beginning
Remote WebDriver mode requested
Removal of cond_fail (overflow on binary operations).
Removal should always succeed here because no other code performs removal.
Remove "once" call from the addressor.
Remove CLI script heading
Remove NetworkAccessManager's ownership of this CookieJar and pass it to the PhantomJS Singleton object.
Remove Subregion from R's exiting subregion array if Subregion no longer has /any/ non-local successors.
Remove a copy for which canNRVO returned true.
Remove a layer of l-value type if present.
Remove all instructions following the noreturn call.
Remove all instructions that were marked dead, and replace instructions that can be replaced with pops but aren't dead.
Remove all of the defaulted arguments.
Remove all old release instructions.
Remove all old retain instructions.
Remove all the now-dead applies.
Remove all uses with the empty tuple ().
Remove an unused global token used by once calls.
Remove any - from the wrong name for better comparing since it will probably come prepended with --
Remove any applies we are deleting so that we don't attempt to specialize them.
Remove any code that follows a (cond_fail 1) and set the block's terminator to unreachable.
Remove any conditional entries from the chains that were added in this scope.
Remove any constraint restrictions.
Remove any constraints that were generated here.
Remove any disjunction choices.
Remove any duplicate type variables.
Remove any existing diagnostics files so that clients can detect their presence to determine if a command was run.
Remove any location filter that may have been setup.
Remove any may/must-aliasing stores to the LSLocation, as they can't be used to kill any upward visible stores due to the interfering load.
Remove any opened existential types.
Remove any opened types.
Remove any overridden declarations from the found-declarations set.
Remove any retain and release instructions.
Remove any shadowed declarations from the found-declarations set.
Remove any solution that is worse than some other solution.
Remove any superseded conformances from AllConformances.
Remove archetypes from this scope from the set of active archetypes.
Remove args from the block.
Remove call to array.props.read/write.
Remove calls to Builtin.staticReport().
Remove checks we have seen for the first time.
Remove clobbered loads we have seen before.
Remove critical edges for the SSA-updater.
Remove dead array.count calls.
Remove dead functions.
Remove dead instructions by doing a traditional liveness analysis.
Remove duplicated declarations.
Remove duplicates then insert the name
Remove elements from key.
Remove everything after the first null
Remove from pConds the elements that correspond to stack positions that have been popped given the current SP offset from FP.
Remove implicit conversions from the expression.
Remove in the future.
Remove instructions from the basic block after a call to a noreturn function.
Remove instructions that we are loading from.
Remove internal functions that are not referenced by anything.
Remove it from the class list.
Remove it from the map as well.
Remove last checked_cast_br, because it will always succeed.
Remove llvm.ident that ClangCodeGen might have left in the module.
Remove no-op copy sequences before allocating spill space, since doing so might modify the CFG.
Remove null elements from the list.
Remove old Meteor installs
Remove operands that are not used anymore.
Remove platform name.
Remove pointless reabstraction thunk closures.
Remove redundant checks along the dominator tree in a loop and hoist checks.
Remove redundant checks down the dominator tree inside the loop, starting at the header.
Remove redundant checks in a basic block.
Remove redundant checks in basic blocks and hoist redundant checks out of / loops.
Remove redundant checks on a per basic block basis.
Remove redundant runtime calls for stack allocated buffers.
Remove references from the dead blocks.
Remove references to empty arrays.
Remove retain/release pairs around builtin "unsafeGuaranteed" instruction / sequences.
Remove retain/releases based on Builtin.unsafeGuaranteed
Remove runtime asserts such as overflow checks and bounds checks.
Remove shadowed declarations from the list of declarations.
Remove stores and record the value that we are saving as the running value.
Remove switch_enum instruction
Remove the "debt" accrued from allocating the slabs so we don't double count the slab-based allocations.
Remove the 'self' type from the given type, if it's a method type.
Remove the AllocRef and all of its users.
Remove the Content-MD5 header coming from PHP if we compressed the data, as the checksum is going to be invalid.
Remove the DynamicSelfType from OrigType, too.
Remove the adjacencies for all adjacent type variables.
Remove the alloc_global instruction.
Remove the blocks we never reached.
Remove the bounds check.
Remove the breakpoint from the unmatched set.
Remove the breakpoint if it was temporary.
Remove the callee from the FPI Stack.
Remove the cast and insert a trap, followed by an unreachable instruction.
Remove the closure argument.
Remove the constraint from the constraint graph.
Remove the constraint.
Remove the copy_addr from Uses.
Remove the current AAWH from the parent chain of all children.
Remove the dead failureBB.
Remove the declarations we temporarily inserted.
Remove the entries from the map.
Remove the entry if its name or context does not match the filter.
Remove the expression from being in the list of decls to execute, we're going to reparent it.
Remove the image from the stack
Remove the instructions that are not potentially useful.
Remove the instructions that were marked as redundant / and return True if and instructions were removed.
Remove the instructions.
Remove the last extension declaration.
Remove the load to look at the address we are loading from.
Remove the matching isNativeTypeChecked and check_subscript call.
Remove the old Apply instruction.
Remove the old DeallocStackInst instructions.
Remove the old check in the loop and the match the retain with a release.
Remove the old constraint.
Remove the old release instructions.
Remove the old retain instructions.
Remove the old retains and create the new *moved* refcounted instructions
Remove the original constraint from the inactive constraint list and add the new one.
Remove the prefix, if any.
Remove the reference from the instruction being deleted to this operand.
Remove the setter attribute.
Remove the size of the first instance, because a single instance of a function is always needed and does not contribute to the _overhead_.
Remove the solver state.
Remove the values before sending to client.
Remove this adjacency from the mapping.
Remove this constraint from the constraint mapping.
Remove this disjunction constraint from the list.
Remove this expression from the stack.
Remove this from the s_loggers vector
Remove this function as soon as we can / get rid of the llvm SwiftStackPromotion pass.
Remove this hack when we don't care about older Clangs on all platforms.
Remove this instruction from our data structures, since we will be removing it.
Remove this optional requirement from the list.
Remove this pindef from AvailablePins.
Remove this type variable from the list.
Remove this when PolymorphicFunctionType goes away.
Remove this when they go away.
Remove those overload locators for which this solution did not have an overload choice.
Remove those type variables for which this solution did not have a binding.
Remove tracked state for the actrec and array arg.
Remove tracked state for the slots for args and the actrec.
Remove trailing semicolon
Remove trailing slash except when the resolved pathname is a single "/".
Remove unreachable blocks from `m_data'.
Remove unreachable blocks.
Remove unused capacity
Remove write-only AllocStacks.
Removes a range of PCs to the filter given a collection of offset ranges.
Removes all dead methods from vtables and witness tables.
Removes and deletes the top of the stack, if present.
Removes available pins that could be released by executing of 'I'.
Removes edges to original dests.
Removes meta-data about a caller to a proflogue from prof-data to ensure that a call to an optimized translation isn't wrongly smashed later.
Removes redundant check_unowned calls if they check the same reference and / there is no instruction in between which could decrement the reference count.
Removes whitespaces from the end, and replaces control characters with ' ' from the beginning.
Removes whitespaces from the end.
Removing a breakpoint with the given id.
Removing any newly inserted arguments that are actually dead.
Removing the useless copy can be thought of as forwarding the original object directly to the call argument in place of the copy.
Removing unreachable incoming edges can change types, so if we changed anything we have to reflow to maintain that IR invariant.
Rename all the source SSATmps that need renaming.
Rename functions with public_external linkage to prevent symbol conflict with stdlib.
Rename the method and create a new method with the original name
Render the web page onto the small tile first
Renumber the old components to the new components.
Reorder and rewrite the most nested concat subsequence, and append it to the previous subsequence in the stack.
Reorder the blocks in the region in topological order (if region is acyclic), since the previous steps may break it.
Reparenting is required with: - nested autoclosures, because the inner autoclosure will be parented to the outer context, not the outer autoclosure - non-local initializers
Repeatedly reverse translation components.
Repeatedly run the collected hash value through SHA256 to burn CPU cycles.
Repeatedly run the collected hash value through SHA512 to burn CPU cycles.
Repeatedly select and split the largest box until we have enough boxes
Replace ")(" with ", ", so "(x: Int)(y: Int)" becomes "(x: Int, y: Int)".
Replace 'Self' with the conforming type.
Replace AllocStacks with Phi-nodes.
Replace DebugValueAddr with DebugValue.
Replace DefLabel with Mov's
Replace OldSuccID by NewSuccID, just deleting OldSuccID if what NewSuccID / is already in the list.
Replace OtherSt with this store.
Replace Self in the parent archetype.
Replace a block argument if all incoming values are equal.
Replace a conditional branch with a Jmp if both branches go to the same block.
Replace a convert_function that only has refcounting uses with its / operand.
Replace a dead apply with a new instruction that computes the same value, and delete the old apply.
Replace a dependent member with a fresh type variable and make it a member of its base type.
Replace a generic type parameter with its corresponding type variable.
Replace all calls of an addressor by calls of a getter .
Replace all incoming inputs with undef and try to delete the instruction.
Replace all loads from the / global address by invocations of a getter that returns / the value of this variable.
Replace all loads from the / property by its constant value.
Replace all retain/releases on convert_function by retain/releases on its argument.
Replace all uses at this level of the tree with uses of the newly constructed aggregate.
Replace all uses of Dest with a use of Src.
Replace all uses of the ApplyInst with the new argument.
Replace all uses of the address of the box's contained value with the address of the stack location.
Replace all uses of the apply instruction with the operands of the return instruction, appropriately mapped.
Replace all uses of the check subscript call by a use of the empty dependence.
Replace all uses of the old apply with the new apply.
Replace all uses of the old instruction by a new instruction.
Replace all uses of the old load with the data and erase the old load.
Replace all uses of the old load with the new bitcasted result and erase the old load.
Replace all uses of the original arg with the new value.
Replace all uses of the retain instructions with our new retainN and then delete them.
Replace all uses outside of I's basic block by undef.
Replace allocateBuffer and destroyBuffer with logging versions.
Replace already-emitted aliases with external declarations.
Replace an application of a cast composition f_inverse(f(x)) by x.
Replace an array.props call by the 'fast swift array' value.
Replace an existing external declaration for the address point.
Replace and destroy the placeholder.
Replace any DynamicSelf types with their underlying Self type.
Replace any other type variable with the archetype within the requirement's context.
Replace any references to Arg in IncomingValues with Agg.
Replace any still-remaining uses with undef and erase.
Replace any still-remaining uses with undef values and erase.
Replace any uses of them with undef values.
Replace archetypes and type parameters with UnresolvedType.
Replace archetypes in the base type.
Replace assert_configuration instructions by their constant value.
Replace branch to BB by branch to TargetFailureBB.
Replace branch to BB by branch to TargetSuccessBB.
Replace by unconditional_cast, followed by a branch.
Replace checked_cast_br by branch to FailureBB.
Replace container box value arguments for the cloned closure with the /    transformed address or value argument.
Replace debug_value_addr with debug_value of the promoted value if we have a valid value to use at this point.
Replace debug_value_addr with debug_value of the promoted value.
Replace dependent types with their archetypes or concrete types.
Replace destroys with a release of the value.
Replace dominated user instructions.
Replace generic type parameters and associated types with their witnesses, when we have them.
Replace input with uninitialized instance.
Replace invalid sequences
Replace it by a retain/release_value on X instead.
Replace it with a Jmp to the next block.
Replace it with a branch to the failure block.
Replace it with the dynamic self type.
Replace load sequence which may contain / a chain of struct_element_addr followed by a load.
Replace loads from a global variable by the known value.
Replace occurrences of 'Self' in the signature with the derived type.
Replace old apply instruction by a new apply instruction that invokes the witness thunk.
Replace one of the `first' Node's successor pointers to `current' with `replace'  Pre: direct_successor(first, current)
Replace operand values (which are passed to the successor block) with corresponding block arguments.
Replace primary file with original content
Replace select_enum_addr by the result
Replace switch_enum_addr by a branch instruction.
Replace the "return nil" with a new 'fail' statement.
Replace the 'self' parameter in the given type.
Replace the 'self' parameter type in the method type with it.
Replace the allocation call with an alloca.
Replace the archetypes with their corresponding dependent types.
Replace the array.props calls uses in the cloned loop by their 'fast' value.
Replace the base of the call with the "self argument".
Replace the base type so we perform the appropriate subtype check.
Replace the best cost and fall through.
Replace the call to assert_configuration by the Debug configuration value.
Replace the call with a call to the regular swift_bufferAllocate.
Replace the cleanup with a new one on the superclass value so we always use concrete retain/release operations.
Replace the computed type with the suggested type.
Replace the content covered by the fixit with the replacement text.
Replace the covariant result type in the opened type.
Replace the dummy values with new block arguments.
Replace the existing completions.
Replace the failed fixit with what actually happened.
Replace the generic parameters with their archetypes throughout the types in the requirements.
Replace the given conditional branching instruction with a plain jump (aka unconditional branch) to the destination block.
Replace the inferred source with the protocol source.
Replace the initializer of PBD with a reference to our repl temporary.
Replace the ith BB argument with a new one with type Ty (and optional / ValueDecl D).
Replace the load with the definition that we found.
Replace the loaded value with our running value.
Replace the lowered value with an ObjCMethod lowering.
Replace the name with the name of the requirement.
Replace the old CheckType with a Mov from the result of the Load so that any uses of its dest point to the correct new value.
Replace the old linker flag entry.
Replace the original copy with a destroy.
Replace the overridden member.
Replace the partial_apply(partial_apply(X)) by X and remove the partial_applies.
Replace the placeholder if we were given one.
Replace the placeholder value with the new GEP.
Replace the rest of the old arguments with constants.
Replace the switch with a branch to the TheSuccessorBlock.
Replace the switch_enum_addr by select_enum_addr, switch_value.
Replace the terminator of BB with a simple branch if all successors go to trampoline jumps to the same destination block.
Replace the trailing release with a check_unowned.
Replace the try_apply with a cond_br false, which will be removed by SimplifyCFG.
Replace the type metadata pointer with the class instance.
Replace the unit with an empty one, but preserve its file path.
Replace the use of the argument with the cloned literal.
Replace the uses with one of the (identical) operands.
Replace users of f_inverse by x.
ReplaceInstUsesAction
Replaces all get-property calls, which we can prove to be true, with / true-literals.
Replacing a copy with a destroy+init is not by itself profitable.
Replacing unconditional_check_branch type instructions by a trap will also invalidate branches/the CFG.
Replicate function_refs to their uses.
RepoAuthoritative has been raptured out of runtime_option.cpp.
RepoAuthoritative mode unit caching
Report a call to an unimplemented initializer.
Report a corrupted type object.
Report a dynamic cast failure.
Report a fatal error to system console, stderr, and crash logs, then abort.
Report a fatal error to system console, stderr, and crash logs.
Report a fatal error.
Report a message to any forthcoming crash log.
Report a message to system console and stderr.
Report a sign error if the input parameter is a negative number, when interpreted as signed.
Report an error if the sign bit is set.
Report diagnostic if the first argument has been folded to '1'.
Report success/failure.
Report the accessors that were utilized.
Report the declarations we found to the consumer.
Report the declarations we found to the real consumer.
Report this record to the functor.
Reposition iterators possibly invalidated by mutation.
Reposition the rethrow block to the end of the postmatter section unless we're emitting into a single predecessor.
Represent the path as "impossible" so we crash if we accidentally do anything that needs the metadata.
Represents a function or inlined function.
Represents a lowered SIL basic block.
Represents a map with arbitrary int64 or string keys.
Represents a map with numeric keys 0, 1, ..., n-1 (but see SKIP below).
Represents a statically-known function as a SIL thin function value.
Represents a value in integer constant evaluation.
Represents a vector of n values.
Represents an ObjC method reference that will be invoked by a form of / objc_msgSend.
Represents an address of an unknown array.
Represents the actual Zend resource.
Represents the loop nest.
Reprint the original message, so readers don't necessarily have to page up through all the detail to find it.
Reprocess each of the unresolved entries to see if it can be resolved now that we're done.
Reproduce the DiagIDs, as we want both the size and access to the raw ids themselves.
Req nodes mean the reference count of the object may be observed, up to some "level".
Request local registry for user defined wrappers and disabled builtins
Request new APIs from CoreImage.
Request new APIs from Foundation.
Request new APIs from SceneKit.
Request new APIs from SpriteKit.
Request new APIs from libdispatch.
Request-allocated StringData are always aligned at 16 bytes, thus it is safe to copy in 16-byte groups.
RequestBodyReadLimit is int64_t and could be -1
RequestLocal is too early.
RequestURI needs script_filename and path_translated to not include the document root
Requests that need semantic typechecking.
Requests will be printed in Requests.cpp, print them out here as well.
Require 'rethrows' on the override if it was there on the base, unless the override is completely non-throwing.
Require Main and REPL files to be the first file added.
Require a non-trivial set of print functions.
Require a selector match.
Require all stores to be into the array storage not the array object, otherwise bail.
Require an access kind to be set on every l-value expression.
Require either a 'get' or an 'address' accessor if there's a 'mutableAddress' accessor.
Require that at least one side of the requirement be a potential archetype.
Require that the given condition evaluate true.
Require that the operand is a non-optional, non-unowned reference-counted type.
Require that the operand is a reference-counted type, or an Optional thereof.
Require that the operand is a type that supports reference storage modifiers.
Require the carried type to be materializable.
Require the copy dest to be a simple alloc_stack.
Require the copy dest value to be identified by this address.
Require the first row to be a non-wildcard.
Require the metadata to be some type that we recognize as a metadata pointer.
Require the pattern to have a particular shape: a number of is-patterns applied to an irrefutable pattern.
Require two function types to be ABI-compatible.
Required class methods
Required constructors (or overrides thereof) have their allocating entry point in the vtable.
Required constructors are dynamically dispatched when the 'self' value is not statically derived.
Required initializers are always considered designated.
Required instance methods
Requirements in class-bound protocols never 'mutate' self.
Requirements of ObjC protocols don't need this.
Requirements:  - xdebug_get_zval_value_fancy - xdebug_get_zval_value_ansi - xdebug_get_zval_value
Requires a local variable id containing the previous error reporting level.
Requires one is attached.
Requires that middle has no other nodes attached to it.
Reroute existing translations for SrcKey to an as-yet indeterminate new one.
Reschedule if still in a context.
Reserve space for all named locals plus one additional variable to avoid reallocations if one extra dynamic variable is used.
Reserve space for polymorphic bindings.
Reserve space for size * 4 / 3 because we limit our max load factor to .75.
Reserve space for the FDE length.
Reserve space for the expression length and mark the beginning of the expression, so that the size can be patched on end_expression().
Reserve the r2 TOC register to avoid changing it
Reset block state before reentering irGenRegionImpl
Reset color before showing the prompt.
Reset fields manually in case the move constructors don't.
Reset it and try again.
Reset jemalloc stats.
Reset profiler otherwise it might recurse further causing segfault.
Reset state if the block has any predecessor that we haven't processed yet.
Reset the array's internal pointer
Reset the beginning of the segment to the string that remains to be consumed.
Reset the collected best-path information.
Reset the credentials since it failed
Reset the currently-active set of substitutions.
Reset the debug location.
Reset the inverse color map
Reset the module filter.
Reset the name lookup cache so we find new decls.
Reset the preloaded g_context
Reset the previous score.
Reset the socket to non-blocking mode and setup socket options
Reset them to UnresolvedTypes for safe measures.
Reset, possibly, some request dependent runtime options based on certain setting values.
Reseting/initializing
Resets the buffer, serializes this command into the buffer and then flushes the buffer.
Resetting the DependentBPA will deallocate but not run the destructor of the dependent TypeLowerings.
Resilience may cause additional data to be laid out prior to this address point.
Resilient enum types lower down to the same opaque type.
Resilient enums are accessed by invoking the value witnesses for these operations.
Resilient tag numbering decreases for payload tags, so reverse the payload tags if this enum is resilient from any context.
Resiliently-sized metadata access always requires an accessor.
Resize the image to the new size
Resolve a (non-type) witness via default definition or optional.
Resolve a (non-type) witness via derivation.
Resolve a (non-type) witness via name lookup.
Resolve a locator to the specific declaration it references, if possible.
Resolve a number reference into the tuple type.
Resolve all associated types before trying to resolve this witness.
Resolve all components up to the last, keeping track of value-type logical properties we need to write back to.
Resolve all of the type witnesses.
Resolve any unmatched elements.
Resolve any unresolved entries.
Resolve conformances for each of the protocols to which this / declaration may provide a conformance.
Resolve path relatively to state and put the real path into state
Resolve specialization attributes after setting ContextParams.
Resolve the 'as' or 'is' expression.
Resolve the assignment expression.
Resolve the associated type and merge the potential archetypes.
Resolve the base to a potential archetype.
Resolve the base type, if we can.
Resolve the conformances for this protocol.
Resolve the conformances of the superclass.
Resolve the declaration signature when we find the declaration.
Resolve the extension, if we haven't done so already.
Resolve the first component, which is the only one that requires unqualified name lookup.
Resolve the function type directly with these attributes.
Resolve the given identifier type representation as a qualified / lookup within the given parent type, returning the type it / references.
Resolve the given identifier type representation as an unqualified type, / returning the type it references.
Resolve the inheritance clauses for each of the associated types.
Resolve the locator to a specific expression.
Resolve the member type.
Resolve the name ids.
Resolve the nested type.
Resolve the optional type.
Resolve the parent type.
Resolve the pattern in the label.
Resolve the property reference.
Resolve the protocol's type.
Resolve the reference to this type declaration in our current context.
Resolve the super type of 'self'.
Resolve the ternary expression.
Resolve the type declaration to a specific type.
Resolve the type declaration within this context.
Resolve the type of the constructor.
Resolve the type witness for the given associated type as / directly as possible.
Resolve the types of the operands.
Resolve the witness for the given non-type requirement as / directly as possible, only resolving other witnesses if / needed, e.g., to determine type witnesses used within the / requirement.
Resolve this extension.
Resolve this initializer, if needed.
Resolve this nested type to this associated type.
Resolve this nested type to this type alias.
Resolve type constant, if needed.
Resolves a filename for the `parse_ini_file`, considering CWD, containing file name, and include paths.
Resources are always greater than nulls.
Resources are always less than anything else.
Respect function no.optimize.
Respond on next break
Respond on step break
Respond on step out break
Respond to signal polling from the server.
Responds to a REPL input.
Response for one-way opearation
Responses are big, print them out with info medium priority.
Responses will be printed in Requests.cpp (with medium prio), print them out here as well.
Responsible for converting the bytecode comparisons (which are type-agnostic) to IR comparisons (which are typed).
Responsible for replying to an XPC request.
Restart at the first argument/parameter.
Restart iteration before the earliest instruction we remove.
Restore Content-Type Header
Restore cleanup states in the opposite order in which we saved them.
Restore clip if required
Restore debugging state.
Restore it if we disabled it.
Restore rvmfp() and return to the callee's func prologue.
Restore the debug location.
Restore the error reporting level and then either return or throw
Restore the justOne option when we cleanup the files collection itself
Restore the original name after write
Restore the previous active count in the active-selector mapping.
Restore the previous best score.
Restore the return value and perform the actual return.
Restore the saved filter and the next flag
Restore type metadata bindings, if we have them.
Restoring previous options
Restrict to VV-safe opcodes if necessary.
Restructure the argument to provide the appropriate labels in the tuple.
Restructure tuple arguments.
Result contains a big integer, as well as one other integer, so we must use bitset mode.
Result is -1 if the field is invalid (all blank, or non-octal).
Result is always value.
Result of eval or custom function
Result of replacement
Result of the select_enum should be a boolean.
Result type can be covariant (or equal).
Result type of a function producing the concatenated string literal.
Result types must match.
Results should always be the same.
Results should be checked in case we process a conditional case.
Results: Returns non-zero if the character matches the given set.
Results: Returns the next format position.
Results: chPtr is filled with the Tcl_UniChar, and the return value is the number of bytes from the UTF-8 string that were consumed.
Resumable object, prefixed by a ResumableNode header, which is what we need to mark.
Resumable suspension takes everything from the frame and moves it into the heap.
Resumable::setResumeAddr(resumeAddr, resumeOffset)
ResumableObj should not be encountered on their own, they should always be prefixed by a ResumableFrame allocation.
Resume in the TC right after our caller.
Resume printing comments from this point.
RetC and RetV are special.
RetC and RetV consume a value from the stack, and this value's type needs to be known at compile-time.
Retain 'self' because the partial apply will take ownership.
Retain 'self' if necessary.
Retain connection while we try to ping it.
Retain motion is a forward pass over the block.
Retain of ThinToThickFunction is a no-op.
Retain the argument as the callee may consume it.
Retain the end of the file.
Retain the objects that own section memory
Retain the result if this is copy-on-success.
Retain type sugar if it's there.
RetainCodeMotionContext - Context to perform retain code motion.
RetainValueInst of a reference type is a strong_release.
RetainValueInst of a trivial type is a no-op + use propagation.
RetainValueInst of an unowned type is an unowned_retain.
Retains and releases are fine.
Retains are blocked by MayDecrements.
Retains are safe as long as they are not inside the / Loop.
Retains can move after it but the last release can't move before it.
Retains can move over it.
Retains, releases of the result of F.
Retire the proxy, which will schedule it for cleanup and destruction on another thread.
Retreat the dfs search.
Retrieve a dynamic result signature for the given declaration.
Retrieve a replacement identifier.
Retrieve a systemlib (or mini systemlib) from the current executable or another ELF object file.
Retrieve all of the globals that will be mapped to members.
Retrieve and sort all of the base names in this particular table.
Retrieve the 'Iterator' protocol.
Retrieve the 'Sequence' protocol.
Retrieve the Clang node for the given extension, if it has one.
Retrieve the ErrorProtocol protocol.
Retrieve the _BridgedToObjectiveC protocol.
Retrieve the _bridgeToObjectiveC witness.
Retrieve the _unconditionallyBridgeFromObjectiveC witness.
Retrieve the action associated with the given object type, computing a new one if it isn't already present.
Retrieve the archetype from the archetype anchor in this equivalence class.
Retrieve the archetype.
Retrieve the argument labels that are provided for a member / reference at the given locator.
Retrieve the argument name.
Retrieve the associated types that are referenced by the given / requirement with a base of 'Self'.
Retrieve the bridging operation to be used if a static conformance to _BridgedToObjectiveC can be proven.
Retrieve the bridging operation to be used if a static conformance to _BridgedToObjectiveC cannot be proven.
Retrieve the conformance for the superclass constraint of the given / potential archetype (if present) to the given protocol.
Retrieve the constraints from fixed bindings.
Retrieve the context of the type, as opposed to the DeclContext of the variable.
Retrieve the declared type of a type declaration or extension.
Retrieve the element interface type and key param decl of a subscript / setter.
Retrieve the instance type of the given Clang declaration context.
Retrieve the interface type for this inherited type.
Retrieve the jump destination for a shared case block.
Retrieve the main object
Retrieve the member type with the given name.
Retrieve the name for an integer type based on its size.
Retrieve the name of the given Clang declaration context for / printing.
Retrieve the name of the given Clang type for use when omitting / needless words.
Retrieve the nearest enclosing nominal type context.
Retrieve the nested type from the representation of this set.
Retrieve the node for the non-representative.
Retrieve the node for the representative that we're merging into.
Retrieve the nominal type and resolve it within this context.
Retrieve the object type for a 'self' parameter, digging into one-element / tuples, inout types, and metatypes.
Retrieve the optionality location for the given type / representation.
Retrieve the original conn and return the underlying connection to it.
Retrieve the parent expression that coerces to Selector, if / there is one.
Retrieve the potential archetype corresponding to this generic type parameter.
Retrieve the potential archetype for the nested type.
Retrieve the protocols to which this type conforms.
Retrieve the raw type of the given enum.
Retrieve the requirement.
Retrieve the requirements of this polymorphic function type.
Retrieve the selector piece.
Retrieve the set of protocols the given protocol inherits.
Retrieve the set of substitutions to be applied to the witness.
Retrieve the source file for the given Objective-C member conflict.
Retrieve the source location associated with this declaration / context.
Retrieve the source location at which the optional is / specified or would be inserted.
Retrieve the state of this conformance.
Retrieve the superclass bound.
Retrieve the superclass of the given class.
Retrieve the symbol by treating it as an expression.
Retrieve the type name to be used for determining whether we can / omit needless words.
Retrieve the type of a reference to the specific declaration choice.
Retrieve the type of the ivar initializer or destroyer method for / a class.
Retrieve the type of the property that is implied by the getter.
Retrieve the type to use for a method found via dynamic lookup.
Retrieve the type variable for 'Self'.
Retrieve the value witness corresponding to the given requirement.
Retrieve the visibility information from the AST.
Retrieves the Array value of this JSONValue Use IsArray() before using this method.
Retrieves the Bool value of this JSONValue Use IsBool() before using this method.
Retrieves the Number value of this JSONValue Use IsNumber() before using this method.
Retrieves the Object value of this JSONValue Use IsObject() before using this method.
Retrieves the String value of this JSONValue Use IsString() before using this method.
Retrieves the child of this JSONValue at the given index. Use IsArray() before using this method.
Retrieves the child of this JSONValue at the given key.
Retrieves the current source location (file, line).
Retrieves the number of children of this JSONValue.
Retrieves the parameter list, return type and context info for / a typed completion placeholder in a function call.
Retrieves the type and interface type for a generic class or class / extension method, given the computed type of that method.
Retrieves the type and interface type for a protocol or / protocol extension method given the computed type of that / method.
Retrieving the results for all executed queries
Retry the command with version 1, in which case values are omitted.
Retry with moving the allocation up.
Return "NULL" if the file couldn't be opened as requested
Return 'true' if there was an error, and 'false' otherwise.
Return () if no return value was given.
Return (share + text), under the assumption that share consists only of shared libraries.
Return / true if it is an erroneous code point.
Return / true if this partial apply will not block our promoting the box.
Return 0 for success, non-zero for failure.
Return 0 if input contains any illegal encoding, otherwise 1.
Return 0 if the checksum is bad (i.e., probably not a tar archive), 1 for old UNIX tar file, 2 for Unix Std (POSIX) tar file, 3 for GNU tar file.
Return 0 if we don't have a quick way to get a better cap.
Return 0 or 1 depending on whether or not a match was found and (optionally), set matched (sub-)patterns for passed-in reference.
Return 1 for different classes to match PHP7 behavior.
Return 1 if generator state is not Done.
Return 1 if generator state is not in the Created state.
Return EOF for end of file.
Return ONLY the cookies that match this URL
Return True on change.
Return YYSIZE_MAXIMUM if overflow occurs during size calculation.
Return a Context for every function in the Program.
Return a MongoCursor for the result set.
Return a TupleType or ParenType for this parameter list.
Return a TypeExpr for a simple identifier and the specified location.
Return a TypeInfo the represents opaque storage for a loadable POD value / with the given storage size.
Return a basic block suitable to be the destination block of a / try_apply instruction.
Return a callee list for a given class method.
Return a callee list for the given witness method.
Return a classification saying that there's an unconditional / throw site.
Return a concrete type or archetype we've already resolved.
Return a constant SSATmp representing a static value held in a TypedValue.
Return a copy of the Unit's line to OffsetRangeVec table.
Return a function which performs an assignment operation on two / existentials.
Return a function which takes three pointer arguments and does a / retaining initWithCopy on the first two: it loads a pointer from / the second, retains it, and stores that in the first.
Return a function which takes two buffer arguments, copies / a pointer from the second to the first, and returns the pointer.
Return a function which takes two pointer arguments and a count, memmoves / or memcpys from the second to the first, and returns the first argument.
Return a function which takes two pointer arguments and returns / the first one immediately.
Return a function which takes two pointer arguments and returns / void immediately.
Return a function which takes two pointer arguments, loads a / pointer from the first, and calls swift_release on it immediately.
Return a function which takes two pointer arguments, memcpys / from the second to the first, and returns the first argument.
Return a function which will return a particular witness table / conformance.
Return a monotonically increasing time given the last time recorded.
Return a new instruction and do not erase the old / instruction.
Return a pair, containing the total parameter count of a function, coupled / with the number of non-default parameters.
Return a pattern corresponding to the 'self' parameter of the given / C function imported as a method.
Return a pattern corresponding to the 'self' parameter of the given / Objective-C method.
Return a pattern corresponding to the formal method parameters of / the current C function imported as a method.
Return a pattern corresponding to the formal parameters of the / current Objective-C method.
Return a pointer to the SILFunction called by Call if we can / determine which function that is, and we have a body for that / function.
Return a reference to an object that's suitable for being used for / the given kind of reference.
Return a specialized emission function if this is a function with a known / lowering, such as a builtin, or return null if there is no specialized / emitter.
Return a stub that will finish entering the callee frame in C++, then call handleResume at the callee's entry point.
Return a union type containing all the types in the argument list.
Return a uniqued substituted type.
Return a user-comprehensible name for the given type.
Return a value for an optional ".None" of the specified type.
Return a value for an optional ".Some(x)" of the specified type.
Return address register.
Return affected line range, which can later be more than one line.
Return all but the first "n" matched characters back to the input stream.
Return all recursive users of V, looking through users which propagate / RCIdentity.
Return all the Cookies in the CookieJar, as a list of Maps (aka JSON in JS space)
Return all the Cookies visible to this Page, as a list of Maps (aka JSON in JS space)
Return all the WorkItems we'll need to start analyzing this program.
Return an AliasClass containing all locations pointed to by any PtrToGen sources to an instruction.
Return an AliasClass representing a range of the eval stack that contains everything below a logical depth.
Return an array of all defined functions.
Return an empty region to restart region formation at env.minstrStart.
Return an empty string if pdf render fails
Return an empty string in case an unsupported format was provided
Return an estimate of the method count of all used traits.
Return an existing specialization if one exists.
Return an existing translation for `args', or nullptr if one can't be found.
Return an id for the semaphore with the given key, and allow max_acquire (default 1) processes to acquire it simultaneously.
Return an initialization address we can emit directly into.
Return and unreachable are free.
Return as soon as possible if we are not producing diagnostics.
Return bound generic type for the unbound type Superclass, / which is a superclass of a bound generic type BoundDerived / (Base may be also the same as BoundDerived or may be / non-generic at all).
Return breakpoints add function + class (optionally)
Return closest available color
Return control to the caller or scheduler.
Return control to the caller.
Return control to the next()/send()/raise() caller.
Return early for the no-simplification case.
Return error if Basic Block is null.
Return exact match color
Return failure if at end of input.
Return false if FriBidi failed
Return false if not running in server mode.
Return false if the type of any local is bottom, which can only happen in unreachable paths.
Return false if there is overflow.
Return false if there is underflow or if the modes mismatch.
Return false if we can't find them.
Return false if we don't have a FrameState saved for `block' yet -- meaning it isn't reachable from the entry block yet.
Return false otherwise.
Return false to wait for next interrupt from server
Return from an eagerly-executed async function: wrap the return value in a StaticWaitHandle object and return that normally, unless we were called via FCallAwait
Return from here lets the opcode execute.
Return from the main function.
Return if already smashed.
Return if there's no abstraction.
Return if we loaded a file
Return immediately if it's not ELF (so we avoid pipe2file unless needed).
Return infix data representing the precedence of E.
Return information about the single failing argument.
Return last error message.
Return list of sectionnames specified by sectionlist.
Return merged result.
Return newly allocated color
Return nil so that the object will be deallocated later.
Return non-zero to indicate symbol lookup is supported.
Return null if that is the case.
Return null on the failure path.
Return null to indicate this to the caller.
Return nullptr to signal error.
Return one of the two values we computed based on the above.
Return success because we recovered.
Return the / instruction with the unexpected use if we find one.
Return the 0...11 month number.
Return the BlockState for the basic block this basic block belongs to.
Return the BlockState for the basic block this instruction belongs to.
Return the Clang struct type which was imported and resulted in / this Swift struct type.
Return the DIFile that is the ancestor of Scope.
Return the ID of the current sandbox, if there is one.
Return the LValueTypeData for a SIL value with the given AST formal type.
Return the Pattern involved in initializing this VarDecl.
Return the SIL-lowering of the given type.
Return the SILBasicBlock of a given ID.
Return the SerializedSILLoader.
Return the TypeConstraint that should be used to constrain baseType for an Idx bytecode.
Return the Unit's SourceLocTable, extracting it from the repo if necessary.
Return the `loop's preExit block if it was already created or if a suitable block already exists.
Return the address as a Builtin.RawPointer.
Return the address of a function that will return type metadata  / for the given non-dependent type.
Return the address of a function which will return the type metadata / for an associated type.
Return the address of a nominal type descriptor.
Return the address of the global variable.
Return the appropriate access kind for the base l-value of a / particular member, which is being accessed in a particular way.
Return the appropriate discriminator set for a closure expression.
Return the archetype.
Return the availability context for the given spec.
Return the best active spec for the target platform or nullptr if no / such spec exists.
Return the bit position of the given Loc in the LocationVault.
Return the bit position of the given Val in the LSValueVault.
Return the cached clone if we have one.
Return the cached layout if available.
Return the cached pointer-to-function type for the given value / witness index.
Return the callee of a once call.
Return the canonical signature.
Return the cast result with the original cleanup.
Return the closest split position on or before `pos'.
Return the concrete type that the given dependent type is constrained to, / or the null Type if it is not the subject of a concrete same-type / constraint.
Return the constant offset of a field as a SizeTy, or nullptr if the / field is not at a fixed offset.
Return the count of shared elements in the front of two forward ranges.
Return the current string ref without claiming any characters.
Return the current time in microseconds.
Return the day within the month
Return the deallocate stack instructions corresponding to the given / AllocStackInst.
Return the debug location from a SILLocation.
Return the deserialized Vtbl.
Return the directory portion of the path
Return the dispatchable length of the given column.
Return the dummy instruction that represents the new value that we will add to the basic block.
Return the effect this instruction has on the value of `sp'.
Return the element layouts.
Return the estimated amount of memory that can be safely taken into the current process RSS.
Return the expression value.
Return the family string of this selector.
Return the formal type that we would use for +allocWithZone:.
Return the forwarding value.
Return the full function type for a set of curried parameter lists that / returns the specified result type.
Return the full source range of this parameter list.
Return the full source range of this parameter.
Return the fully qualified dotted path for DeclContext.
Return the implicit access kind for a MemberRefExpr with the / specified base and member in the specified DeclContext.
Return the index of a parameter adjustment.
Return the index of the given dependent type in the list of all / dependent types.
Return the index of the given protocol conformance in the list of all / protocol conformances for the given dependent type in the given signature.
Return the index of the parent metadata pointer for the given class.
Return the initialized 'self'.
Return the instance type or null if not set yet.
Return the last extract we created.
Return the length of YYSTR.
Return the list of functions that can be called via the given apply site.
Return the list of functions that can be called via the given callee.
Return the max valid depth of firstType and secondType.
Return the maximum stack cell count.
Return the minimum post-dominator tree level of any of the direct controlling predecessors of this node or any child.
Return the minimum precedence that an expression in the place of 'expr' must have without needing to be surrounded by parentheses.
Return the name (like "autoclosure") for an attribute ID.
Return the name to import a CF typedef as.
Return the new QWebPage to the QWebKit backend
Return the new reader.
Return the new type with the old convention.
Return the newly allocated nbytes-sized block.
Return the next character without claiming it.
Return the next intersection point between `current' and `other', or kMaxPos if they never intersect.
Return the next len characters without claiming them.
Return the next pixel from the image
Return the next, or nullptr if it doesn't have a next:
Return the non-trivial field.
Return the number of bytes copied, including the terminating null byte.
Return the number of bytes written
Return the number of days between jan 01 1601 and jan 01 of year.
Return the number of extra inhabitants for a pointer that reserves / the given number of low bits.
Return the number of parameters required for this block.
Return the number of rvalue elements in the given canonical type.
Return the number of successor-edges including fall-through paths but not implicit exception paths.
Return the number of tag values represented with extra / inhabitants in the payload.
Return the number of times a pattern must be specialized / before becoming irrefutable.
Return the offset from the address point to the end of the / metadata object.
Return the operand we wrap.
Return the original type or a null type, depending on the 'ignoreMissing' / flag.
Return the parameter convention used by Apply to pass an argument / indirectly via Address.
Return the precedence-yielding parent of 'expr', along with the index of 'expr' as the child of that parent.
Return the range of indexes for the given tuple type element.
Return the rc-identity root of the RC instruction, i.e. / retain or release.
Return the rc-identity root of the SILValue.
Return the referenced node, or null if this is not a Ref type.
Return the required SpillState coming into inst.
Return the result at +1.
Return the resulting default witness table.
Return the resulting witness table.
Return the set of clusters that are left, which are the ones that didn't get merged (so their first func is it's original func).
Return the set of clusters that are left, which are the ones that didn't get merged.
Return the single member of the lowered explosion for the / given SIL value.
Return the singleton.
Return the size and alignment of this type.
Return the size of the standard heap header.
Return the size reported by a type.
Return the size reported by the variable's type.
Return the smallest (supported) unsigned length that can store the value
Return the smallest size int that can store the value
Return the standard access strategy for getting a non-dependent / type metadata object.
Return the start of the location's source range.
Return the start offset of the nearest enclosing section.
Return the starting address of the string.
Return the statically-known offset of the given element.
Return the subinterval which covers or has a use at `pos', else nullptr if no subinterval does.
Return the substituted, unlowered AST type of the argument.
Return the substituted, unlowered AST type of the result of / this application.
Return the total size and address point of a metadata record.
Return the tuple - the result + the overflow flag.
Return the tuple: (the result (same as input), the overflow flag).
Return the tuple: (the result, the overflow flag).
Return the type metadata access function for the given type, if it / is guaranteed to exist.
Return the type metadata for a given mangled name, used in the / implementation of _typeByName().
Return the type of the instance value.
Return the type that a parameter to a builtin function is supposed to be coerced to.
Return the underlying SILValue after stripping off SILArguments that cannot / affect RC identity.
Return the underlying SILValue after stripping off identity SILArguments if / we belong to a BB with one predecessor.
Return the value as +1 if the optional was +1.
Return the value coming from the "filePicker" callback, IFF not null.
Return the value pointer from 'map' if it exists.
Return the value that is written into the global variable.
Return the witness table that's been set for this type.
Return this data pointer.
Return this function pointer, bitcasted to an i8*.
Return this value only if the file actually exists
Return to the caller function.
Return to the caller.
Return true / if the ForwardSetOut changes.
Return true if CurrentDef has been forwarded through one copy into / another.
Return true if Offset o is inside the protected region of a fault funclet for iterId, otherwise false.
Return true if Ptr alias's self.
Return true if V is an object that at compile time can be uniquely / identified.
Return true if V1 and V2 are distinct objects that can be uniquely / identified at compile time.
Return true if an error is emitted.
Return true if any possible definition of one php::Class could derive from another at runtime, or vice versa.
Return true if block was / merged.
Return true if changes were made, else false.
Return true if inlining this call site into a cold block is profitable.
Return true if inlining this call site is profitable.
Return true if k is one of AHM's magic values.
Return true if the argument of a CallExpr (or related node) has a trailing / closure.
Return true if the array satisfies requirement on the ArraySpec.
Return true if the conversion from fromType to toType is an invalid string / index operation.
Return true if the data flow can converge in 1 iteration.
Return true if the given value is an instruction or block argument that is / known to produce a nonaliasing address with respect to TBAA rules (i.e. the / pointer is not type punned).
Return true if the instruction blocks the Ptr to be moved further.
Return true if the specified token looks like the start of a clause in a / stmt-condition.
Return true if the specified type looks like an integer of floating point / type.
Return true if this SILBBArgument is the result of a call to self.init.
Return true if this constraint is a conversion or requirement between two / types.
Return true if this function name is a comparison operator.
Return true if this instruction can load a TypedValue using a 16-byte load into a SIMD register.
Return true if this is a builtin operator that cannot be defined in user / code.
Return true if this is a closure expression that will require "self." / qualification of member references.
Return true if this is a non-resolved ExprPattern which is syntactically / irrefutable.
Return true if this is an implicit reference to self.
Return true if this pattern (or a subpattern) is refutable.
Return true if this stored property needs to be accessed with getters and / setters for Objective-C.
Return true if this type is known to be an ArrayType.
Return true if we *might* remove this instruction.
Return true if we advance the sequence / and false otherwise.
Return true if we are extracting the only non-trivial field of out parent / struct.
Return true if we are the last argument of our BB and that our parent function has a call signature with self.
Return true if we can get the addresses of elements with the / 'getSubInitializationsForTuple' method.
Return true if we do not need optimistic data flow.
Return true if we do so and false otherwise.
Return true if we know for sure that one php::Class must derive from another at runtime, in all possible instantiations.
Return true if we moved or deleted any instructions.
Return true if we printed out / either an id or a use list.
Return true if we should return `h'.
Return true iff the key is found.
Return undef for blocks with predecessor.
Return undef for dead node.
Return undefined value.
Return updated scan pointer as function result.
Return value from evaluation
Return value must be freed
Return value of DnsQuery_A() function
Return value symbolic flavor
Return whether an IRInstruction may decref one of its sources, if its next edge is traversed, but not if its taken edge is traversed.
Return whether an IRInstruction may decref one of its sources, if its taken edge is traversed.
Return whether an IRInstruction may observe the reference count of a specific argument.
Return whether or not sym represents a symbolic stack element, rather than an actual stack element.
Return whether there are at least len characters remaining.
Return whether update was successful
Return with an error if the posted data is garbled
Return: success/failure
Returned upon end-of-file.
Returning a non-declared property, we know that it is accessible since all dynamic properties are.
Returning false indicates a failure to communicate with the client (for commands that do so).
Returning false since PPC64 specific code is under development
Returning null since PPC64 specific code is under development
Returning since PPC64 specific code is under development
Returning true stops the call to the default interpreter which implies the handler for that opcode must perform all the right steps wrt the state.
Returns 'false' (i.e. no error) if it is legal to match functions with the corresponding function type representations and the given match kind.
Returns .Some(I) if I is a release that is the only non-debug instruction / with side-effects in the use-def graph originating from Arg.
Returns / .Some(nullptr), if all uses from the arg were either debug insts or do not / have side-effects.
Returns 0 if all options were processed without errors.
Returns 0-terminated hostname.
Returns 1 if it worked, and 0 if it didn't.
Returns 1 when an error was found and *handled*, and it returns 0 if no error situation has occurred on the cursor
Returns 1 when an error was found and it returns 0 if no error situation has occurred on the cursor
Returns 1 when it worked, and 0 when an error was encountered.
Returns NULL if no splittable boxes remain
Returns None / if no such instruction exists.
Returns None if no such root is found.
Returns None on error, Optional(nullptr) if no operator decl found, or Optional(decl) if decl was found.
Returns None on error.
Returns TCA of "best" current translation.
Returns TCRegion containing addr if any, TCRCount otherwise.
Returns a *single* forwardable SILValue for the given LSLocation right / before the InsertPt instruction.
Returns a Variant representing the serialized data.
Returns a connection for the operation.
Returns a list of distinct values for the given key across a collection.
Returns a list of tokens, but with various normalizations performed based on the token type.
Returns a metadata reference for a nominal type.
Returns a new context to be introduced for the declaration, or nullptr / if no new context should be introduced.
Returns a new function type exactly like this one but with the self / parameter replaced.
Returns a pair of Constants consisting of the getter and setter / function pointers, in that order.
Returns a pointer to a place for a property value.
Returns a pointer to a specific value in MInstrState.
Returns a random number from Mersenne Twister
Returns a tuple of RValues holding the accessor value, base (retained if / necessary), and subscript arguments, in that order.
Returns a unique id for the breakpoint.
Returns a version of the input type with the ExtInfo AbstractCC set correctly.
Returns an IR block corresponding to the given bytecode offset.
Returns an Interrupt site for the function that called the function that contains this site.
Returns an accessor kind that
Returns an exception to propagate, or nulltpr if the VM execution should be resumed.
Returns an expression producing the index value, assuming that / the storage is a subscript declaration.
Returns count of code points in input, substituting 1 code point per invalid sequence.
Returns false and sets 'error' on failure.
Returns false if an exception occurs during the send (typically a socket error).
Returns false if an exception occurs during these steps.
Returns false if any of the non-local successors of the region are not leaking blocks.
Returns false if cloning required by jump threading cannot be performed, because some of the constraints are violated.
Returns false if the breakpoint is not well formed.
Returns false if the confirmation message send failed.
Returns false if the file does not exist or could not be read as an HPHP::String instance containing the contents of the file.
Returns false if the instruction may change the size of any array.
Returns false if the server was unable to return source for this command.
Returns false if the server was unable to return the information needed for this command.
Returns false if the user comparison function modifies the array we are sorting.
Returns false if the user-defined comparison function modifies the array we are sorting.
Returns false if we can't continue because we don't know the length of this instruction or one of the immediates was invalid.
Returns false iff the region should be truncated before inst's SrcKey.
Returns false on timeout, true when data has been read even if that data didn't form a usable command.
Returns false otherwise.
Returns how many connections were closed
Returns just the PID from the hash
Returns just the host and port from the hash
Returns null and raises a warning when input is an array, resource, or object.
Returns nullptr if it's an unknown key or not a string.
Returns nullptr if the key is not in the array.
Returns nullptr if there is no type param list to import or we suppress its import, as in the case of NSArray, NSSet, and NSDictionary.
Returns nullptr otherwise.
Returns old property if removed otherwise null
Returns the Apply and WitnessMethod instructions that use the / open_existential_addr instructions, or null if at least one of the / instructions is missing.
Returns the ConstantInfo corresponding to the VTable thunk for overriding.
Returns the ForwardValIn for the current basic block.
Returns the ForwardValOut for the current basic block.
Returns the OutputKind for the given Action.
Returns the SILParameterInfo for the given declaration's `self` parameter.
Returns the SILValue base to bit index.
Returns the TargetMachine instance or zero if no triple is provided.
Returns the address of a value-witness function.
Returns the address of a value-witness table.
Returns the adjusted base, which may point to tvRef2.
Returns the alias analysis we will use during all computations.
Returns the attached xdebug profiler.
Returns the base address, i.e. the first address which is not a projection.
Returns the bytes read on success Returns -31 on unknown failure Returns -80 on timeout Returns -32 when remote server closes the connection
Returns the callee of an apply_inst if it is basically inlineable.
Returns the common prefix of two strings at camel-case word granularity.
Returns the common word-prefix of two strings, allowing the second string / to be a common English plural form of the first.
Returns the connected (or connecting) socket, or -1 on failure.
Returns the corresponding unit.
Returns the current basic block we are processing.
Returns the current type expansion analysis we are .
Returns the database response for the command.
Returns the declaration of the entity to use as the base of / the access, or nil if no base is required.
Returns the default http method to use with the different auth types
Returns the default witness for a requirement, or nullptr if there is / no default.
Returns the difference (in dB) between two images.
Returns the empty string if the input doesn't match that format.
Returns the epilogue release matcher we are using.
Returns the expected input flavor of stack slot idx.
Returns the file descriptor of the new log file and also sets the name of the file and the start time of the next period via pointers supplied.
Returns the first availability attribute on the declaration that is active / on the target platform.
Returns the first instruction, starting from "startInst", with an accompanying exit block that dominates "dominatedInst".
Returns the forward arguments.
Returns the frame of the callee's callee.
Returns the id of the next region block in workQ whose corresponding IR block is currently reachable from the IR unit's entry, or folly::none if no such block exists.
Returns the id of the translation containing the given address, or INVALID_ID if none.
Returns the image, or NULL upon error.
Returns the index of the origin protocol we chose.
Returns the innermost node containing the target range that matches / the predicate.
Returns the latest position for which `allow' (which we populate) is valid.
Returns the location vault of the current function.
Returns the name of the symbol of the given address if available, otherwise just returns the address
Returns the new intermediate block if one was inserted, and nullptr otherwise.
Returns the number of protocol witness tables directly carried / by values of this type.
Returns the original boolean value, looking through possible invert / builtins.
Returns the peer address in addr/addrlen (it will emalloc these, so be sure to efree the result).
Returns the place where to insert the deallocation.
Returns the protocols that values of this type are known to / implement.
Returns the redundant loads and their replacement in the currently basic / block.
Returns the resolved path on success, or "" on failure,
Returns the set of of TransIDs that are in `bid's retranslation chain in `region'.
Returns the source range which should be refined by declaration.
Returns the sum of the weights of the arcs going from srcs to dst.
Returns the taken block of a terminator instruction if the condition turns out to be constant.
Returns the thick metatype for the given SILType.
Returns the top of the stack, or NULL.
Returns the truncated result, and the number of bytes truncated.
Returns the xml node for the given stack frame.
Returns true / If the block was removed.
Returns true for error.
Returns true for failure to resolve.
Returns true if / a diagnostic was emitted and false otherwise.
Returns true if A is an opened existential type, Self, or is equal to an / archetype in F's nested archetype list.
Returns true if F is a function which the pass know show to specialize / function signatures for.
Returns true if Inst is a function that we know never uses ref count values.
Returns true if LHS and RHS contain identical set of releases.
Returns true if User must use Ptr in a guaranteed way.
Returns true if a diagnostic / was emitted.
Returns true if a diagnostic about an accessor being less available / than the accessor it overrides would be redundant because we will / already emit another diagnostic.
Returns true if a function is marked as alive.
Returns true if after the / merge operation the region is tracking any state.
Returns true if all arrays in memory are considered to be unsafe and / clears this flag.
Returns true if an error occurred, without recording the base name.
Returns true if an error occurred.
Returns true if any content was added to Builder.
Returns true if any could / be merge.
Returns true if any generic types parameters of the class are unbound.
Returns true if any illegal IUOs were found.
Returns true if any inlined frames were marked dead.
Returns true if both values are equal or yield the address of the same / global variable.
Returns true if file is a suffix path of fullPath
Returns true if given the current lattice state, do we care if the value / we are tracking is decremented.
Returns true if given the current lattice state, do we care if the value / we are tracking is used.
Returns true if given the current lattice state, do we care if the value we / are tracking is used.
Returns true if it is expected that the macro is ignored.
Returns true if reduce_support_bit succeeded on every support bit in the set.
Returns true if some declaration lexically enclosing the reference / matches the passed in predicate and false otherwise.
Returns true if spill space must be allocated before execution of this instruction.
Returns true if the AllocStack is only stored into.
Returns true if the Array is unsafe.
Returns true if the argument of this value is a single valued RValue / that is passed either at plus zero or is trivial.
Returns true if the declaration should introduce a new refinement context.
Returns true if the given SDK path points to an SDK that is too old for / the given target.
Returns true if the given return or throw block can be used as a merge point / for new return or error values.
Returns true if the given variable name is a superglobal.
Returns true if the instruction can be duplicated without any special / additional handling.
Returns true if the instruction can store source operand srcIdx to memory as a cell using a 16-byte store.
Returns true if the last command parsed by the client has an argument that changes the status of a breakpoint.
Returns true if the passed in ref count inst matches the ref count inst we are tracking.
Returns true if the protocol is complete and the machine is at an interrupt.
Returns true if the repl should continue, / false if it should quit.
Returns true if the translation was relocated and false otherwise.
Returns true if the two paths have a non-empty symmetric difference.
Returns true if the type is a tuple which contains at least one array / (we don't check for arrays in nested tuples).
Returns true if the walker should traverse an AST node with / source range Range.
Returns true if there is any availability attribute on the declaration / that is active on the target platform.
Returns true if there was a match, false otherwise.
Returns true if this AllocStacks is captured.
Returns true if this attribute can appear on the specified decl.
Returns true if this breakpoint is enabled at the given stack level.
Returns true if this function can be referenced from a fragile function / body.
Returns true if this function has either a self metadata argument or / object from which Self metadata may be obtained.
Returns true if this instruction is a safe array use if all of its users are / also safe array users.
Returns true if this is a Zero node.
Returns true if this is an instruction that may have side effects in a / general sense but are inert from a load store perspective.
Returns true if this is not possible.
Returns true if this succeeds, else false.
Returns true if type `a` has archetypes that can be bound to form `b`.
Returns true if we actually removed the support (i.e. we accounted for it by reducing a lower bound, or the location wasn't actually supporting anything right now).
Returns true if we added the decl's module to the import set, false if / the decl is a local decl.
Returns true if we can prove that the two input SILValues which do not equal / cannot alias.
Returns true if we completely accounted for removing the support.
Returns true if we have at least two values to compare.
Returns true if we need to add defer edges for the arguments of a block.
Returns true if we proved that RCIdentity has a non-payloaded enum case, / false if RCIdentity has a payloaded enum case, and None if we failed to find / anything.
Returns true if we read any characters into name.
Returns true if we read any characters into word.
Returns true if we succeeded.
Returns true if we successfully read one, or false.
Returns true if we will already diagnose a bad override on the property's accessor of the given kind.
Returns true iff `block' ends the IR unit after finishing execution of the bytecode instruction at `sk'.
Returns true iff a method named methodName appears in iface or any of its implemented (parent) interfaces.
Returns true iff a request to the given path should be delegated to the proxy origin.
Returns true iff at least one event was received.
Returns true iff changes are made.
Returns true iff changes were made.
Returns true iff merging happend.
Returns true iff provided wait handle was abandoned.
Returns true iff the unit was modified.
Returns true iff there is data to be read.
Returns true iff we already have Eval.JitMaxTranslations translations recorded in srcRec.
Returns true on failure.
Returns true on success
Returns true on success, false if codegen failed.
Returns true on success.
Returns true upon success, false if nodes that are not present in the post-dominator tree are detected.
Returns whether a set on something containing type t could have side-effects (running destuctors, or modifying arbitrary things via a Ref).
Returns whether a type is generic enough to try hoisting a prediction in order to specialize it.
Returns whether all the type and reffiness guards for `block' are satisfied by 'bd' and its corresponding block.
Returns whether any states changed.
Returns whether decrefing a type could run a destructor.
Returns whether or not block `bid' is in the retranslation chain for `region's entry block.
Returns whether or not the weight of any arc was inferred and, in case of success, the weight of such arc is updated.
Returns: -1 if it worked, but the option really shouldn't be used 0 if it worked 1 if either name or value was missing 2 if the option didn't exist 3 on logic errors
Returns: 0 if it worked 2 if the option didn't exist 3 on logical errors.
Returns: 0 on success -1 on failure, but not critical enough to throw an exception 1..
Returns: FAILURE/SUCCESS whether the input was correct (i.e. no range errors)
Retype destinations of the label if we had args.
Retypecheck the anchor type, which is the base of the member expression.
Retypecheck the callee expression without a contextual type to resolve whatever we can in it.
Reuse our cached list of imports if we have one.
Reuse same temporary array.
Reuse the last source location if we are still in the same scope to get a more contiguous line table.
Reverse iteration count.
Reverse order to pop values off ctxt stack
Reverse post order block ids.
Reverse the args because cmpq can only have a constant in the LHS.
Reverse to get a path from base to most-derived.
Revert all of the types within the signature of the constructor.
Revert all of the types within the signature of the function.
Revert the body parameter types.
Revert the dependent types within the given generic parameter list.
Revert the generic function signature and type-check it again, completely.
Revert the generic parameter list.
Revert the inherited clause of the generic parameter list.
Revert the requirements of the generic parameter list.
Revert the result type.
Revert the signature and type-check it again, completely.
Revert the types within the signature so it can be type-checked with archetypes below.
Revisit the instruction on the next pass through the loop, so that we emit a mask update as appropriate.
Revisit this block now that we've changed it and remove the DestBB.
Rewind to the beginning of the decl.
Rewind to the beginning of the top-level code.
Rewind to the first token of the accessor body.
Rewrite darwinX.Y triples to macosx10.X'.Y ones.
Rewrite dynamic self to the appropriate interface type.
Rewrite memory operands that are based on registers we've copied or lea'd off of other registers.
Rewrite the branch operand for each incoming branch.
Rewrite the code we just created in the preheader and update SSA form.
Rewrite the operand type to the expected argument type, to handle tuple conversions etc.
Rewrite the program argument.
Rewrite to another register if it's just a copy.
Rewrite unknown releases into swift_releases.
Rewrite unknown retains into swift_retains.
Richard Stevens p 298.
Right now SetInt is used for the AddInt entry point also.
Right now consider it circular even if the referenced variant only showed up in one spot.
Right now it's just here because we need to think about and test it before removing that set.
Right now just pattern match applies.
Right now that just means skipping over TupleExpr instances that only exist to hold arguments to binary operators.
Right now these operations only need to do work for array shapes, so the default case (zero-arg call) is applied to most other types.
Right now this is just RuntimeOption::SourceRoot but mwilliams wants to fix it so it is settable, so I'll leave this for now
Right now this just takes the C-style escaped version, which can't contain """ bytes anyway, but it's a little worse output than it needs to be.
Right now we always guard that it is at least uncounted (this means a constant set to STDIN or something will always side exit here).
Right now we conservatively leave the effects of those may-decrefs on the next() path also.
Right now we don't try to optimize in this situation.
Right now we generally can't limit any of these better than general re-entry rules, since they can raise warnings and re-enter.
Right now, our smashable calls are always a known size.
Right now, that only is used for MONGO_RP_NEAREST, and MONGO_RP_NEAREST uses this function (see below in mongo_find_all_candidate_servers().
Right now, this / must always be for purposes of defining it.
Right now, we choose mongo_ce_CursorException for everything but status 80, which is a cursor timeout instead.
Right now, we never allocate fields before the address point.
Right now, we only worry about there being a difference in prefix matter.
Right string literal operand of a string concatenation.
Rip-relative offsets that point outside the range being moved need to be adjusted so they continue to point at the right thing
Roll back, drop the unit and region, and clear fixups.
Roll over the jcc and the jmp/fallthru.
Root protocol initializers (ones that reassign to self, not delegating to self.init) have no members to initialize and self itself has already been reported to be uninit in the primary diagnostic.
Rosh Ha-Shanah   The first day of the Jewish year (Tishri 1).
Rotate loops recursively bottom-up in the loop tree.
Rotate subkeys and do compression permutation.
RotateSingleBlockLoops
Rotates an image by 180 degrees (counter clockwise)
Rotates an image by 270 degrees (counter clockwise)
Rotates an image by 90 degrees (counter clockwise)
Rotation is separate from addition to prevent recomputation.
Rough check to see whether this is a numeric string or not
Round Integer-Of-Unusual-Size types up to their allocation size.
Round base up to align, which must be a power of two.
Round the physical size up to the next power of two.
Round to NUMCOLORS levels of antialiasing for index color images since only 256 colors are available.
Round up the header size to alignment.
Round up the memory size and alignment to a power of 2.
Round up to alignment to get the offset.
Round up to an even number of bytes.
Round up to the alignment of the element.
Round up to the minimal alignment.
Round up to the start of a huge page, and set the high water mark to one below.
Row (or column) of contribution weights
Row-major ever since gd 1.3
Rows can be added using addRows.
RpoSort does a depth-first search over successor and exception edges of a Graph, visits blocks in postorder, and builds the reverse-postorder list of blocks in-place.
Rule out multiple version specs referring to the same platform.
Rules about block order:  - The "primary function body" must come first.
Rules for ICU's RuleBasedBreakIterator class.
Rules for the lowering of these vasms: 1) All vasms emitted in lowering are already adjusted/patched.
Run 'swift-autolink-extract'.
Run GLE, just to ensure all the data has been written
Run an iteration of the high-level SSA passes.
Run an iteration of the mid-level SSA passes.
Run another iteration of the SSA optimizations to optimize the devirtualized inline caches and constants propagated into closures (CapturePropagation).
Run backwards through an array chain doing array_set operations to produce the array type that incorporates the effects of any intermediate defining dims.
Run callbacks only if it's safe to do so, i.e., not when there's a pending exception or we're unwinding from a C++ exception.
Run default priority queue once.
Run high-level loop opts.
Run no-pending-io priority queue once.
Run queue of ready async functions once.
Run release hoisting.
Run shutdown handlers.
Run the actual search
Run the data flow to move retains and releases.
Run the devirtualizer, specializer, and inliner.
Run the external emitter, sending the code to its stdin
Run the function passes.
Run the generated program.
Run the iterative DF to converge the BBWriteSetIn.
Run the iterative data flow to converge.
Run the iterative data flow until convergence.
Run the transforms by alternating between function transforms and module transforms.
Run them under a malloc'ed stack.
Running variables for the current/previous piece.
Running without a resource directory is not a supported configuration.
Runs a command and gets the first line of output
Runs at most 100 times, if we haven't finished by then, call it a data error to avoid going nuts.
Runs the given function with the given context argument exactly once.
Runtime entries using the DefaultCC calling convention do not demand a global symbol by default.
Runtime type metadata always represents the maximal abstraction level of the type.
Runtime typechecking for IRInstruction operands.
RuntimeException object
RuntimeOption::EvalVMStackElms-sized and -aligned.
SET reads 4 input bytes in little-endian byte order and stores them in a properly aligned word in host byte order.
SETTING THIS ONE CAUSES STRIPED IMAGE to be done: solve this #define ORIGINAL_LIB_JPEG_REVERSE_ODD_ROWS
SHA1 basic transformation.
SHA1 block update operation.
SHA256 basic transformation.
SHA256 block update operation.
SHA256 initialization.
SHA256-based Unix crypt implementation.
SHA384 block update operation.
SHA384 initialization.
SHA384 uses the exact same algorithm
SHA512 basic transformation.
SHA512 block update operation.
SHA512-based Unix crypt implementation.
SHIFT_TEMPS must be included in the variables of any routine using RIGHT_SHIFT.
SHUTTERSPEED comes after EXPOSURE TIME
SIL box types are artificial, but for the purposes of dynamic layout, we use the NativeObject metadata.
SIL exposes a greater number of conventions than Swift source.
SIL functions cannot be variadic.
SIL mode uses the same syntax.
SIL scalar conversions which never change the IR type.
SIL type lowering only does special things to tuples and functions.
SIL uses polymorphic function types to resolve overloaded member functions.
SILArgument blocks if it defines the released value.
SILCombine can expose further opportunities for SimplifyCFG.
SILDeclRef uses sigil "#" and prints the fully qualified dotted path.
SILGen can't build phi nodes for them and it would not make much sense anyways.
SILGen doesn't actually re-use blocks for the normal edge, but it's good to be prepared.
SILGen produces shadow variables for "inout" arguments to provide proper semantics for when the inout argument is closed over.
SILGen represents them with a Default basic block with an unreachable instruction.
SILGen the module and produce SIL diagnostics.
SILGenExtension - an ASTVisitor for generating SIL from method declarations / and protocol conformances inside type extensions.
SILGenFunction destructor - called after the entire function's AST has been / visited.
SILGenLValue - An ASTVisitor for building logical lvalues.
SILPrinter class - This holds the internal implementation details of / printing SIL structures.
SILVTable contains one element declared in Entries.
SIL_VTABLE or SIL_GLOBALVAR or SIL_WITNESS_TABLE record also means the end of this SILFunction.
SJIStoJIS() is sjis2jis() by Ken Lunde.
SMA data model is defined in 'swift::sma' namespace.
SOAP 1.2 enc:id enc:ref
SOAP client calls this function to parse response from SOAP server
SP relative offset of the first non-frame cell within the inlined call.
SPARSECOLORMETHOD constants
SPEC Violation: Allow tabs due to real world cases
SQLITE_OPEN_NOMUTEX specifies that the connection be opened such that no mutexes are used to protect the database connection from other threads.
SSATmps with loop-invariant definitions, either because they are purely loop invariant or because the other definitions they depend on are also loop invariant.
SSAUpdater can modify TerminatorInst and therefore invalidate the predecessor iterator.
SSAUpdater cannot handle multiple defs in the same blocks.
SSL config for this request
SSL terminated (but socket may still be active)
SSLv2 protocol might be disabled in the OpenSSL library
STREAM_META_GROUP_NAME
STREAM_META_OWNER_NAME
Sack of inputs and pre-computed data used by the main XLS algorithm.
Safe array semantics operation.
Safe as we'll onlyr read the string from the XML node, not write/free it.
Safe because they create new arrays.
Safe to just delete self.
Safely translates JSValues to an array of doubles.
Said class methods must be in an actual class.
Same applies to optional members.
Same as above but with some other bits.
Same as do_eval(const Unit*, int) except that this evaluates a string
Same as previous macro, but useful when we know that the buffer stack is not NULL or when we need an lvalue.
Same as unserialize from AsyncMysqlQueryEvent but the result is a vector of query results
Same as vspprintf but taking an va_list
Same conditions should hold.
Same decl should always either have or not have a parent.
Same enum elements don't necessarily imply same enum types.
Same if one of the 2 types is an optional type
Same logic for any suffix type.
Same name and external linkage means they're the same.
Same thing as the above regarding TUninit and TBottom.
Same thing for arrays.
Same type requirements may allow for generic inference, even if this generic parameter is not mentioned in the function signature.
Same version upgrade detected, mark absent so the install runs
Same with Closure, since it's a dynamic object but still has its own different behavior for var_dump and cast to array
Same work as above, but opposite order.
Same-order combining marks.
Same-type constraints are eliminated if both sides of the constraint are rooted in substituted parameters.
Same-type requirements are type checked but not recorded in substitutions.
Same-type requirements aren't recorded in substitutions.
Same-type requirements require exact name matches.
Same: Swift.IntegerLiteralType.
Sampling based profiler.
Sandbox path will be updated upon first request with that sandbox arrives
Sanitize the expression.
Sanitizer runtime libraries requires C++.
Sanity check special member function.
Sanity check that we actually found a path at all.
Sanity check that we did see the OpaqueValueExpr.
Sanity check: if the caller gave us a dependent type, there's no way we can handle that.
Sanity check: obviously invalid arguments.
Satisfy the default implementation (bookkeeping).
Save EG/PG(error_handling) so that we can show log messages when we have already thrown an exception
Save a slot for the field type vector address to be instantiated into.
Save any existing type data of the subexpr tree, and reset it to null in prep for re-type-checking the tree.
Save command in the REPL history
Save current state for block.
Save off the forwarded indirect return address if we have one.
Save off the string we have so far, re-fill the buffer, and repeat.
Save our old indent and increment.
Save some work and return as soon as possible if we are not producing diagnostics.
Save that aside while we explore the type.
Save the best color numbers (plus 1) in the main cache array
Save the char so we can change it if need be
Save the cleanup on the argument so we can forward it onto the cast result.
Save the conformance and 'value' decl for later type checking.
Save the conformances from the substitution so that we can substitute them into substitutions that map between archetypes.
Save the current options, and set things up so that systemlib.php can be read from and stored in the normal repo.
Save the cursor and load any abbrev records at the start of the block.
Save the duplicated instructions in case we need to remove them.
Save the failure for this type-protocol pair in the cache.
Save the file position of chunk index, and allocate enough space for each chunk_info block .
Save the final size and alignment into the metadata record.
Save the location and operand information from the branch, then destroy it.
Save the locator we're using for the expression.
Save the metadata for future lookups.
Save the original expression.
Save the original token, in case code-completion needs it.
Save the parsed map to the owner.
Save the position, write the index, restore position (paranoia).
Save the return of handleResume(), then sync regs.
Save the return value and its length
Save the size into the Objective-C metadata as well.
Save the storage property and the initStorage reference for later.
Save the transparent color.
Save the type-checked expression in the pattern.
Save this in case the debugger needs it.
Save time if we already know we processed this AST version.
Saw a check for the first time.
Scalar-to-tuple and tuple-to-tuple.
Scalarize CopyAddrInst.
Scalarize a load down to its subelements.
Scale to 128 levels of alpha for gd use.
Scan a floating point number
Scan a string up to width characters or whitespace.
Scan ahead to see if this is the final cleanup block in this basic block.
Scan ahead until we / find and end-curly-quote (or straight one).
Scan all of the definitions in the function bottom-up using the priority queue.
Scan all of the instructions in this function in search of ApplyInsts.
Scan all of the uses of the AllocStack and check if it is not used for anything other than the init_existential_addr/open_existential_addr container.
Scan all of the uses of the address of the box to see if any disqualifies the box from being promoted to the stack.
Scan all of the uses of the retain count value, collecting all the releases and validating that we don't have an unexpected user.
Scan an instruction and build dependencies for it.
Scan an unsigned or signed integer.
Scan backward recording all operands that use CopySrc until we see the most recent init of CopySrc.
Scan backward to find the start of the line.
Scan backwards for a preposition.
Scan field conservatively.
Scan for supplementary characters
Scan forward from the alloc box to find the first store, which (conservatively) must be in the same basic block as the alloc box
Scan forward recording all operands that use CopyDest until we see the next deinit of CopyDest.
Scan forward to see if we can find the 'in'.
Scan forward until we find the word as a complete word.
Scan inside out until we find something with the right label.
Scan instructions in the given section to find valid instruction boundaries, and check that branches a) land on valid boundaries, b) do not escape the section.
Scan its users and add them to the worklist for recursive processing.
Scan only sections that were not scanned yet.
Scan past any values marked with the Elem, NewElem, or Prop markers
Scan past simple instructions that cannot reduce refcounts.
Scan past simple instructions that cannot reduce strong refcounts.
Scan the JPEG headers.
Scan the blocks in a post-order direction to make sure that we sink the users of each instruction before visiting the instruction itself to allow us to scan the function just once.
Scan the body of the function, looking for anything scary.
Scan the box for interesting uses.
Scan the chain of inlined scopes.
Scan the function / and remove in-block usage of the AllocStack.
Scan the function for any calls to noreturn functions.
Scan the memory buffer looking for expected-note/warning/error.
Scan the metadata layout for the class to find the key offsets to put in our descriptor.
Scan the parent block of AI and check that the users of AI inside this block are inside the lifetime of the allocated memory.
Scan the users in search of a deallocation instruction.
Scan the uses of `ivl' for phi nodes, and return a pair of hints for the first one we find.
Scan the value from the temporary buffer.
Scan the vector looking for this instance of ServerStats.
Scan the whole module and search Apply sites.
Scan through Clang attributes and map them onto Swift equivalents.
Scan through the uses and add them to the worklist for recursive processing.
Scan to see if we are in any non-switch labeled statements (loops).
Scan to see if we have a disjunction constraint for this callee.
Scan until we find the right one.
Scan until we get to the end of the block.
Scan until we get to the top of the block.
Scanning the vector is not terribly efficient, but this doesn't happen often when the server is in a steady state
Scans all instructions of the module and builds the dependency graph.
Scans all references inside a function.
Scatter spare bits from the low bits of an integer value.
Scatter the occupied bits.
Scatter the spare bits.
Schedule all jobs we can.
Schedule any that aren't complete.
Schedule each predecessor if the input set changed.
Schedule it for final cleanup on another thread.
Schedule taken for later, and continue doing the next path now.
Schedule the adviseOut instead of doing it immediately, so that the initial accesses to the primed keys are not too bad.
Schedule users for constant folding.
Schedule users of the new instruction for constant folding.
Scheduled blocks for the fixed point computation.
Schema validation options
Scope any further writeback just within this operation.
Scope information for control flow statements (break, continue, fallthrough).
ScopeCloner expects NewFn to be a clone of the original / function, with all debug scopes and locations still pointing to / the original function.
Score the base name match.
Score this particular optional requirement.
Scout out the specified destination of an AssignExpr to recursively / identify DiscardAssignmentExpr in legal places.
Scratch block can change blocks allocation, hence cannot use regular iterators.
Search among the declarations.
Search among the references.
Search for 'FIXME:' or 'TODO:'.
Search for a compatible extant class.
Search for allocation- and deallocation-calls in the function.
Search for function-exiting blocks, i.e. return and throw.
Search for the inherited conformance among our immediate parents.
Search for the phidef in block `b', then return its dest tuple.
Search for the program and use the path if found.
Search for the section we hold autolink entries in
Search for the section which holds the hash.
Search in memory for matching certificate.
Search the buffers back-to front, so later alias buffers are visited first.
Search the duplicated instruction in the predecessor.
Search the given filename in the list of evaled files.
Search the loaded dls.
Search the pathlist for any of a list of font names.
Search the runtime import path.
Search the subtree if the target range is inside its range.
Search the type of this context and its supertypes.
Search the whole function for stack promotable allocations.
Search the witness table in the ConformanceCache.
Search through the resolvedOverloadSets to see if we have a resolution for this member.
Searching from most to least recently created may have better locality than alternative search orders.
Second is true if the insertion took place.
Second line of defense: Look up the mangled name.
Second pass, check each remaining extension against their dependency list until they have all been loaded
Second phase: transformation.
Second step: add the source graph's defer edges to this graph.
Second step: create defer-edges for block arguments.
Second step: do the actual inlining.
Second step: propagate the connection graphs up the call-graph until it stabilizes.
Second step: propagate the side-effect information up the call-graph until it stabilizes.
Second value is an array of object properties optionally set by the user
Second, reduce the available values into a single SILValue we can use to forward.
Second, the calculation algorithm described in "Jewish Calendar Mystery Dispelled" was coded and used to verify all dates from the year 1 (3761 B.C.) to the year 13760 (10000 A.D.).
Second, try to get a magic file from Common Files
Second, we propagate the use-point information through the graph.
Section 6.1: Bias adaptation function
Section 6.2: Decoding procedure
Section 6.3: Encoding procedure
Section Filters Declarations
Section Header Record
Secure, false by default
See "RC lower bounds" in the documentation---there are some subtleties here.
See "Weakening DecRefs" in the doc comment at the top of this file.
See ../core/BridgeObjectiveC.swift for documentation.
See AnalysisResult::collectFunctionsAndClasses.
See DCE::ReverseDependencies.
See EventHook::GetFunctionNameForProfiler().
See Func::finishedEmittingParams and Func::numParams.
See GEMS I for the algorithm details
See KindOfDouble (below)
See LLVM's separateNestedLoop.
See MessageFormat::cacheExplicitFormats()
See MixedArray::isTombstone().
See ObjectData::release.
See RFC 1010 for values
See TODO(#3602740): unset with intermediate dims on previously declared properties doesn't define them to null.
See TypeAnnotation::getScalarArrayRep().
See also ClangImporter.cpp's canImportAsOptional.
See also MongoDB::command and append_getlasterror, where this has to be done too.
See also tvDupFlattenVars()
See also tvDupFlatternVars()
See arPreliveOverwriteCells for details about why we need this marker.
See autoTypecheckRequestInit().
See below for the implementations of the Op template parameter.
See bytecode.specification for CreateCl for the relevant invariants.
See cancelTimerSource() above.
See comment in addMethod().
See comment in listAssignmentVisitLHS.
See comment in tvCastToNullableObjectInPlace
See comment there and t3879280 for details.
See comments about `GeneralEffects' in memory-effects.h.
See comments in invokeFunc().
See comments in listAssignmentVisitLHS and listAssignmentAssignElements for more explanation.
See comments in pure_spill_frame for an explanation of why we don't need any support bits on this now.
See comments with init_error_limit for rationale.
See computeSimpleCollectionOp.
See dce.cpp for an explanation.
See emitResolveClsBase() for examples.
See findDeallocPoint().
See first if the entire repr resolves to a type.
See further discussion in the doc comment at the top of this file.
See gd_arc_f_buggy.c for a better version that doesn't seem to be bug-free yet.
See generic Get##METHOD below for why we are doing this Note that value is a string, so value.toString() is not a temporary.
See header for why this is required.
See how many bytes we need to cover all the empty cases.
See how many consecutive bits we have.
See how much of the value we can fit here.
See http://curl.haxx.se/lxr/source/docs/libcurl/symbols-in-versions or curl src/docs/libcurl/symbols-in-versions for a (almost) complete list of options and which version they were introduced
See http://swift.org/LICENSE.txt for license information See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
See https://github.com/webscalesql/webscalesql-5.6/issues/23
See icu/Tokenizer.cpp for definition of types.
See if Continue has a release on self as the instruction right after the apply.
See if V2 after stripping casts aliases O1.
See if a connection is in our blacklist to short-circut trying to connect to a node that is known to be down.
See if all of them are the same value.
See if any addresses are here
See if any instructions in the block can be eliminated.
See if it is reached over Success or Failure path.
See if it provides a value or refines the demanded element mask / used for load promotion.
See if it's a property
See if iter is an apply inst that is a safe guaranteed semantic function.
See if spare bits fit into the 31 bits of the index.
See if the given name matches the function's name.
See if the payload types have any spare bits in common.
See if the placeholder is encapsulated with an EditorPlaceholderExpr and retrieve parameter and return type ranges.
See if the repr resolves to a type.
See if the value matches the payload type exactly.
See if there are any Tier-based overrides
See if there's a following argument type.
See if there's a raw value expression.
See if there's anything we can do to fix the conformance:
See if this can be removed.
See if this input should be passed with -primary-file.
See if this is a type alias.
See if this is an optional initializer.
See if we already defined this function.
See if we already have a version of this function in the module.
See if we cached the mangling signature.
See if we can defer initialization of the buffer to a copy_addr into it.
See if we can match the class name to the beginning of the first selector piece.
See if we can reach the From-node by transitively visiting the predecessor nodes of the To-node.
See if we have a cached conformance.
See if we have a cached projection we can use.
See if we have a callee region we can inline---but only if the singleton inliner isn't actively inlining.
See if we have a retain of some sort, if we don't, bail.
See if we have all loads from this unchecked_addr_cast.
See if we have an instance method, instance member or static method, and check if it can be accessed on our base type.
See if we triggered deserialization through our conformances.
See if we're in an Xcode toolchain.
See if we're just checking the array kind or object class of a value with a mostly-known type.
See if we've already got this cached.
See if we've cached the lowered capture list for this function.
See if we've produced a block copy helper for this type before.
See if we've produced a block destroy helper for this type before.
See longer comment above.
See note above about this wait.
See note in debugger-hook.h.
See notes in update_box about scaling distances.
See readLongString for more details.
See swift::performTypeChecking for TopLevelCodeDecl handling.
See task description for further details.
See task description for more details.
See the GNU General Public License for more details.
See the GNU Library General Public License for more details.
See the IJG JPEG library documentation for more details.
See the License for the specific language governing permissions and limitations under the License.
See the NOTICE file distributed with this work for additional information regarding copyright ownership.
See the TBAA section / in the SIL reference manual.
See the TODO in computeSubSeqRelation.
See the code in utf8ToModifiedUTF8 for what's happening here.
See the comment above for a rare situation in which the transparent pixel may not work properly with 16-bit channels.
See the comment for SelfTypeVar in ConstraintSystem.h.
See the comment in AbstractionPattern.h for a discussion.
See the comment in SILType.cpp.
See the comments at the top of this file.
See the comments in CGetS about constprop for public statics.
See the comments in asyncFunctionReturn.
See the definition of Fixed, Versionable and VersionableSparse in the header for details.
See the disjoint data function objects above.
See the docs above in "Effects of Pure Stores on Memory Support" for an explanation.
See the documentation for exceptionStackBoundary in the header for more information.
See the extern "C" declaration of this function, above.
See the file "license.terms" for information on usage and redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES.
See the implementation note below.
See the long comment beginning "From RFC 3986, Appendix A Collected ABNF for URI" in qurl.cpp for rationale for the exclude strings used here.
See the related issue https://github.com/facebook/hhvm/issues/5244
See the way we set up the timer group and cancellation handler in setTimeout() below.
See through implicit conversions of the expression.
See upload.cpp:read_post.
See what spare bits from the payload we can use for layout optimization.
See what we can do backwards.
See whether the current value at the destination has a payload.
See whether the payload case's type has extra inhabitants.
See whether the source value has a payload.
See whether this is a payload or empty case we're emitting.
See whether we already emitted this protocol reference.
See whether we have a deferred fixed-size buffer initialization.
See whether we lowered a type equivalent to this one.
Seed the generator with a simple uint32
Seed the stack with the protocol declarations in the original list.
Seed the type map with pre-existing substitutions.
Seek within m_buffer if we can, otherwise kill it and call user stream_seek / stream_tell
Seems to work around segfaults in Qt 4.8: https://gist.github.com/1430393
Select out the chunk of the value to merge with the existing payload.
Select the "necessary column", Maranget's term for the column / most likely to give an optimal decision tree.
Select the linker to use
Select the remaining regions, iteratively picking the most likely region to execute next.
SelectEnum must be exhaustive, so the second case must be handled either by a case or the default.
Selector for error message.
Selector for the partial_application_of_function_invalid diagnostic message.
Selector for unimplemented_static_var message.
Selector pieces beyond the first are simple.
Self and Parent should never happen, because type aliases are not allowed to use those MetaTypes
Self and super requirements must also be checked and diagnosed.
Self argument mismatches.
Self is a curried argument and thus comes last.
Self is always an artificial argument.
Self is always the first callsite.
Self is passed inout.
Sema conservatively converts the base to inout expr when it is an lvalue.
Sema does later checks for UnresolvedPatternExpr's in arbitrary places, but rejecting these early is good because we can provide better up-front diagnostics and can recover better from it.
Sema forces conditions to have Builtin.i1 type, which guarantees this.
Sema has diagnostics with hard-coded expectations about what statements return false from this method.
Sema leaves some subexpressions null, which seems really unfortunate.
Semantic analysis fills in the depth when it processes the generic parameter list.
Semantic annotation queries for a particular document should cancel previously queued queries for the same document.
Semantic calls are safe.
Semantic checks ensure that the return annotation is "Awaitable" or "WaitHandle" and that it has at most one type parameter
Semaphore 0 (SYSVSEM_SEM) is the actual semaphore, it is initialized to max_acquire and decremented as processes acquire it.
Semaphore 2 (SYSVSEM_SETVAL) serializes the calls to GETVAL SYSVSEM_USAGE and SETVAL SYSVSEM_SEM.
Semaphore functions using System V semaphores.
Semicolon *should* always be required, but PHP's implementation allows omitting it and still functioning.
Send CmdSignal over to the client and wait for a response.
Send and wait for reply
Send breakpoints to the server, and then attach to the sandbox if necessary.
Send finished event from the processing thread to the web request thread.
Send the disconnect error as notification.
Send the gd2 id, to verify file format.
Send the user input to the main Phantom frame for evaluation
Send the xml shutdown response
Sends GLog output to adb logcat.
Sends a "list file" command to the proxy attached to the given client.
Sends a copy of the given command to the associated client using the buffer in m_thrift.
Sends a getnonce command to the server for authentication  Returns the nonsense when it worked, or NULL if it didn't.
Sends a ping command to the server and stores the result.
Sends an Info command to the server to retrieve source location information for the function or class specified by the command argument.
Sends an acknowledgment back to the client so that it can go ahead and terminate.
Sends an ismaster command to the server to find server flags  Returns 1 when it worked, and 0 when an error was encountered.
Sends this list command to the server to retrieve the source to be listed and then displays the source on the client.
Separate forward declarations from the class itself.
Separate out the accessor methods.
Separate out the checks for methods.
Separate the declarations that we are going to print into different buckets.
Serialize 'this' object.
Serialize 'use' parameters.
Serialize a Variant recursively.
Serialize all the params into something we can use for the key
Serialize compiler instance
Serialize function parameters.
Serialize operation info
Serialize the witness table in two cases: 1) We're serializing everything 2) The type has a fixed layout in all resilience domains, and the conformance is externally visible
Serialized as part of the type.
Serialized variants and objects shouldn't ever make it into the repo.
Serializes a Variant, and truncates it to a limit if necessary.
Serializes this command into the given Thrift buffer.
Server note has to live long enough for the access log to fire.
Server should have matched it.
Server shutdown - Explained
Server-side work for a command.
ServerShutdownEOM isn't required to be smaller than ServerShutdownListenWait, but it makes sense to make it be, in order to make shutdown faster.
Service request stub emitter.
Set AllArchetypes of the protocol.
Set AttrHot on hot functions.
Set C language options.
Set IRBuilder's Block associated to blockId's block according to the mapping in blockIdToIRBlock.
Set IRBuilder's Blocks for srcBlockId's successors' offsets within the region.
Set LegalUsers to false and return.
Set PC so logging code in getTranslation doesn't get confused.
Set a bit in the control variable at the current insertion point.
Set a flag if the class uses Swift 1.0 refcounting.
Set a value range on the load instruction, which must be the argument of the builtin.
Set an internal breakpoint after the instruction if it can fall thru.
Set an internal breakpoint at the target of a control flow instruction.
Set backward pointers from last to pred.
Set by a .ini file at the start
Set connection type depending on flags
Set constructor override.
Set cookie expire date via "classic" string format
Set cookie expire date via "number of seconds since epoch" NOTE: Every JS number is a Double.
Set cookies and returns "true" if at least 1 cookie expired and has been removed
Set cookies and returns "true" if at least 1 session cookie was found and removed
Set current virtual host.
Set deepInit if the property requires "deep" initialization.
Set defaults from config.hdf
Set downcasts are handled specially.
Set each bound variable in the pattern to have an error type.
Set flag before recursing to catch circularity.
Set flags to tell polling thread to end.
Set flow control (for uploads) to 1MB.
Set function override.
Set in FrontendOptions
Set it to implicit to disable printing it for SIL.
Set it to the minimum stack size, which is set earlier by execute_program_impl.
Set its next block appropriately.
Set locals to Uninit.
Set lower bits as needed.
Set m_dbgBranchGuardSrc after patching, so we don't try to patch the debug guard.
Set m_nextKI to 0 for now to prepare for renumbering integer keys
Set new used value (we've removed any tombstones).
Set non-empty errno if afdt_send_fd_msg doesn't set one on error
Set of RPO ids that still need to be visited.
Set of all ThreadInfos for the running process.
Set of all blocks that may reach the loop, not including loop blocks.
Set of all types which are currently known to be pointer followable or countable.
Set of arguments that need to be released after each invocation.
Set of block reverse post order ids that still need to be visited.
Set of blocks that branch to/reach this basic block P and are immediate successors of a switch_enum instruction.
Set of ids of the other MustAliasSets that this set may alias, in a flow insensitive way, and not including this set itself.
Set of indirect subclasses for the class.
Set of let properties in a given nominal type.
Set of lifetime endpoints for this partial_apply.
Set of memory location ids that are being used to support the lower bound of this object.
Set of properties which already fulfill all conditions, except the available of constant, statically known initializer.
Set options for the current file/buffer.
Set our BB list to have this function as its parent.
Set our lattice state to be decremented.
Set our lattice state to be incremented.
Set prop is happening with WithRef semantics---we only use a binding assignment if it was already KindOfRef, so despite the const_cast here we're safely not modifying the original Variant.
Set run status to STOPPING.
Set script file encoding
Set semaphore 1 back to zero.
Set state from Running to Started.
Set state to succeeded.
Set the "arch" platform condition.
Set the "os" platform condition.
Set the "runtime" platform condition.
Set the CFI table row address to the start address, and reset the CFA offset to what it was at the end of the CIE.
Set the Clang resource directory to the path we computed.
Set the DFSNum for this node if we haven't already, and if we have, which indicates it's already been visited, return.
Set the IR global's initializer to the constant for this SIL struct.
Set the IR global's initializer to the constant for this SIL tuple.
Set the ODBC version we are going to use to 3.
Set the SDK path and target if given.
Set the alignment from the TypeInfo.
Set the array.props argument.
Set the assert configuration according to the optimization level if it has not been set by the -Ounchecked flag.
Set the attributes, if any
Set the body of the class type.
Set the body of the closure.
Set the class to the pure Objective-C superclass, so that when dealloc runs, it starts at that superclass.
Set the class variables
Set the computed setter.
Set the conformances.
Set the constraints for both side of the conditional branch, if that the condition is dominating the dest block (see comment above).
Set the constructor's type(s).
Set the constructor's type.
Set the current column.
Set the current fields as the body of the given struct type.
Set the current generation, remove the node from the stack, and process it.
Set the current line number.
Set the debug info location for I, if applicable.
Set the debug locations of all instructions.
Set the debug scope for the function.
Set the decl context of any vardecls to this FuncDecl.
Set the default connection type, we might change this if we encounter the replicaSet option later
Set the delegate to the result of visiting our expression
Set the destination index.
Set the destinations for 'break' and 'continue'
Set the destinations for 'break' and 'continue'.
Set the destinations for any 'break' and 'continue' statements inside the body.
Set the error reporting level to 0 to ensure non-fatal errors are hidden
Set the error result slot.
Set the first argument name to be the name we computed.
Set the first callee block as a successor to the FCall's block and "fallthrough" from the caller into the callee's first block.
Set the foreign error convention for a throwing method.
Set the function up as the getter.
Set the generic parameters and requirements.
Set the hash entry we found to point to element slot 0.
Set the inherited protocols of a protocol.
Set the initializer interface type of the constructor.
Set the initializer type of the constructor.
Set the input stream.
Set the interface type.
Set the kind of initializer.
Set the lazy resolver for this context.
Set the location/scope of the intrinsic.
Set the low bit of the value to indicate "compiled by Swift".
Set the lowered explosion for the self argument.
Set the manager from the global manager
Set the match location in subject
Set the metadata pointer.
Set the metatype in local data.
Set the module cache path.
Set the module's string representation.
Set the most significant bit.
Set the new end index to the last value of the induction.
Set the new start index to the first value of the induction.
Set the nextRetrans blocks according to the computed chains.
Set the page Library path
Set the phi group for each phi use variable to that of the corresponding phi def variable (allocating a new group if the def variable has not already been assigned one).
Set the pre-header of loop `loopId' to `preHeader', and also add `preHeader' to any ancestor of `loopId'.
Set the predicted type for `l', discarding any previous prediction.
Set the primary file to the code-completion point if one exists.
Set the profCount of the IRUnit's entry block, which is created a priori.
Set the protocol witness tables.
Set the proxy for this thread to be the localProxy we just created.
Set the return value to NULL, as the connection is broken and has been removed
Set the search bits appropriately.
Set the specified generic parameters onto this abstract function, setting the parameters' context to the function along the way.
Set the specified generic parameters onto this type alias, setting the parameters' context along the way.
Set the state and return.
Set the static callback to offer Completions to the User
Set the static initializer and remove "once" from addressor if a global can be statically initialized.
Set the store bit for stack slot deallocated in this basic block.
Set the superclass type.
Set the token to a sentinel so that we know the lexer isn't primed yet.
Set the type of the TypeAlias to the right MetatypeType.
Set the type of the initializer.
Set the type on the pattern.
Set the type we checked against.
Set the typo-corrected name.
Set the uncurry level.
Set the underlying type of each of the associated types to the appropriate archetype.
Set the unnamed "state" local to the appropriate identifier
Set the user-defined data.
Set this block as the dominance point.
Set this declaration as invalid, then break the cycle somehow.
Set to false if only one side is zero.
Set to start of buffer
Set to true if both sides are zero.
Set to true if the metadata record for the generic type has fields / outside of the generic parameter vector.
Set to true if the value witness table for the generic type is dependent / on its generic parameters.
Set to true once we have a match.
Set to zero so we can't do it if the req counter wraps.
Set un-passed parameters to Uninit (or the empty array, for the variadic capture parameter) and set up the ExtraArgs on the ActRec as needed.
Set up Env, only visiting reachable blocks.
Set up PHP frame linkage for our parent by copying our ActRec's sfp.
Set up TargetOptions and create the target features string.
Set up a "catch" block for when an error occurs.
Set up a cache and put this data file in it.
Set up a callback which will be called immediately after a task has finished execution.
Set up a callback which will be called immediately after a task has started.
Set up a cleanup to write back to the inout.
Set up a conformance to represent the behavior instantiation.
Set up a constraint system where we open the generic parameters of the protocol extension.
Set up a continuation BB and phi nodes to receive the result value.
Set up a decl context for the closure.
Set up a diagnostics engine that swallows diagnostics.
Set up a dummy global to stand in for the constant.
Set up a dummy global to stand in for the metadata object while we produce relative references.
Set up a fake frame here, in case of errors.
Set up a function declaration.
Set up a result buffer if desirable/required.
Set up a writeback through a +0 buffer.
Set up an initial clause matrix.
Set up an optional-failure scope (which cannot actually return).
Set up callbacks to support stream wrappers for reading and writing xml files and loading external entities.
Set up criteria array
Set up error conformance to be lazily expanded
Set up inlining context, but disable it for profiling mode.
Set up line thickness
Set up linkage with the top VM frame in this nesting.
Set up method pointers
Set up proxy if required
Set up scheduleCommandIfNecessaryAndPossible.
Set up something for FileCache to read in.
Set up the 'byte output' routine
Set up the 'self' argument.
Set up the C underlying type as its Swift raw type.
Set up the IRBuilder.
Set up the OR-mask arrays for the initial and final permutations, and for the key initial and compression permutations.
Set up the PHI nodes on the error edge.
Set up the PHI nodes on the normal edge.
Set up the RegionContext for the tracelet selector.
Set up the VM registers.
Set up the alloca insertion point.
Set up the args array.
Set up the bitvector of elements being demanded by the load.
Set up the block for the false case.
Set up the builder we use to insert at our insertion point.
Set up the cache variable.
Set up the callee state.
Set up the closure object and class context.
Set up the code completion consumer to pass results to organizer.
Set up the constraint system for matching.
Set up the context into which to emit the outer result.
Set up the current x and y position
Set up the datastructure used to collect the uses of the allocation.
Set up the dependency.
Set up the disjunction for the array or scalar cases.
Set up the final emission passes.
Set up the first two fields.
Set up the generic signature.
Set up the globals:  g_init_bits - initial number of bits g_outfile   - pointer to output file
Set up the imported header module.
Set up the initialized release block.
Set up the inner result.
Set up the layout info in the vwtable.
Set up the load forwarding.
Set up the match, determining the requirement and witness types in the process.
Set up the necessary values
Set up the parameter info.
Set up the result buffer.
Set up the substitutions, if we have any.
Set up the superclass of the metaclass, which is the metaclass of the superclass.
Set up the throw destination if necessary.
Set up the uninitialized release block.
Set up the value for redundant load elimination.
Set up the value witness table if it's dependent.
Set up this emitter afresh from the current callee specs.
Set up writebacks for the call(s).
Set/ImmSet, val is the key
SetL preserves reffiness of a local.
SetOpL is like IncDecL, but with the complication that we don't know if we can mark it dead when visiting it, because it is going to pop an input but unlike SetL doesn't push the value it popped.
Sets RuntimeOption::ExecutionMode according to commandline options prior to config load
Sets all unknown elements to not-available.
Sets changed to true if anything was moved or deleted.
Sets read preference mode and tagsets.
Sets the baseValue such as the current stack depth matches the parameter.
Sets the elements of a use to available.
Sets the wire protocol flag to allow reading from a secondary.
Sets up an initialization for the allocated box.
Setter's arg type should be same as getter's return type
Setters declared in reference type contexts are never mutating.
Setting DWARF Version depend on platform
Setting it to PRIMARY when it already is PRIMARY doesn't hurt.
Setting one of these variables forces the STL default allocator to call new() or delete() for each allocation or deletion.
Setting the bound parameter to true tells vm_call_user_func() propogate the current late bound class
Setting the int at the size of the array can keep it in packed mode---it's the same as an append.
Setting the type clears the typeSrcs, so the new type may not be derived from the old type in any way.
Setting this will ensure we stay out of JIT code and in the interpreter so phpDebuggerOpcodeHook has a chance to work.
Setting up crypto failed.
Settings constants before looping
Setup Preprocessor callbacks before initialing the parser to make sure we catch implicit includes.
Setup a typechecker for protocol conformance resolving.
Setup m_entry after property initialization, since it depends on the value of m_defHint.
Setup server-side usage logging before accepting any connections.
Setup the SIL Options.
Setup the VarLocs to point to the incoming args and setup initialization so any args needing cleanup will get that as well.
Setup the builder we will use to insert at our insertion point.
Setup the flow filter on the VM context for all offsets covered by the current source line.
Setup the input buffer state to scan a string.
Setup the input buffer state to scan directly from a user-specified character buffer.
Setup the input buffer state to scan the given bytes.
Setup the padding string values if specified.
Setup the variable exporter
Several operation names have suffixes and don't match the name from Builtins.def, so handle those first.
Several things could have gone wrong here, and we'll check for each of them at some point: - The keyword argument might be redundant, in which case we can point out the issue.
Shadow any initializers that are worse.
Shallow-dump a pattern node one level deep for debug purposes.
Shapes may not have leading integers in key names, considered as a parse time error.
Shared code to read color tables from gd file.
Shared helper functions
Shared ref to keep us alive.
Shared thunks and Clang-imported definitions can always be delayed.
Shed the 'self' type and generic requirements from method manglings.
Shift away the reserved bits.
Shift the bits into place.
Shift the error token.
Shift the lookahead token.
Shift the mask down to this element.
Shift the most significant bits of the tag value into place.
Shift the remaining bits down.
Shift the selected bits into place.
Shift to state state ST_LT_CHECK to do a more extensive check to determine if this is the beginning of an XHP tag.
Short circuit portscan, we're dealing with an IPv6 embedded address
Short version, display and type are the same.
Short-circuit for cases where we're executing a line of code that we know we don't need an interrupt for, e.g., stepping over a line of code.
Short-circuit other commands
Short-circuit out if we already emitted the import for this decl.
Short-circuit when we're doing things like evaling PHP for print command, or conditional breakpoints.
Short-cut for the most common (and simplest) case
Short-hand to get the rpoId of a block in a given FuncAnalysis.
Should already be 0 after mmap.
Should be C calling convention, but NSApplicationMain has an overlay to fix the type of argv.
Should be StaticArr: t2124292
Should be a type followed by a series of protocol conformances.
Should be after FunctionSignatureOpts and before the last inliner.
Should be called outside m_lock
Should be done in caller
Should be in the same BB.
Should be removed when these features are no longer gated.
Should be significantly faster.
Should have handled the conversion in one of the cases above.
Should never be called.
Should never be polymorphic.
Should never get here or the buffer was invalid
Should never happen (Attr::Static check in ctor)
Should never read more than 10 bytes, which is the max for a 64-bit int
Should not be loaded.
Should not have any newlines at the beginning.
Should not really have to do anything as there is only going to be one server
Should not wait for the new AST, it should give the previous answer.
Should only be one conformance, for the ErrorProtocol protocol.
Should only have one tuple extract after CSE.
Should only include this default if not explicitly ignored.
Should refactor so we handle it (we already know things about the array).
Should run after box-to-stack promotion since it is limited to propagating through stack locations.
Should run before aggregate lowering since that splits up copy_addr.
Should wait for the new AST, because the cursor location has been edited out.
Should wait for the new AST, because the cursor location points to a different token.
Should wait for the new AST, because the declaration location for the 'foo' reference has been edited out.
Should we replace calls to assert_configuration by the assert configuration.
Should we take control of the mang
Should we treat instructions that increment ref counts as None instead of / MayHaveSideEffects.
Should've been handled earlier in union_of.
Shouldn't be calling this function after the runtime options are loaded.
Shouldn't happen because we only call genObject() on offsets already visited and verified to be an object type.
Shouldn't happen where we have requirement representations.
Shouldn't need this side channel.
Shove in the T_ELSE and T_WHITESPACE, then return the remaining T_IF
Show exactly where this constructor came from.
Show upgrade on install and modify pages
Show web-inspector if in debug mode
Show/Hide the version label if it exists.
Shows sorted patterns list in the order which is used for the matching
Shrink it to actually-used volume and set its statistics
Shrink the min/max bounds of a box to enclose only nonzero elements,
Shuffle args into two vectors.
Shuffle things around so the Vreg previously defined by the setcc is now defined by the phidef.
Shut up the compiler warning
Shutdown the debugger
Shutdown the listen sockets, this will 2.a Close any idle connections 2.b Send SPDY GOAWAY frames 2.c Insert Connection: close on HTTP/1.1 keep-alive connections as the response headers are sent 3.
Shutdown the server socket.
Side effects: Initializes the charset.
Side exit if the static local is null.
Side exit if the static local is uninitialized.
Side exit if the static property is null.
Sign bit of the operand is promoted.
Sign extension in the first char has no effect - nothing to overwrite yet, and those extra 24 bits will be fully shifted out of the 32-bit word.
Signal JS shim to catch, decorate and store this new child page
Signal an abnormal exit by returning 1.
Signal to the main server thread to exit immediately if we want to die on SIGTERM
Signals on Windows are not operating system primitives and mostly shouldn't be used, but installing a handler for SIGABRT is the only way to intercept calls to abort().
Silence downstream errors referencing this associated type.
Silence error messages about testably importing a Clang module.
Silence operator, eval, preincrement, and predecrement
Silently ignore it for now.
Silently truncate long inputs.
Silentyly fail to match PHP5 behavior
Similar for Top, or InitCell, etc.
Similar for the other IterInits below.
Similar special case for FCallBuiltin.
Similar to FPushFunc/FPushObjMethod, we have an incomplete ActRec on the stack and must handle that properly if we throw or re-enter.
Similar to above, but with mulodi4.
Similar to class_alias, when a type alias is declared with the same name as a class in the program, we need to make sure the class is marked redeclaring.
Similar to fixups - this is a return address so get the address returned to.
Similar to start above, end could be the start of an existing region.
Similar to static variables, find any definitions which refer to this function in order to extract linkage information.
Similar to swift::conflicting, but lenient about protocol extensions which / don't affect code completion's concept of overloading.
Similar to the PatternBindingDecl case above, we return the first EnumElementDecl.
Similar to the function case in do_analyze, we have to handle the fact that there are infinitely growing chains in our type lattice under union_of.
Similarly for addressImmediates - and see comment above for non-address immediates.
Similarly reusable stubs will still point to the old code.
Similarly suggest applying the Fix-It to the parent enum case rather than the enum element.
Similarly, Vector is only usable with int keys, so we can only do this for Vector if it's an Int.
Similarly, apc strings could be in the ServerNote array, and its possible they are scheduled to be destroyed after this request finishes.
Similarly, destructors refer to the instance method -dealloc.
Similarly, do not try to serialize WaitHandles as they contain internal state via non-NativeData means.
Similarly, the last 6 months do not change from year to year.
Similarly, the output of SetL is obvious if you know what its input is (which we'll assert if we know).
Simple case: Just change the reference kind
Simple case: add the constraint.
Simple case: bridgeable object types.
Simple case: direct reference to a declaration.
Simple case: for methods and initializers, check that the selectors match.
Simple case: forced checked cast.
Simple case: it's a scalar value so we just serialize it
Simple case: protocols don't form bound generic types.
Simple case: the property type of the getter is in the return type.
Simple case: use the nominal type's generic parameters.
Simple case: we have the same identifier.
Simple cases we want to handle fast.
Simple debugging print function.
Simple division can't be used since that will cause wrong results.
Simple enumerations conform to Equatable.
Simple enumerations conform to Hashable.
Simple implementation of bstrcaseeq, used for bstrcasestr since the above implementation is specialized for exact-matching strings.
Simple memory accesses cannot reduce refcounts.
Simple optional-to-optional conversions.
Simple pass for testing the new loop region dumper analysis.
Simple program which provides a command-line interface to the debug-info printer.
Simple single-character escapes.
Simple soundex algorithm as described by Knuth in TAOCP, vol 3
Simple stats about opcodes (that don't require full type information---those cases are only enabled when extendedStats is on).
Simple subtraction of each component would yield PtrToMembInt, but that would mean we removed PtrToRefInt from the lhs despite it not being in rhs.
Simple tuple-like class used to order instructions for printing.
Simple, our stored type is already bridged
SimpleValue - Instances of this struct represent available values in the / scoped hash table.
SimpleXMLElement is the only class that has custom double casting.
SimpleXMLElement is the only class that has proper custom int casting.
SimpleXMLElement is the only non-collection class that has custom bool casting.
SimpleXMLElementIterator
Simplest way of expressing aperture, so I trust it the most.
Simplifications that walk the dominator tree to prove redundancy in conditional branching.
Simplified version of is_numeric_string which also allows for non-numeric garbage Because PHP
Simplifies basic block arguments.
Simplify MemoryRef vasm types by their direct variant as ppc64 can't change data directly in memory.
Simplify a condition branch to a block starting with "cond_fail 1".
Simplify a pattern of integer compares to a select_value.
Simplify a select_enum on an enum instruction.
Simplify a switch_enum.
Simplify aggregate instructions into scalar instructions.
Simplify an `inst' at block `b', instruction `i', returning whether or not any changes were made.
Simplify an apply of the builtin canBeClass to either 0 or 1 / when we can statically determine the result.
Simplify at this index until no changes are made.
Simplify cond_br where both sides jump to the same blocks with the same args.
Simplify expressions which are type sugar productions that got parsed / as expressions due to the parser not knowing which identifiers are / type names.
Simplify invocations of builtin operations that may overflow.
Simplify operations that may overflow.
Simplify terminators that could have been simplified by threading.
Simplify terminators.
Simplify the block argument list.
Simplify the blocks with terminators that rely on constant conditions.
Simplify the given locator down to a specific anchor expression, / if possible.
Simplify the given type for use in a type property constraint.
Simplify the locator.
Simplify the program termination block.
Simplify the type we're casting to.
Simplify this constraint.
Simplify this term in the disjunction.
Simplify() calls can make blocks unreachable as we walk, and visiting the unreachable blocks with simplify calls is not allowed.
SimplifyCFG deletes the dead BB arg.
Simplifying other blocks might have resulted in unreachable loops.
Simply eliminate the allocation and any obviously trivial noop copies into and out of it.
Simply importing the categories adds them to the list of extensions.
Simply replace the load.
Simply return if we are not performing RLE or we do not have all the values available to perform RLE.
Simply setup a "step out breakpoint" and let the program run.
Simply take care of the vasm's Vptr, reemmiting it if patch occured
Simulate already having mangled names
Simulate the demangling / parsing process
Simulate the reference count effects of the calls before removing them.
Simultaneously, BC markers in these exit blocks are updated to reference the new FP.
Since MovePos is an instruction, we know that there is always a valid iterator after it.
Since Swift protocol descriptors are laid out to look like ObjC Protocol* objects, the name has to clearly be a Swift mangled name.
Since `CapCode::Threshold + 1' is a small size class (it should always be a power of 2), the threshold for string length is
Since `current' is shorter, we might have a different hint, or a different heuristically-determined best-reg.
Since `other' is an inactive Vreg interval, it cannot cover current's start, and `current' cannot cover other's start, since `other' started earlier.
Since all countable types are automatically pointer followable, mark them as such.
Since all uses of result #1 are gone, this only walks through uses of result #0 (the retain count pointer).
Since before this, the only type-indices that can be present are "kIndexUnknown" and "kIndexUnknownNoPtrs".
Since builtin types are sign-agnostic, print the signedness separately.
Since captures are created via partial_apply instructions, we need to see which function parameter fulfilled this metadata need and grab its type.
Since check is a control flow instruction, it needs to end the block, so all the code after it has to move to either the taken block (exit) or the fallthrough block (specialized).
Since cload does the load unconditionally anyway, we can just load and cmov.
Since each extra inhabitant corresponds to a specific bit pattern that is known to be invalid given the payload type, projection of the payload value is a no-op.
Since function entry breakpoints are handled by onOpcode, this just handles pushing the active line breakpoint
Since incompleteQ is ordered, we'll always visit blocks with earlier RPO ids first, which hopefully means less iterations.
Since indexed types with scan set to false come first, this will ensure that false is kept over true.
Since it does not equal our record, we can skip it.
Since it doesn't seem to work to include the .h file, just sleaze declare it here.
Since it is a forward dataflow- problem, it is faster to go through the worklist in reverse order.
Since it is an addr cast, only address types are handled here.
Since it will be teleported to its place in memory, we don't care about the type.
Since it's an operator we insert the decl after the type at global scope.
Since it's noreturn, there should be a true unreachable terminator right after.
Since it's unlikely (but not impossible) to have zero generic parameters at a depth, encode indexes starting from 1, and use a special mangling for zero.
Since kMaxTrackedALocs is bounded by a constant, it's kinda O(stk_expand_map), but not in a good way.
Since libmemcachd is in C, we cannot use lambda functions as lambda functions are special typed and normally passed by templated types.
Since line numbers are only used for generating warnings and backtraces, the set of Offset-to-Line# mappings needed is sparse.
Since major is a function on SVR4, we cannot use `ifndef major'.
Since many types have similar structure, multiple types can share the same layout.
Since most accesses to magic property getters aren't going to recurse, we optimize for the case where only a single getter is active.
Since nested generic functions are not supported yet, the only case where generic parameters can be captured is by closures and non-generic local functions.
Since not all of our unions carry a type register, there are some situations with strings and arrays that are neither constantly-foldable nor in the emitTypeTest code path.
Since popen() doesn't indicate if the internal fork() doesn't work (e.g. the shell can't be executed) we explicitly set it to 0 to be sure we don't catch any older errno value.
Since previous translations aren't reachable from here, we know we just created some garbage in the TC.
Since removing this functionality could cause a lot of functionality to break, instead we continue to allow access case-insensitively, but with a warning
Since resolve() takes a Class::Const and no other fields of the Const can change, just copy cns and give the copy our local version of the ArrayData*.
Since resumables are stored on the heap, we need to go back in the callstack a bit to find the base of the stack.
Since some of the template parameters may not yet be parsed when we parse the template, the inference of the correct template linkage is deferred until all the types' linkages are computed.
Since some of these optimizations inspect tracked state, we don't perform any of them on non-main traces.
Since spare bits correspond to bits which are known to be zero for all valid representations of the payload type, they must be stripped out before the payload value can be manipulated.
Since stores themselves don't have any uses, we can short-cut the classification scheme above.
Since struct_extract users are not visited by / StructUseCollector, they are never added to ArrayUserSet.
Since sunset varies, the day is assumed to begin at 6:00 P.M.
Since that is not *that* interesting from an ARC perspective (i.e. no ref count operations in a loop), disable it on such functions temporarily in order to unblock others.
Since the / anonymous type is imported as a nested type of the outer type, this / generated name will most likely be unique.
Since the UTF-8 BOM doesn't carry information (UTF-8 has no dependency on byte order), throw it away.
Since the allocation has already been promoted to an alloc_stack, we know it doesn't escape.
Since the current context class could call it last time, we can call the new implementation too.
Since the function is non-void, we need to return something.
Since the head of our edge is SubLoopHeaderRegion, this must be local.
Since the innermost GenericParamList is in the beginning of the vector, we process in reverse order to handle the outermost list first.
Since the length of a metonic cycle is a constant, this is a simple calculation, except that it requires an intermediate value which is bigger that 32 bits.
Since the lower bound is non-zero, we don't need to worry about changing lower bounds in other sets that May-Alias this one, because of the "exclusivity" rule for lower bounds.
Since the object itself is stored in the alloca, emitting it as a reference type would be wrong.
Since the source and dest are RC identical, store the reference into the source temp without a retain.
Since the stack is maintainined on a per request basis, for performance reasons, it only makes sense to expand if necessary and cycles are wasted contracting.
Since the stack state is going to be considered "trimmed" over there, we need to null the extraArgs/varEnv field if the function could read it.
Since the string is already parsed, Tok already points to the first token after the whole string, but PreviousLoc is not exactly correct.
Since the task signalled, unconditionally set result to -2.
Since the union is made of all of the fields at once, this is a trivial accessor that casts self to the correct field type.
Since the user can stop the trace at any time, this isn't an error.
Since there are no payloads, we need just enough bits to hold a discriminator.
Since there are no side effects, it is perfectly fine to delete this instruction if all uses of the instruction are also eliminable.
Since there can be many subscripts for the same nominal type, we need to find the one matching the specified type.
Since there can be multiple names for the same codec (i.e., "utf8" and "utf-8"), we need to get the codec in the system first and use its canonical name
Since there's no semantically correct way to do PureLoads from the locations in a PureSpillFrame unless something must have stored over them again first, we don't need to kill anything here.
Since there's only one legal extra inhabitant, it has to have the null pattern.
Since these are represented by a single byte in UTF8 (and will not be present in any multi-byte UTF8 representations), we can just switch on the value of the current byte.
Since these deltas potentially include memory allocated from another thread but deallocated on this one, it is possible for these nubmers to go negative.
Since these values are part of the hash, it should never be wrong.
Since they are already known to be definitely init, don't reprocess them.
Since they are both optional, it's really hard to express that there can be either ordering in the bison grammar.
Since they are captured, we need to pass them directly into the new specialized function.
Since they both have enough lower bound for their support, we know we can account for everything here.
Since this case is very rare, just punt on the whole trace so it gets interpreted.
Since this happens implicitly, we can't blame the client if it shuts down while we are trying to ping.
Since this is a global analysis, we need this to / cache information about different paths through the CFG.
Since this is may-information that makes analysis more conservative, the memory support bits should conceptually be or'd at merge points.
Since this is monotonic time, I assume the 52 bits of mantissa are enough in the double value.
Since this is our primary output, we need to specify the option here.
Since this is repeated in exif_process_IFD_TAG make it a notice here and make it a warning in the exif_process_IFD_TAG which is called elsewhere.
Since this sequence is directly in-line, rip-relative like this is more compact than loading a 64-bit immediate.
Since visit() does both of these things, we need to delay calling visit() until listAssignmentAssignElements below.
Since we are already initialized by initPredTopDown(), this has the effect of an intersection.
Since we are already initialized by initSuccBottomUp(), this has the effect of an intersection.
Since we are going to change the BB, add its successors and predecessors for re-processing.
Since we are not dead, make sure our parent is not dead.
Since we are overwriting, decref.
Since we can now execute the relocated code, its ok to start fixing these things now.
Since we can't call popm lower function here at the moment it seems sufficient.
Since we cannot "adjust back" diagnostics, we just return an empty set.
Since we canonicalized earlier, we know that if our retain has any uses, they were replaced already.
Since we didn't push a scope, the bound variables are live after this statement.
Since we do not / look through enums or classes, in the current type system it should not be / possible to have a cycle implying that a RPOT should be fine.
Since we don't add the type, also don't add the space after ':'.
Since we don't always alloc and dealloc a shared structure from the same thread it is possible that this can go negative when we are tracking jemalloc stats.
Since we don't care about the actual length, we can use this, which lets us ignore the string data a larger proportion of the time.
Since we don't know how big it is (i.e. how much data we should memcpy), we have no choice but to ask malloc to realloc for us.
Since we don't need the instrumenter, and all we actually need is the playground semantics visible to the user, like silencing the "expression resolves to an unused l-value" error, disable it.
Since we don't spill physical registers, and Vregs are SSA, a value's assigned slot never changes.
Since we had a declaration before, its linkage should be external, ensure that we have a compatible linkage for sanity.
Since we have no way of knowing the true length either, we'll bump up our buffer size to a reasonable size, just in case
Since we have two arrays, we need to manually tail allocate each of them, rather than relying on the flexible array trick.
Since we initialize our data structure by processing the loop nest bottom up, this should always give us the correct region for the level of the loop we are processing.
Since we just checked that res is either MethodFoundWithThis or MethodFoundNoThis, magicCall must be false.
Since we know all the locations accessed in this function, we can resize the bit vector to the appropriate size.
Since we know what the output type is, we can set it as the favored type of this expression.
Since we know where it is going, we don't have to give up on everything.
Since we only sink retains (we do not move any other / instructions) which themselves are NOT MayDecrement operations, and moving / retains can't turn non-decrement instruction MayDecrement.
Since we only support ISO-8859-1 or UTF8 right now, and they use the same mapping array, use it.
Since we only typecheck the primary file (plus referenced constructs from other files), any error is likely to break SIL generation.
Since we process the loop tree bottom up they are guaranteed to be available in the map.
Since we return to the entry of the function, reset the location.
Since we successfully processed at least one function, return true.
Since we unwrapped constraints before, add this constraint.
Since we'll be choosing the same overload, we can merge the overload tyvar as well.
Since we'll be collapsing this call site, make sure there's another call site that will actually perform the invocation.
Since we'll either stop when we get out of whatever is driving this resumable, or we'll stop when we get back into it, we know the object will remain alive.
Since we're exposing an element of a Vector in an read/write context, we need to sever any buffer sharing that might be going on.
Since we're going to keep these settings for the lifetime of the program, we need to make them static.
Since we're just going to forward our args directly to the initializer, don't allocate local variables for them.
Since we're merging argument constraints, make sure that the representative tyvar is properly bound to the argument type.
Since we're moving FuncRef up, this must be the only call to it in the block.
Since x is captured by-ref by the closure, x must live on the heap.
Single character pattern matching should be simple and fast.
Single code point matching.
Single entry, single exit (aside from exceptions).
Single or empty values.
Single-element labeled tuples are not permitted, either.
Single-element store results in repetition.
Single-parameter methods.
SingleBufferInitializations always have an address.
Singleton inlining optimization.
Singleton metatype values are empty.
Sink it down into type resolution when it is actually needed.
Sink one of the copies of the instruction.
Sink one of the instructions to BB
Sink retain_value, release_value before select_enum to be retain_value, / release_value on the payload of the switch_enum in the destination BBs.
Sink retain_value, release_value before switch_enum to be retain_value, / release_value on the payload of the switch_enum in the destination BBs.
Sink the fix_lifetime instruction.
Size of default input buffer.
Size of input buffer in bytes, not including room for EOB characters.
Size of the offsets array
Size of the stack at the previous Concat.
Sizeof always returns non-negative results.
Skip 'super.init' bit
Skip D-edges (edges that are dom-tree edges).
Skip QD entries, they're only used by dn_expand later on
Skip a leading 'k' in a 'kConstant' pattern
Skip a split backedge.
Skip a type suffix that can be dropped.
Skip abstract methods, if the method already exists in the class.
Skip all "// CHECK" lines.
Skip any leading whitespace at the beginning of a field unless the format suppresses this behavior.
Skip any type variables that are bound.
Skip any whitespace This is much faster than the isspace() function
Skip anything from an AST file.
Skip anything in a protocol extension.
Skip arguments where the name doesn't match.
Skip asserting the top of the stack if it just came immediately out of an 'obvious' instruction (see hasObviousStackOutput), or if this instruction ignoresStackInput.
Skip binding a TypedValue that's about to be destroyed and just destroy it now.
Skip by a closure capture list if present.
Skip checking for SIL.
Skip claimed arguments.
Skip comment markers at the beginning and at the end.
Skip components that have no unbound type variables.
Skip data --- used to skip over a potentially large amount of uninteresting data (such as an APPn marker).
Skip declarations in other files.
Skip declarations in other modules.
Skip declarations that are not accessible.
Skip declarations with an invalid 'override' attribute on them.
Skip defaulted-protocol constraints.
Skip deprecated or swift_name'd enumerators.
Skip down to the generic parameter list that houses the corresponding generic parameter.
Skip dst if we already generated a region starting at that SrcKey.
Skip fieldname to get to data
Skip files that don't use dependency analysis.
Skip fulfilled parameters.
Skip functions that are marked with the 'no import' tag.
Skip generated, internal methods.
Skip getters/setters.
Skip global init functions.
Skip gyb comments that are line number markers.
Skip if merged cluster would be bigger than the threshold.
Skip if no predCluster (predecessor w/ no samples), or if same as cluster, of it's frozen.
Skip if the probability of taking this arc is below the specified threshold.
Skip if we don't need to reify this protocol.
Skip immediates and defs.
Skip immediates and uses.
Skip implicit conversions completely.
Skip incrementing the color count so that the dither / matching phase won't use it on pixels that shouldn't have been transparent.
Skip initializer contexts, we will not find any declarations there.
Skip instructions that don't have side-effects.
Skip invalid declarations and ourselves.
Skip invalid declarations.
Skip invalid superclass initializers.
Skip leading whitespace
Skip leading whitespace.
Skip local successors.
Skip malformed unreachable blocks that can appear transiently.
Skip materializeForSet -- it won't be used with a dynamic property.
Skip most significant byte
Skip nested types bound to concrete types.
Skip non-apply instructions.
Skip non-named declarations.
Skip non-type members.
Skip non-uppercase letters.
Skip operator requirements, because they match globally and  therefore tend to cause deduction mismatches.
Skip out of order non-token nodes.
Skip outer potential archetypes.
Skip over "safe" and "unsafe" if present.
Skip over 'type's in the context stack.
Skip over ASCII art, if present.
Skip over LBox (Which includes both TBox and LBox itself
Skip over a leading backslash
Skip over a parenthesized argument, if present.
Skip over any claimed arguments.
Skip over any uppercase letters at the beginning of the word.
Skip over empty parent contexts.
Skip over escaped characters.
Skip over inout expressions.
Skip over quote character in string literal.
Skip over random instructions that don't touch memory in the caller.
Skip over random instructions that don't touch memory.
Skip over same-type requirements.
Skip over the implicit 'self'.
Skip over the losing solutions.
Skip over the prefix.
Skip over the value of the global, embedded in mergeableData
Skip over trailing closures.
Skip over trailing slash to the next segment
Skip parameters that are defaulted to source location or other caller context information.
Skip parameters that were introduced by outer generic function signatures.
Skip parameters, since we do not gracefully handle nested declarations on a single line.
Skip past any leading X.
Skip past the node directly at the specified location, allowing the caller to effectively replace it.
Skip past the stuff we saved for the intercept case.
Skip past unrelated retains.
Skip pattern bindings that consist of just one computed variable.
Skip pattern-globally ignored opcodes.
Skip potential zero-extend if we know the value.
Skip presumed whitespace.
Skip property freeing for the following types
Skip spaces and tabs, but other whitespace (such as comments or newlines) stop the skip.
Skip stored variables, unless they came from a Clang module.
Skip struct and tuple address projections.
Skip the 'self' parameter.
Skip the case where we find the select_enum element
Skip the check for UnreachableInst, if explicitly asked to do so.
Skip the decl if it cannot have a comment.
Skip the decl if it does not have a comment.
Skip the decl if it's not visible to clients.
Skip the entry for the simple name so that we report each declaration once.
Skip the first 3 bytes to emulate the file type examination
Skip the foreign-error parameter.
Skip the generic parameter's context entirely.
Skip the implementations of all local declarations...
Skip the initial m_handledCount - 1 handlers that were considered before.
Skip the internal closure "0Closure" variable
Skip the last two checks.
Skip the next same-type constraint.
Skip the overflow check here because the int will be small.
Skip the overflow check here because the section name will be small-ish.
Skip the rest of the file to prevent the parser from constructing the AST for it.
Skip the self types parameter entirely.
Skip the synthesized 'self' input type of the opened type.
Skip the translation of this instruction (the FPush) -and- the next instruction (the FCall) if singleton inlining succeeds.
Skip the whole debug section.
Skip this block if its profile weight is less than the number of times the loop is invoked, since otherwise we're likely to executed the instruction more by hoisting it out of the loop.
Skip this declaration, because we prefer the overridden method.
Skip this designated initializer if it's in an extension.
Skip through optional evaluations and binds.
Skip tid if its weight is below the JitPGOMinBlockPercent percentage of the weight of the block where this region started.
Skip to next top-level test
Skip to the parent of a nominal type.
Skip trailing inherited conformances.
Skip trivial children.
Skip tvCoerceParamTo*() call if we're already the right type
Skip type aliases, which are just shortcuts down the tree.
Skip type aliases, which are just shortcuts.
Skip type decls if they aren't visible, or any type that has a witness.
Skip type variables in dead components.
Skip unavailable requirements.
Skip unavailable superclass initializers.
Skip unfulfilled parameters.
Skip unimplemented method.
Skip uninteresting type arguments.
Skip unknown arguments.
Skip unnamed elements.
Skip unreachable blocks.
Skip until we get the start of another character.
Skip up to the module
Skip value requirements that have corresponding witnesses.
Skip white space and pick up leading +/- sign if any.
Skip whitespace backwards until we hit a newline.
Skip: 'e' encoding 'v' str.
Skips leading underscores in either name, and skips a repeated word at the boundary.
Skips leading underscores.
Skips whitespace (including newlines and comments).
Skips whitespace, then populates name with valid extname characters.
Skips whitespace, then populates word with valid bareword characters.
Slam that information directly into the generic arguments buffer.
Slice off the NecessaryBindings struct at the beginning, if it's there.
Slice the spare bit vector.
Slight hack: see comments in hphp.y
Slightly larger than formatlen
Slots may be null, which should be ignored.
Slow path when length is large enough to need the real CapCode encoding.
Slow path: unblock all parents, and return to the scheduler.
Slow path: unblock all parents, then return.
Slower case: we have to load the src address from the targetcache
SmallVector::emplace_back will never need to call this because we reserve the right size, but it does try statically.
Smaller HealthLevel indicates better health condition, under which this function returns a bigger number.
Smaller, self-destribing enums
Smallest period allowed is per minute.
Smash callers of the old prologue with the address of the new one.
Smash the type and member names together so we can continue using StringMap.
Smashable movs and jmps are two instructions plus inline 64-bit data, so they need to be 8-byte aligned.
SnapshotBuilder is not (yet) thread-safe.
Sneak into the module and get all of the local type decls
So I put a right shift to loose the lsb.
So Java will handle the translated exception, fall through and return a good version number.
So a stored variable should still have getter/setter USRs (pointing to the variable declaration), and an addressed variable should have its "getter" point at the addressor.
So all we need to do here is set the name
So assume that it does.
So before we leave, update the marker to placate EndCatch assertions, which is trying to detect failure to do this properly.
So bottom up for such a parameter, we are always known safe.
So check if we can't keep the value.
So convert it to a number if it's a number or bool or null and to a string if it's anything else except arrays .
So convert the EOB_ACT_LAST_MATCH to EOB_ACT_END_OF_FILE.
So define(FOO, 'bar') is equivalent to define('FOO', 'bar').
So don't go around using the translation-time values of vmfp()/vmsp(), since they have an unpredictable relationship to the source.
So dont do anything if m_stack.top() is NULL
So fast path is never reached in that case (e.g. when debugging).
So for any string here we can assume it promoted to an empty array.
So for now we just put it in both places.
So going through them lets stores be as bad as if the address would escape.
So here we check if a username and password are used.
So if emitOrDeleteBlock ever learns to just continue in the predecessor, we'll need to suppress that here.
So if we have a scalar or a different sort of aggregate, bail.
So in both cases we actually want to DecRef the *old* value, so we have to restore it here (because realize_param replaced it with the new value).
So in cases where we don't know the key statically we need to union TInitNull into the result.
So in order to make sure we can eliminate the SpillFrame, we do the CallBuiltin instruction after we've left the inlined frame.
So in this case we leave the lower bound alone, and also must not remove the bit.
So in this implementation, property_value is implemented as property_get
So instead we always store as i8* and require the bitcast whenever we change representations.
So it makes sense to stay packed.
So it must be BLOCKED on something.
So it's fine for the .sil to shadow it, since that's the one we want.
So it's safe to just bump the refcount back up here, and pretend like nothing ever happened.
So its callee signature will be the same as its return signature.
So just account the length of our function scope in to the length of the CallerWeight.
So just fail hard here.
So let's decompress it.
So let's issue the cache request ASAP.
So let's temporarily set our context to Handled so the catch body is allowed to throw.
So lval() is appropriate here, to force escalation of APCLocalArray to MixedArray.
So now let's actually ask for compressed data this time.
So only ignore global private decls.
So our catch blocks are sometimes handling a PHP exception, and sometimes a failure to coerce.
So pushing a state here evens the stacks.
So remove Bar() to re-balance the stack.
So skip over any of those.
So someone has invalidated the LoopAnalysis structure by changing the CFG before calling this function, which isn't ok.
So that the optimization has a positive effect.
So that this iterator / can be used in the SSAUpdaterImpl.
So that we can raise strict warnings for mismatched params in FCallBuiltin
So that we ignore them for upcoming checked_cast_br instructions.
So the base is an rvalue type.
So the phonome SCI invades both S and C.
So there is only one possible function.
So this should be fast.
So use a stublogue and "convert" it manually later.
So we *could* have a loadable payload resulting from the TEDAI without the TEDAI being loadable itself.
So we are tranferring these flags just for better modularization between FileScope and VariableTable.
So we can gdFree it with impunity.
So we can insert a load in the pre-header that defines a Gen, and replace the load at the position in the loop with an AssertType.
So we can read anything anywhere on the eval stack above the call's entry depth here.
So we can sync sp and fp by ourselves here.
So we can treat them as not aliasing for the / purpose of bound checking.
So we cannot safely invoke alloca (N) if N exceeds 4096.
So we disable usage of interned strings as hash keys especually for this table.
So we do not return on a failure case.
So we do nothing here and are at the mercy of Dr.
So we don't know for sure if return hook should be called.
So we don't need to try to deserialize anything or handle the case that sval.data is file-backed.
So we don't want to include the Uninit (which isn't really a user-visible type for the property) or by the time we union things in we'll have inferred nothing much.
So we find the caller's FP, compensate for its locals and iterators, and then we've found the base of the generator's stack.
So we follow the link again.
So we force to serialize it as 13 bit unsigned int instead.
So we have last-ditch exception handlers in main.cpp that should catch everything, and in case _that_ fails, we replace the terminate handler with something that is guaranteed not to allocate memory.
So we have to create an array and then iterate over that.
So we have to say the call destroys locals, to be conservative.
So we just always give real seconds, which is "close enough".
So we just cause an stl alloc here.
So we just don't do it.
So we just merge the effects from all of them.
So we know they overlap.
So we make an exception here.
So we mark exiting blocks as visited by putting them in the BBMap.
So we move it into the zombie list.
So we move to the next II, SI.
So we need to IncRef here if it is being returned.
So we need to clear the timeout, wait (if necessary) for a pending signal to be handled, and then set the new timeout
So we need to know what we determined the last time we were alloewd to do that so we can return it again.
So we need to patch it to avoid ppc64el unsuported address modes.
So we need to the remember the addresses of the global ivar offsets.
So we only set GenericParamCaptures if we have a closure, or a non-generic function defined inside a local context.
So we only want to turn on profiling if collection is now needed.
So we overload the meaning of tl_doneAutoTypecheck to make sure that we don't enable auto-typechecking until systemlib is fully merged.
So we really need the copy.
So we return a SILDeclRef on the first lookup result and also / return all the lookup results.
So we steal one bit from the memory field to use as a flag.
So we throw it in a bump-allocator that's mprotect'd to prevent writes.
So we unique the exiting region list.
So we won't expand support for this feature to new compression types.
So we'll do the same.
So we'll ignore the error code.
So we're sending a KILL command to see if we can stop the query execution.
So what we do here is map the underlying types of those typealiases back to the builtin type.
So, a / store to an 2-field struct as mentioned above will generate 2 LSLocations / and 2 LSValues.
So, a scanner for T will be generated as well.
So, all that boils down to this: we ignore the extra args field (the unwinder will not consult the ExtraArgs field because it believes the ActRec is pre-live).
So, allocate a temporary one (containing the Zend resource pointer) and pass it into the destructor.
So, basically, we just need to undo the changes made by getTypeOfReference and then reapply them on the substituted type.
So, for a PureStore we can simply mark the location as no-longer providing memory support on the set it used to, but leave the lower bound alone.
So, for correctness in the presence of nested loops (natural or not), we need to start to refuse to hoist checks if we see a block where we haven't visited all of its predecessors yet.
So, for example, a type T can have an automatically generated scanner for some instances of T, but a conservative scanner for others depending on which type index the instance has.
So, for example, we may suggest wrapping a variable declaration in a guard, which would not be valid if the variable is later used.
So, if we store f and its staticness we can handle calls with and without this completely in assembly.
So, in order to infer the fully qualified name for any given class, the current scope is tracked as the DIEs are walked.
So, in the presence of magic methods, we must handle the fact that attempting to call an inaccessible method will instead call the magic method, if it exists.
So, it can be eliminated if the cell it pushes is used as either Use::Not or Use::UsedIfLastRef.
So, it is generally unsuitable for extensions that use handlers or extra data.
So, it is not guaranteed to be found in the thread-map.
So, it is safe to replace a class_method invocation by a direct call of this remaining implementation.
So, looks like it's not cycle, but the word I started typing first.
So, perform an alloc_ref_dynamic and pass that along to the initializer.
So, resume execution in the TC at a stub that will throw the execution from a safe place.
So, substitutions from AI are for class B.
So, the approach used is to take the given day number and round it to the closest molad of Tishri (first new moon of the year).
So, the first molad was 5 hours 793 halakim after the start of Tishri 1, 0001 (which was Monday September 7, 4761 B.C.
So, we make it const here to make sure we don't misuse it.
So, we may have an assertion on the type of the top of the stack after this instruction.
So, we need to load the superclass metadata dynamically.
So, we need to save these values for later.
So, we rebind it here, to match what invokeFunc will expect.
So, we strip out all prefixes and detect the bases ourselves.
So, we'll check for and handle both cases.
So, with bind/bindTo, if we are trying to bind an instance to a static closure, we just raise a warning and continue on.
Soft extended type hints raise warnings instead of recoverable errors, to ease migration.
Software written by Ian F.
Solve for this component.
Solve the dataflow problem.
Some IRGen-generated helper functions don't have a corresponding SIL function, hence the dyn_cast.
Some analysis we need.
Some asserts and tracing.
Some basic canonicalization and maybe.
Some builtin and structural types have value witnesses exported from the runtime.
Some builtin functions modify locals, read the varenv, or inspect the caller frame (e.g. for the value of m_thisOrClass).
Some byte codes, such as for the implicit "return 0" at the end of a a source file do not have valid source locations.
Some callers have caused the server to start executing more PHP, so update the machine/client state accordingly.
Some cases might get assigned state numbers but not actually occur in the try block.
Some classes in hhvm can be "enums", which we need to handle as non-object types.
Some clients of SILCloner copy over the original function's debug scope.
Some cmds require us to interpret all instructions until the cmd completes.
Some constant users may indirectly cause folding of their users.
Some constants / are also defined in ShortestPathAnalysis.
Some countries did not accept it until much later.
Some data, like the values of __CLASS__ and friends, are not available while we're still in the initial parse phase.
Some day we will do some high level analysis of uninitialized variables (rdar://15157729) but until then, output a specialized error.
Some existentials use special containers.
Some extra esoteric options that aren't exposed in --help for now.
Some fixes need more information from the locator.
Some general concepts:  - "Scanner".
Some imported expressions don't have types, even in checked mode.
Some inputs can cause us to allocate gigantic arrays, so we have to make sure we're not exceeding the memory limit.
Some instructions can cause PHP to be invoked without an explicit call.
Some instructions can never be "trivially dead" due to side effects or producing a void value.
Some instructions don't have direct memory side effects but can't be sunk because of other reasons.
Some invariants about Closure classes.
Some kinds of expression don't really evaluate their subexpression, so we don't need to traverse.
Some known optimizations are not included to reduce source code size and avoid compile-time configuration.
Some literal kinds are related.
Some llvm intrinsics don't like phi nodes as their constant inputs (e.g ctlz).
Some may read or write to that pointer while some only read.
Some methods are forced to be statically dispatched.
Some modules don't specify a triple, and this is okay.
Some nullable parameters default to 'nil'.
Some of the closure locals are mapped to used variables or static locals.
Some of them may end up getting default-initialized, but regardless, we need to make space for them on the stack.
Some of these are derived IVs like i+1 or i*4, which we will eventually want to handle.
Some of these relationships may change as async/await implementation progresses.
Some opcodes like Await may change state of the async function just before exit hook decides to throw C++ exception.
Some other platform...
Some other simple field, including "returns" (see SimpleFields.def)
Some properties may need to be marked with the AttrDeepInit attribute, while other properties should not be marked with this attrbiute.
Some reads could raise warnings and run arbitrary code.
Some remaining known issues that aren't supported here (or in conjunction with as.cpp):  - .line/.srcpos directives  - Static locals.
Some server commands pre-formatted texts with color for clients.
Some special cases that also clobber flags:
Some stack locations.
Some stuff related to Array and Function type is missing.
Some systems don't have the BFD_DECOMPRESS flag
Some test cases with optional wait handles.
Some that touch memory we might care about later, but currently don't:
Some things that dereference certain kinds of pointers (e.g. LdObjClass) can probably be in the list too.
Some type was specified, might be simple or complicated
Some unique global pointers.
Some unknown function.
Some unknown terminator instruction.
Some values that were refcounted may become non-refcounted after conversions, and we can't DecRef things twice.
Some vasm opcodes don't have equivalent single instructions on ARM, and the equivalent instruction sequences require scratch registers.
Somehow, we managed not to find a return value.
Someone beat us to it.
Someone called stop before we got here.
Someone created it between our check above and getting the write lease.
Someone else already smashed this one.
Someone else may have changed the func prologue while we waited for the write lease, so read it again.
Someone else pulled in new conformances while we were waiting.
Something else is wrong.
Something got resolved, so loop again.
Something is wrong with the connection, we need to remove this from our list
Something like "init(foo: ())" A throwing method has an error parameter.
Something we depend on still isn't resolved, try another
Sometimes GCC and Clang will emit invalid function addresses.
Sometimes a paren is just a paren.
Sometimes a scalar type gets applied to a single-argument parameter list.
Sometimes acoldStart is the same as afrozenStart.
Sometimes calls to builtin functions are inlined so that the call itself can occur via CallBuiltin rather than NativeImpl.
Sometimes code in irgen asks for a value with DataTypeSpecific but can tolerate a less specific value.
Sometimes curried method parameter lists get default arg info.
Sometimes function resolution can't determine which function something will call, but can restrict it to a family of functions.
Sometimes in the stdlib due to hand offs, we will see code like:
Sometimes libbz2 will return fewer bytes than requested, and set bzerror to BZ_STREAM_END, but it's not actually EOF, and you can keep reading from the file - so, only set EOF after a failed read.
Sometimes we have handlers in generated code, i.e., Continuation::next.
Sometimes we lose too much track of what's going on to do anything useful.
Sometimes, target is a part of "parent", for instance, "#else" is a part / of an ifconfigstmt, so that ifconfigstmt is not really the parent of "#else".
Somewhat cargo-culted from QDisabledNetworkReply.
Soon we'll add alpha channel to palettes
Sorry, MArrayIter only goes forwards
Sort N1 after N2 if N1 is complete and N2 is not.
Sort Swift declarations so that we print them in a consistent order.
Sort all functions by their profile count, and set AttrHot to the top Eval.HotFuncCount functions.
Sort all of the subgroups first, and fill in the bucket for each result.
Sort and print the top translations.
Sort and unique the insert points so we can put them into ImmutablePointerSets.
Sort blocks in reverse postorder, and try to arrange fall-through blocks in the same area to be close together.
Sort blocks such that all predecessors of B come before B, except loop-edge predecessors.
Sort by SILValue ID+Subindex. To make the output somehow consistent with the output of the function's SIL.
Sort by enumeration number so that clients get a stable order.
Sort callback for sorting entries by "strength" (basically length)
Sort entries by increasing hotness before priming.
Sort enum into payload and no-payload cases.
Sort first by filter name (case-insensitive).
Sort first by filter name (case-sensitive).
Sort for deterministic import.
Sort handlers by priority so that lower priority values get shutdown first
Sort imported declarations in source order *within a submodule*.
Sort imported declarations in source order.
Sort it and fill in parent info
Sort modules by name.
Sort nameCache, and then transform Results to return the pointers in order.
Sort out the requirements.
Sort specified array.
Sort the Objective-C selectors so we emit them in a stable order.
Sort the callees for each decl and remove duplicates.
Sort the combined samples, then copy the top hits back into `l'.
Sort the conflict declarations.
Sort the constraints into buckets based on component number.
Sort the diagnostics by their address in the memory buffer as the primary key.
Sort the entries by input order.
Sort the fixits by their start location.
Sort the indices and unique them.
Sort the list of class vtables so the largest ones come first.
Sort the list of interfaces so the biggest conflict sets come first.
Sort the m_blocks vector in reverse post order.
Sort the methods by declaration order.
Sort the module names so we can print in a deterministic order.
Sort the predictions by location, so that we can simply compare the type-prediction vectors for different blocks later.
Sort the protocol set.
Sort the protocols by their mangled names.
Sort the protocols in canonical order.
Sort the protocols so that we get a deterministic ordering.
Sort the same-types by LHS, then by RHS.
Sort the set of conflicts so we get a deterministic order for diagnostics.
Sort the set of local unsatisfied requirements, so we get a deterministic order for diagnostics.
Sort the set of protocols by module + name, to give a stable ordering.
Sort the summary table.
Sort the types in the set.
Sort the worklist so that complete items are first.
Sort them and make them unique.
Sort these subclasses in the order they should be tested by the speculative devirtualization.
Sort true before false instead of alphabetically.
SortALlowedDirectories might add something and remove duplicates.
Sorts the regions vector in a linear order to be used for translation.
Source and target type sizes are the same.
Source can be null, in which case this will be the only / thing done.
Source inputs always need to be compiled.
Source is foreign, so do the representation change first.
Source is native, so we can convert signature first.
Source type is always smaller than the target type.
SourceRoot has been default to: Process::GetCurrentDirectory() + '/'
Space for the eventually created colormap is stashed here
Space wasted by alignment is tracked in these maps.
Spare bit information is not available at runtime, so spare bits can only be used if all payload types are fixed-size in all resilience domains.
Spawn a thread to call it and callback when it's done.
Special action meaning "start processing a new file".
Special case - empty array
Special case - empty object
Special case -- any class-bound protocol can be passed as an AnyObject argument.
Special case builtins because they are meaningless to the user
Special case for "unistd.h", since it is non-ANSI.
Special case for FPass* instructions.
Special case for NSZone*, which has its own Swift wrapper.
Special case for PHP4 Backward Compatibility
Special case for Protocol, which gets forward-declared as an ObjC class which is hidden in modern Objective-C runtimes.
Special case for a single-character break as it needs no additional storage space
Special case for accessors, which inherit the access of their storage.
Special case for resource since VariableSerializer does not take care of it
Special case for specifying no fixits should appear.
Special case for superclass method calls.
Special case for when the property is known to be an int.
Special case of some common conversions involving Swift.String indexes, catching cases where people attempt to index them with an integer.
Special case the "conversion to void" case.
Special case the top-level pseudo-main.
Special case where no modulus is required
Special case: "Index" in the name matches "Int" or "Integer" in the type.
Special case: "Indexes" and "Indices" in the name match "IndexSet" in the type.
Special case: "ObjectValue" in the name matches "Object" in the type.
Special case: Mutable can appear in both and may screw up word order.
Special case: We need to create an empty first parameter for our argument label
Special case: an empty string should continue to be an empty string.
Special case: arm64 defaults to the "cyclone" CPU for Darwin, but Clang only detects this if we use -arch.
Special case: if it is a 0-to-count loop, we know that the count cannot be negative.
Special case: if the word in the name ends in 's', and we have a collection element type, see if this is a plural.
Special case: the base type of an overloading binding.
Special case: we are overriding a 'required' initializer, so we need (only) the 'required' keyword.
Special cases for 'callable': Hack typechecker throws a naming error (unbound name), however, hhvm still supports this type hint to be compatible with php.
Special cases, optimized implementations
Special cases: +0 and -0
Special cases: - "connect" isn't supported by the URL parsing - "readPreferenceTags" is an array of tagsets we need to iterate over
Special diagnostic for classes.
Special diagnostic for enums.
Special diagnostic for protocols and protocol compositions.
Special diagnostic for structs.
Special diagnostic for tuples.
Special handling for associated types.
Special handling for yields from generators and awaits from async.
Special handling of class SoapVar
Special handling of subjectAltName, see CVE-2013-4073 Christian Heimes
Special headers that are not prefixed with HTTP_
Special internal orderings.
Special long value case for SIG_DFL and SIG_IGN
Special magic to handle inout exprs and tuples in argument lists.
Special mangling for the first generic param.
Special options parameters, invalid for URL parsing - only possiblity is 'connect' for now
Special pattern: constants of the form "kFooBarBaz", extend "FooBar" with property "Baz"
Special properties like the Memoize cache should be set to their default value, not the current value.
Special-case AnyObject, which may not be in the list of conformances.
Special-case backslash for line continuations in the REPL.
Special-case diagnostics with no location.
Special-case dynamic packing in order to thread the jumps.
Special-case for SIL generic parameter decls, which don't have a real DeclContext.
Special-case some logic around emitting assert(), or jumping around it.
Special-case the Swift frontend.
Special-case the empty string.
Special-case the various types we might see here.
Special-case writing to stdout.
Special-case: there's nothing to store.
Special-case: tuples containing inouts.
Specialcase when we are warning about unreachable code after a call to a noreturn function.
Specialization Statistics
Specialization may be able to eliminate it later, or we'll lower it away at IRGen time.
Specializations are below.
Specializations have shared linkage, which means they do not have an external entry point, Since the callee is not fragile we cannot serialize the body of the specialized callee either.
Specializations of private symbols should remain so.
Specializations of public or hidden symbols can be shared by all TUs that specialize the definition.
Specialize a partial_apply by promoting the parameters indicated by / indices.
Specialize calls to generic functions by substituting static type information.
Specialize going bottom-up.
Specialize the Load left on the main trace after cloning the generic version to the exit---give it the type the old CheckType would've produced.
Specialize the generic method.
Specialize the given column to the given array of new columns.
Specialize the identified loop nest based on the 'array.props' calls.
Specialize the inherited conformance, if necessary.
Specialized emitter for Builtin.addressof.
Specialized emitter for Builtin.bridgeFromRawPointer.
Specialized emitter for Builtin.bridgeToRawPointer.
Specialized emitter for Builtin.castFromNativeObject.
Specialized emitter for Builtin.castFromUnknownObject.
Specialized emitter for Builtin.castReference.
Specialized emitter for Builtin.castReferenceFromBridgeObject.
Specialized emitter for Builtin.castToBridgeObject.
Specialized emitter for Builtin.castToNativeObject.
Specialized emitter for Builtin.castToUnknownObject.
Specialized emitter for Builtin.condfail.
Specialized emitter for Builtin.destroy.
Specialized emitter for Builtin.fixLifetime.
Specialized emitter for Builtin.gep.
Specialized emitter for Builtin.load and Builtin.take.
Specialized emitter for Builtin.reinterpretCast.
Specialized emitter for type traits.
Specialized test cases need some SSATmp*'s and similar things, so let's make some instructions.
Specializes a generic function for a concrete type list.
Specially handle checking if an uninit var's type is null.
Specific checking for methods.
Specifically imagine this:
Specifically keep track of Objective-C initializers, which can come from either init methods or factory methods.
Specifically skipped/avoided
Specifically, check to see there is whitespace before and after the end of range.
Specifically, removes the calls to Builtin.staticReport(), which are not needed post SIL.
Specs dictate that they are both type XML_DOCUMENT_TYPE_NODE
Speculate the targets of virtual calls by assuming that the requested / class is at the bottom of the class hierarchy.
Speculate virtual call targets.
Speculatively devirtualizes witness- and class-method calls into direct calls.
Spill `ivl' from its start until its first register use.
Spill space allocation.
Spill space is allocated right before it's needed and freed before any instruction that exits the unit, which is any block-ending instruction with no successors in the unit.
Spill space is needed and must be allocated at or before this point.
SpillFrame's spOffset is to the bottom of where it will store the ActRec, but AliasClass needs an offset to the highest cell it will store.
SpillState is used by allocateSpillSpace() to decide where to allocate/free spill space.
SpillStates is used to hold in/out state for each block after the analysis pass of allocateSpillSpace().
Spills, reg-reg moves, and loads of constant values or spill space all occur between instruction.
Spin here and wait for the client to be marked as stopped before going back to the event loop.
Splice it out of the chain.
Splice together the parts before and after the matched type.
Split `ivl' at `cur_start' and spill the second part.
Split a hash back into its constituent parts
Split all critical edges from all or non only cond_br terminators.
Split all critical edges from non cond_br terminators.
Split all critical edges in the function updating the dominator tree and / loop information (if they are not set to null).
Split all critical edges such that we can move code onto edges.
Split all critical edges.
Split and spill any inactive intervals after `cur_start' if they intersect with `current'.
Split and spill other active intervals after `cur_start'.
Split any critical edges in between exiting block and succ iter.
Split at the first occurrence of "Mutable".
Split critical edges from the lifetime region to not yet handled frontier blocks.
Split critical edges resulting from VirtAI.
Split every edge between two basic blocks.
Split into before and after ranges.
Split of a new empty preheader.
Split positions must be after an interval's start position, and on or before the chosen split point.
Split tail into preallocations and store them back into freelists.
Split the '+'-delimited addresses and resolve their associated symbols.
Split the base name after the last preposition, if there is one.
Split the base name from the parameters.
Split the base name, if it makes sense.
Split the case index into two pieces, the tag and tag index.
Split the edge from 'Dest' to 'ThreadedSuccessorBlock' it is now critical.
Split the header by ','
Split the module path.
Split the preheader before the first instruction.
Split the range 'current' into two halves: 'current' and 'otherHalf'.
Split the return block if it is nontrivial.
Split the text into context name and base name.
Split the token into two.
Split the version string into tokens separated by the '.' character.
Split up opaque operations (copy_addr, retain_value, etc.).
Split up operations on stack-allocated aggregates (struct, tuple).
Split up the call to prevent template explosion
Splits all critical edges from non cond_br terminators in a function.
Splits the basic block at the iterator with an unconditional branch and / updates the dominator tree and loop info.
Splits the critical edges between from and to.
Splits the critical edges in `unit', if any.
Splits the n-th critical edge from the terminator and updates dominance and / loop info if set.
Splitting critical edges should hoist BeginCatch for us.
Splitting this way might give us an empty string at the end
Sponsored in part by the Defense Advanced Research Projects Agency (DARPA) and Air Force Research Laboratory, Air Force Materiel Command, USAF, under agreement number F39502-99-1-0512.
Square output for digest
Squash important frontend options into a single argument for LLDB.
Squash the innermost concat stream if we consumed its concat result.
Src is not optional, but dest is optional.
SrcRec::newTranslation() makes this code reachable.
Stack containing all of the potential archetypes to visit.
Stack depth should be 0 after RetC or RetV.
Stack depth should be 0 at the end of a function body
Stack depth should be 0 when entering a DV init
Stack depth should be 0 when entering a catch block
Stack depth should be 0 when entering a fault funclet
Stack depth should be 1 after resume from suspend.
Stack of in-progress fpi regions.
Stack of input buffers.
Stack ranges, with subtype and maybe.
Stack result is a new string so we're responsible for decreffing value.
Stack these in tmp (autoboxed to int64_t) until we fill the GP regs, or we run out of args (in which case we'll pad them).
StackNode - contains all the needed information to create a stack for doing a depth first traversal of the tree.
Stacks slots are marked as being needed or not needed.
Stacktrace logging is controlled by xdebug.default_enable.
Standard allocator for Patterns.
Standard allocator for TypeReprs.
Standard config options
Standard message handlers
Standard says more types possible but skip them...
Standard substitutions shouldn't start with 's' (because that's reserved for the swift module itself) or a digit or '_'.
Start HHVM internal memory buckets
Start Of Scan (begins compressed data)
Start YYX at -YYN if negative to avoid negative indexes in YYCHECK.
Start a new IR block to hold the remainder of this block.
Start a scope for the current branch.
Start all the threads and do the LLVM compilation.
Start another mangled name.
Start at the beginning of the string
Start building a vtable if this is a class.
Start by adding a heap header.
Start by cloning functions from stdlib.
Start by decomposing the input types into sets of tuple elements.
Start by finding the decls for 'self' and 'value'.
Start by rerunning the query, to get a bitmask of exactly which elements are uninitialized.
Start by splitting the current block.
Start calculating non-fixed offsets from the end of the first fixed field.
Start calculating offsets from the last fixed-offset field.
Start computation of P byte sequence.
Start computation of S byte sequence.
Start from the elementwise-canonical signature.
Start inserting into that block.
Start layout by appending to a standard heap object header.
Start layout from the given instance start offset.
Start looking for fixup entries at the current (C++) frame.
Start of loop unrolling passes.
Start of option with offset
Start of segment to append while walking
Start of the next iteration.
Start our worklist with NewBase and Root.
Start out by classifying all the constraints.
Start over with our newly-populated cache.
Start processing TEST_SIZE number of requests at the same time with that many threads.
Start random number generator
Start recording argument names.
Start removing right after the opening parenthesis.
Start removing right after the preceding argument, so we consume the comma as well.
Start scanning backwards from the terminator.
Start script execution
Start the REPL's loop
Start the spare bit set using all the common spare bits.
Start the validating loop
Start tracing, then grab the current begin frame
Start tracking the read to this LSLocation in the killset and update the genset accordingly.
Start tracking this location and value.
Start tracking this location.
Start with .hdf and .ini files
Start with / folding the operations used by the standard library.
Start with a base benefit.
Start with an empty image information structure.
Start with any pending exception that might be on the thread.
Start with the correct parent FP so that VarEnv can properly exitFP().
Start with the fields we were given, if there are any.
Start with the global effects.
Start with the known type of the decl.
Start with the spare bit mask for all pointers.
Start with the substitutions from the apply.
Start with the time of the first molad after creation.
Start with transparent background.
Starting from BB, go back the control flow graph until we reach already handled blocks.
Starting from SearchRoot, finds the innermost node containing ChildRange / for which Predicate returns true.
Starting from currBC, find the next bytecode with a non-empty x86 range that could potentially correspond to instruction ip.
Starting from the current expression, count up if the expression is equal to its parent expression's base.
Starting from the innermost context that is not a type context, count all parent contexts that have generic parameters.
Starts profiling using the given profiler
Starts tracing using the given profiler
Stash a pointer to the VM Classes for stdclass, Exception, pinitSentinel and resource
Stash any releases that we see.
Stash the color map into the image
Stash this in the ASTContext for later emission.
StatCache::realpath() is based on the realpath(3) implementation that is part of FreeBSD's libc.
State for one entry on the FPI stack which corresponds to one call-site in progress.
State is uninitialized.
State numbers can be reused once all the references are released.
State structure for rc_analyze.
State transition from Mode::Shared to Mode::Flat.
State when we are within a quoted string
Statement Parsing and AST Building
States for each block, indexed by RPO id.
Static are alive for the lifetime of the process.
Static assertions are an implementation detail.
Static closure body: we still need to pass the object instance for the closure prologue to properly do its dispatch (and extract use vars).
Static computed property
Static definitions have a "specification" which basically links the definition to the declaration.
Static metatypes are unitary and can optimized to a "thin" empty representation if the type also appears as a static metatype in the original abstraction pattern.
Static properties don't need to exclude closures for this, though---we use instance properties for the closure 86static_* properties.
Static properties should never be Uninit.
Static properties use the metatype as their base.
Static property marker
Static stored property
Static strings used to identify certain special types in the debug info, which serve as markers for special actions.
Static/class declarations require an initializer unless in a protocol.
StaticArr/StaticStr may be promoted to CountedArr/CountedStr.
Statics Server session properties
Statistics for failure to infer
Statistics for why we couldn't infer in more specific ways, and fell back to methods
Stay consistent with the readline library
Stay here, stacked args
Stay within bounds of both yycheck and yytname.
Steady state, its probably already in the cache.
Steal the branch argument as the return value if present.
Steal the subscript values without copying them so that we can peek at them in diagnoseWritebackConflict.
Step 1: scan the whole module and build the dependency graph.
Step 2: propagate the flags through the dependency graph.
Step 3: replace get-property calls with literals.
Step doesn't care about this interrupt...
Step out of the current control flow to emit a foreign error block, / which loads from the error slot and jumps to the error slot.
Step out, but save the filter first, as it is cleared when we step out.
Step over PopR following a call
Step through the list of requirements in the generic type.
Stepping back twice (slow path).
Stepping forward to visit the remaining elements.
Steps over function calls.
Stick to a normal hhvm array for the wrapper
Sticking this into ASTContext isn't enough because then the DenseMap will leak.
Still have format specs, but no more args passed throw_wrong_arguments_nr check should guarantee that we're already past min args
Still, for the keys in file, a deserialization from memory is required on first access.
Stmt Attr Cursor type
Stolen directly out of the book...
Stop CPU timer so we won't time out twice.
Stop GCC from complaining about a noreturn function possibly returning.
Stop and destory this proxy.
Stop at an unescaped space or tab.
Stop at may interfere.
Stop here if we have nothing else to do.
Stop if this was the last box
Stop if we simplified away the tail of the block.
Stop merging at side-effects or reads from memory.
Stop on deallocation.
Stop the graceful shutdown timer
Stop the proxy and ensure that no new uses of it can occur.
Stop the proxy, and stop execution of the current request.
Stop the sandbox thread, and wait for it to end.
Stop the scan if we've reached the highest level of side effect.
Stop wall timer so we won't time out twice.
Stop when we hit a parameter at a different depth.
Stopping the VM is synchronous and all requests will run to completion, unless the alarm fires.
Store PHP source code for constant initializer.
Store Uninit to tvRef and tvRef2.
Store a clang argument expansion into a buffer.
Store a copy of the name so that we own the lifetime.
Store a copy of this value with independent ownership into the given / uninitialized address.
Store actual stack elements array in a thread-local in order to amortize the cost of allocation.
Store an index_addr projection.
Store an r-value into the given address as an initialization.
Store appropriate value inside the state local.
Store back to the cache variable.
Store file date/time.
Store first two pre-read bytes.
Store in the session.
Store info about the default value if there is one.
Store into the value.
Store it as properties too
Store it back to the cache variable.
Store it in our maps for later lookup.
Store it in the cache.
Store it into the result.
Store location information.
Store necessary bindings, if we have them.
Store nil to the foreign error slot.
Store off the sub-expression, in case a new one is provided via the type check operation.
Store pointer to the page for later cleanup
Store result into the AFWH object and unblock all parents.
Store slab tail bytes (if any) in freelists.
Store state in digest
Store subpat_names into the cache entry
Store that to the appropriate slot in the new witness table.
Store that we have modified the self argument.
Store the 'in' value.
Store the FPIEnt's index in the FuncEmitter's entry table.
Store the RefData but do not increment the refcount
Store the async function's return value to the AsyncFunctionWaitHandle.
Store the block header literal.
Store the compiled pattern and extra info in the cache.
Store the conformance and record the dependency.
Store the context arguments on the heap.
Store the context arguments.
Store the cpu frequency.
Store the current exception object in the appropriate local variable
Store the current stack depth
Store the data as the current value of this extension's ini setting.
Store the data pointer, if any, transferring the +1.
Store the direct result to the original result address.
Store the discriminator for the no-payload case.
Store the error to the foreign error slot.
Store the exception to the error slot.
Store the expr itself as a placeholder RHS.
Store the extra inhabitant.
Store the fetched result back to the cache.
Store the function constant and calling convention as a StaticFunction so we can avoid bitcasting or thunking if we don't need to.
Store the function pointer.
Store the function to the block without claiming it, so that it still gets cleaned up in scope.
Store the hash in the global variable so that it is written into the object file.
Store the important parts of the exception in non-thread vars to bubble up during unserialize
Store the instance pointer.
Store the max payload size in the metadata.
Store the metadata ref.
Store the name of the called function to the first param, then null it out on the ActRec.
Store the named value if we had a name.
Store the native error in the appropriate location and return.
Store the new direct parameter to the alloc_stack.
Store the new pointer.
Store the payload back.
Store the prefix length.
Store the protocol witness tables.
Store the receiver and class to the struct.
Store the reference into a temporary.
Store the reference to the runtime's idea of the protocol descriptor.
Store the result later.
Store the return value on the top of the eval stack.
Store the summary for parent loops to use.
Store the super.init expression within the constructor declaration to be emitted during SILGen.
Store the tag into the spare bits.
Store the type-protocol pair in the cache.
Store the value into element slot 0.
Store the witness table pointers.
Store this archetype builder.
Store this somewhere more appropriate.
Store this task's ReturnCode as our Result if we haven't stored anything yet.
Store to a temporary.
Store to the "pointee" property.
Store top-level binary exprs for further analysis.
Store untouched full datetimestamp
Store zero directly to the fixed-layout extra tag field.
Stored properties and variables can't be transparent.
Stored properties imported from Clang don't get accessors.
Stored properties in SIL mode don't get accessors.
Stored properties in protocols are converted to computed elsewhere.
Stored properties of reference types produce lvalues.
Stored properties will be initialized in a separate .cxx_construct method called by the Objective-C runtime.
Stored properties with tuple types are tracked with independent lifetimes for each of the tuple members.
Stored variables in Swift source will be picked up by the PatternBindingDecl.
Stores *to* the allocation are writes.
Stores - Keep track of all of the store instructions we see.
Stores either a this pointer or a Cctx -- statically unknown.
Stores our HDF-specified values (only integral values for now) across requests.
Stores parsed user/password/database to be copied to each server struct
Stores the key in a similar fashion as "priming" would do (no TTL limit).
Stores the set of Objective-C methods with a given selector within the / Objective-C method lookup table.
Stores to array elements.
Stores to self are initializations store or the rebind of self as part of the super.init call.
Stores which functions implement a vtable or witness table method.
Storing into the object can be ignored.
Storing the result into the AFWH overwrites contextIdx (they share a union), so it has to be done after the checks in the fast path (but before unblocking parents).
Strange things like "decltype(nullptr_t)"
Strdup S using the bump pointer.
Strdup StringRef S using the bump pointer.
Strdup a raw char array using the bump pointer.
Stream wrappers close themselves on sweep, so there's nothing to do here
Strength reduce destroy_addr inst into release/store if we have a non-address only type.
Strideof always returns non-negative results.
Strideof should never return 0, so return 1 if the type has a 0 stride.
StrideofNonZero always returns positive results.
String dir_rewinddir()
String interpolation.
String is converted successfuly
String is okay because it is bridged to NSString.
String literal conversion function to be used.
String literal symbolic flavor
String literals concatenation optimizer.
String name for the given error type, as defined by php5 xdebug in xdebug_var.c
String streams for writing to the CHUNKS and STRINGS sections.
String to match against
String wants a null, and dereferences one past the size we give it.
String'ify the arguments.
String'ify the parameter types.
StringData::capacity() returns the buffer size without the null terminator.
StringLiteralExpr is a weird case, implicitly generated by string literal expansion in Sema.
Strings are hash-commoned so presumably only one can be null per unit.
Strings are less than anything else (usually arrays).
Strings passed to libcurl as 'char *' arguments, are copied by the library...
Strip all chars not part of section 5 of http://www.faqs.org/rfcs/rfc1738.html
Strip an inner layer of potentially existential metatype.
Strip any leading space before an enclosure
Strip any upcasts off of our 'self' value, potentially leaving us with a value whose type is closer (in the class hierarchy) to the actual dynamic type.
Strip directory name from the file name.
Strip extraneous whitespace from vasm code strings.
Strip inout from 'self'.
Strip off a single level of uncurried function type.
Strip off any AutoClosures that were produced by a previous type check so that we don't choke in CSGen.
Strip off any casts on V1, V2.
Strip off any non-argument instructions from IV.
Strip off casts/indexing insts/address projections from V until there is / nothing left to strip.
Strip off lvalue/inout types.
Strip off one layer of application from the covariant result.
Strip off struct_extract_refs until we hit array address.
Strip off the extract.
Strip off the part of the name that is redundant with type information, so long as there's something preceding the preposition.
Strip off the part of the name that is redundant with type information.
Strip off the prefix.
Strip off the projection path from base to the accessed field.
Strip off the requirements of a generic function type.
Strip optional wrappers off of the destination type in sync with stripping them off the origin type.
Strip reference storage qualifiers like unowned and weak.
Strip slashes which came before the file name
Strip the "is function input" bits unless this is a type that knows about them.
Strip the 'ApplyFunction' off the locator.
Strip the MarkDependenceInst (new array implementation) where the above pattern looks like the following.
Strip the arguments and rewire the branch in the source block.
Strip the context type from the base name of a method.
Strip the file hash from the closure name.
Strip the last path component except when we have single "/".
Strip the last path component.
Strip the segment name.
Strip the struct load and the address projection to the location / holding the array struct.
Strip trailing slashes
Strip trailing space from buf, saving end of line in case required for enclosure field
Strips and stores the struct_extract projections leading to the array / storage reference.
Struct and enum constructors do everything in a single function.
Struct or enum type must have been bridged.
StructArrayProfile data counts how many times a non-struct array was observed.
StructDecl if we are visiting a struct.
Structs and enums imported from C *always* have a fixed layout.
Structs depend on their physical fields.
Structs do not alias non-structs.
Structural mismatches imply that the witness cannot match.
Structurally infinite loops like: bb1: br bb1 are not present in the post-dominator tree.
Structure to hold cache meta data Same definition in ext_apc.cpp
Structure to save state of computation between the single steps.
Stub QNetworkReply used when file:/// URLs are disabled.
Stub constructors don't get an entry.
Stub function ABI  The code below is Call-stub ABI compliant, not PPC64 ABI.
Subclass-to-superclass conversion.
Subclasses and extensions cannot do it.
Subclasses must override SILWitnessVisitor::visitAbstractStorageDecl() / to call addAbstractStorageDecl(), since we need the substitutions to / be passed down into addMethod().
Subclasses of this class, including this class itself (unless it is an interface).
Subintervals sorted by Interval start.
Submodules share lookup tables with their parents.
Subscript decls have function type.
Subscript setters and getters are named with the reserved word "subscript".
Subscripts and computed properties are ok on rvalues so long as the getter is nonmutating.
Subscripts are always instance members.
Subscripts can never have names.
Subscripts cannot be renamed, so handle them directly.
Subscripts of non-optional reference type that were imported from Objective-C.
Subscripts should probably be collected in extended metadata.
Subscripts use a specific selector.
Subsequent calls to ProxygenServer::stop() won't do anything.
Subsequent optimization passes will see the load and propagate the available values into it.
Substitute a context archetype if we have context generic params.
Substitute context parameters out of the "from" and "to" types.
Substitute in better common value witnesses if we have them.
Substitute in better value witnesses if we have them.
Substitute in our own 'self' parameter.
Substitute in the appropriate type for 'Self'.
Substitute into the parent type.
Substitute into the type.
Substitute into the witness function tye.
Substitute into the witness function type.
Substitute the 'Self' type into the requirement to get the concrete witness type, leaving the other generic parameters open.
Substitute the `Self` type from a protocol conformance into a protocol / requirement's type to get the type of the witness.
Substitute the base into the member's type.
Substitute the function type.
Substitute the replacement.
Substitute the requirement type into the conforming context.
Substitute the storage type into the conforming context.
Substitute the substitutions in the specialized conformance.
Substitute the type we're coming from as the base of the member type to produce the projected type result.
Substitute the variable and function names.
Substitute type parameters in the base type to get a fully concrete type.
Substituted types are uninteresting sugar that prevents the heuristics below from kicking in.
Substituting the parameter eliminates conformance constraints rooted in the parameter.
Substitution for the same archetype as in a previous argument.
Subtract a constant from a builtin integer value.
Subtract an uncurry level for captures, if any.
Subtract immediate move word to destiny and do not touch the higher 32bits
Subtract number of payload cases from the payload tag.
Subtract s_nextThreadIdx because if n threads start at the same time, one of their start times will be increased by n-1 (and we need to subtract 1 anyway, to deal with exact seconds).
Subtract the number of cases.
Subtract the old jemalloc adjustment (delta0) and add the current one (delta) to arrive at the new combined usage number.
Subtract truncated time from last_sample_tsc
Subtype conversions: - upcasts
Subtypes of the specified type.
Succeed trivially for an empty payload, or if the payload is masked out completely.
Succeeded thus far, check to see if anything went wrong while actually executing changes.
Success block: recurse.
Success means that we won't end up in the other branch, but failure doesn't.
Success must be at least as strong as failure.
Success, store the breakpoint and increment the id.
Successfully created the process.
Successfully scanned the body of the expression literal.
Such a load might be optimized away if inlined.
Such a reference must be retained until after the next iteration is complete.
Such a thunk is called a "re-abstraction thunk" -- the AST-level type of the function value does not change, only the manner in which parameters and results are passed.
Such allocations may missing their final release.
Such an edge "short-cuts" a loop if it is never iterated.
Such private decls may affect the data layout of a class/struct or the vtable layout of a class.
Sufficient space is allocated to the return value to hold the suppressed trailing zeros.
Suggest adding availability attributes.
Suggest inserting '.dynamicType' to construct another object of the same dynamic type.
Suggested captions: "before jiffy removal", "after goat saturation", etc.
Summary: - Horizontal filter contributions are calculated on the fly, as each column is mapped from src to dst image.
SunOS 5.x (command line)
SunOS 5.x (short name)
SunOS 5.x core files contain two PT_NOTE sections, with the types NT_PRPSINFO (old) and NT_PSINFO (new).
SunOS 5.x hardware capabilities
SunOS 5.x hardware capability descriptions
SunOS 5.x software capabilities
SunOS 5.x, 64-bit (command line)
SunOS 5.x, 64-bit (short name)
Super-Boxes can contain super-boxes which provides us with a hierarchical storage system.
Superclass requirement.
Superclass requirements aren't recorded in substitutions.
Superclass requirements.
Superficially verify that the input is a swift module file.
Supertypes of the specified type.
Support for collecting a set of generic requirements, both explicitly stated and inferred, and computing the archetypes and required witness tables from those requirements.
Support for multiple channels added (argb for now).
Support for systemlib functions implemented in PHP
Support for the stub freelist.
Support optional color output.
Suppress 'try' coverage checking within a single level of do/catch in debugger functions.
Suppress GenericMetadataBuilderBase's default behavior of introducing fill ops for generic arguments unless they belong directly to the target class and not its ancestors.
Suppress a deprecation warning if the availability checking machinery thinks the reference program location will not execute on any deployment target for the current platform.
Suppress all diagnostics when there's an un-analyzable throw site.
Suppress diagnostics about availability overrides for accessors if they would be redundant with other diagnostics.
Suppress diagnostics in the presence of errors.
Suppress diagnostics when in a fatal state, except for follow-on notes
Suppress the diagnostic if we are in synthesized code inside a synthesized function and the reference is lexically contained in a declaration that is itself marked unavailable.
Suppress the import of this method when the corresponding property is not suppressed.
Suppress unused-variable warnings by "using" E.
Suppress value names for values with opened existentials.
Suppress warnings about useless try or catch.
Surely this could be "shrinked", but it would probably look uglier.
Suspend the async function.
Suspending can go anywhere, and doesn't even kill locals.
Swallow any exceptions that escape the __destruct method
Swallow the exception.
Swallow this exception - we don't want to crash the app, an error is enough.
Swap L and R because equality is commutative.
Swap it out for the full version if possible.
Swap operands if the dest is s0.
Swap our destinations.
Swap the literals with the next few results.
Swift Enums can be both like DWARF enums and discriminated unions.
Swift Varargs are not representable in Objective-C.
Swift classes are objects in and of themselves.
Swift code already handles this, but we need to insert it for clang doc comments when not printing other clang comments.
Swift designated initializers are Objective-C designated initializers.
Swift does not permit class methods with Objective-C selectors 'load', 'alloc', or 'allocWithZone:'.
Swift doesn't have write-only subscripting.
Swift enums require that the raw type is convertible from one of the primitive literal protocols.
Swift extensions are printed with their associated type unless it's a cross-module extension.
Swift function types are formally functions that take the class and return the method, we have to strip off the first level of function call to compare against the type from the demangled name.
Swift intrinsic names start with int_.
Swift native classes never have a tagged-pointer representation.
Swift restriction: init methods must start with the word "init".
Swift runtime functions in support of enums.
Swift runtime functions in support of lazy initialization.
Swift supports three representations of functions:
Swift will preserve any / data stored into this arbitrarily sized and aligned field, but doesn't / know anything about the data.
Swift's closure model is that all local variables are capture by reference.
Swift.ImplicitlyUnwrappedOptional
Switch back to the original method and mark it as a memoize implementation
Switch on the incoming value.
Switch on the optional error.
Switch on the optional result.
Switch on the tag value.
Switch out nontrivial payloads.
Switch over the cases for this tag.
Switch over the extra inhabitant patterns we used.
Switch over the no-payload cases.
Switch over the tag bits for payload cases.
Switch the locale to IMAGICK_LC_NUMERIC_LOCALE if imagick.locale_fix is on
Switch this proxy to debug the given sandbox.
Switch through the rest of builtins.
Switch to a different input buffer.
Switch to a new external colormap between output passes.
Switch to a phplogue context to enter the catch.
Switch to the interpreter before even beginning the instruction.
SwitchProfile is variable-sized so we have to manually allocate it and pass the buffer to TargetProfile::data().
Switching on a singleton does not require a value.
Symbol of the custom scanner function which handles scanning base classes.
Symbol of the custom scanner function which handles the entire type.
Symbolic stack elements do not have corresponding values on the real eval stack at runtime, and represent things like local variable ids or literal ints and strings.
Symbolize frames under the assumption that they are defined in /proc/self/exe without relocation.
Sync VM regs for the TC frame represented by `context'.
Sync return regs before calling native assert function.
Sync the translator state.
Sync vmsp and the return regs.
Synchronously stop satellites
SyntaxSugarType derivations.
Synthesize -- remaining args...
Synthesize a call to _undefined() of appropriate type.
Synthesize accessors as necessary.
Synthesize accessors for lazy, all checking already been performed.
Synthesize accessors for the protocol witness table to use.
Synthesize and type-check the body of the getter.
Synthesize and type-check the body of the setter.
Synthesize availability attributes for protocol requirements / based on availability of the types mentioned in the requirements.
Synthesize identifier locations.
Synthesize materializeForSet in non-protocol contexts.
Synthesize the bodies of the property's accessors now, forwarding to the 'value' implementation.
Synthesize the body of a trivial getter.
Synthesize the body of a trivial setter.
Synthesize the getter body
Synthesize the getter for a lazy property with the specified storage / vardecl.
Synthesize the setter body
Synthesize trivial conformances for each of the protocols.
Synthesized are always after actual ones.
System classes override
System crypt() function
System functions override
System units are merge only, and everything is persistent.
System-wide ini settings -- PHP_INI_SYSTEM
Systemlib files were all parsed by hphp_process_init
Systemlib.php is not loaded again, so we need this if we are to hit any breakpoints in systemlib.
SystemlibSessionModule
SystemlibSessionModule implementations
T must be an Objective-C class or protocol.
T2 is the result type provided via the construction constraint itself.
TAG( output )  Output the given code.
TBAA requirement for all address arguments.
TBAA says that objects cannot be type punned.
TBB: move this up so include files are not brought in
TESTING  This algorithm has been tested from the year 4713 B.C.
TESTING  This algorithm has been tested from the year 4714 B.C.
TESTING  This algorithm has been tested in two ways.
THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
THERE IS NO WARRANTY - USE AT YOUR OWN RISK.
THIS FILE IS AUTOMATICALLY GENERATED.
THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED WARRANTY.
THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC.
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
THOUGHT:  It would be nice if, rather than having things like...
THREE(IVA,SA,SA),    FMANY,   ONE(CV)
THREE(IVA,SA,SA),    FMANY,   ONE(RV)
TIFF thumbnail: our data structure cannot store a thumbnail of a thumbnail
TIMELIB_UNSET (and other constants) defined in timelib.h (see hhvm-third-party)
TNull could be uninit
TODO #2821803: Figure out whether this is caused by another bug somewhere.
TODO (#3271358): New fault funclets might appear while emitting finally fault funclets.
TODO (#3271396) This can be greatly improved.
TODO (6512343): this needs to be hooked into scan methods for Extensions.
TODO (t7832883): DTRT when we have exception pointers
TODO - we should not get every data type as a SQL_C_CHAR, but cast to an appropriate type instead
TODO 6900503: consider making this thread-safe.
TODO Create the helper.
TODO Have loadSystemlib() or Native::registerBuiltinFunction track this for us so that we can support this here and in ReflectionExtesion
TODO Task #1970153: It would be great if there were set() methods that didn't bump up the refcount so that we didn't have to decrement it here
TODO Task #2661075: Here and elsewhere in the runtime, we convert Resources to the empty array during various serialization operations, which does not match Zend behavior.
TODO Task #4442937: Come up with a cleaner way to do this.
TODO The frontend will currently never emit copy_addr or destroy_addr for block storage.
TODO check for a "yamlSerialize()" instance method
TODO expose a function for base sig string
TODO figure out how to use compar
TODO fix folly to better detect error cases (currently I think it just aborts) and catch them here.
TODO handle conflict with FORM auth and anything but POST or PUT
TODO if you are clever you can make the macro do these
TODO look into merging oauth parameters if they occur in the current url
TODO make these PHP_INI_ALL and thread local once we use them
TODO may not always be all-ones
TODO refactor It grabs the write lease and iterates through whole SrcDB...
TODO request-local cache to avoid hashtable lookup
TODO t#6485898 - Remove uses of call time pass by reference
TODO(#1097182): Iterator verification disabled
TODO(#1273094): we should probably modify the actual builtins to return values via registers using the C ABI and do a reg-to-reg move.
TODO(#2044801): we should be doing this control flow at the IR level.
TODO(#2103214): Support persistent type aliases.
TODO(#2329497) can't handle_request_surprise() yet, unwinder unable to replace fault
TODO(#2329497) will not happen once CheckSurprise is used
TODO(#2458166): it might be a CufIter, but we're just lucky that the bit pattern for the CufIter is going to have a 0 in getIterType for now.
TODO(#2464197): Continuation bug in repo mode.
TODO(#2464197): dce breaks switch for verify
TODO(#2570852): we should really issue a warning here
TODO(#2606310): if we're removing the /last/ element, we probably could stay packed, but this needs to be verified.
TODO(#2884927): we probably need to be aware of possibly-integer-like string keys here before we can start using ElemS for anything.
TODO(#2913342): lookup the constant in RDS in case it's dynamic and already initialized.
TODO(#2973538): Move HHBC text generation to after all the units are created, and get rid of the LitstrTable locking, since it won't be needed in that case.
TODO(#3017265): UnitEmitter is very coupled to emitter.cpp, and expects classes and things to be added in an order that isn't quite clear.
TODO(#3029148) this could be InitCell
TODO(#3331014): We have this hack until more ARM codegen is working.
TODO(#3499765): we need to handle interfaces that the collection classes implement before we can ever return false here.
TODO(#3519401): when we start unfolding type aliases, we could look at whether it is an alias for a specific class here.
TODO(#3521039): we could just put the litstr table in the same blob as the above and delete LitstrRepoProxy.
TODO(#3577303): some of these could be nothrow, which is probably information we have want to propagate back out through the return value here (rather than bundling everything into the interpreter).
TODO(#3621433): better interface stuff
TODO(#3634984): Additionally, DefInlineFP is marking may-load on all the locals of the outer frame.
TODO(#3649211): we'll need to handle inheritance cycles here after hphpc is fixed not to just remove them.
TODO(#3653110): could nothrow if t2 can't be an Obj or Res
TODO(#3666699): function name case sensitivity here shouldn't break equality.
TODO(#3685260): this should not be removing interfaces from the base list.
TODO(#3696042): We don't have support for static properties with specialized array types in the minstr functions yet, so if we have one after 86sinit, throw it away.
TODO(#3696042): should be able to loosen_statics here.
TODO(#3696042): this same logic should be in loosen_statics.
TODO(#3696042): this should be modified to keep specialized array information, including whether the array is possibly empty.
TODO(#3696042): we could materialize a static array here if we check if a whole specialized array is constants, and if it can't be empty.
TODO(#3704) Clean this up-- this was taken from php5 xdebug
TODO(#3704) If we aren't profiling, we should try to save space by removing unneeded trace data
TODO(#3704) In php5 xdebug this function works even in cli mode.
TODO(#3704) Remove when xdebug fully implemented
TODO(#3704) Requires xdebug_debug_zval, just print to stdout
TODO(#3704) See xdebug_start_error_collection
TODO(#3704) Support collect_params output
TODO(#3704) This could be merged into the above array code.
TODO(#3704) This relies on xdebug_var_dump
TODO(#3704) This requires overriding the default behavior on exceptions/errors.
TODO(#3704) This requires var_dump
TODO(#3704) This requires var_dump, error handling, and stack trace printing
TODO(#3704) This requires var_dump.
TODO(#3704) see xdebug_start_error_collection()
TODO(#3732260): this should probably spend an extra interp pass in debug builds to check that no transformation to the bytecode was made that changes the block output state.
TODO(#3788877): more heuristics here would be useful.
TODO(#3875556): constant evaluate conversions when we can.
TODO(#3888164): we should make it so we don't need KindOfUninit checks
TODO(#3888164): we should restructure things so we don't have to check KindOfUninit here.
TODO(#4205897): option specialized array types
TODO(#4205897): optional array types.
TODO(#4205897): we need to use this before it's worth putting in the repo.
TODO(#4238160): Inlining into pseudomain callsites is still buggy.
TODO(#4323657): we should make this assertion for all non-empty blocks (exits in addition to catches).
TODO(#4441939): for this to be safe for the index invariants on return types, we need to be intersecting the types here.
TODO(#4441939): we can't do anything if it's a strict subtype of array because of the lack of intersection types.
TODO(#4557954) Make unwinder able to deal with new exceptions better.
TODO(#5372569): if we combine dv inits into the same regions we could possibly avoid storing KindOfUninits if we modify this.
TODO(#5623596): this optimization required for correctness in refcount opts right now.
TODO(#5703534): this is using a different TransContext than actual translation will use.
TODO(#5710324): it seems a little odd that region-tracelet is not part of irgen:: but needs access to this.
TODO(#5962341): These take non-constant offset arguments, and are currently only used for collections and class property inits, so we aren't hooked up yet.
TODO(#7728856): We should really move this into vasm-x64.cpp...
TODO(#7757602) this should be investigated.
TODO(#8908075): We've been fishing the m_savedRip out of the callee's logically-trashed frame for a while now, but we really ought to respect that the frame is freed and not touch it.
TODO(#8947159): Configure cumulative statistics during reset.
TODO(#8947159): Dynamically configure cumulative statistics rather than forcing the decision at startup.
TODO(#9876771): these should be cleaned up.
TODO(#9876778): we should be able to support CallArray here as well.
TODO(10152762): Run this concurrently with non-disk warmup.
TODO(4441939): We could do better if we had an intersect_of() function that provided a formal way to compute the intersection of two Types.
TODO(7657500): in the runtime, resolve this type to a class.
TODO(9604438): Protect against script does not exist
TODO(9755792): Add real execution mode for snapshot generation.
TODO(9755792): Ensure APCFileStorage is enabled.
TODO(9795696): Race in thread map may trigger spurious logging at thread exit, so for now, only spawn threads if we're a server.
TODO(9994180): Throw on error
TODO(T5601927): output_compression supports int values where the value represents the output buffer size.
TODO(cjhopman): this seems unsafe unless we require that it is only called on the main js queue.
TODO(dreiss): Make this timeout configurable.
TODO(gut) use Decoder, but for now, do it hardcoded
TODO(gut): move them to lower if rsp() manipulation is exclusively allowed in lea and not anymore in addqi and subqi
TODO(https://github.com/facebook/hhvm/issues/6040) Implement throwing from delegate generators.
TODO(stephentu): constants
TODO(stephentu): fix this hack
TODO(t2598894): We do this for consistency with the old guard relaxation code, but may change it in the future.
TODO(t7561579) until we can properly handle non-file streams here, don't pretend we can and crash.
TODO: "Nondependent witness table" probably deserves its own flag.
TODO: 'swift_context' IR attribute
TODO: 'swift_error' IR attribute
TODO: - Optimize pixel accesses and loops once we have continuous buffer - Add scale support for a portion only of an image (equivalent of copyresized/resampled)
TODO: - tuple literal projection, which may become interestingly idiomatic
TODO: A linear series of ifs is suboptimal.
TODO: A standard "copy strong array" entrypoint for arrays of single refcounted pointer types.
TODO: A standard "destroy strong array" entrypoint for arrays of single refcounted pointer types.
TODO: Add a copyPODArray runtime entry point for bitwise-takable but non- fixed-size types.
TODO: Add gdImageGetRowPtr and works with ptr at the row level for the true color and palette images new formats will simply work with ptr
TODO: Add more cases than Struct
TODO: Add properties to protocol.
TODO: Add support for determining control dependence.
TODO: Add support for working around control dependence issues.
TODO: Add swift_error attribute.
TODO: Add total count to snapshot header.
TODO: Allocating new vtable slots for derived methods with different ABIs would invalidate the assumption that the same thunk is correct, as above.
TODO: Allow customizing recorded events
TODO: Allow the box to be typed, but for staging purposes, only require it when -sil-enable-typed-boxes is enabled.
TODO: Although runtime checks are not required, we get them anyway when asking the runtime to perform this cast.
TODO: Array index overflow
TODO: Arrays currently lower-bound the stride to 1.
TODO: Attempt to analyze partial applies or run closure propagation first.
TODO: Avoid copies on address-only types.
TODO: Bridge object conversions imply a masking operation that should be "hella cheap" but not really expensive
TODO: C++ types have different rules.
TODO: CanGenericSignature should be const-correct.
TODO: Cast to NSError succeeds always.
TODO: Change this into an assert.
TODO: Check for a type here.
TODO: Check if the function is ASan black listed either in the external file or via annotations.
TODO: Check that EI is really an IntegerLiteralInst
TODO: Check that the deployment target supports the new calling convention.
TODO: Check that we've specified the target.
TODO: Check the call graph to be less conservative about what destructors might be called.
TODO: Check this already at argument parsing.
TODO: Closure contexts should always be guaranteed.
TODO: Compute the BCT.
TODO: Copy arguments of the partial_apply into new temporaries only if the lifetime of arguments ends before their uses by apply instructions.
TODO: Could accept +0 arguments here when forwardFunctionArguments/ emitApply can.
TODO: Could allow known-empty types to be inserted or removed, but SIL doesn't know what empty types are yet.
TODO: Could avoid a retain if the bridged parameter is also +0 and doesn't require a bridging conversion.
TODO: Could handle many other members more specifically.
TODO: Could look through arbitrary implicit conversions that don't have side effects, or through tuple shuffles, by emitting ignored default arguments.
TODO: Currently all indirect function values use some variation of the "C" calling convention, but that may change.
TODO: Currently we only handle cases in which one side of the copy is block local.
TODO: Currently we only handle the address-only case, not the retain/release case.
TODO: Develop a proper interface for this.
TODO: Don't call an internal function like this, but add a new C-level function for instantiating cursors
TODO: Don't emit the symbol if field has a fixed offset and size in all resilience domains
TODO: Doug suggested that we could generate one error per non-throwing function with throw sites within it, possibly with notes for the throw sites.
TODO: Dynamic thunks could conceivably require reabstraction too.
TODO: Eliminate the need for this.
TODO: Encapsulate this better in Callee.
TODO: Enums with Equatable/Hashable/Comparable payloads
TODO: Erase from module if there are no more uses.
TODO: Eventually we can plug in some analysis on the what the release of the Ptr can do, i.e. be more precise about Ptr's deinit.
TODO: Expand this to handle *any* guaranteed parameter.
TODO: Extra inhabitants
TODO: Final class metatypes could in principle be thin.
TODO: Find out what to do with the error message here
TODO: Fix better error message
TODO: For now, disallow tyvar, archetype and function types.
TODO: For now, we leave invalid casts in address form so that the runtime will trap.
TODO: For private types or protocols, we might be able to definitively deny bindings.
TODO: Function types go through a more elaborate lowering.
TODO: Generalize this to general objects.
TODO: Give these predictable mangled names and shared linkage.
TODO: Given that we know the range of elements being accessed, we don't need to go all the way deep into a recursive tuple here.
TODO: Handle generic instantiations, where we need to eagerly specialize on the given generic parameters, and static methods, where we need to drop in the metatype.
TODO: Handle non-protocol constraints ('class', base class)
TODO: Handle non-protocol requirements ('class', base class, etc.)
TODO: Handle object IntlCalendar
TODO: Handle secondary 'where' constraints on the associated types.
TODO: Handle some of the llvm intrinsics here.
TODO: Handle substitutions and indirect results
TODO: Have Callee encapsulate the captures better.
TODO: I am currently just disabling this behavior so we can get this out for Seed 5.
TODO: I am writing this too fast.
TODO: I think this is a copy paste error, since we a trap BB should have an unreachable at its end.
TODO: I wanted to call this 'verify', but some other pass is using this option.
TODO: IRGen wants substitutions for secondary archetypes.
TODO: If BB has only one predecessor and has bb args, fold them away, then use instsimplify on all the users of those values - even ones outside that block.
TODO: If Index equals zero, then we know that the two lists have nothing in common and should return unrelated.
TODO: If Obj-C interop is off, we can relax this to allow referencing class metadata too.
TODO: If a nominal type is in the same source file as we're currently emitting, we would be able to see its value witness table.
TODO: If all candidates have the same type for some argument, we could pass down partial information.
TODO: If function context arguments were given objc retain counts, we wouldn't need to create a separate heap object here.
TODO: If it is a private type or internal type and we can prove that there are no derived types conforming to a protocol, then we can still return WillFail.
TODO: If more stuff needs to be placed here, refactor into its own method.
TODO: If source type size is smaller than the target type the result will be always false.
TODO: If the archetype has a superclass constraint, check that the substitution is a subclass.
TODO: If the dominating checked_cast_br is non-exact, then it is in general not safe to assume that current exact cast would have the same outcome.
TODO: If the payload type info provides a preferred explosion schema, use it.
TODO: If the protocol name was elided from the assoc type mangling, we could try to fish it out of the generic signature constraints on the base.
TODO: If this is the last use of the closure, and if it has internal linkage, we should remove it from the SILModule now.
TODO: If we add in alias analysis support here for apply inst, we will need to check that the pointer does not escape.
TODO: If we can prove that a given global variable is assigned only once, during initialization, then we can treat it as if it is a let.
TODO: If we could require Objective-C classes to have an attribute to get this behavior, we could avoid runtime overhead here.
TODO: If we had the notion of a closed enum with no private cases or resilience concerns, then complete NS_ENUMs with no case corresponding to zero would also not be zero- initializable.
TODO: If we know the specific release instruction, we can potentially do more.
TODO: If we know the type statically has extra inhabitants, we know there are more witnesses.
TODO: If we were able to claim the value from a uniquely-owned existential box, we would want to deallocError here.
TODO: Implement the SILGen fixes so this can be removed.
TODO: Implement this more generally for arbitrary values.
TODO: In existential-to-existential casts, we should carry over common witness tables from the source to the destination.
TODO: In principle, this could be isBindableToSuperclassOf instead of isExactSubclassOf.
TODO: In principle, we could invoke the getter only once inside each function that loads from the global.
TODO: In pseudo-main, the VGetG instruction invalidates what we know about the types of the locals because it could cause any one of the local variables to become "boxed".
TODO: Integrate has empty non-symmetric difference into here.
TODO: Investigate whether or not it is
TODO: Issue a proper error message here
TODO: It is only safe to directly deallocate an instruction if this BB is being removed in scope of destructing a SILFunction.
TODO: It sort of sucks having to print these bottom up computationally.
TODO: It would be a bit more efficient to use a preallocated buffer in this case.
TODO: It would be better if we could get all declarations from a given module, not only the top-level ones.
TODO: It would be nice to use an analog of getTypeListString that doesn't include the argument types.
TODO: Its important to make this as precise as possible.
TODO: Just change this into a partition method.
TODO: Keep more detailed error information in the BreakPointInfo and emit that information here.
TODO: Lazy properties can't yet be observed.
TODO: Linear search through the payload elements is lame.
TODO: Look through static method applications to the type.
TODO: MCAST_* constants and logic to handle them
TODO: Make the test more precise.
TODO: Mapper needs to calculate a function hash as it goes.
TODO: Maybe we could provide prefabs for 1 witness table.
TODO: More general conditions in which we can relate the BB to a single case, such as when there's a single literal "false" case.
TODO: More interesting dominance analysis could be done here to see if the alloc_stack is dominated by copy_addrs into it on all paths.
TODO: More sophisticated param and return ABI compatibility rules could diverge.
TODO: Narrow this to the sourceClass being exactly NSObject.
TODO: Need IntlCalendar implemented first
TODO: Non-ErrorProtocol boxed existentials.
TODO: Non-ErrorType boxed existentials.
TODO: Not handling various string conversions or void conversions.
TODO: Note that we search manually, rather than invoking lookupMember on the ConstraintSystem object.
TODO: Once the importer learns how to import un-defined structs, then we will be able to infer them.
TODO: Once there is a proper support for IPO, / bodies of all external functions can be removed.
TODO: Once there is an efficient API to check if a given symbol is a specialization of a specific type, use it instead.
TODO: Only one "types" is allowed
TODO: Or if the box is uniquely referenced.
TODO: Or we always retain them when guaranteed contexts aren't enabled.
TODO: Other numeric literals (complex, imaginary, etc.)
TODO: Ought to support captures in block funcs.
TODO: Parallel LLVM compilation cannot be used if a (single) module is needed as return value.
TODO: Peek through struct element users like COWArrayOpts.
TODO: Prove this and put the proof here.
TODO: Randomize the filler.
TODO: Randomize the set of extra inhabitants we check.
TODO: Reabstract the lvalue to match the abstraction level expected by the inout address conversion's InOutType.
TODO: Record all loads during collectUsers.
TODO: Refactor this code so the decision on whether or not to accept an / instruction.
TODO: Remove the let property, because it is never accessed.
TODO: Remove this hack.
TODO: Remove this when failable initializers are fully implemented.
TODO: Replace this with a check on the computed subseq relation.
TODO: Resolve persistent constants
TODO: Should apply the default arg generator's captures, but Sema doesn't track them.
TODO: Should be a SILType.
TODO: Should be able to accept +0 values here, once forwardFunctionArguments/emitApply are able to.
TODO: Should be able to hand it off at +0 in some cases.
TODO: Should destructure recursively.
TODO: Should have a more efficient way to copy payload nondestructively from an enum.
TODO: Similar to the above, a more general isBindableToSuperclassOf base class constraint could potentially introduce secondary constraints.
TODO: Since we expect a pattern in this position, we should optimistically parse pattern nodes for productions shared by pattern and expression grammar.
TODO: Sink more than just integers.
TODO: Some convenient way to override the code if that's desired.
TODO: Static functions too.
TODO: Stored properties with didSet accessors that don't look at the oldValue could also be addressed.
TODO: Strengthen analysis.
TODO: Structs with Equatable/Hashable/Comparable members
TODO: Substitute out archetypes from the enclosing context with generic parameters.
TODO: Support dynamic-sized captures.
TODO: Support fragile initializers.
TODO: Support parameter closure with multiple vars.
TODO: Support parameter requirements in non-type contexts.
TODO: Support server IP whitelist.
TODO: Support storage-backed behaviors in non-type contexts.
TODO: Support this function also for other enum implementation strategies.
TODO: Swift submodules.
TODO: Switch to AcrRec API once it lands
TODO: Task #1137917: See if we can avoid marking most builtins with "MayUseVV" and still make things work
TODO: The QoI could be improved in many different ways here.
TODO: The initializer could eventually be consumed by DI-style initialization.
TODO: The noescape bit could be of interest to SIL optimizations.
TODO: The ordering of checks may benefit from using a PGO, because the most probable alternatives could be checked first.
TODO: The read preferences spec has a list of commands that *can* be send to slave
TODO: The systems that we need to solve for interpolated string expressions require bespoke logic that don't currently work with this approach.
TODO: There are cases we could statically warn about, such as casting from a non-class to a class-constrained archetype or existential.
TODO: There are some traits of partially-fixed layouts we could check too.
TODO: These are free if the metatype is for a Swift class.
TODO: They don't have to be.
TODO: Thick metatypes are free if they don't require generic or lazy instantiation.
TODO: This can be fixed by extending DIBuilder.
TODO: This creates a bunch of bitcasting noise for non-integer payload fields.
TODO: This doesn't work
TODO: This instruction could in principle be generalized.
TODO: This is a hack and eventually this pass should not be required at all.
TODO: This is a really trivial local algorithm.
TODO: This is an atrocity.
TODO: This is heinous - the same thing is happening in clang, but the API really needs to be cleaned up for both.
TODO: This is not safe without proving the object being released is not related to the allocated object.
TODO: This is only valid for arithmetic expressions.
TODO: This is probably wrong for varargs, e.g. calling "print" with the wrong label.
TODO: This is way conservative.
TODO: This is where we'd plug in some global algorithms someday.
TODO: This isn't plumbed through all the way yet.
TODO: This list is conservative.
TODO: This logic covers the most common case, when there's exactly one more no-payload case than extra inhabitants in the payload.
TODO: This might be a faster / better-cached way to materialize local type data for the concrete type.
TODO: This needs a better name.
TODO: This relies on the lowest level array.uninitialized not being inlined.
TODO: This seems overly limited.
TODO: This should handle tuple member lookups, like x.1231 as well.
TODO: This should happen once per function.
TODO: This should not be necessary.
TODO: This should only ignore *unresolved* archetypes.
TODO: This uses exact SILValue equivalence to detect aliases, we could do something stronger here to catch other obvious cases.
TODO: Track lifetime markers for function args.
TODO: Translate from the diagnostic info to the SourceManager location if available.
TODO: Turning off local doesn't really work, see #2941881
TODO: Type should be either integer or function
TODO: Unless they have magic methods...
TODO: Update for EnumPayload implementation changes.
TODO: Use the witness entry instead of falling through here.
TODO: Using parentMap would be more general, rather than requiring the issue to be related to the root of the expr under study.
TODO: Verify interesting layout properties specific to the kind of type, such as struct or class field offsets, enum case tags, vtable entries, etc.
TODO: Warn on unreachable user code here as well.
TODO: We already created an ArraySemanticsCall in isSafeArraySemanticFunction.
TODO: We can probably handle other partial applies here.
TODO: We can use all values greater than the largest discriminator as extra inhabitants, not just those made available by spare bits.
TODO: We could allow static (or class final) functions too by "capturing" the metatype in a thunk.
TODO: We could also convert multiple indirect results by returning a tuple type and created tuple_extract instructions at the call site.
TODO: We could be lazier about this.
TODO: We could be more precise with the bridged-to type.
TODO: We could clean up from a reclaimed uniquely-referenced error box.
TODO: We could conceivably have an indirect opaque ** imported as COpaquePointer.
TODO: We could do bitcasts entirely in the value domain in some cases, but for simplicity, let's just always go through the stack for now.
TODO: We could easily handle hoisting above loops if LoopInfo is available.
TODO: We could golf this a little more by assuming the first type is a dependent type.
TODO: We could use isUniquelyReferenced to shorten the duration of the box to the point that the opaque value is copied out.
TODO: We currently limit this optimization to known arithmetic operators, but we should be able to broaden this out to logical operators as well.
TODO: We do this because of how inout parameter bindings are handled for implicit closure parameters.
TODO: We just check the block itself for now.
TODO: We may want to delete debug instructions to allow us to sink more instructions.
TODO: We might be able to coordinate AllowPlusZero across conditionals / if all branches of the conditional can actually produce a +0 result.
TODO: We might be able to form a nicer schema if the payload elements share a schema.
TODO: We need information from the ARC optimizer to prove that property if we are going to use it.
TODO: We need to split edges from non-condbr exits for the SSA updater.
TODO: We should be able to flat-out replace the select_enum instruction with the selected value in another pass.
TODO: We should be able to handle destructors that do nothing but release members of the object.
TODO: We should compare generic signatures.
TODO: We should enforce that ObjC methods are dispatched on ObjC metatypes, but IRGen appears not to care right now.
TODO: We should have an "isNoReturn" bit on Swift's BuiltinInfo, but for now, let's recognize noreturn intrinsics and builtins specially here.
TODO: We should indirectly reference classes.
TODO: We should run this at -Onone even though it's not diagnostic.
TODO: We shouldn't be able to get an lvalue here, but the AST sometimes produces an inout base for non-mutating accessors.
TODO: What is the right location to use here.
TODO: When a contextual type is missing, we could try to diagnose cases where the element types mismatch.
TODO: When a contextual type is missing, we could try to diagnose cases where the element types mismatch...
TODO: When data handles are introduced, print that instead.
TODO: When serialization is reworked, this should be removed.
TODO: When there's a store or copy_addr immediately into the box, peephole it into the initializer parameter to allocError.
TODO: When we support address types, this code path will need to be updated.
TODO: When we switch to malloc/free allocation we'll be leaking memory here.
TODO: Would be nice to have a "getMinimumKnownSize" on TypeInfo for dynamic-layout aggregates.
TODO: Write a strongly-worded letter to the person that came up with a pair of functions spelled "get" and "Set".
TODO: accept a second release in the throw block to let the argument be dead.
TODO: add an instruction for non-destructively getting a specific element's data.
TODO: add ini setting to turn 'y'/'n' checks on/off
TODO: add noreturn serialization.
TODO: add support for other algorithms instead of OPENSSL_ALGO_SHA1
TODO: add swift_error attribute Initialize at the alloca point.
TODO: adjust for error type parameter.
TODO: also handle other semantic functions.
TODO: as soon as we generate alloca instructions with accurate lifetimes we should also do a better stack size calculation here.
TODO: assert that this list is consistent with isTransitiveEscapeInst().
TODO: attempt to specialize this based on the known types.
TODO: avoid unnecessary repeat lookup of ObjCClassWrapper/ForeignClass when the type matches.
TODO: be less conservative about what destructors might be called.
TODO: block descriptor pointer.
TODO: change this to is same ExtInfo.
TODO: check name space separately
TODO: check the body of didSet to only do this load (which may call the superclass getter) if didSet takes an argument.
TODO: checking may alias with Base is overly conservative, we should check may alias with base plus projection path.
TODO: clang puts this in __TEXT,__objc_methname,cstring_literals
TODO: clang puts this in __TEXT,__objc_methtype,cstring_literals
TODO: class metatype to/from AnyObject TODO: protocol concrete metatype to/from ObjCProtocol
TODO: classes nested within generic types
TODO: closures in a non-class scope should be neither static nor non-static, but right now we don't really have this idea.
TODO: coalesce into a single convention attribute.
TODO: collect the witness tables.
TODO: consider producing warnings when we decide not to merge comments.
TODO: consider re-using a dom analysis from the PassManager TODO: consider using a cheaper analysis at -O0
TODO: consider using a slower mode that dynamically checks whether the buffer size is small enough.
TODO: consider using different layout rules.
TODO: could expand this to make a callback into PHP user-space
TODO: create one if necessary.
TODO: derive this information in a more general way, e.g. add it to Builtins.def
TODO: do something intermediate when e.g. all we needed to do was set parent metadata pointers.
TODO: don't load-and-retain if the value is passed at +0.
TODO: eliminate all these
TODO: emit diagnostic with error string
TODO: enums nested inside generic types
TODO: evaluate the effect of sync() and uncomment if desirable.
TODO: experiment with disabling this chunked flag and letting proxygen framework do the chunking
TODO: extensions TODO: local contexts
TODO: figure out right value for isKnownPrivate
TODO: find out what this does
TODO: fixing this properly requires D1787768.
TODO: get rid of "bogus"..
TODO: handle address-only types
TODO: handle casting to a loadable existential by generating init_existential_ref.
TODO: handle enums with array data.
TODO: handle resilient types
TODO: if the base is +1, break apart its cleanup.
TODO: if the class pointer is guaranteed, we can do this lazily, at which point it might make sense to do it for a wider selection of types.
TODO: if we guaranteed that this load couldn't crash, we could use a select here instead, which might be profitable.
TODO: if we're casting to an existential type, don't throw away the protocol conformance information we already have.
TODO: import as closed enum instead For now, fall through and treat as a struct
TODO: improve the handling of RuntimeIncludePath.
TODO: in conditional conformances, allocate space for the assumed conformances here.
TODO: include Jobs in the diagnostic.
TODO: include the module in the onceToken's name mangling.
TODO: incomplete tuple patterns, with some syntax.
TODO: inout apply's should only clobber pieces passed in.
TODO: investigate whether these should be removed, in favor of definitions in other classes.
TODO: it would be great to factor this even lower into SILGen to the point where we can see that the parameter is +0 guaranteed.
TODO: it would be nice to be able to handle more signals
TODO: it'd be nice to be able to do this without copying.
TODO: just make sure that we have a path to them that the debug info can follow.
TODO: let options dictate fuzzy matching...
TODO: let's remove gratuitous mallocs and copies please
TODO: make the sil location more precise.
TODO: manage as a set of lists, to speed up addition of binding constraints.
TODO: may-load here probably doesn't need to include AFrameAny normally.
TODO: maybe PrivateExternals should get SharedExternal (these are private functions from the stdlib which are specialized in another module).
TODO: maybe inline manually (only caller).
TODO: maybe we can do this lazily or maybe we should disallow SIL passes to create critical edges.
TODO: maybe we should have a cache entry anyway if the fulfillment is expensive.
TODO: merge with emitIVA in unit.h
TODO: namespace isn't stored
TODO: need more test cases for this sniffing
TODO: no good when generics are around
TODO: not all elements converted.
TODO: not sure this is the right thing to do.
TODO: obviously we need to handle many more patterns.
TODO: optimize this if there are no specializes in play
TODO: pass something about the root conformance necessary to reconstruct this.
TODO: perform some preflight checks to ensure the file exists.
TODO: preserve the function pointer at its original abstraction level
TODO: produce warning invalid ns
TODO: project stored properties directly TODO: need to get baseFormalType from AST
TODO: properly handle task began.
TODO: prove that some conversions from class existential metatype to a concrete non-class metatype will obviously fail.
TODO: prove that some conversions to existential metatype will obviously succeed/fail.
TODO: provide an API to find the best metadata path to the conformance and decide whether it's expensive enough to be worth caching.
TODO: provide reflective descriptions of the type and conformance requirements stored here.
TODO: proxygen only supports downstream keep-alive
TODO: reactivate the linker mode if it is supported in llvm again.
TODO: reconsider whether having a default case is a good idea.
TODO: redesign from a SmallString to a StringScratchBuffer design for all of this name mangling, since we have to use one for omit needless words anyways
TODO: refactor this code outside of the method.
TODO: reference any additional headers you need in STDAFX.H and not in this file
TODO: remove once the frontend understands what action it should perform
TODO: reorder, if possible, so that diagnostics emitted during CompilerInvocation::parseArgs are included in the serialized file.
TODO: security checking
TODO: set up Outputs appropriately.
TODO: some smart thing that avoids duplicating the value in the general loop below.
TODO: strip leading underscores
TODO: structs nested within generic types
TODO: support percentage frequency is a percentage, not bytes
TODO: swift_context marker.
TODO: swift_error marker.
TODO: t5226715 We shouldn't need to check s_defaultLocale here, but right now this is called for every request.
TODO: t5226715 We shouldn't need to check s_session here, but right now this is called for every request.
TODO: t5284137 add some tests for abortRequest
TODO: take advantage of protocol conformances already known.
TODO: the IR would be more legible if we made a struct instead.
TODO: the conformance might be conditional.
TODO: the integer literal bit size is 2048, but we only have a 64-bit conversion function available (on all platforms).
TODO: there are probably cases where we can avoid redoing the entire linkage computation.
TODO: these need to be implemented.
TODO: this could use a fancier dominance analysis, maybe.
TODO: this error message is unhelpful if the format string is not one character long
TODO: this is a workaround until rdar://problem/25225083 is implemented.
TODO: this logic doesn't really work with init methods TODO: this privileges the old API over the new one
TODO: this should be consume-ordered when LLVM supports it.
TODO: this should probably read out the other elements of the global data which control Option or RuntimeOption values -- the others are read out in an inconsistent and ad-hoc manner.
TODO: this would be useful for resilience
TODO: try and force the stream to be FILE*
TODO: try to emit the argument at +0.
TODO: try with cast(), get() to obtain a number
TODO: tuples TODO: functions TODO: metatypes
TODO: unique and reuse the () parameter list in ASTContext, it is common to / many methods.
TODO: use "tinycc" on platforms that support it
TODO: use ObjC class references
TODO: use a caching entrypoint (with all information out-of-line) for non-dependent tuples.
TODO: use a custom CC that returns three scalars efficiently
TODO: use the correct SILLocation from module.
TODO: use the known fast rgba multiplication implementation once the new formats are in place
TODO: verify the path is valid.
TODO: we can avoid creating entries for some obvious cases here.
TODO: we can pass at +0 (immediate) to an unowned parameter if we know that there will be no arbitrary side-effects between now and the call.
TODO: we can't currently support lazy properties on non-type-contexts.
TODO: we could make the logic here more complicated to handle each type of instructions in a more precise manner.
TODO: we could try harder here, e.g. for enum elements to provide the enum type.
TODO: we eventually want to return seqid to the caller
TODO: we may eventually want to make an option which specifies directories or filenames to exclude from PHP7 behavior, and so checking these may want to be per-file.
TODO: we may need to bind extra information in the IGF in order to make conditional conformances work.
TODO: we should consider Throw block as well, or better we should abstract the Return block or Throw block away in the matcher.
TODO: we should fix this, otherwise we are missing RLE opportunities.
TODO: we should probably implement a fancier buffer size control here.
TODO: we should probably mark dependence on the base.
TODO: we're only saving the last error
TODO: we're returning timestamps as strings
TODO_4: evaluate when these can throw, non-constant type stuff.
TODO_4: if we don't end up with a use for this, remove it.
TODOs: Implement DeltaE instead, way better perceptual differences
TRUE if next pass must zero histogram
TWO(IVA, SA), CVUMANY,  ONE(RV)
TWO(IVA,SA),  CVUMANY,   ONE(CV)
T_CONSTANT_ENCAPSED_STRING
T_FUNCTION related functions
T_START_HEREDOC has a trailing newline, so we can start looking for the ending label right away
Tab-expand all leading whitespace
Table with characters for base64 transformation.
Tables that the pass uses when walking the domtree.
Tabulate the strings for each column, row-major.
Tack it on for consistency with other members.
Tag declaration context.
Tag sets will be included if available.
Tail call elimination on ppc64: call without creating a stack and keep LR contents as prior to the call.
Tail duplicate successor blocks of blocks that perform an objc method call / and who contain releases.
Tail-allocate space for the UUID.
Tail-recur to actually call the constructor.
Take a look at the conversion type to check to make sure it is sensible.
Take a prefix of rows that share the same semantic kind of pattern.
Take a value out of the source inner result address, reabstract / it, and add it as the next direct outer result.
Take a value out of the source inner result address, reabstract / it, and initialize the destination outer result address.
Take advantage of the empty version being 0.0.0.0.
Take advantage of the fact the type-checker leaves the types on the AST.
Take an argument at +0 and bring it to +1.
Take argument value from the dominating BB
Take argument value from the dominating BB.
Take care of all ancestors first
Take care of formal indirect returns ourselves.
Take care of freeing the args, tearing down the ActRec, and moving the return value to the right place.
Take care to close both file descriptors and unlink the output file after reading its contents.
Take care, as the sprintf implementation may return less places than we requested due to internal buffer limitations
Take cpu0's speed as a proxy for all cpus.
Take direct value arguments and inout pointers by value.
Take from an indirect inner result and make it the next outer / direct result.
Take from an indirect inner result into an outer indirect result.
Take indirect value arguments out of memory.
Take into account even those functions that should not be optimized, because they may contain access to the let properties.
Take local ownership of the optional result value.
Take only the last part
Take out locations that are dead.
Take over XPC's UINT64 to mean SourceKitD's UID.
Take ownership of the exception.
Take some bits off of the bottom of the pattern.
Take some load off the CPU when polling thread is paused.
Take that result and inject it into an optional.
Take the ClassHierarchyAnalysis into account.
Take the address argument and cast it to RawPointer.
Take the arguments for special processing, in place of the above.
Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0 the key.
Take the branch before setting locals if the iter is already empty, but after popping.
Take the following example, where t1 has a lower bound of zero: StMem ptr, t1 IncRef t1 IncRef t1 RaiseWarning "something"  // any instruction that can re-enter and decref t1 DecRef t1 ...
Take the incoming function pointer and add a null context pointer to it.
Take the information about the forward ref out of the map.
Take the init of the last pattern in the list.
Take the initializer from the PatternBindingDecl for VD.
Take the intersection componentwise.
Take the last N direct outer results, tuple them, and make that a / new direct outer result.
Take the last direct outer result, inject it into an optional / type, and make that a new direct outer result.
Take the list of unresolved entries to process.
Take the next direct inner result and just make it a direct / outer result.
Take the next direct inner result and store it into an / outer result address.
Take the next direct inner result, reabstract it, and add it as / the next direct outer result.
Take the next direct inner result, reabstract it, and initialize / the destination outer result address.
Take the payload from the optional.
Take the raw pointer argument and cast it to the destination type.
Take the reference type argument and cast it to BridgeObject.
Take the reference type argument and cast it to RawPointer.
Take the reference type argument and cast it.
Take the type reference inside a protocol conformance record and fetch the / canonical metadata pointer for the type it refers to.
Take the union componentwise.
Take the value in param, apply any needed conversions and return the value to be passed to CallBuiltin.
Take yet unprocessed bytes into account.
TakeAlways or TakeOnSuccess values should have / cleanups when their types are non-trivial.
Taken from here http://git.io/wY2WPw
Taken from php-src https://github.com/php/php-src/blob/PHP-5.6/Zend/zend_execute_API.c#L960
Taken: LdClsPropAddr* returned Nullptr because it isn't defined
Taken: LdGblAddr branched here because no global variable exists with that name.
Taken: Property is Uninit.
Taken: global doesn't exist
Taken: need to initialize the static local
Taken: retrieve the result from the wait handle
Taken: src is not an object
Taken: tvRef isn't Uninit.
Taken: value is not Boxed
Takeover didn't complete in 30s, stop the old server
TakeoverAgent provides the ability to transfer the accept socket (the file descriptor used to accept new connections) from an older instance of the server to a new one that has just been brought up.
Takes a PtrToGen as its first operand, so we can't easily grab an array base.
Takes a pair of RGBA row data as input and generates 2 rows of Y data and one row of subsampled U, V data as output Input: 1, 2.
Takes can be done by primitive copy in these case.
Takes the same inputs as the linker, but doesn't own them.
Tantzen, Communications of the Association for Computing Machinery August 1963.
Target is after end of Node, skip it.
Target is before start of Node, skip it.
Target is right at the end of Node, mark it.
Target is right at the start of Node, mark it.
Target is within Node and Node is really the parent of Target, take it.
Target specific FP types.
TargetSink should have an owning pointer to the allocator that keeps the results alive.
Targets of jmps on ppc64 must be aligned to instruction.
Targets of jmps on x64 must be aligned to 16 bytes.
Tear down any side-table data structures.
Teardown the frame we erected by enterDebuggerDummyEnv()
Technically not prohibited by the spec.
Technically we don't need to do TStr case.
Technically we should be coallescing these child calls, but this is what php5 xdebug does.
Technically we shouldn't have to eval the unit right now (it'll execute the pseudo-main, which should be empty) and could get away with just mergeFuncs.
Tediously free stuff.
Teleport the closure to the next local.
Teleport the reference from the destroyed stack cell to the ActRec.
Tell LLVM the lifetime of the allocated stack memory.
Tell SQLite to retry.
Tell all files to parse as library, which is necessary to load them as serialized ASTs.
Tell the ErrorProtocol to become an NSError, using _bridgeErrorProtocolToNSError.
Tell the constraint system what the contextual type is.
Tell the core we're ready for the packages to be processed now.
Tell the database to destroy its cursor
Tell the inner variant to skip the nesting check for data inside
Tell the type checker not to touch this constructor.
Tell the type checker not to touch this destructor.
Tell the type checker not to touch this extension.
Temp register used only for breaking cycles.
Template type parameters are represented using child DIEs, not attributes.
Template used to generate code fragment for binary instructions (Ins) with one argument being a constant.
Templates are instantiated over the collection class and the iterator style.
Temporaries created as copies of alloc_stack arguments of the partial_apply.
Temporarily assign parent properties' indexes to their additive inverses minus one.
Temporarily change the active scope to null, so we don't record / any changes made while performing the undo operation.
Temporarily copy the first result to temporary storage.
Temporarily deactivate the main array cleanup.
Temporarily disable printing the diagnostics.
Temporarily ignore the justOne option while cleaning the data by _id
Temporarily swap out the parser's current lexer with our new one.
Temporary arena used for a constraint solver.
Temporary buffer for re-allocation
Temporary buffer for vector immediates.
Temporary buffer to hold scanned number strings before they are passed to strtoul()
Temporary debugging flag until this pass is better tested.
Temporary hack to reject literals with ud-suffix.
Temporary to hold the intermediate result.
Temporary, during file-cache migration.
Tends to be less accurate as distance increases.
Terminate destination --- called by jpeg_finish_compress after all data has been written.
Terminate loop in recursion.
Terminate source --- called by jpeg_finish_decompress after all data has been read.
Terminate the string.
Terminate token and skip trailing separators
Terminiation is guaranteed because the widening operator has only finite chains in the type lattice.
Ternary has fixed precedence.
Test 1: Move a file over its parent directory.
Test 1: Move empty over nonexistent.
Test 1: Move source over nonexistent.
Test 2: Move a file into a nonexistent directory.
Test 2: Move empty over empty.
Test 2: Move source over empty.
Test 3: Move empty over non-empty.
Test 3: Move source over non-empty-but-different.
Test 4: Move empty over self.
Test 4: Move source over identical.
Test 5: Move source over self.
Test Object cast operations
Test Resource cast operations
Test a bit in the control variable at the current insertion point.
Test assignment operator method
Test comparison in between invalid and valid PointerIntEnums.
Test containment for ranges with lower end points.
Test copy constructor method
Test copy constructor method where SmallBlotMapVector isn't small.
Test copying from a default-constructed map.
Test copying from an empty map where SmallBlotMapVector isn't small.
Test erase(iterator) method
Test erase(value) method
Test fixture, with helper functions implemented by forwarding to global function overloads selected by component types of the type parameter.
Test for execute permission.
Test for read permission.
Test for type parameters, as opposed to a generic decl context, in case the enclosing enum type was illegally declared inside of a generic context.
Test for write permission.
Test if it is the exact same class.
Test if stream is EOF if the flag is not already set.
Test if this is a payload or no-payload case.
Test intersection for ranges with lower end points.
Test is a little different, so we have this BASIC_OP stuff.
Test movzbl with high byte regs, avoiding destination registers that need a rex prefix
Test of object_init_ex().
Test that All acts like the top element in the lattice with respect to containment.
Test that All acts like the top element in the lattice with respect to intersection.
Test that All acts like the top element in the lattice with respect to union.
Test that Empty acts like the bottom element in the lattice with respect to containment.
Test that Empty acts like the bottom element in the lattice with respect to intersection.
Test that Empty acts like the bottom element in the lattice with respect to union.
Test that filling a small dense map with exactly the number of elements in the map grows to have enough space for an empty bucket.
Test that pointer enums with different cases but the same value compare different.
Test that pointer enums with the same case and data are equal.
Test that pointer enums with the same case but different data are not equal.
Test that pointers and indices compare differently.
Test that setcc/xor pair is collapsed.
Test that setcc/xor pair is not collapsed when setcc result has more than one use.
Test the empty string, spelled various ways.
Test the function and pass names we're given against the debug options that force us to break prior to a given pass and/or on a given function.
Test to see if there is a value with the same name as 'proposedName' in the same module as the decl FIXME: This will miss macros.
Test union for ranges with lower end points.
Test whether the object's isa is a metaclass, which indicates that the object is a class.
TestUnsetStatement TestEchoStatement TestForStatement TestObjectPropertyExpression TestListAssignment TestUnaryOpExpression - internal_functions - isset_variables
Testify that there's a fulfillment at the given path.
Testing for StaticStr will make you miss out on CountedStr, and vice versa, and similarly for arrays.
Testing for equality with true simplifies to just the left operand, while equality with false is the negation of the left operand (equivalent to XORing with true).
Tests for resilient witness table instantiation, with runtime-provided default requirements
Tests that that actually clears out the map.
Tests that the result of a findPrefix matches what we expect from the std::map.
Thanks to "Super Pikeman."
Thanks to Aaron Giles for this idea.
Thanks to Frank Warmerdam for pointing out the issue.
Thanks to Frank Warmerdam.
Thanks to Geert Jansen
Thanks to John Buckman.
Thanks to Steven Brown.
That "tuple" might not actually be a tuple.
That aside, the greatest value wins, but we can't know that it will until we've scanned both numbers to know that they have the same magnitude, so we remember it in BIAS.
That behavior is preserved when CookieDeduplicate is not enabled.
That clips too, so don't clip twice.
That could help to adjust intersections  to produce a nice interior_extrema.
That covers the local, so incref once more for the stack.
That data structure tracks the first position at which a register is /unavailable/, so it would appear that constrain()'s return value is off-by-one.
That decref can't have had side effects, because iter_next_cold would have been called otherwise.
That doesn't serve any direct purpose, but it's neat.
That expression happens to cause an assumption that we made earlier to be violated (that `ar` is on the stack), so if we detect this situation we need to fix up the value of `ar`.
That generic type should equal itself.
That is not a guaranteed condition but it gives us an idea of what's possible.
That is the *true* exiting region.
That is the IFD for the first thumbnail
That is the largest legal value, divided by the base.
That is the only case where we support pattern matching a release.
That is, a reference with an invalid location that is contained inside a #available() and with no intermediate DeclContext will not be refined.
That is, if a particular import is a top-level import, add it.
That is, if all hit conditions have been met
That is, make sure that on every version where the conforming declaration is available, if the requirement is available then the witness is available as well.
That is, we allow equality in stopping tests when the round-nearest rule will give the same floating-point value as would satisfaction of the stopping test with strict inequality.
That isn't the case for Swift enums.
That matches how we want to use them in most cases.
That may destroy the proxy here, or it may remain alive if there is a thread still processing an interrupt with it since such threads have their own shared reference.
That means that these casts would not be appropriate for bridging-like conversions.
That means we have to be even more clever than the spec says that we need to :-/
That method assumes that no backtracking is possible.
That might involve storing directly.
That mostly means we need to be good at not marking things external.
That overload isn't available on QSslConfiguration.
That pattern guarantees a monotonically increasing counter.
That produce Selectors.
That said, if those checks are determined to be removable, we can remove this as well per rdar://problem/18801263
That said, this function is reasonably efficient for most use cases.
That shouldn't ever happen today, though, since we only ever indirect the 'self' parameter of functions imported as methods.
That will be type-checked after we've determine the complete function type.
That will cause SameType requirement to have Archetypes inside.
That will remove the element and not block, even if we hold an ExpMap::accessor to the element in another thread, which would allow us to proceed and free vpkey.
That'll mean we'll chop off the trailing N-1 opcodes, then in the next region we'll select N-1 opcodes and chop off N-2 opcodes, and so forth...
That's enough to build the l-value.
That's not a subtype relationship.
That's not what clang does.
That's okay because we will visit them in our next invocation of the inliner.
That's okay, though...
That's the last special case defined so far.
That's why we explicitly handle the declaration, instead of using our macros.
Thats only OK if we only preferred it
The "-z" option of "file" is the reason for this ugly code.
The "/test" of "/test/name" should have been added as a directory.
The "Ref" variants have been removed.
The "autoreleased" convention doesn't survive through a partial application, since the thunk takes responsibility for retaining the return value.
The "availability" semantics attribute is treated like global-init.
The "built-in" Objective-C types id, Class, and SEL can actually be (and are) defined within the library.
The "const" storage-class-modifier is valid.
The "could be" relationship also holds.
The "introduced" versions are the same.
The "length" is an / estimation of the execution time.
The "piggy-bank" data-structure that we use for processing the dom-tree bottom-up.
The "returns inner pointer" convention doesn't survive through a partial application, since the thunk takes responsibility for lifetime-extending 'self'.
The "self" parameter should not get bridged unless it's a metatype.
The "this" variable in methods, pseudo-main, or closures is special and is handled separately below.
The "weight" for the benefit which a single loop nest gives.
The '#' will be lexed as part of the object literal keyword token itself.
The 'Self' type must be bound to an archetype.
The 'Z' type specifier in zend_parse_parameters() demands a zval** which remains valid until the caller returns.
The 'ar' argument points to an ActRec of the invoked/resumed function.
The 'filename' parameter may be NULL if there is no file associated with the source code.
The 'isascii' bit is lowered as an integer_literal.
The 'metadata flags' field in a class is actually a pointer to / the metaclass object for the class.
The 'q' introducer is thus left off of generic params.
The 'self' argument might be in the context position, which is now the end of the parameter list.
The 'self' variable to use when rebinding 'self' in a constructor.
The 'try' case is only for simple local recovery, so we only bother to check 'let' and 'var' right now.
The (uncomposed) ErrorProtocol existential uses a special boxed representation.
The +1 argument is passed indirectly, so we need to copy into a temporary.
The / ObjC runtime requires protocol references to be loaded from an / indirect variable, the address of which is given by / getAddrOfObjCProtocolRef.
The / former latch now dominates the former header.
The / most general form of an unmaterializable type preserves the / basic structure of the unmaterializable components, replacing / any materializable components with fresh type variables.
The / read or stored value, kept in a map between LSLocation and LSValue, / becomes the available value for the LSLocation.
The / result is of type ObjCClassPtrTy.
The / rows should not be used in this matrix afterwards.
The / source location is used to diagnose a failure if the block ends up never / being defined.
The / text is inserted immediately *after* the token specified.
The 0 digit has special meaning at the beginning of a number.
The 1st shear may use the original clrBack as color index Convert it once here
The 2 instructions given are not identical, but are passed as arguments / to a common successor.
The 2/3/1 scale factors used here correspond loosely to the relative weights of the colors in the NTSC grayscale equation.
The 5 month cycle is used to account for the varying lengths of months.
The ABI IR types for the entrypoint might differ from the Swift IR types for the body of the function.
The ABI-passed type will still be mixed/Variant.
The API routine is partially broken on filenames ending ".com".
The ARC passes will remove references to the function when they're no longer needed.
The AST representation for a defer statement is a bit weird.
The AbstractClosureExpr or AbstractFunctionDecl being analyzed.
The ActRec in question was pushed before the beginning of the tracelet, so we can make a guess about parameter reffiness and record our assumptions about parameter reffiness as tracelet guards.
The AddElem* instructions decref their args, so don't decref pop'ed values.
The AddNewElem helper decrefs its args, so don't decref pop'ed values.
The AliasAnalysis Cache must not grow beyond this size.
The AllocStackInst that we are handling.
The Array may escape here.
The ArrayAdd helper decrefs its args, so don't decref pop'ed values.
The ArrayIter destructor will decRef the array
The ArrayIter destructor will decRef the array.
The AsyncRet unique stub may or may not be able to do fast return (jump to parent directly).
The BBSetIns have converged, run last iteration and figure out insertion point for each RC root.
The BBSetOuts have converged, run last iteration and figure out insertion point for each refcounted root.
The BaseS* bytecodes consume the Class from the eval stack so the final operations don't have to expect an A-flavored input.
The BitVector in / each g is then laid on top of it to keep track of which LSLocation / has a downward available value.
The BitVector in each / BlockState is then laid on top of it to keep track of which LSLocation / has a downward available value.
The BitVector in each / BlockState is then laid on top of it to keep track of which LSLocation / has an upward visible store.
The Builtin module cannot be explicitly imported unless we're a .sil file or in the REPL.
The Builtin module declares no operators, nor do derived units.
The Builtin reference types can alias any class instance.
The Builtin.NativeObject metadata can stand in for boxes.
The Builtin.once token guarding the global initialization.
The CF attributes aren't represented in the type, so we need to check them here.
The CallArray that triggered the call to doFCallArrayTC has a catch trace which needs to be run.
The CallEmission class below uses these / to generate the actual SIL call.
The ClosureHoistable flag keeps them ahead of any other classes, but in mergeImpl we're going to define functions before we define classes, so we do them first here.
The ConcurrentMap data structure allows us to insert and search the map concurrently without locking.
The ConsumedArgToEpilogueReleaseMatcher finds the final releases in the following way.
The CookieJar is disabled: don't return any cookie
The CreateCl opcode is specified as not being allowed before the class it creates exists, and closure classes are always unique.
The Cursor creation should be done through an init method otherwise a connection have to be requested twice.
The Cursor creation should be done through an init method.
The DRE argument is a reference to a noescape parameter.
The DWARF output created by Swift is intentionally flat, therefore archetypes are emitted with their DeclContext if they appear at the top level of a type (_Tt).
The DateTimeZone constructor doesn't support offset time zones, so we must mess with DateTimeZone structure ourselves
The ErrorProtocol existential has a special boxed representation.
The FP from the DefInlineFP we're seeking to remove.
The FP in succ came directly from pred, but pred now has a new FP, simply update all instances of predOldFp with predCurFp
The FPI delta from instrFpToArDelta includes locals and iterators, so when we're in a resumed context we have to adjust for the fact that they're in a different place.
The FPInvOffset of the stack slot is just its 1-indexed slot.
The File is also owned by the native data so it does not need to be cleaned up by an XML callback.
The FileScope maintains a stack of attributes, so that it correctly handles each function.
The GeneralEffects should already contain AHeapAny in both loads and stores if it affects those locations for reasons other than re-entry, but does not need to if it doesn't.
The GenericTypeParamDecls might be from a different module file.
The GlobalPropertyOpt performs an analysis on the whole module to determine / the values of high-level properties.
The Graphics Interchange Format(c) is the Copyright property of CompuServe Incorporated.
The Gregorian calendar was not instituted until October 15, 1582 (or October 5, 1582 in the Julian calendar).
The HHAS systemlib functions are not currently visible to hhbbc, but we know they can't return references.
The HHIRLICM runtime option is all capitals, so separation cannot be determined.
The HHVM ini option becomes the standard PHP option.
The HashCollection implementation makes use of s_theEmptyMixedArray, a special static empty array that has all of MixedArray's fields initialized to convenient values.
The ID of the block enclosing `pos'.
The IR-generation for function types is specifically not type-dependent.
The IfConfigDecl is ahead of its members in source order.
The InOutDeshadowing guaranteed optimization will eliminate the variable if it is not needed.
The Initializer will be added later when/if it is parsed.
The InlineReturn instruction that defines this region.
The JSON_parser takes a UTF-8 encoded string and determines if it is a syntactically correct JSON text.
The Jewish calendar has been in use for several thousand years, but in the early days there was no formula to determine the start of a month.
The Julian calendar specifies that every year that is a multiple of 4 will be a leap year.
The JumpDest must be valid.
The MD5 transformation for all four rounds.
The MInstrState we need to use is at a constant offset from the base of the RDS header.
The MUI must be used on a project_box or alloc_stack instruction.
The Map::accessor here establishes a write lock, which means that other threads, protected by read locks through Map::const_accessor, will not read erased values from APC.
The MemoryBehavior Cache must not grow beyond this size.
The Mod IR instruction has undefined behavior for -1, but php semantics are to return zero.
The MySQL C API documentation say that you shouldn't touch the internals of the MySQL's datastructurs.
The NAdder function controls whether it's actually building a graph or just performing analysis.
The NativeImpl opcode may appear later in the function because of Asserts generated in hhbbc
The OS might guarantee only one guard page at the bottom of the stack, and a page size can be as small as 4096 bytes.
The ObjC runtime will drop a reference to its magic Protocol class here.
The ObjC type param didn't get imported, possibly because it was suppressed.
The Objective-C runtime will copy field offsets from the field offset vector into field offset globals for us, if present.
The Objective-C thunk was never even declared, so it is not defined.
The Optional is just to avoid copy constructing MArrayIter.
The PBD covers the whole initializer.
The PMBuilder only knows about LLVM AA passes.
The PartialApplyArg from the caller is now mapped to its cloned instruction.
The PassByRefKind of a list assignment expression is determined by the PassByRefKind of the RHS.
The PopC will decide it can't be eliminated, which prevents us from eliminating the CGetL.
The PreClass runtime structures require knowing these offsets.
The REPL got a "quit" signal.
The REPL prompt string for line continuations.
The RO-data is not shared between instantiations, but the global ivar offset is (by definition).
The RValue will have one scalar ManagedValue / for each exploded tuple element in the RValue, so this needs to make the / shape of the initialization match the available elements.
The ReadLock here is to sync with clear(), which only has a WriteLock, not a specific accessor.
The RetCtrl is generally ending a bytecode instruction, with the exception being in an Await bytecode instruction, where we consider the end of the bytecode instruction to be the non-suspending path.
The RetCtrl opcode also suspends resumables, which we model as having any possible effects.
The SIL StackPromotion pass generates a pair of swift_bufferAllocateOnStack and swift_bufferDeallocateFromStack calls.
The SIL function type being represented.
The SIL type encodes conventions according to the original type.
The SIL verifier walks over a SIL function / basic block / instruction, / checking and enforcing its invariants.
The SIL witness thunk has the type of the AST-level witness with witness substitutions applied, at the abstraction level of the original protocol requirement.
The SILDeclRef declaring the method.
The SILGenFunction that we are emitting SIL into.
The SILType of the value.
The SILValue IDs which are printed as edge source labels.
The SSA updater we use to materialize covering values.
The SSAUpdater can't handle critical non cond_br edges.
The Self and Parent cases should never reach here because they were handled above
The Self type is abstract, so we must pass in a witness table.
The Software shall be used for Good, not Evil.
The SourceMgr buffer ID of the REPL input.
The StackPromoter acts as a "graph" for which the post-dominator-tree is calculated.
The StartBlock is inside a loop but we couldn't find a deallocation place in this loop, e.g. because there are uses outside the loop.
The String conversion allows `NULL` to ""
The Substitution header does not share state with the rest of the mangling.
The Swift-field-less cases use opaque storage, which is guaranteed to ignore the type passed to it.
The To node already has an outgoing pointsTo edge, so the only thing we can do is to merge both content nodes.
The TopLevelCodeDecl is already set up in Decls to be returned to caller.
The Type class doesn't fully correctly handle the fact that the earlier stages of the compiler consider null to be either initalized or uninitalized, so we need to do this check first.
The Type we're allowed to assume any static property contains is the union of the ClassInfo-specific type with the unknown class type for that property name that's stored here.
The TypeExpansion Cache must not grow beyond this size.
The TypedValue may be a non-scalar, but it must have a static value.
The UnitEmitter expects EH regions that look a certain way (basically the way emitter.cpp likes them).
The VASMs that are composed of these kind of operations, must be lowered to first extract the operator into a register and later perform operation using the entire register, i.
The VM can handle the NewStructArray bytecode when struct arrays are disabled.
The VM state should be synced using VMRegAnchor by the caller, before entering libxml2.
The VWT pointer always immediately precedes the address point.
The VarDecl and any accessor decls (for computed properties) go in CurDeclContext.
The VarDecl for the let decl.
The VarDecl or SubscriptDecl being get/set.
The Variable whose (sub-)lifetime this (sub-)interval represents.
The Vreg this value represents.
The WuManberReplacement class, related data structures and hash function are ported from php_strtr_array_* as implemented in PHP 5.6.10.
The XML context is also deleted in this function, so the ownership of the File is kept locally in 'stream'.
The XML context is owned by the native data attached to 'this_'.
The XPC connection is still valid and sending a message to it will re-launch the service.
The YYSTATE alias is for lex compatibility.
The _ after the k seems to have an effect.
The __init__ method gets special treatment
The `alt_hint' is for phijcc.
The `base' register is not necessarily a virtual register.
The `doCheckStack' and `doInitArgs' callbacks should return truthy in order to short-circuit the rest of invokeFuncImpl() and return early, else they should return falsey.
The `doInitArgs' and `doEnterVM' callbacks take an ActRec* argument corresponding to the reentry frame.
The `initializerType' is for use during refine_public_statics, and inferredType will always be a supertype of initializerType.
The `live' registers must be preserved across any native calls (and generally left untouched).
The `mcprep' instruction here creates a smashable move, which serves as the inline cache, or "prime cache" for the method lookup.
The `shouldFreeIter` immediate determines whether we need to call free on our iterator or not.
The above code might use fixups.literals but shouldn't use anything else.
The above is not the case for pinit, so we need to load.
The absolute depth at the label can then be inferred from the absolute depth at the jump.
The absolute stack depth is unknown.
The accepted expression types are: - The magic constants "true" and "false".
The accessor returns (temporary: Builtin.RawPointer, callback: Builtin.RawPointer), where the first pointer is the materialized address and the second is the address of an optional callback.
The action influences the behavior of that particular scanner.
The actions are inferred by looking for member functions with special names, and static members with special names.
The actions inherent to the type are used when automatically generating a scanner for that type, while the actions here override those.
The active members of the #if block will be type checked along with their enclosing declaration.
The active scope is now the parent scope.
The actual analysis and optimization do not depend on the copy being linked to call arguments.
The actual closure has a closure expression as scope.
The actual computation according to FIPS 180-2:6.2.2 step 3.
The actual computation according to FIPS 180-2:6.3.2 step 3.
The actual decRef has to happen after the call to arr().end() below, because both can have visible side effects (calls to __destruct() and valid()).
The actual error will be diagnosed when we perform full semantic analysis on the class itself.
The actual error will be diagnosed when we perform full semantic analysis on the enum itself.
The actual file should be located in dumpDir.
The actual opening operation will occur when we see the OpaqueValueExpr.
The actual operand will sort out which result idx to use.
The actual result value just needs to be bridged normally.
The actual semantics are handled elsewhere.
The actual type witness that was inferred.
The actual weight including a possible weight correction.
The adapted closure value might outlive the block's original scope.
The address of an empty value is always undefined, so we can just return nil back in this case.
The address of the array passed to the current make_mutable we are analysing.
The address of the buffer used for the binding, if this is an address-only / let.
The address of the first local is passed in the second argument register.
The address-of operator produces an explicit inout T from an lvalue T.
The addresses of empty values are undefined, so we can't safely mark them dereferenceable.
The adjacency information has something extra in it.
The adjustment index, for parameter adjustments.
The affected range starts from the previous newline.
The aggregate's type lowering.
The algorithm is based on:
The algorithm uses two passes:  Analysis: - For each block in RPO: - Load in-state, which has been populated by at least one predecessor (or manually set to NoSpill for the entry block).
The algorithm works as follows: In case we have a read preference of primary, secondary or nearest the set will always contain a set of all nodes that should always be considered to be returned.
The algorithms are based on a preponderance of less authoritative sources.
The alias analysis that we will use during all computations.
The alignof value is one greater than the alignment mask.
The alloc_stack that we are analyzing.
The allocation instruction may be moved, so increment Iter prior to doing the optimization.
The allocation is inside a stack alloc-dealloc region and we are now leaving this region without having found a place for the deallocation.
The allocation we are analyzing.
The allocator used for all allocations within this arena.
The allocator we are currently using.
The allocator we are using.
The alpha channel is where it's really at these days.
The analysis must determine whether any array / mutation can occur between the retain and release.
The analysis result structure for rc_analyze.
The analyze pass does not mutate the unit, while the optimize pass iteratively removes nested frames.
The anchor for the constraint is almost always an OverloadedDeclRefExpr or UnresolvedDotExpr.
The anonymous context cannot access protected or private properties, so we can fail fast here.
The applicant not being a class should have been diagnosed by the early checker.
The application should resume compression after it has made more room in the output buffer.
The application should resume decompression after it has loaded more data into the input buffer.
The applied function is the first operand.
The apply callee that abstractly represents the entry point that is being / called.
The apply instruction does not capture the pointer when it is passed through 'inout' arguments or for indirect returns.
The apply instruction in the caller (null if this is the tracker of the callee).
The appropriate fix is probably to gin up a source range for the declaration when synthesizing it.
The ar that we're looking for is the ar of the delegate generator, so grab that here.
The archetype builder is associated with the canonical signature.
The archetype builder now has all of the requirements, although there might still be errors that have not yet been diagnosed.
The archetype describing this opened existential.
The archetype may come from the explicit type in a cast expression.
The archetype order here needs to be consistent with MetadataLayout::addGenericFields.
The archetype's protocol constraints.
The archetype's superclass constraint.
The archetypes may be missing, but we can compare them directly because archetypes are always canonical.
The argument binds to a parameter that comes earlier than the previous argument.
The argument could be shuffled if it includes default arguments, label differences, or other exciting things like that.
The argument is +0, so we can use the address of the param in the context directly.
The argument is a pointer to data in the format you find in an .eh_frame section.
The argument is dead.
The argument is either a ParenExpr or TupleExpr.
The argument is no longer in use.
The argument isn't pushed until the final member operation.
The argument of the dominating checked_cast_br's successor block.
The argument should be a closure.
The argument to the has-member block is the uncurried method.
The argument tuple is then required to have keywords for every argument that name properties of the type.
The argument type must be convertible to the input type.
The argument we are splitting.
The arguments /    to swift_bufferAllocate in SIL are not constant because they depend on /    the not-yet-evaluatable sizeof and alignof builtins.
The arguments after _NAMELENGTH and _CONTENTSLENGTH must be explicitly cast to long in curl_formadd use since curl needs a long not an int.
The arguments are pushed in order, so we should refer them by index instead of taking the top, that would lead to reverse order.
The arguments may not be used in another block, because when the predecessor of SBB directly jumps to the successor, the SBB block does not dominate the other use anymore.
The arguments must match the suffix of the original function's input types.
The arguments need not already / be of i8* type.
The arguments then form a tuple pattern matching the element's data.
The arguments to the func are defined in their own scope.
The arguments to the result function type must match the prefix of the original function's input types.
The arguments which feed this tuple element.
The array allocation call.
The array created by the other thread is now in expected, return it instead and delete the one we just made.
The array does not escape.
The array is ok, so long as it is mutable.
The array may mutate itself in place and return the same pointer, or the array may allocate a new array and return that.
The array must be a dictionary literal type.
The array must be an array literal type.
The array must match get_element_addr's array.
The array must strictly dominate the header.
The array pointer we're currently adding to.
The array reference is invariant.
The array value may be returned by its initializer or some other factory function.
The array value returned by the allocation call.
The array value was stored or has escaped.
The assert() clause above should prevent that, however.
The assert() clauses above should prevent that, however.
The associated type metadata is passed first so that this function is CC-compatible with a conformance's witness table access function.
The associated types inferred from matching this witness.
The assumed execution length of a function call.
The assumption here is that for builtins, the generated func contains only a single opcode (NativeImpl), and there are no non-argument locals.
The assumption is that every / initializer has the same size.
The assumption is that if fromType has larger elements, or additional elements, their presence cannot induce a more compact layout of the overlapping elements.
The assumption is that we / cannot deinitialize memory via projections.
The assumption we make is that 'args' and 'inoutArgs' were built up in parallel, with empty spots being dropped into 'args' wherever there's an inout argument to insert.
The asyncRetCtrl stub takes the return TV as its arguments.
The author of this software is David M.
The backtick is punctuation.
The backtracking also seemed a bit convoluted to do directly on the IR.
The base classes and members aren't always reported in DWARF in offset order, but make the output deterministic here to simplify consumers of the information.
The base expression is simply the metatype of the base type.
The base is passed at +0, so it isn't consumed.
The base may also legitimately be an object and our next base is in an object property.
The base must have a member of the given name, such that accessing that member through the base returns a value convertible to the type of this expression.
The base of a dynamic member reference cannot be an existential type.
The base of a member reference cannot be an existential type.
The base of a subscript cannot be an existential type.
The base value for every call: it represents the benefit of removing the / call overhead itself.
The baseList is non-empty, and the last element is this class.
The basic MD5 functions.
The basic block name is optional.
The basic block that we are optimizing.
The basic block this BlockState represents.
The basic blocks are visited in a random order.
The basic idea here is that we haven't constrained block layout based on the exception tree, but adjacent blocks are still reasonably likely to have the same ExnNode.
The basic idea is: length is bad, loops are good.
The basic implementation of the RemoteASTContext interface.
The basic value-witness table for ObjC unowned pointers.
The basic value-witness table for Swift object pointers.
The basic value-witness table for Swift unowned pointers.
The basic value-witness table for Swift weak pointers.
The basic value-witness table for empty types.
The basic value-witness table for function types.
The basic value-witness table for thin function types.
The beginning of the path might not be part of the cycle, so find where the cycle starts.
The benefit if a load can (probably) eliminated because it loads from / a stack location in the caller.
The benefit if a retain/release can (probably) be eliminated after / inlining.
The benefit if a store can (probably) eliminated because it stores to / a stack location in the caller.
The benefit if the condition of a terminator instruction gets constant / due to inlining.
The benefit if the operand of an apply gets constant, e.g. if a closure / is passed to an apply instruction in the callee.
The benefit of a onFastPath builtin.
The best path length we found.
The best we can do is assert that it's a subclass of Closure.
The best we can say is if the timer exists and fired and cancelled itself, we can clip to 0, otherwise just return the full timeout seconds.
The best-known return type of the function, if we have any information.
The better solution would be to require all variables to be described with a SILDebugValue(Addr) and then not describe capture list arguments.
The big data set should use out-of-line storage on any pointer width.
The bindings should be fixed-layout inside the object, so we can pass None here.
The bit count is dynamic.
The bit position is then used to set/reset the bitvector kept by each BlockState.
The bit position is then used to set/reset the bitvector kept by each g.
The block begins with an optional DefLabel, followed by an optional BeginCatch.
The block containing the checked_cast_br.
The block header is pointer aligned.
The block is implicitly emitted and filled in.
The block is not / automatically inserted into the function.
The block may be a side exit or a normal IR block, depending on whether or not the offset is in the current RegionDesc.
The block of the first input value compare.
The block storage consists of the block header (ObjCBlockStructTy) followed by the lowered type of the capture.
The block where we assume we can insert the deallocation.
The block which contains the cond_br of the input value comparison / or the block which assigns the default value.
The block will capture the original function value.
The blockAnalysis vector is indexed by post order id.
The body block must end in a noreturn call, return, break etc.
The body is actually emitted by SILGen
The body is runtime-dependent, so we can't put anything useful here statically.
The body of #if statements are not walked into, we need custom processing for them.
The body of topLevelDecl will get set later.
The body result cannot be 'none' unless it's an autoclosure.
The bool indicates whether fb_intercept has ever been called on a function with this name.
The bool, int, float, and string typenames are not given any special treatment by the parser and are treated the same as regular class names (which initially gets marked as type code 5).
The bottom line is that we can't really use ModulesInitialised() to help steer the choices here.
The box is going away so we need to release the stored value now.
The box tracks the offset to the value inside the box.
The box won't affect loadability or fixed-ness.
The boxed value can't be assumed to be uniquely referenced.
The boxed value may be shared, so we always have to copy it.
The branch emitted during irgen will deal with this
The branch may not be a Jmp, in which case there won't be a label
The branches must be convertible to a common type.
The breakpoint is deleted, so this has to be last
The breakpoint might have been removed while I'm waiting
The bridging operations are generic, so we need to form substitutions and compute the resulting type.
The buffer operations assume that the value is stored indirectly, because installCommonValueWitnesses will install the direct equivalents instead.
The builder used to create new instructions during register promotion.
The builtin opaque Objective-C pointer type.
The builtin types generally don't require metadata, but some of them have nodes in the runtime anyway.
The bump pointer allocator destructor will deallocate but not destroy all our independent TypeLowerings.
The byte order is still little endian but the word order is big endian.
The c-style-for loop and foreach-style-for loop are conflated together into a single keyword, so we have to do some lookahead to resolve what is going on.
The cache entries in a generic cache are laid out like this:
The cache is full or a collision occurred, and we don't need our strdup'ed key.
The cache of identifiers we've already looked up.
The cache should never fill up since tzinfos are finite.
The calendar was created in 46 B.C., but the details did not stabilize until at least 8 A.D., and perhaps as late at the 4th century.
The call explicitly populates the struct for dirs, but returns false for them because it is geared toward file includes.
The call from enterTCHelper() that got us into the TC was popped off the RSB by the ret that got us to this stub.
The call is 'dynamic' if the method is not of a struct and the receiver is not 'super'.
The call is a buffer allocation, e.g. for Array.
The call is like a struct(buffer) instruction.
The call node should still be marked as explicit
The call to expirePaths() cannot be safely omitted, because it would otherwise be possible for a symlink-induced cycle to keep some or all of the node tree alive.
The call to super.init has to either be an apply or a try_apply.
The call to the builtin should be replaced with the constant value.
The call to the builtin should get removed before we reach IRGen.
The call/function can only throw if one of the parameters in / the current rethrows context can throw.
The call/function can throw.
The call/function can't throw.
The call/function contains invalid code.
The callable should generate the proper instruction(s) to perform the comparison operation which matches the given opcode.
The callback gets the address of 'self' at +0.
The callback gets the value at +1.
The callback is a BB argument from the switch_enum.
The callback storage parameter on materializeForSet.
The callee for a super call has to be either a method or constructor.
The callee function my be a bitcast constant expression.
The callee function never returns.
The callee main blocks are therefore identified by walking the graph backwards from the InlineReturn and selecting each block encountered, terminating when the DefInlineFP is encountered.
The callee needs to be callable with FCallBuiltin, because NativeImpl requires a frame.
The caller / handles this case and does recovery as appropriate.
The caller has already determined that all Stores are to the same element within an otherwise dead object.
The caller is supposed to take responsibility for ensuring that 'self' survives a method call.
The caller must check for and / handle this case.
The caller must ensure that the source buffer is long enough that this routine does not run off the end and dereference non-existent memory looking for trail bytes.
The caller must have already opened the stream, and is responsible for closing it after finishing compression.
The caller must have already opened the stream, and is responsible for closing it after finishing decompression.
The caller of this function will use it to know whether it can avoid a generic incref, unbox, etc.
The caller will call this again with nullptr before destroying the given usage logger.
The caller will remove the copy_addr.
The caller/callee function which is tracked.
The calling convention and function representation can't be changed.
The calls to Array get_element that use this array allocation.
The calls to Array.count that use this array allocation.
The candidate list of an unresolved_dot_expr is the candidate list of the base uncurried by one level, and we refer to the name of the member, not to the name of any base.
The candidate-specific matching data and algorithms.
The canonical mangling signature removes dependent types that are equal to concrete types, but isn't necessarily parallel with substitutions.
The canonical type for a protocol composition canonicalizes the order of the protocols.
The capture list is not always initialized by the point we reference it.
The capture may be worse aligned.
The captures are represented as a placeholder curry level in the formal type.
The case statement can have multiple case items, each can have a where.
The case-exit will have left us in a normal insertion state (i.e. not a post-terminator IP) with nothing to clean up after.
The cast can't change the representation at runtime.
The cast functions don't know how to work with anything but the most general possible abstraction level.
The cast instructions don't know how to work with anything but the most general possible abstraction level.
The cast loads directly from the source address.
The cast may succeed if the target type can be inhabited by a class metatype.
The cast succeeds only if the metadata pointers are statically equivalent.
The cast takes the source reference.
The cast to (char *) in the following accommodates both implementations that use char* generic pointers, and those that use void* generic pointers.
The cast will load the reference from the source temp and store it into a dest temp effectively forwarding the cleanup.
The catch body just happens in the enclosing context.
The cell it pops can be marked Use::Not only if Dup itself can be eliminated.
The chaining operator immediately begins a formal access to the base l-value.
The change would only be tracked through one of / the allocations.
The character (space) used to separate alternate fonts in the fontlist parameter to gdImageStringFT.
The character after the slash is nothing special.
The character is lower case.
The character is title case.
The character is upper case.
The check above enforces an invariant that allows us to always know that m_nextKI is not present in the array, so it is safe to use findForNewInsert()
The check for little-endian architectures that tolerate unaligned memory accesses is just an optimization.
The check subscript call is no longer associated with another operation.
The check_subscript call was removed.
The checkers appear in argument order, so each one increments curSrc, and at the end we can check that the argument count was also correct.
The children are just the elements of the lowered tuple.
The chunks themselves get copied into the CodeCompletionString.
The class additionally may be weak-linked, so we have to check for null.
The class cannot be generic.
The class context must be the vtable's class, or a superclass thereof.
The class for building result plans.
The class has fixed size, so the field offset is known statically.
The class is defined in a generic context, so its superclass type may refer to generic parameters of the class or some parent type of the class.
The class may be ObjC, in which case we need to instantiate its Swift metadata.
The class must be defined in Objective-C.
The class must not have a superclass.
The class pointer is an unknown heap object, so it may be a tagged pointer, if the platform has those.
The class we're bridging through must be a subtype of the type we're coming from.
The class' instance property initialization template is in different places, depending on whether it has any request-dependent initializers (i.e. constants)
The clause matrix will be initialized with zero rows / and a column for every occurrence.
The cleanup is only active and installed when emitting the body of a defer, and it is disabled at the end.
The cleanup we pushed to deallocate the local variable before it / gets initialized.
The cleanup we pushed to destroy and deallocate the local variable.
The cleanup we pushed to destroy the local variable.
The client is asserting that infinite recursion is / not possible because it has relaxed a constraint on the system.
The client is expected to disable inlining for the region it gives us to peek.
The client process on the other end of the connection has either crashed or cancelled the connection.
The client should handle this, not pass it down to diagnoseInitError.
The client uses the prefix of the argument following the command name to narrow down the list displayed to the user.
The client uses the prefix of the argument following the command to narrow down the list displayed to the user.
The client will block until the server echoes this command back to it.
The client's current line is then updated to point to the last listed line.
The cloned start node shares the same dominator as the original node.
The closure is the first local.
The closure was from a trait, so we need a unique name in the implementing class.
The code below depends on cacheLookup having the right number of elements Push a dummy value even though we'll use the cacheID as an int instead instead of emitting a local
The code below is used for both, function/method parameter type as well as for function/method return type.
The code emission here assumes that we don't need to have active cleanups for all the result values we're not actively transforming.
The code in readSILInstruction assumes that such a situation means that fn is a declaration.
The code is generated according to the following principles:
The code path in handleSlowPath currently assumes we've ruled this out.
The code requires a 32-bit integer type, though.
The code we're jumping to expects to find a return address in x30, and a saved return address on the stack.
The code-completion kinds are a good match for the semantic kinds we want.
The collection object itself is increfed.
The column with the most pattern nodes prior to a wildcard turns out to be a good and cheap-to-calculate heuristic for generating an optimal decision tree.
The combined READER/HANDLER
The command failed, try to find an error message
The common case: there is a single output file.
The common cause is that the operand is not an lvalue.
The common spare bits actually used for a tag in the payload area.
The compare function for instruction operands.
The comparison above is just to short-circuit the overhead when the Classes are an exact match.
The comparison was ambiguous.
The compiler and execution environment for the REPL.
The compiler should already have initialized these.
The compiler specializes the two-arg version of min() and max() into an HNI provided helper.
The compiler will reject actual uses.
The compiler will use a nil reference as a way to avoid allocating memory for boxes of empty type.
The complete set of substitutions may be different, e.g. because the found witness thunk F may have been created by a specialization pass and have additional generic parameters.
The computations that follow attempt to 'best guess' the indentation and new lines so that the user doesn't have to add any whitespace.
The concat helpers incref their results, which will be consumed by the stloc.
The cond_fail must post-dominate the predecessor block.
The condition of a foreach loop can be parenthesized.
The conditional cast still needs its branch destinations.
The conditional expression must conform to LogicValue.
The configuration command line strings were already processed above Don't process them again.
The conflict checking is fairly conservative, only / considering rough structure.
The conformance checker we're using.
The conformance must be complete, or we can't serialize it.
The conformance to _BridgedToObjectiveC is statically known.
The conformance will be on the containing 'self' type, or '()' if the property is in a non-type context.
The conformances should be all abstract or all concrete.
The connection is blacklisted, but we've reached our ping interval so lets remove the blacklisting and pretend we didn't know about it
The connection is the one we're looking for
The conservative scans may have added more items to the worklist, so drain it again.
The const_cast is ok because we fully own the array, with no sharing.
The const_cast is safe because we escalated the array.
The constant tracker of the caller function (null if this is the tracker of the callee).
The constants table is used to inline values for expressions See ClassConstantExpression::preOptimize.
The constrained type can only be a generic parameter or an associated type thereof.
The constraint is valid blocks dominated by this block.
The constraint solver depends on multiple constraints being present in this case, so it can generate the appropriate lvalue wrapper for the argument type.
The constraints themselves never fail, but they help deduce type variables that were opened.
The constructor for this class, if we know what it is.
The constructor must be declared within the class itself.
The constructor was opened with the allocating type, not the initializer type.
The constructors are only found on the metatype.
The content of the destination address.
The context field of a thick function is a Builtin.NativeObject.
The context for emitting the r-value.
The context for reabstracting the r-value.
The context for the code we're running.
The context into which the subscript should go.
The context is in the highest slot.
The context is modeled exactly like a native Swift / class reference.
The context keeping the parameter alive.
The context type must be a tuple.
The context where the constant will be introduced.
The contextual inout marker is part of argument lists.
The continuation block
The control block is malformed until we've at least read a major version number.
The convention didn't provide a source of the metadata, so we'll want to check the necessary bindings structure to see if it was stored there (it most likely is).
The convention for general deallocators.
The convention fulfills the requirement, so record how to get to the metadata.
The conversion destination of throw is always ErrorType (at the moment) if this ever expands, this should be a specific form like () is for return.
The conversion may be a no-op if the right operand is already a bool.
The conversion may be a no-op if the right operand is already a double.
The conversion may be a no-op if the right operand is already an int.
The cookie must have a non-empty "name" and a "value"
The copy's dest must be an indirect SIL argument.
The copy_addr doesn't provide any values, but we've arranged for our iterators to visit the newly generated instructions, which do.
The copy_addr instruction is both a load and a store.
The core of the algorithm: Mark functions as alive which can be reached from the anchors.
The corresponding load-projection must match the store-projection.
The corresponding value witness from which the type witness / was inferred.
The count is always 1 unless the substituted type is a tuple.
The count is the second argument.
The count of the allocated array.
The countedness or possible-emptiness of the arrays is handled outside of this function, so it's ok to just return TArr from all of these here.
The critical / thing here is that performing an operation involving archetypes / is dependent on the witness binding we can see.
The current basic block contains concrete value for part of the location and covering values for the rest.
The current basic block contains concrete values for the entire location.
The current basic block contains covering values for the entire location.
The current continuation level reverts to the level of the one we're seeing.
The current function ID.
The current function to be optimized.
The current heuristic we use for translation chaining is to assume the most common cases are probably translated first, so we chain new translations on the end.
The current instruction being simplified is always at insts.top().
The current instruction doesn't have a catch block so it'd better not throw.
The current location is initially determined by the breakpoint where the debugger is currently stopped and can thereafter be modified by list commands and by switching the the stack frame.
The current piece of subject
The current stored values at memory addresses.
The current token did not end with e.g. a "."
The current token is no valid hexadecimal digit
The data flow has stabilized, run one last iteration over all the basic blocks and try to remove dead stores.
The data is gathered in thread local storage.
The data occupies the entire payload.
The dead store elimination context, keep information about stores in a basic / block granularity.
The dead stores in the current basic block.
The dealloc_stack of an alloc_stack must be in the loop, otherwise the dealloc_stack will be fed by a phi node of two alloc_stacks.
The deallocating destructor is always auto-generated.
The deallocation Instruction.
The debugger may choose to hold the thread below here and execute any number of commands from the client.
The debugger synthesizes typealiases of unbound generic types to produce its extensions, which subverts bindExtensionDecl's ability to create the generic parameter lists.
The debugger will execute any logic needed to handle the event, and will block below this to wait for and process more commands from the debugger client.
The decl is captured normally, even if it was captured directly in the subclosure.
The decl that has the raw value.
The declaration from the module.
The declaration must have a parameter.
The declaration of ObjectiveC.ObjCBool.
The declaration of Swift.Any.
The declaration of Swift.Bool.
The declaration of Swift.Double.
The declaration of Swift.Float.
The declaration of Swift.Int.
The declaration of Swift.OpaquePointer.
The declaration of Swift.OptionSet.
The declaration of Swift.String.
The declaration of Swift.UInt.
The declaration of Swift.Void.
The declaration we found must be exposed to Objective-C.
The declarations are in different source files (or unknown source files) of the same module.
The declared properties in the resultant array should be a permutation of propVec.
The declared variable(s) for the current element are destroyed at the end of each loop iteration.
The decls-and-types block is lazily loaded.
The default Swift conventions.
The default assumption is that inouts are read-write.
The default behavior in PHP is to auto-prime generators.
The default conventions for ObjC blocks.
The default conventions for Swift initializing constructors.
The default driver kind is determined by Name.
The default initial size is a power-of-two minus 1.
The default of "true" here is correct -- see autoTypecheckRequestInit().
The default on linux for the newly allocated memory is read/write/exec but on some systems its just read/write.
The default std::terminate() handler in some C++ runtimes tries to print details of the exception or maybe even a stack trace.
The default value of the AllocStack is NULL because we don't have uninitialized variables in Swift.
The default zero initializer suppresses the implicit value constructor that would normally be formed, so we have to add that explicitly as well.
The defaulted protocol associated with this binding.
The deinit of a box does not capture its content.
The deinit of an array buffer does not capture the array elements.
The dependency module could not be loaded.
The dependent generic signature.
The depth of this currently-opened existential.
The depth of uncurries that we have seen.
The derived method may require thunking to match up to the ABI of the base method.
The derived type that is making the super call is resilient, for example we may be in an extension of a class outside of our resilience domain.
The deserializer caches functions that it deserializes so that if it is asked to deserialize that function again, it does not do extra work.
The design is that the compiler will emit a load of this / pointer, and the linker will ensure that that pointer is unique.
The dest of the CheckType (which would've been Bottom) is now never going to be defined, so we return a Bottom.
The dest's will be erased at the end of the pass.
The destination BB can take the argument payload, if any, as a BB arguments, or it can ignore it and take no arguments.
The destination BB must not have BB arguments.
The destination always wants a +1 value, so make the source +1 if it's a scalar.
The destination block for a 'fallthrough' statement.
The destination index, if any.
The destination is of the expected type.
The destination must be the header of its loop.
The destination object is made permanent so that multiple JPEG images can be written to the same file without re-executing jpeg_stdio_dest.
The destination of these instructions is somewhat counter intuitive so we take care to ensure that we step to the most appropriate place.
The destination protocol.
The destination type is nontrivial, and may be smaller than the source type, so RC identity cannot be assumed.
The destruct functions below all arbitrarily take RefData* as an example of a refcounted object, then just cast to the proper type.
The destructor doesn't need to do anything, the CC's destructor will pop the context if we set it.
The destructor in turn can cause arbitrary side effects.
The destructor must be out-of-line in order to trigger generation of the vtable.
The details are unknown, but the lengths of the months were adjusted until they finally stablized in 8 A.D.
The difference with FPushClsMethod is what ends up on the ActRec (late-bound class), which we currently aren't tracking.
The difficult case is when you have an argument with /multiple/ predecessors.
The direct check for SubstitutableType works because only class-bounded generic types can be passed directly.
The directory itself was modified, so invalidate its cached stat structure.
The distance can be zero due to the "with" transformation above.
The distances for a block in it's scope (either loop or function).
The documentation for connect() says in case of non-blocking connections the select function reports success in the writefds set and failure in the exceptfds set.
The documentation says a read filter is only created for 'r' and '+' modes, but the implementation will always create one unless STREAM_FILTER_WRITE is passed.
The dominating exact cast was successful, but it casted to a different type.
The downside is that we may return stale information, but we get the benefit of increased responsiveness, since the request will not be blocked waiting on the AST to be fully typechecked.
The driver kind must be parsed prior to parsing arguments, since that affects how arguments are parsed.
The dynamic function pointer is packed "last" into the context, and we pulled it out as an argument.
The dynamically unknown case is the interesting one, handle it below.
The easiest case is if we're going to use all of the available payload tag bits (plus potentially some extra bits), because we can just straight-up use CommonSpareBits as that bitset.
The easiest way to do this is include a hash of the filename.
The easy path here is if we don't need to use an addressor.
The echoed command is discarded.
The edges in the dependency graph, i.e. entries, which depend on this / entry.
The effect an instruction can have on array bounds.
The effects for the first case are generally handled in the miFinal op functions.
The element is transferred into the array (should already be incref'd).
The element type must conform to NSCopying.
The element will be resolved when we type-check the pattern.
The elements are assigned discriminators ABI-compatible with their raw values from C.
The elements are assigned discriminators in declaration order.
The elements are pushed on the stack, so we arbitrarily limit this to a small multiple of MixedArray::SmallSize (12).
The elements are returned as an / AvailabilitySet.
The else branch does *not* see these variables.
The else branch, if any, is outside of the scope of the condition.
The emitter associates object access with the subsequent expression and this would be difficult to modify.
The emitter should never generate bytecode where the iterator is at the end before IterNext is executed.
The empty compiler version represents the latest possible version, usually built from the source repository.
The empty tuple type has a singleton metadata.
The end of the ordinary section is just the end of the function unless postmatter blocks exist.
The end of the postmatter section is always the end of the function.
The entire series of modifications is a series of 10 identical double-rounds.
The entity is available.
The entity is mangled in its own generic context.
The entry block must not have any predecessors.
The entry block starts with a DefFP instruction.
The entry is keyed by the least derived method.
The entry point builder that is used to construct ARC entry points.
The entry point to the transformation.
The enum constant goes into the redeclaration context of the enum.
The enum has the alignment of the payload.
The enum has the worst alignment of its payloads.
The enum must not have associated values.
The enum value is either passed as an extra argument if we are moving an retain that does not refer to the enum typed value - otherwise it is the argument to the refcount instruction.
The enumeration was mapped to a high-level Swift type, and its elements were created as children of that enum.
The enumeration was mapped to a struct containing the integral type.
The enumeration was simply mapped to an integral type.
The env.setLoc here handles dealing with a parameter that was already known to be a reference.
The epilog takes a void return because the return of 'self' is implicit.
The epilogue release matcher we are currently using.
The epilogue release matcher we are using.
The epoch (first day of the first year) is 22 September 1792 in the Gregorian calendar.
The error at a given pixel is propagated to its not-yet-processed neighbors using the standard F-S fractions, ...
The error convention provides the result type.
The error_code is cleared, otherwise the caller will read the last error message from the driver.
The eval stack is also dead at this point (the return value is passed to ReturnHook as src(1), and the ReturnHook may not access the stack).
The event hook has already cleaned up the stack and popped the callee's frame, so we're ready to continue from the original call site.
The event queue overflowed, so all bets are off.
The exact naming is Y'CbCr, following the ITU-R BT.601 standard.
The exact static type of the instance should be tested first.
The exception cleanup should be getting forwarded around correctly anyway, but push a scope to ensure it gets popped.
The exception is C functions imported as methods.
The exception to that are option types with data, objects/classes, and arrays.
The exception was either handled, or a catch or fault handler was identified and the VM state has been prepared for entry to it.
The exception was not handled in this nesting of the VM---it needs to be rethrown.
The exclusivity of the lower bound means we know we're just cancelling out something that raised the lower bound on this set and no other, so the state on other sets can't be affected.
The executor is guaranteed to be valid for the duration of the task because: 1.
The existential conforms to AnyObject if it's class-constrained.
The existential container is class-constrained if any of its protocol constraints are.
The existential value being opened.
The existing BreakPointInfo objects may include non empty values for m_stack.
The exited process was a light process.
The expression that will be wrapped by a RebindSelfInConstructorExpr / node when visited.
The expression type must conform to the Sequence.
The ext_libxml extension is the only XML extension that should be storing streams in the MemoryManager since it has no other place to safely store a req::ptr.
The extra args are the request type and the stub address.
The extra byte is for the tag.
The extra data for the InterpOne comes with some additional information about which local(s) it may modify, which is all we try to be more precise about right now.
The extra layer of locking is here so that InstanceBits::init can safely iterate over s_instanceCounts while building its map of names to bits.
The fact that the type will be slightly off is ok because all the code after the Jmp is unreachable.
The fact that this is *directly* be a reference storage type cuts the code down quite a bit in getTypeOfReference.
The fact that we do not use an atomic operation here means that we could get a stale read, but in practice that poses no problems for how we are using the value.
The factored exit list contains unique elements.
The failed type witness result.
The failure callback may have defined a class or type alias for us, in which case we're done.
The failure function can do anything, including something like like raising an error or rebuilding the map.
The fall-through case.
The fallback translation is where to jump to if the currently-translating translation's checks fail.
The fault blocks should all have factored exits to parent catches/faults, if there are any.
The fg and bg colors must already be in the color table for palette images.
The field of the member.
The field should not be anonymous, since we are using its name to derive the generated declaration name.
The files are stored in the same / same directory as the main output file.
The final 7 bits of all VEX/XOP prefixes are the same:
The final case is a PureStore to an unknown location (either because it was not supplied a AliasAnalysis id, or because it stored to something like a PtrToGen that could refer to anything in memory).
The final null terminator is provided by getAddrOfGlobalString.
The final result will be added to the first context.
The final two entries in the list are the basic block destinations.
The final two values in the list are the basic block identifiers.
The finalizer on hybridData calls resetNative which will delete the object, if reseetNative has not already been called.
The first 59 days of the year are the same regardless of the length of the year.
The first N are the use vars.
The first Pred must have at least one non-terminator.
The first argument is the object being destroyed.
The first axis deals with special behavior of fixed-size loadable and address-only enums.
The first body parameter pattern for a constructor specifies the "self" instance, but the constructor is invoked from outside on a metatype.
The first cases apply because final operations are going to directly affect the type of these elements.
The first category for a class in a module gets the module's / name as its key, e.g., NSObject (MySwiftModule).
The first causes a transition to the end-of-buffer state.
The first character in the file is not left-bound.
The first child is always a kind that specifies the type of param that we have.
The first component uses unqualified lookup.
The first element is the selector.
The first entry is always the weak*.
The first few bad arcs typically point at the problem, so report them.
The first instruction of the exit-block is part of the frontier.
The first is to report the value of a pointer at a certain offset.
The first list index given out is always 1.
The first metonic cycle starts with Jewish year 1, or 3761/60 B.C.
The first non indirect result is the closure.
The first non-index element address encountered pushes an "zero index" address node to represent the implicit index_addr #0.
The first not indirect result argument is the closure.
The first page is the root object, which will be invalidated when it is deleted.
The first pass, m always is 0, so no_read becomes 1 in the first pass.
The first pattern entry we parse will record the location of the let/var/case into the StmtCondition.
The first result is the array value.
The first step of processing an element is to collect information about the element into data structures we use later.
The first thing we have to do is get the type.
The first thread to hit an interrupt becomes the current thread, and all others block until the current thread is done with its interrupt.
The first time this unit is merged, if the classes turn out to be all unique and defined, we replace the PreClass*'s with the corresponding Class*'s, with the low-order bit marked.
The first time through, we've counted up weak uses of the frame and then finally marked it dead.
The first time we don't need to check for release.
The first two cases are simple to handle, whereas the partial case requires dynamic codegen based on the liveness bitmask.
The first two parameters are pointers, and we make some simplifying assumptions.
The first type argument for Dictionary or Set needs to be NSObject-bound.
The first type conforms to the second
The first type is a subclass of the second.
The first type must be convertible to the constructor's argument type.
The first type needs wrapping in a closure despite already being a function type.
The fix is to add a lock to HttpServer::Server but it seems like overkill.
The fix is to check if genericArgs exist in the Decl's Archetypes, if they all exist, we use indices to the Decl's Archetypes..
The fixupWork() looks for a TC frame, and we never call fixup() directly from the TC, so skipping this frame isn't a problem.
The flag for this is in the VM's normal ThreadInfo, but we don't have a way to get that given just a tid.
The flags argument describes the behavior in cases where the named property is nonexistent or inaccessible.
The flattening of traits may result in requirements migrating from the trait's declaration into that of the "using" class.
The float won't be larger than 1e15 anyway.
The flow cmd has determined that it is done with its work and doesn't need to remain for later processing.
The following EBCDIC-to-ASCII table may relate more closely to reality, or at least to modern reality.
The following StringRefs are owned by FuzzyStringMatcher and must outlive this object.
The following assertions come after the above, because if the tree is totally clobbered it's easy for the wrong ones to fire.
The following comes from malloc_extension.cc in google-perftools
The following constants define the cost model for inlining.
The following consume some arguments only in the event of an exception.
The following definition of Storeinc is appropriate for MIPS processors.
The following environment variables can be used to turn up the number of combinations.
The following fields of cursor are used: - ns - opts - skip - limit - query - fields
The following functions make DArr* structs out of static arrays, to simplify implementing some of the type system operations on them.
The following getContentNode() will create a new content node.
The following have the old CRc flag, but don't observe or consume from this module's perspective.
The following instructions are used for debugging memory optimizations.
The following kinds correspond to SIL non-address values.
The following libraries are required to build a satisfactory static program
The following license applies:
The following mappings are used if this is a compilation in scripting mode and global variables are accessed without addressors.
The following may re-enter, and also deal with a stack slot.
The following methods should only be attempted if we can sink to our successor.
The following php_mt_...() functions are based on a C++ class MTRand by Richard J.
The following pop and push instructions ensure that the arguments are place on the symbolic stack in a correct order.
The following static assertions should ensure `kMaxStringSimpleLen' has the properties we want.
The following structure contains the information associated with a character set.
The following terms apply to all files associated with the software unless explicitly disclaimed in individual files.
The following two lines are equivalent to popm lower.
The following types exist primarily for internal use by the type checker.
The following vasms reemit other vasms.
The for-each statement.
The formal / dynamic type ignores dynamic subclasses such as those introduced / by KVO.
The formal metatype parameter to a C function imported as a static method is dropped on the floor.
The formal type is just that with the right representation.
The format of this hash is md5(PID,PASSWORD,USERNAME).
The former is a release of a class in an initializer, the later is used for local variable destruction.
The found init value is different from the already seen init value.
The fpValue, irSPOff, and curFunc are not cleared because they must agree at bytecode-level control-flow merge points (which can be either merge points at the bytecode or due to retranslated blocks).
The frame may span a call if it could have done so in either state.
The full metadata is used based on the visibility of the address point, not the metadata itself.
The full metadata object is private to the containing module.
The function accepted ownership.
The function already returned.
The function calls an unconditionally throwing function.
The function containing the initialization code.
The function doesn't exist yet.
The function has no unidentified releases, so let's look at the arguments in detail.
The function in the current module will be changed.
The function is 'rethrows', and it was passed a default / argument that was not rethrowing-only in this context.
The function is 'rethrows', and it was passed an explicit / argument that was not rethrowing-only in this context.
The function is always an rvalue.
The function is dead, but we need it later (at IRGen) for debug info or vtable stub generation.
The function may release this argument, so check if the pointer can escape to it.
The function prologue is where the stack frame is set up and storage for local variables and function arguments is initialized.
The function reference and call file/line are stored when tracing/profiling on function enter
The function reference.
The function return type is the first element in the list.
The function returns false if the reply to the client fails during the sending process.
The function that we are optimizing.
The function that we are processing.
The function throws unconditionally.
The function type for swift_bufferDeallocateFromStack.
The function we are currently processing.
The function's formal parameters are on the stack
The function's native representation.
The function/enum case must be callable with the given argument.
The function_ref needs to be invariant.
The functions below with names "couldBeIn*" detect the second case.
The functions we used to simplify the CFG put things in the worklist.
The fundamental issue here is that since we do not have any notion of size, we cannot know the effect of a cast + gep on the final location that we are reaching.
The funny approach here is to validate the translator's assembly technique.
The gen set accumulates the set of variables in the block with upward-exposed uses.
The general structure of a generic metadata.
The generated name / is derived from the name of the field in the outer type.
The generation count at which this list was last updated.
The generator doesn't know how to get the base class from the derived (though in theory this could be inferred from the debug information), so punt and make the user specify a custom base scanner.
The generator itself is still holding a reference to them though, so null out the key/value to free the memory.
The generic context is currently re-specified by the type mangling.
The generic fast/slowPath calls are frequently only inlined one level down to _branchHint before inlining the call sites that they guard.
The generic function currently always requires indirection, but pointers are always loadable.
The generic function signature is complete and well-formed.
The generic parameter 'Self'.
The generic parameter list itself.
The generic signature filter.
The generic signature for a witness method with abstract Self must have exactly one protocol requirement.
The generic signature is complete and well-formed.
The generic type parameter (depth, index) serves as the key to the metadata source map.
The genset keeps a list of upward visible stores / and the killset keeps a list of LSLocation this basic block reads (kills).
The getRawValueExpr should remain the untouched original LiteralExpr for serialization and validation purposes.
The getter checks the optional, storing the initial value in if nil.
The getter is mutating if the behavior implementation is, unless we're in a class or non-instance context.
The getter selector is the property name itself.
The getter/setter types are different.
The given callable is invoked with the adjusted (if any) opcode to use.
The given type should use opaque type info.
The global DCE performs a liveness analysis and then uses this information to allow dead stores to locals to be eliminated across blocks.
The global MCGenerator object.
The global initializations are in SIL.
The global will exist only if the abstract type has concrete layout, so if we're not laying out the abstract type, use its access rule.
The goal is discoverability of #os() (via the diagnostic and Fix-It) rather than magically fixing the code in all cases.
The goal is to call a `targetFunction' that is overloaded on the extra data type structs.
The goal is to obtain an order that improves locality when the function is executed.
The goal is to sink IncRefs past Check* and Assert* instructions that may provide further type information to enable more specialized IncRefs (or even completely eliminate them).
The goal of the scanner generator is find the maximal set of pointer followable types, use those to compute the layout of each indexed type, then output those layouts in the form of C++ code.
The grammar syntactically requires a simple identifier for the variable name.
The graphs are constructed after first computing information that allows us to process each must-alias-set independently.
The group info file does not exist.
The handle, if non-null, is effectively +1.
The handshake is different when entering at a func prologue.
The hardware counter is only 48 bits, so reset this at the beginning of every request to make sure we don't overflow.
The hardware counter will then measure time for that thread, and all its children - which is exactly what we want.
The head structure has a pointer to the most-recently-used element, and elements are moved to this position in the list each time they are used.
The header needs to exit the loop.
The heavy lifting happens when visiting expressions.
The helper function will populate indexChains.
The heuristic is that double-quoting is unnecessary unless the string contains an apostrophe, a comma, or backslash (other than backslash-backslash).
The high level algorithm is that via the loop info we already know for / each subloop: / / 1.
The higher-level start logic will try *very* hard to recover from this.
The hint was self or parent and there's no corresponding class for the current func.
The human readable name returned / by swift_getTypeName() is non-unique, so we used mangled names / internally.
The i.s already comes converted to FP
The idea is to generate the function body right after calling this function, so that all prologues are placed right before it, and with the hottest prologues closer to it.
The identifier could be a name or it could be a type.
The identifying information for a generic parameter.
The immediate arguments must be last.
The immediate dominator of a successor of this block needn't be this block, but it has to be something which dominates this block.
The immediate is 32 bits, sign-extended to 64.
The implementation F (the implementing method) which was found may have a different set of generic parameters, e.g. because it is implemented by a class D1 derived from B.
The implementation here / depends on the underlying reference type.
The implementations below produce reasonably good machine code that is comparable to the machine code for strcasecmp from glibc 4.4.0.
The implications of this include not being able to break an expression over multiple lines in an interpolated string.
The implicit 'self' argument if in a type context.
The implicit value/buffer parameter.
The importer maps builtin types like 'int' to named types like 'CInt', which are generally typealiases.
The index into the source file's Decls at which to start / irgenning the next REPL input.
The index into the source file's Decls at which to start / typechecking the next REPL input.
The index of the first "physical" parameter from paramTys/FI that corresponds to a logical parameter from params.
The index of the subscript is evaluated as an rvalue.
The index of the target row.
The index of this child, used to project it out.
The index types match.
The individual optimizations called here are expected to change block boundaries and potentially add new blocks.
The inferred availability required to access a group of declarations / on a single platform.
The info for the parent of this Class.
The information we need to record in generic type metadata / is the information in the type's generic signature, minus the / information recoverable from the type's parent type.
The inhabitant is an invalid pointer.
The initial buffer size is 0
The initial code size
The initial size is arbitrary, we just guess 80 characters per line
The initial state of this live set depends on whether we are performing global or local DCE, and in the local case includes all locals in the function.
The initializer for a global variable.
The initializer for an enum element.
The initializer for an instance variable.
The initializer is its own entity whose context is the variable.
The initializer is just a pointer to the method name.
The initializer must have a single, non-empty argument name.
The inline Func* might be null if it was uncacheable (not low-malloced).
The inline cache is a 64-bit immediate, and we need to atomically set both the Func* and the Class*.
The inline cache is guaranteed to be set only once, but the one-way request-local method cache is updated on each miss.
The inline cache is set up so that we always miss initially, and take the slow path to initialize it.
The inlining decision could be smarter but this is enough for now since we never emit guards in inlined functions (t7385908).
The innermost M levels of optionals on the operand are reflected in the requested destination type, so we should map these nils into the result.
The inout arguments which feed this tuple element.
The inout must reference dereferenceable memory of the type.
The inout self is just loaded to produce a value in this case.
The input / SILFunction can either be an empty declaration or null.
The input is exploded and the output is an optional tuple.
The input is exploded and the output is not.
The input may have witness tables or other additional data, but the class reference is always first.
The input type is (T.Type, Builtin.RawPointer, Builtin.RawPointer, Builtin.Word).
The input type is (T.Type, Builtin.RawPointer, Builtin.Word).
The input value or null if it is the default case.
The inputs vector is only used for deciding when to break the tracelet, which can never happen for these cases.
The insert into seen wasn't successful.
The insertion point is left in the block where the / condition has matched and any bound variables are in scope.
The instance type field of MetatypeMetadata is immediately after the isa field.
The instance type is not a SIL type.
The instance type of a metatype is always abstract, not SIL-lowered.
The instance type of an existential metatype must be either an existential or an existential metatype.
The instr-profiling pass in llvm typically sets the function name ptr's section.
The instruction can be legally replaced with a Jmp to either its next or taken edge.
The instruction was a pure load, and its value was known to be available in `knownValue', with best known type `knownType'.
The instruction we are lowering has an argument which is different for each predecessor.
The instructions in between that were weak uses may need modifications now that their frame is going away.
The intent behind this definition is that it'll catch any uses of REJECT which flex missed.
The intent was to create a new calendar system that was based on scientific principals, not religious traditions.
The intention is the caller would include other information they care about in the tail of the array so they can decide how to act on the potentially-now-queryable descriptors.
The interesting cases are already handled above.
The interpOne functions are fat wrappers around the iop* functions, mostly adding a bunch of debug-only logging and stats tracking.
The interpreter will have popped the pre-live ActRec already, so we can just return to the caller after syncing the return regs.
The intersection finding technique of this code could be improved by remembering the previous intertersection, and by using the slope.
The intersection is thus Bottom.
The intrinsic must refer to the function profiling name var, which is inaccessible during SILGen.
The intrinsic takes its parameter indirectly.
The invalid context cannot access protected or private methods, so we can fail fast here.
The invariant is that this is always zero-initialized, so we don't need to do anything extra here.
The invariant is that this iterator starts a path from source and that sourceKey is correctly describes it.
The invariant on the out-parameter is that it's always zeroed, so there's nothing to do here.
The invoke method is only cached in the Class for a fast path JIT translation.
The invokeFunc below will get very confused if this is the case, since it will be using a varEnv that belongs to the wrong function on the stack.
The isa is the metaclass pointer for the root class.
The iterator decl is built directly on top of the sequence expression, so don't visit both.
The kernel removed the directory watch, either as a side effect of directory deletion, or because inotify_rm_watch() was explicitly called during Node destruction.
The key idea behind this concept is that we can keep lower bounds higher than we would otherwise be able to by tracking at least some of the pointers to the object that may be in memory.
The key is a load instruction, the value is the corresponding store instruction which stores the loaded value.
The key is the base address of the memory (after skipping address projections).
The key of this map is the source of the dependency (inst_a), the value is the destination (inst_b).
The key thing to notice is that in general this cannot happen due to critical edge splitting.
The key thing to remember is that an enum is address only if any of its cases are address only.
The kill set is the set of variables the block will re-define, ignoring exceptional control flow.
The killBeforePEI set is the set of variables killed before a PEI.
The kind of adjustment.
The kind of bindings permitted.
The kind of bindings that are permitted.
The kind of initializer to import.
The kind of literal binding found.
The kind of variance (none, covariance, contravariance) to apply / when comparing types from a witness to types in the requirement / we're matching it against.
The kinds of TypeInfos implementing struct types.
The kinds of overload choice match, but the contents don't.
The l-value type is the result of applying substitutions to the type-of-reference.
The labels are in scope for both the 'do' and all of the catch clauses.
The larger it is the more important it is to / inline
The last component of the path *could* be a database name.
The last extension that was included within the member lookup table's / results.
The last instruction must be isBlockEnd() and the middle instructions must not be isBlockEnd().
The last is to invoke a custom function (with a certain symbol), passing a pointer formed by the offset as the first parameter (which serves as the this pointer).
The last multiplication could overflow.
The last multiplication could underflow.
The last one to fail will delete us.
The last param noQuotes indicates to serializer to not put the output in double quotes (used when printing the output of a __toDebugDisplay() of an object when it is a string.
The last part is the salt string.
The last pcre error code is available for the whole thread.
The last release_value or strong_release instruction before the deallocation.
The last three are handled automatically by generic attribute validation -- for the first one, we have to check FuncDecls ourselves.
The last two "parts" can at most be ARG_LIMIT and MSG_LIMIT which we need not examine.
The last user should delete it.
The last witness is computed dynamically at instantiation time.
The latter is needed because for certain multiple inputs to the buggy algorithm there exist easily found inputs to the correct algorithm that produce the same hash.
The latter should never happen.
The layout of an existential buffer.
The layout of standard containers depends on whether the existential is class-constrained.
The layout of the container depends on whether it's class-constrained or a special protocol.
The layout of this struct is CrashReporter ABI, so there are no ABI concerns here.
The leftmost of imeth's contiguous trailing optional parameters must start somewhere to the right of this parameter (which may be the variadic param)
The length is lowered as an integer_literal.
The length of the block itself.
The length of the key.
The length of the transcoded string in UTF-16 code points.
The length of the transcoded string in UTF-8 code points.
The let/var pattern is part of the statement.
The level is a number we have to keep the lower_bound above to avoid changing program behavior.
The level of 'switch' nesting.
The lexer likes null-terminated data.
The libxml_streams_IO_nop_close callback does nothing.
The license and further copyright text can be found in the file LICENSE.TXT at the root directory of the distribution.
The licensing information for MurmurHash as specified on its website, http://sites.google.com/site/murmurhash/, is as follows: "For business purposes, Murmurhash is under the MIT license.
The lifetime ends if we have a live block and a not-live successor.
The limit for passing a list of files on the command line.
The limit is just there to not run into an infinite loop in case of an unreachable CFG cycle.
The line number is assumed to be valid in the unit.
The line numbers we output are bogus, but it's not totally clear what line numbers to put.
The lineFocus and and charFocus parameters are non zero only when the source location comes from a breakpoint.
The linkage of a template is the most restrictive linkage of its original linkage and the linkage of its template parameters.
The linkage of template instantiations need to be fixed up depending on the linkage of its template parameters.
The list of first level projections that Arg can be split into.
The list of identical instructions.
The list of instructions whose evaluation resulted in error or warning.
The literal expression has this type.
The live out information of the block.
The liveIn computation also depends on the liveOutExn state, so again reschedule if it changes.
The liveOut state is the union of liveIn states of each normal successor, and liveOutExn is the union of liveIn states of each exceptional successor.
The liveOutExn sets only take part in the liveIn computation when the block has factored exits.
The llvm IR did not change.
The load can only be a take if the base is a +1 rvalue.
The load instruction must have no more uses left to erase it.
The load must be post-dominated by the builtin.
The loadInst can be either a real load or a copy_addr.
The local DCE algorithm addresses dead eval stack manipulations and dead stores to locals that are visible within a single basic block.
The local variable decl being initialized.
The local variables YYSIZE and YYSTACKSIZE give the old and new number of elements in the stack, and YYPTR gives the new location of the stack.
The locals are already gone.
The location is untracked.
The location of this diagnostic points to the beginning of the first / token that the parser considers invalid.
The locations for the subscripts are almost certainly SubscriptExprs.
The locations where the error started and ended.
The locator we're using.
The logic above ensures that the first slot is not a tombstone, so it's safe to set m_pos to 0.
The logic above possibly moved elements and tombstones around within the buffer, so we make sure m_pos is not pointing at garbage by resetting it.
The logic of `scaledIdx * 16` is split in the following two instructions, in order to save a byte in the shl instruction.
The logic used here for reading POST data buffers is mostly borrowed from proxygen server.
The longer term fix is in review D2099778, but we want that to simmer in Master for a while and we need a hotfix for our current 3.6 LTS (Github Issue #4993)
The longest anonymous name
The longest property name we use in an uploaded file array
The longest run of digits wins.
The lookahead symbol.
The loop / might contain early exits so this is the maximum if no early exits are / taken.
The loop associated with this header consists of all nodes reachable in the reverse CFG from its back-edges's sources before the header.
The loop below will correct for any error in this estimate.
The loop terminates when a command is executed that causes the machine to resume execution, or which should cause the client to exit.
The loop will advance 'i' again.
The lower bound must be tracked conservatively to ensure that our transformations are correct.
The lowered type is the formal type, but uncurried and with parameters automatically turned into their bridged equivalents.
The lowered type must be the properly-abstracted form of the AST type.
The lowered type should be an LLVM struct comprising the block header (IGM.ObjCBlockStructTy) as its first element and the capture as its second.
The lowest log level we get from JS is 0.
The lvalue or rvalue representing the argument source of self.
The m_savedRip will be set during the call to doFCallArrayTC.
The magic number is stored to make sure bad values do not cause us to allocate bogus or extremely large amounts of memory when encountering an object with the new format.
The main AA entry point.
The main REPL prompt string.
The main class for parsing a demangling tree out of a mangled string.
The main entry point for the optimization.
The main entry point is also a basic block start.
The main entry point of the optimization.
The main entry point to the optimization.
The main execution loop of DebuggerClient.
The main frame is never destroyed unexpectedly, but child frames can go away for all sorts of reasons.
The main loop for this pass.
The main motivation for this is to generally eliminate the need for a separate stack pointer (the result of HHIR's DefSP instruction, which will just be an lea off of the rvmfp() physical register).
The main point of the merging algorithm is to map each content node in the source graph to a content node in this (destination) graph.
The main problem here is when the non-payloaded cases are created / with new enum instructions (which happens when casting sometimes): / /   bb9: /     ...
The main reasoning to do that is so that the extensions have the values already parsed into their types.
The main scanner function which does all the work.
The main server will be stopped asynchronously.
The main thread's native stack may be larger than desired if set_stack_size() failed.
The mandatory inliner drops debug_value instructions when inlining, as if it were a "nodebug" function in C.
The mandatory inliner drops debug_value_addr instructions when inlining, as if it were a "nodebug" function in C.
The map does not contain succ, we have not processed it before
The map of statements to counters.
The mapped value is -1 if no ASet is currently supported by that location.
The marker for BeginCatch must match the marker on inst.
The matching alloc_stack must be in the loop.
The maximum combined value of all throwing expressions in the current / context.
The maximum length of an e-mail address is 320 octets, per RFC 2821.
The maximum length of any particular string in the whitelist.
The maximum number of functions we'll optimize without popping any off the worklist.
The mayRaiseError instructions should all be going through may_reenter right now, which will kill the stack below the re-entry depth---unless the marker for `inst' doesn't have an fp set.
The meaning and interpretation of the DIEs is deliberately left vague by the standard, so different compilers can encode things in different ways (and no implementation is bug free).
The mechanism used to keep the function body separate from the DV init is to temporarily mark the SrcKey for the function body as already optimized.
The member ref expression we are emitting.
The member reference is in a context where an access will call / the getter.
The member reference is in a context where an access will call / the setter.
The member reference is in a context where it will be turned into / an inout argument.
The member type also needs to be convertible to the context type, which preserves lvalue-ness.
The memory content can be stored in this ConstantTracker or in the caller's ConstantTracker.
The memory object has class type.
The merge module action needs to be first to force the right outputs for the other actions.
The merge of deprecated and obsoleted versions takes the minimum.
The merge of two introduction versions is the maximum of the two versions.
The merge_memory_support function elaborates on the details of how this is done.
The mergeables array begins with the hoistable Func*s, followed by the (potentially) hoistable Class*s.
The message is only valid for the first subexpr.
The metaclass pointer will be instantiated here.
The metadata is now complete.
The metadata might be for a non-class type, which wouldn't have an ObjC class object.
The metatype may carry additional witness tables we can drop.
The metatype represents an arbitrary named type: dig through to the declared type to see what we're dealing with.
The method is removed by dead method elimination.
The method used to calculate the color difference is based on the color distance in the RGB(a) cube.
The method's depth starts below the depth of the context.
The miIntermediate routines must handle subtypes of TArr outside of calls to this as well.
The minstr is done here, so we want to drop a FinishMemberOp to kill off stores to MIState.
The miss path is complicated and rare.
The mode flags in stat are different from the flags used by access.
The module generator.
The module map used for Glibc depends on the target we're compiling for, and is not included in the resource directory with the other implicit module maps.
The module pass, which runs the optimization.
The module that we are optimizing.
The module value should never actually be used.
The module we are currently processing.
The mongos nodes aren't tagged either.
The most common case here is to parse something that was a lexically obvious pattern, which will come back wrapped in an immediate UnresolvedPatternExpr.
The most common case of getting an unreachable instruction is a missing return statement.
The most common case that leads here is Ret*, which does not fall-thru and has no encoded target.
The most common unnamed value of closure type is a ClosureExpr, so special case it.
The most general convention is generally to pass the entire tuple indirectly, but if it's not materializable, the convention is actually to break it up into materializable chunks.
The most general resilience expansion where the given declaration is visible.
The most general resilience expansion which has knowledge of the declaration's layout.
The most general resilience expansion which has knowledge of the global variable's layout.
The most general resilience scope where the enum type is visible.
The most general resilience scope where the enum's layout is known.
The most-recently-returned value is always left at the beginning of the list after retrieval.
The mutation invalidates a capture if it occurs in a block reachable from the block the partial_apply is in, or if it is in the same block is after the partial_apply.
The name didn't match.
The name must not be empty.
The name of a typedef-name.
The name of the Swift migrator binary.
The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission.
The names "Apache Server" and "Apache Group" must not be used to endorse or promote products derived from this software without prior written permission.
The names 'init'/'deinit'/'subscript' are actually keywords.
The names of its contributors may not be used to endorse or promote products derived from this software without specific prior written permission.
The names of the authors may not be used to endorse or promote products derived from this software without specific prior written permission.
The names of the output files are derived / from the main output file.
The names to use are the stringified versions of pass kinds.
The namespace might be empty.
The namespace only or the namespace and class might be empty.
The native call for this instruction is the slow path that does proper subtype checking.
The native implementation already put the return value on the stack for us, and handled cleaning up the arguments.
The native systemlibs: for now just skip.
The nearest ping time is in the first element
The negative answer does not always mean that there is no conformance, unless it is an exact match on the type.
The nesting depth of stack allocation instructions for each block.
The new Julian calendar set fixed lengths for the months, abandoning the lunar cycle.
The new block corresponding to `startBlock' is returned.
The new block is dominated by the SrcBB.
The new compression format stores a magic number and the size of the uncompressed object.
The new constant could be further folded now, add it to the worklist.
The new entries added to m_classDecs are always empty, so it doesnt matter that we dont include them in the iteration
The new node is placed or moved to the front of n's caller list, in the hopes that the next search on n will be the same addr.
The new non-critical edge though will be placed at the same spot in the new terminator where the critical edge was in the old terminator.
The new partial_apply will no longer take any arguments--they are all expressed as literals.
The new rows are placed using / the column-specialization algorithm.
The new state becomes the current state.
The new word is either zerod or set to 1, depending on whether we are one of the special builtins that takes variadic reference arguments.
The newlocale() call already did that for us.
The next 2 functions should be used to manage the generation count/time in the treadmill for both the requests and the work items.
The next counter value to assign.
The next element becomes the new top.
The next few lines are basically copied from gd2CreateFromFile we change the file size, so don't want to use the code directly.
The next instruction after the last use is part of the frontier.
The next three routines implement inverse colormap filling.
The next witness is an out-of-line base protocol.
The no-payload cases are distributed between multiple payload tags.
The node is intentionally leaked.
The node wasn't created by this extension, so doesn't already have a DOMDocument - make one.
The node whose end marks the end of the refinement context.
The non-derived flags imply the derived flags, even if the class is final, so you don't need to check both in those situations.
The non-interface type of a method that returns DynamicSelf uses DynamicSelf for the type of 'self', which is important when type checking the body of the function.
The non-polymorphic types.
The non-reentrant case occurs when a non-async or async generator is resumed via ContEnter or ContRaise opcode.
The non-trivial element.
The normal Unit m_lineTable is capable of producing enough line number information for things needed in production modes (backtraces, warnings, etc).
The normal case - we were called via FCall, or FCallArray.
The normal case for DV initializers is that each one falls through to the next, with the block jumping back to the main entry point.
The normal case for production mode is that all builtins are persistent, and every systemlib unit is accordingly going to be merge only.
The normal case here is an overridden public method.
The normal logic below will decide if we're done at that point or not.
The notion of a / near miss is used to refine overload sets to a smaller candidate set that is / the most relevant options.
The notional context in which we're writing and type-checking code.
The ns argument selects which namespace to use.
The number is the maximum number of / iterations encountered when compiling the stdlib on April 2 2015.
The number of OptionalEvaluationExprs between the point of the inner cast and the enclosing OptionalEvaluationExpr (exclusive) which represents failure for the entire operation.
The number of bits of precision can be adjusted by changing these symbols.
The number of elements must match exactly.
The number of empty cases representable by each tag value.
The number of extra tag bits outside of the payload required to discriminate enum cases.
The number of fields so far in words, plus 4 bytes for size and 4 bytes for flags.
The number of generic type arguments being bound must be equal to the total number of generic parameters in the current generic type context.
The number of generic witnesses in the type we're emitting.
The number of incoming edges from (reachable) predecessors for each block.
The number of iterations that can be caused by this is bounded by the nesting depth.
The number of locations is currently generally small, so this is probably ok for now---but if we remove the limit we may need to revisit this so it can't blow up.
The number of logical CPUs this machine has.
The number of memory / behavior or alias query we need to do in worst case is roughly linear to / # of BBs x(times) # of locations.
The number of milliseconds has to be greater than zero.
The number of nested types that haven't yet been resolved to archetypes.
The number of non-trivial protocols for this existential.
The number of nonzero histogram cells within this box
The number of payload bits.
The number of possible values for the extra tag bits that are used.
The number of primitive subelements across all elements of this memory / value.
The number of remaining specializations until this row becomes / irrefutable.
The number of selector pieces we'll have.
The number of symbols on the RHS of the reduced rule.
The number of tag values used for no-payload cases.
The number of times we've refined returnTy.
The number of value witnesses that occur in protocol / extensions.
The number we're after is the integer represented by those digits times 10**e
The object being a deallocating object.
The object file we are doing lookups in -- either the binary itself, or a particular slice of a universal binary.
The object has the deallocating bit set so retain, release is irrelevant.
The object is / uninitialized except for its header.
The object is hooked into hphp_session_init() and hphp_context_shutdown() to be init'd and reset'd at the end of a request.
The object type is an lvalue if the optional was.
The object type is incomplete, but has internal or external linkage.
The offset from the beginning of a box to its value.
The offset of the address point in the type we're emitting.
The offset of the block, if we've already emitted it.
The offset of the tail-allocated dependent VWT, if any.
The offset past the end of this block.
The offset will always be the same for converting to title case.
The old basic block is left / without a terminator.
The old branch instructions are no longer used, erase them.
The old branch is deleted.
The onFastPath builtin has only an effect on SIL level, so we lower it to a no-op.
The one exception to this is if we are given an empty iterator, in which case ContAssignDelegate will remove our delegate and just send us to YieldFromDelegate to return our null.
The one from hphp/runtime/ext_zend_compat/php-src/Zend/zend_strtod.h does not wrap with HPHP namespace, and implements functionality required by the zend extension compatibility layer.
The one-byte opcode map
The ones that return a TCA return a non-nullptr value to indicate that the caller must resume execution in the TC at the returned address.
The ones with at least one capital are the composite ops, and the capitals correspond roughly to the positions of buffers (as opposed to objects) in the arguments.
The only allowed state transitions are to states with higher values, so we merge with std::max().
The only branch in the code below *should* result in non-branching machine code.
The only case this can happen is if the accessor label is immediately after a brace (possibly preceded by attributes).
The only case this returns a non-singular value is when there are varargs in play.
The only difference being the specification of leap years.
The only good way to solve this is to treat such allocations as roots and always conservative scan them.
The only kind of stored variable that should make it to here is a global variable.
The only non-member decl that can be an lvalue is VarDecl.
The only other thing we return WillSucceed for currently is an upcast.
The only other transformation we know how to do safely is add a setter.
The only precise union with different stags we support so far is iterator stuff.
The only projection which we do not currently handle are enums since we may not know the correct case.
The only purpose here is / to catch obviously broken attempts to copy or destroy the buffer.
The only reasonable semantics for this would be to inherit the setter but override the getter, and that would be surprising at best.
The only thing interesting in a string is a possible APCString*, which is not a request-local allocation.
The only thing left to do is synthesize storage for lazy variables.
The only thing that can change the FP is inlining, but we can't have one of the predecessors in an inlined callee while the other isn't.
The only thing that matters in the inner arrays is the first element being a MySQL instance.
The only things we are going to do is write uninits to the non-passed params and to the non-parameter locals, and possibly shuffle some of the locals into an ExtraArgs structure.
The only time the base is allowed to be inout is if we are accessing a computed property or if the base is a protocol or existential.
The only two cases where an archetype is always legal in a function is if it is self or if it is from an opened existential type.
The only type differences we expect here should be due to substitution of class archetypes.
The only type we can possibly expect to agree / upon is the most general form.
The only valid return expression in an initializer is the literal 'nil'.
The only valid use of the noescape parameter is an immediate call, either as the callee or as an argument (in which case, the typechecker validates that the noescape bit didn't get stripped off).
The only way an accessor can produce an lvalue is if we have a property where both the getter and setter are nonmutating.
The only way that we modify the arity of function parameters is here for dead arguments.
The only way this could be a magic call is if the LookupResult indicated as much.
The only way to figure out which stack elements are activation records is to follow the frame chain.
The only way to produce an aliasing typed / address is with pointer_to_address (via UnsafePointer) or / unchecked_addr_cast (via Builtin.reinterpretCast).
The only way to represent a small integer is to use the bitset mode.
The opaque value (of archetype type) stored within the / existential.
The operand is an alloc_box.
The operand is an alloc_existential_box.
The operand must be a function type or a class type.
The operand must be at the right abstraction level for the existential.
The operand values are equal after replacing with the successor block / arguments.
The operands need to be loop invariant.
The operation doesn't have to be initializeWithCopy, but they all have basically the same type.
The operations that are only legal after a call to Escalate are:  - ValidMArrayIter - AdvanceMArrayIter
The operator token in this case lexes as a binary operator because it neither leads nor follows a proper subexpression.
The opposite of a projection instruction: composing a struct/tuple.
The optimize pass requires that critical edges be split prior to processing the unit.
The option key follows
The option's value should follow
The optional evaluation is passed through.
The optional object type is the same, so we assume the optional types are layout identical, allowing the use of unchecked bit casts.
The optional will be lowered to an integer type the size of the word.
The order of function parameters is as follows:
The order of these methods is so that the first ones win on case insensitive name conflicts.
The order that we visit uses for a given def is irrelevant.
The ordering has been set up so that indexed types that are identical except for the "scan" field will have the indexed types with scan set to false first.
The ordering in the existential type metadata is by metadata pointer, which isn't necessarily stable across invocations.
The ordering of implicit nodes isn't particularly important.
The origin index to use.
The origin should either be a metatype or an alloc_ref.
The original 'phi' argument values are just the values coming from the preheader edge.
The original function has no direct result yet.
The original normal result of the try_apply is an empty tuple.
The original operand values are equal.
The original parameter type.
The original source is redundant.
The original type isn't necessarily a tuple.
The original version of tiger got the endianness backwards This fb-specific version remains for backward compatibility
The other cases are empty.
The other fields can be ignored.
The other instructions are just cloned to the preheader.
The other known protocols aren't special at runtime.
The outer columns before the specialized column.
The outer matching loop.
The outer result can be indirect, and it doesn't necessarily have an abstraction difference.
The outermost N levels of optionals on the operand must all be present or the cast fails.
The outermost list appears first in the module file.
The outgoing edge carries the value on which we switch/cond_branch.
The output is only an estimation because all printed numbers are LLVM instruction counts rather than real code size bytes.
The output stack uses the rest of htab, and contains characters.
The overflow case is handled / in SILCombine.
The overflow flag is not returned / explicitly, because this simplification is only possible if there is / no overflow.
The overlay might shadow things.
The overridden property must not be mutable.
The override member type is semantically a subtype of the base member type.
The owner of the function's Name is the FunctionTable key.
The owner's already in its own cleanup.
The padding can be used as spare bits by enum layout.
The padding is done by adding '0's to the left of the string that is going to be printed.
The padding is done by printing the character ch.
The paramdecl should have function type, and we restrict it to functions taking ().
The paramdecl should have function type.
The parameter did not specify a separate API name.
The parameter has an explicitly-specified API name, and it's wrong.
The parameter must reference dereferenceable memory of the type.
The parameters which go into this tuple element.
The params and requirements cannot both be empty.
The parser generated a unique name for the class, use that
The parser generated a unique name for the function, use that for the class
The parser will have already diagnosed this, but treat this as a type error as well to get the ParamDecl marked invalid and to get an ErrorType.
The part of the ActRec that mirrors the native frame record is the first sixteen bytes.
The partial application takes ownership of the context parameters.
The partial_apply had ownership of this box so we must now release it explicitly when the partial_apply is released.
The particular policies used here have proved out well in experimental comparisons, but better ones may yet be found.
The pass begins by identifying the main-trace or callee main blocks and a set of blocks referred to as exit-heads.
The pass is strictly for testing that analysis.
The pass2 scanning routines call fill_inverse_cmap when they need to use an unfilled entry in the cache.
The passed in SGFContext.
The passed iterator reference is then modified to be the correct "next" iterator.
The passed-in ar is only useful in whole-program mode, so create a distinct ar to be used only for emission of this unit, and perform unit-level (non-global) optimization.
The passmanager we are using.
The password first, since that is what is most unknown
The path from the selected origin down to the destination / protocol.
The path may be empty if the file being loaded is a partial AST, and the current compiler invocation is a merge-modules step.
The path only contained slashes
The path to be tacked on to the target locator to identify the specific target.
The pattern and guard aren't allowed to throw.
The pattern fields are in an enum and should be less than the field count
The pattern from this row which we are specializing upon.
The pattern is to call getTime() outside of the lock and correctTime() while holding the lock.
The pattern of a catch.
The pattern variables were all emitted as lets and one got passed in, now we finally alloc a box for the var and forward in the chosen value.
The patterns which should replace the specialized pattern.
The payload case gets its native representation.
The payload is POD, so copying is bitwise, and destruction is a noop.
The payload is address-only.
The payload is currently always at the address point.
The payload is initialized, now apply the tag.
The payload may be empty.
The payload might be zero sized, if the enum consists entirely of empty cases, or there might not be any tag bits, if the lowering is able to pack all of them into the payload itself.
The payload of this specific enum case might be loadable even if the overall enum is address-only.
The payload size in bytes.
The payloads are all POD, so copying is bitwise, and destruction is a / noop.
The payloads are all bitwise-takable, but have no other special / shared layout.
The payloads are all reference-counted values, and there is at / most one no-payload case with the tagged-zero representation.
The pc-relative offset is from the end of the instruction, and the instruction is shrinking by 4 bytes (opcode goes from 2 bytes to 1, and offset goes from 4 to 1), so we need to adjust delta by 4.
The period of this function is equal to the product of both primes.
The pessimistic case still applies, however, if you need to reduce the lower bound on a must-alias-set S that currently has a lower bound of zero.
The physical register assigned to this subinterval.
The pipeline may be specified as a single array of operations or a variable number of operation arguments.
The pkeys array points to elements inside of Keys returned from Key::Get() which may be newly allocated and have no other owners.
The plan here is that each thread starts with s_thisThreadIdx as -1.
The plan needs to be built using the formal result type after foreign-error adjustment.
The playground instrumenter changes the AST in ways that disrupt the SourceKit functionality.
The point is past an end of the line segment.
The point lies inside the portion of the plane spanned by the line segment.
The point of the type-scanners is to determine how to find pointers to countable types from other types.
The pointer back to the AST node that produced the callee.
The pointer can be converted from a string, if the element type is compatible.
The pointer element type must be void or a byte-sized type.
The pointer in the slot should still have been null.
The pointer must be defined outside of this basic block.
The pointer to the returned array element buffer pointer.
The polymorphic type will start with any arguments from the parent.
The position is not increased, we are just filling in the first 4 bytes with the size.
The possible uses are one of: 1) The initialization store (TheStore).
The possible uses are: 1) The initialization store.
The possible values are: 0 (never executed) 1 (monomorphic) many (polymorphic)
The post-dominator tree level for this node.
The potential versions in the declaration are constrained by both the declared availability of the declaration and the potential versions of its lexical context.
The precedence-yielding parent is the nearest ancestor of 'expr' which imposes a minimum precedence on 'expr'.
The predecessor must be the normal edge from a try_apply that invokes a noreturn function.
The predicate / indicates how close a given candidate is to the desired match.
The prefix should normally always be present.
The presence of 'dynamic' or 'final' blocks the inference of 'dynamic'.
The presence of a generic type parameter indicates that we cannot use this type binding.
The present code works in the post-conversion color space, typically RGB.
The presentation requires an / introduction version and does not support deprecation, obsoletion, or / messages.
The previous metadata should be global data, so we have no real choice but to drop it on the floor.
The primary entrypoint.
The primary goals of this implementation are portability and ease of use.
The primary motivation is to help with SDK changes.
The primary thing we need to do more conservatively with must-alias-sets that have memory support is reduce their lower bound if they could be decref'd through that pointer in memory.
The private routine to ultimately emit a call or invoke instruction.
The private typealias are not included in the modules that are available to the debugger.
The probably doesn't matter outside of a FuncDecl, which we'll have to special-case, but it's an interesting bit of data loss.
The problem arises because, when lldb / uses swift to parse expressions, it needs to emulate the current / frame's scope.
The prof-counters are collected independently.
The programmer has guaranteed that the closure will not capture the self pointer passed to it or anything that is transitively reachable from the pointer.
The projected value is the payload.
The prologue is 1) still in the caller frame for now, and 2) shared across multiple call sites.
The prologues are sorted in ascending order of profile counters.
The prop definition in traits conflicts with the definition in a class so make a different prop for each trait
The proper long-term fix is that closure functions should be emitted with a convention that takes the closure box as the context parameter.
The property is public (or we're in the debugger and we are bypassing accessibility checks).
The property must have type T.
The property should be considered computed by the time we're through.
The property which we want to track: is the value/field a native swift / array which doesn't need deferred type check.
The property's accessors will decide whether the getter is mutating, and whether there's a setter.
The props can't be the same if they are at different offsets, though.
The protocol and conforming type are in different resilience domains.
The protocol and conforming type are in the same resilience domain.
The protocol can be imported.
The protocol conformance checker.
The protocol name is mangled as a type symbol, with the _Tt prefix.
The protocol self is implicitly decurried.
The protocols are the same at every level, so we can just set the metatype correctly and then recurse, letting the recursive call fill in the conformance information correctly.
The pseudomain comes first.
The purpose is / to prevent these predicates from changing values by mistake.
The purpose of the MAKE_DISPATCHER layer is to weed out Opcode values that have no associated extra data.
The purpose of this is to enable unit tests for SIL Alias Analysis / implementations independent of any other passes.
The quality parameter for Wbmp stands for the threshold when called from image2wbmp()
The quality parameter for gd2 stands for chunk size
The range in the interface source.
The range of the complete default argument.
The range that we use to iterate over the post order and reverse post / order of the given function.
The raw F-S error computation can potentially compute error values of up to +- MAXJSAMPLE.
The raw type should be a C integer type, which should have a single scalar representation as a Swift struct.
The raw type should be the first inherited type.
The raw value is the enum element's name.
The raw value is the previous element's raw value, incremented.
The raw value must be syntactically a simple literal.
The raw value of an imported EnumElementDecl doesn't seem to have a type for some reason.
The read preference spec states: "slaveOk remains as a bit in the wire protocol and drivers will set this bit to 1 for all reads except with PRIMARY read preference."
The real RHS is the type parameter stored in the node itself.
The real init-once enforcement is done by the compiler for the "static" in initExceptionHelpers.
The reason for this is if the cast is not dead then there must be some other use after the cast that we will protect if a release is not in between the cast and the use.
The reason for this is that if a type is constrained, we need to be able to find "all" possible sources of the type and constrain them.
The reason for this is that nothing is allowed to DecRef the context of a frame, except code that tears down that frame (either via a return or unwinding).
The reason for this is that our struct types currently are implying the presence of all the keys in the struct (it might be worth adding some more types for struct subtyping to handle this better.)
The reason for this is that that way, when allocating for case b, you don't need to store the SmallNode size again.
The reason is that if there is not a single predecessor then the code that is dominated by the block can be reachable from other blocks.
The reason is that it's trivially CSEable, so we might as well make it available everywhere.
The reason is that the type may depend on some other instruction that is still in the loop.
The reason this is ok is that one of the following two things are happening:  o The old next() block is becoming unreachable.
The reason to allow back-tracking is easily shown by a series of foldable incs and decs.
The reason to just use a default argument here is that it allows us to centralize all instruction removal in SILCombine into this one function.
The reason we have this unusual case only when dealing with builtin calls is that in that situation, we're actually tracking references and memory locations associated with the call.
The reason why is that we do not want to move retains, releases over isUniquelyReferenced calls.
The reason why it makes sense to / just use a sorted vector with std::count is because generally functions do / not have that many arguments and even fewer promoted arguments.
The reason why this is different from the ref bitcast is b/c the use of a ref bit cast is still a ref typed value implying that our ARC dataflow will properly handle its users.
The reason why this is ok to do is currently we only perform closure specialization if we know the function_ref in question.
The reason why we care about taking / non-trivial types as arguments is that we want to be careful in the face of / intrinsics that may be equivalent to bitcast and inttoptr operations.
The reason why we sort the list is so that we will process projections with the same value decl and tuples with the same indices together.
The receiver accepts ownership of the notification object.
The receiver accepts ownership of the response.
The record does not apply to a single type.
The record is followed by the substitution list.
The reentrant case occurs when asio scheduler resumes an async function or async generator.
The refcount is positive, so the value is refcounted.
The reference implicitly binds 'self'.
The reference is safe if an over-approximation of the running OS versions is fully contained within an under-approximation of the versions on which the declaration is available.
The reference to Self occurs in the result type.
The refinement below will clean this approximation up.
The regex below is based on a regex by Michael Rushton.
The regions in the following copy operation cannot overlap.
The register allocator passes us constraints via `free_until' and `allow'.
The relation is defined as follows:  Consider a phidef F with arity n (i.e., it defines n variables).
The relationship expressed in the builtin.
The relative address is the difference between those.
The release side of this is:
The remainder will be in r1, the upper 16 bits of the quotient will be in d2 and the lower 16 bits will be in d1.
The remaining 5 to 6 days in the year are grouped at the end and are holidays.
The remaining Unicode characters should be mapped to S_ETC.
The remaining bits in the extra tag bytes are spare.
The remaining case is when the lower bound before an incref is one.
The remaining code is the reference MD5 code (md5c.c) from rfc1321
The remaining lookups will be in the parent context.
The remaining situations are that m_stag is STag::None, in which case it is a subclass since osbits wasn't in the intersection.
The remapping case could be accomplished with less memory for non- interlaced images, but interlacing causes some serious complications.
The replacement is for the corresponding archetype by ordering.
The replacement type must be materializable.
The replicaset verification is done next step (setName).
The repo wasn't loadable
The representation of an existential is different for some protocols.
The representation of an existential metatype remains consistent arbitrarily deep: a metatype, followed by some protocols.
The representations must match.
The request thread will unpause us when it exits its command loop.
The required accessibility, if the check failed due to the / witness being less accessible than the requirement.
The required attribute only applies to constructors.
The required availability, if the check failed due to the / witness being less available than the requirement.
The required type is not defined in the standard library.
The requirement is that we can't create another reference to the array by performing an array operation: for example, storing or appending one array into a two-dimensional array.
The requirement should be for a nongeneric, nonmutating instance method.
The requirement to which the first witness was matched.
The requirement to which the second witness was matched.
The requirement was explicit and required, keep it.
The requirement was inferred or redundant, drop it.
The resolution succeeded.
The rest also applies to other integer formats, so fall into that case.
The rest are the same as the globals declared in the non-reentrant scanner.
The rest of the new args.
The rest of the outer columns.
The rest we'll just count.
The result and argument types must match.
The result can be empty in error cases.
The result from those instructions may be used as inputs to additional instructions.
The result function has already been reabstracted to the substituted type, so use the substituted formal type as the abstraction pattern for argument passing now.
The result has ownership semantics, so retain it with a cleanup.
The result is / always an i8*.
The result is converted from indirect to direct.
The result is perfectly decided locally.
The result is placed in `left'.
The result is placed in buf, and len denotes the length of the string The sign is returned in the is_negative argument (and is not placed in buf).
The result is returned as a new image.
The result is the object type of the optional subexpression.
The result might be exactly on an edge, or in-between instruction positions.
The result of a partial_apply is a thick function which stores the boxed partial applied arguments.
The result of attempting to resolve a witness.
The result of the comparison might be independent of the truth value of the LHS.
The result of the expression is the partial application of the constructor to the subexpression.
The result of this is that s_request_wrappers is no longer request-local - requestInit() and requestShutdown() will never be called again.
The result type (without the final optional) is a subtype of the operand type, so it will never have a higher depth.
The result type is the type we're converting to.
The result type may be a partial function type we need to close up later.
The result type must be materializable.
The result type of something.
The result type of the function must be convertible to the base type.
The result type would not have a single-refcounted-pointer rep.
The result types are equivalent.
The result types of the expressions yielding protocol values (reflected in SubstFormalType) reflect an implicit level of function application, including some extra polymorphic substitution.
The result value is passed as a parameter to the normal block.
The result value must match the type of the instruction.
The resulting BaseLoc is either inside an array, is the global init_null_variant, or inside tvScratch.
The resulting YUV data can be directly fed into the WebPEncode routine.
The resulting set of substitutions.
The results of a try_apply are not only the normal and error return values, but also the decision whether it throws or not.
The resumeAsyncFunc() entry point in ExecutionContext doesn't care what we put here, but also won't try to decref it, so we use a null.
The retain-unowned optimization will benefit from the release-motion.
The return inst needs to load the value from the alloc_stack.
The return type here describes extra structure for the protocol witness table for some reason.
The return type of _bridgeErrorProtocolToNSError is formally 'AnyObject' to avoid stdlib-to-Foundation dependencies, but it's really NSError.
The return type should be void.
The return value is a pointer to the new metadata table, and the size of the table will be updated by passing by ref.
The return value is a string representation of the code.
The return value is known to be at least a Gen.
The return value is the error code
The return value must be removed from the stack, or the unwinder would try to free it if the hook throws---but the event hook routine decrefs the return value in that case if necessary.
The return value of this pass represents an equivalence relation over phi uses and defs.
The return value of those calls (if any) do not return a non-native swift array.
The returnType flag is only non-folly::none for these, but note that something may be a builtin and still have a folly::none return type.
The returned SILValue / (which has type Builtin.Int1) represents the result of this check.
The returned StringRef is a slice of the "a" argument.
The returned array is mixed, and is guaranteed not to be isFull().
The returned char* is exactly what was passed in.
The returned color is always in the ARGB format (truecolor).
The returned mixed array is guaranteed not to be full.
The returned value is used to convert TSC counter values to microseconds.
The right fix here is to update AbstractStorageDecl::addTrivialAccessors() to take brace locations and have callers of that method provide appropriate source locations.
The right fix is to avoid doing that above.
The right thing to do here is to not synthesize that code in the first place.
The rodata pointer will be instantiated here.
The root node will / always be a Global.
The root type refinement context reflects the fact that all parts of the source file are guaranteed to be executing on at least the minimum platform version.
The rotations are all by constant distances.
The routine below is shamelessly, gloriously floating point.
The routines in this file implement thunking between lowered function types.
The rule here is that only blocks with a single predecessor and blocks that are dominated by them can rely on branch information.
The rule_inc_dec_fold will first apply when we're pointing to the "inc-4" node, removing "inc-4" and "dec-5".
The rules are applied in a single pass over the flowgraph, going forwards, but potentially backtracking when certain rules apply, since they may enable more rules to apply to previous nodes.
The rules are different from normal conversions.
The runtime adds Stringish to any class providing a __toString() function, so we mirror that here to make sure analysis of interfaces is correct.
The runtime currently does not track spare bits, so we can't use them if the type is layout-dependent.
The runtime doesn't support casts to CF types and always lets them succeed.
The runtime ignores these fields if the IsResilient flag is not set.
The runtime limits the count to INT_MAX.
The runtime needs to be able to freely manipulate live weak references without worrying about us mucking around with their bits, so weak references are completely opaque.
The runtime provides a value witness table for Builtin.NativeObject.
The runtime supports a max of 0x7FFFFFFF extra inhabitants, which ought to be enough for anybody.
The runtime uses dlopen to look for the protocol conformances.
The safe default for a dependent type is to assume that it needs its own implementation.
The safety of this assumes that neither this release nor any of the loads can throw.
The same IDs as the SILPrinter uses.
The same index could / either refer to the next element (indexed) or a subelement.
The same instruction may theoretically have different types of uses.
The sample belongs to the previous function.
The scope is tracked as a stack of contexts, pushing and popping off contexts when a namespace or type is entered or exited.
The scope of states used in finally router is controled using shared pointer refcounting.
The second attribute form is for user attributes and only applies if attributeMap is non null.
The second axis essentially deals with how the case discriminator, or tag, is represented within an enum value.
The second case is because vector operations may change the base at each step if it is a defining instruction.
The second causes a jam in that state.
The second half of this conditional must match QNetworkAccessManager's own idea of what a local file URL is.
The second hint accounts for F's entire equivalence class---see analyzePhiHints() for more details.
The second is to conservative scan a range given by a start offset and a length.
The second not indirect result argument is the closure.
The second param should be the ini setting name after "hhvm.hack."
The second pass over the image maps each input pixel to the closest output color (optionally after applying a Floyd-Steinberg dithering correction).
The second result is a RawPointer to the base address of the array.
The second retain cannot be matched with the release but must be matched by a follow up instruction.
The second return value is the owner / pointer, if applicable.
The second time, we do, but we can type-specialize.
The second type conforms to the first.
The second type is a subclass of the first.
The second version component isn't used for comparison.
The selectors must coincide.
The self application might be a DynamicMemberRefExpr.
The semantic expression is set up by type-checking to include all the other children as sub-expressions, so if it exists, we should just bypass the rest of the visitation.
The semantic value of the lookahead symbol.
The semantic value stack.
The semantics of these functions is the following:  If the `copy' argument is false, a COW is not required for language semantics.
The sentinel at the end of the array is the max index value.
The server already has read preferences configured, but we're still trying to set slave okay.
The server continues accepting until RequestType::TERMINATE is seen.
The server side push handler is just here to catch errors and egress state changes.
The server will have checked the breakpoint list for validity.
The service has crashed.
The set is optional, but get is not.
The set of archetypes that are currently available.
The set of associated types that have been inferred by matching / the given value witness to its corresponding requirement.
The set of blocks in this loop.
The set of currently available pins that have not been invalidate by an / instruction that mayRelease memory.
The set of directly accessible types, which is only used when we're performing dynamic lookup into an existential type.
The set of inherited protocol conformances.
The set of known declarations.
The set of locals that were ever live in this block.
The set of methods with the given selector.
The set of nominal type declarations we should (and have) visited.
The set of normal protocol conformances.
The set of opened existential archetypes that are currently / active.
The set of optional adjustments performed on the witness.
The set of potential bindings.
The set of property names that show up in the defining module of / an Objective-C class.
The set of property names that show up in the defining module of a / class.
The set of remembered files is cleared out during MemoryManager reset.
The set of specialized protocol conformances.
The set of type witnesses inferred by this solution, along / with the index into the value witnesses where the type was / inferred.
The set of witnesses that were considered when attempting to / infer associated types.
The set refers to operands instead of instructions because an apply could have several operands with release semantics.
The setcc should now be dead and will be cleaned up by dce.
The setter just forwards on to storage without materializing the initial value.
The setter llvm::Constant* will be null if / the property is not settable.
The setter loads the oldValue, invokes willSet with the incoming value, does a direct store, then invokes didSet with the oldValue.
The setter selector for, e.g., 'fooBar' is 'setFooBar:', with the property name capitalized and preceded by 'set'.
The shortest distance from the block entry to the scope exit.
The shortest distance from the scope entry to the block entry.
The sign bit of a result is 0 only if the sign bit of a source operand is 0.
The similar effect on local bases is handled in miBase.
The simple case: check if it is a "cond_fail 1".
The simple case: just a single literal segment.
The simplify() implementations may allocate scratch blocks and modify instruction streams, so we cannot use standard iterators here.
The single terminator instruction is part of the frontier.
The size includes the added tag bits.
The size is the number of times this function / is inlined into its caller.
The size of an array large to enough to hold all stacks, each with N elements.
The size of the maximum gap between one aligned stack and the next.
The size of the pascal string length (sz) is 1, 2, or 4.
The slow-path: we have to emit code to get from the box to it's value address.
The small data set should use inline storage on any pointer width.
The sole purpose of marking the flexible array member is so we know where the suffix begins.
The solution contains an error.
The solution is incomplete.
The solution is to fork/exec in a thread, and start the hardware counters there.
The sort of thing you need when you're avoiding v-tables.
The source and destination cleanups will be independent.
The source and destination do not overlap.
The source base type must be a subtype of the destination base type.
The source code of the verification program is included in this package.
The source key and value types must be subtypes of the destination key and value types, respectively.
The source line used for the function prologue.
The source may be optionally inout.
The source must be convertible to the destination.
The source object and input buffer are made permanent so that a series of JPEG images can be read from the same file by calling jpeg_gdIOCtx_src only before the first one.
The source of the store is a load from the same address, which is also in this block.
The source of those codes is at https://github.com/mongodb/mongo/blob/master/docs/errors.md  We should kill the connection so the next request doesn't do the same wrong thing.
The source string contains an ill-formed subsequence at the end.
The source type an Objective-C class type bridged to a Swift / type.
The source type can be checked-cast to the destination type.
The source type can be explicitly converted to the destination type.
The source type created a new Swift type, using swift_newtype
The source type is 'BOOL'.
The source type is 'Boolean'.
The source type is 'NSUInteger'.
The source type is 'void'.
The source type is a C++ reference type.
The source type is a CF object pointer type.
The source type is a block pointer type.
The source type is a function pointer type.
The source type is an Objective-C object pointer type.
The source type is any other pointer type.
The spare bit value is biased by one because all zero spare bits represents a valid value of the type.
The spare bits shared by all payloads, if any.
The spec says that's an error
The spec says that's an error, so we throw an exception with code 23 (defined in php_mongo.h)
The spec states that a WAP client does not need to implement ExtHeaders.
The special ctx (Class*)-1 is used by unserialization to mean that protected properties are ok.
The specialized column.
The specialized function is always a thin function.
The specified AbstractStorageDecl was just found to satisfy a / protocol property requirement.
The specified instruction is a non-load access of the element being / promoted.
The specified instruction is a use of some number of elements.
The speed of this approach is heavily influenced by the subbox size: too small means too much overhead, too big loses because Heckbert's criterion can't eliminate as many colormap entries.
The spill slot assigned to this value.
The src type is at least as good as the new type.
The stack depth at the label depends on the current depth
The stack depth at the target must be the same as the current depth (whatever this may be: it may still be unknown)
The stack overflow code knows how to handle the possibility of an ExtraArgs structure on the ActRec, and the uninits are harmless as long as we know we aren't going to segfault while we write them.
The stack will still contain the collection in that case, and loaded_collection_array will be non-nullptr.
The stacks and their tools: `yyss': related to states.
The stacks must have the same depth.
The standard VMRegAnchor treatment won't work for some cases called during function prologues.
The standard metadata for the empty tuple.
The start line is not the same, see if this is at the 'else' clause.
The state buf must be large enough to hold one state per character in the main buffer.
The state doesn't have this problem during optimization passes, because we'll always process the jump before the target block.
The state of memory support for each must-alias-set is a bitvector of the memory locations AliasAnalysis has identified in the program.
The state transition table takes the current state and the current symbol, and returns either a new state or an action.
The state variable is passed in to allow a function like fgetss to maintain state across calls to the function.
The static src/dest types cannot be checked here even if they are loadable.
The stats parameter allows the updates to be applied to either m_stats as in refreshStats() or to a separate MemoryUsageStats struct as in getStatsSafe().
The storage better not be resilient.
The storage is completely trivial.
The storage occupied by the enum may be smaller than the one of the raw type as long as it is large enough to hold all enum values.
The storage type of a class existential is a struct containing / a refcounted pointer to the class instance value followed by / witness table pointers for each conformed-to protocol.
The store to pointer is not used along any path to program exit.
The store to pointer is overwritten by another store before any / potential use of the pointer.
The stored value is the new running value.
The straight-forward way is to look for the DW_AT_object_pointer attribute (which is only present for member functions).
The stream has been restarted
The stride of a Swift type may not match its LLVM size.
The string `key' may not be an integer-like string.
The string `key' must not be an integer-like string.
The string is "OrpheanBeholderScryDoubt" on big-endian.
The string is ModuleName.TypeName.
The string is modified in place, so there shouldn't be more than one reference to it.
The string key must not be an integer-like string.
The string literal provides the data.
The string must not be an integer-like string.
The string was already proved to be valid UTF-8
The string we're using as a key must be static, because we're using it as a key in the cache (across requests).
The strings compare the same.
The strong reference count should be +1 -- tear down the object
The struct alignment is the max of the alignment of the fields.
The struct_extract, unchecked_ref_cast is handled below in the "Transitive SafeArrayElementUse" code.
The structure of ObjC class ivar lists as emitted by compilers.
The structure of ObjC class ivars as emitted by compilers.
The structure of ObjC class rodata as emitted by compilers.
The structure produced here is / consumed by swift_getGenericMetadata() and must correspond to / the fill operations that the compiler emits for the bound decl.
The stub and the eventual targets take rvmfp() as an argument, pointing to the callee ActRec.
The stub uses arg reg 0 as scratch and to pass arguments to destructors, so it expects the iter argument in arg reg 1.
The stubs are terminated by a ud2.
The sub expression should be an UnresolvedDeclRefExpr (we won't tolerate extra parens).
The subclass is the common base type.
The subclassList is non-empty, contains this ClassInfo, and contains only unique elements.
The subexpression consumes the current 'self' binding.
The subexpression is always an rvalue.
The subexpression must be either 'self' or 'super'.
The submodule of the extension is encoded in the extra data.
The subscript index expression.
The subscript index parameters.
The substituted parameter type.
The substituted types must match up in tuple-ness and arity.
The substitution determines the destination type.
The substitution determines the type of the thing we're destroying.
The substitution gives the type of the load.
The substitution record is serialized later.
The successor blocks and the destination blocks may have no arguments.
The successor node is a new PHINode.
The successor/predecessor edge in between S and ER with a new successor/predecessor edge in between S and L.
The suffix layout will be applied contiguously on the remaining portion of the block.
The suffix sometimes begins at the end of the object, but sometimes within it.
The summary currently includes all translations, so it's misleading if we're filtering a specific kind of translations or address range.
The summary for a function.
The sunk instruction should now read from the argument of the BB it was moved to.
The superclass field in a class type is the first field past the isa.
The superclass of the metaclass is the metaclass of the superclass.
The superclass should be the first inherited type.
The supported encoding types are hardcoded here because we are limited to the encodings supported by expat/xmltok.
The suspend hook will decref the newly created generator if it throws.
The suspend hooks can load anything (re-entering the VM), but can't write to frame locals.
The symbol for other nominal type metadata is generated at the address point.
The symbols being reduced.
The symmetric difference is empty.
The sync_sp temporary will be eliminated by vasm-copy.
The syntax is probably easiest to understand by looking at some examples (or the semi-BNF markup around some of the parse functions here).
The system is back in a normal state.
The systemlib name must match the name used by the build process.
The systems are not considered equivalent.
The tab_prefix table is the same size and type as the codetab.
The tab_suffix table needs 2**GIFBITS characters.
The table passed to s_callMap's constructor describes helpers calls used by translated code.
The target anchor is the function being called.
The target metadata is the first argument.
The targeted usecase is debugging and testing SIL passes.
The task failed, so return true without performing any further dependency analysis.
The template variable live controls whether or not MemoryManager member variables are updated and whether or not to call helper methods in response to memory anomalies.
The temporary memory is +0 if the value was.
The terminator has an invalid source location to signal to the DataflowDiagnostic pass that this code does not correspond to user code.
The terminator might change from under us.
The text to display when the debugger client processes "help break".
The text to display when the debugger client processes "help list".
The text to display when the debugger client processes "help quit".
The thing being capture specified is an identifier, or as an identifier followed by an expression.
The third (quality) parameter for Wbmp stands for the threshold when called from image2wbmp().
The third element is the method implementation pointer.
The three output values will always be modified.
The threshold argument defines the tolerance to be used while comparing the image color and the color to crop.
The threshold method works relatively well but it can be improved.
The thunk now carries the information on how the signature is optimized.
The thunk takes an A' and converts it into an A, calls the inner function value, and converts the result from B to B'.
The thunk that implements the partial apply calls the closure function that expects all arguments to be consumed by the function.
The thunk will call the specialized function.
The tier-based command line overwrites will already have been set in the call above.
The token spans multiple lines, make sure to replace syntax map data for affected lines.
The tolerances below are conservative.
The top level run routine of the pass.
The top translation may have changed while we waited for the write lease, so read it again.
The top-level DIEs correspond to compilation-units, and all the children of these top-level DIEs correspond to the information in that compilation-unit.
The top-level entry point.
The top-level indents here create the line to the node we're trying to print.
The top-level interface to the remangler.
The top-level node for the function appears first in the list.
The total number of LLVM instructions in the module.
The total size and address point of a metadata object.
The total size includes space for the tag.
The tracked FPI state must always be the same, notice that the size of the FPI stacks may differ as the FPush associated with one of the merged blocks may be outside the region.
The trailing arguments are now propagated through the partial apply.
The transfer function is a function of the set of locals read and killed in the block, and does not depend on the final live out state, so we can compute it here.
The transfer is performed in a separate event loop that we wait on, so it is effectively synchronous.
The transport is overriding everything and just handing us the filename
The transport take precedence over the config file
The tree formed by the parent edges is a spanning tree for the reachable nodes.
The trick here is that the ClosureExpr provides a DeclContext for stuff inside of it, so it isn't safe to just drop it and rip the BraceStmt from inside of it.
The tuple contains the known return type for the builtin, the total number of calls seen and the total number of calls that could be reduced.
The tuple record itself is empty.
The tuple should have the source range enclosing its arguments unless they are invalid or there are no arguments.
The two GEPs do not alias if they are accessing different fields, even if we don't know the base pointers.
The two angles are acute.
The two exceptions are persistent constants and TypeAliases which are allowed in systemlib.
The two most common values for numExtraTagBytes are zero and one.
The two object types have the same linkage and same name, so now examine which linkage that actually is to determine how to check for object equality.
The two solutions are to make address projections variadic (something on the wee horizon) or enable Projection to represent a cast as a special sort of projection.
The two systems are not identical.
The two types are required to either both be l-values or / both not be l-values.
The two-byte opcode map (first byte is 0x0f)
The type can be polymorphic.
The type can serve as its own / abstraction pattern.
The type constrained by a generic requirement should always be a generic parameter or associated type thereof.
The type expansion analysis we will use during all computations.
The type for a generic TypeAliasDecl is an UnboundGenericType.
The type from the indexer doesn't contain the in-class initializer types.
The type info class for the on-stack representation of an ObjC block.
The type inside the box.
The type is simply inout of whatever the lvalue's object type was.
The type is the type of the actual result, not the prefix.
The type may be optional due to a failable initializer in the protocol.
The type may be optional.
The type metadata bindings should be at a fixed offset, so we can pass None for NonFixedOffsets.
The type must / have generic arguments.
The type must be an enum.
The type must first be a type reference.
The type must have generic arguments.
The type must refer to a protocol.
The type name may be multi-part.
The type of a TypeExpr is always a metatype type.
The type of a function that merges two version tuples.
The type of a match predicate, which takes as input a node and its / parent and returns a bool indicating whether the node matches.
The type of a tmp defined by DefLabel is the union of the types of the tmps at each incoming Jmp.
The type of a tuple expression is simply a tuple of the types of its subexpressions.
The type of a variable.
The type of failure is that multiple occurrences of the same generic are being passed arguments with different concrete types.
The type of the capture list is just the type of its closure.
The type of the capture list is the type of the closure contained inside it.
The type of the dynamic method must match the usual type of the method, but with the more opaque Self type.
The type of the expression must conform to the StringInterpolationConvertible protocol.
The type of the initializer.
The type of the internal lookup table.
The type of the sequence.
The type of the src is the same or more refined than type, so the guard is unnecessary.
The type of the substitution is the source type of the thin to thick instruction.
The type of the thunk function.
The type part of a NamedTypeRepr will get the callback.
The type to which the imported type is bridged.
The type to which the type variable can be bound.
The type we got should be lowered, so lower it like a SILType.
The type we need to bind to the archetype is the one that's deep in the type.
The type we're converting from.
The type we're working with, in case we want to build it differently based on the attributes we see.
The type will be a polymorphic function if the Self type is generic.
The type will be walked as a part of another TypedPattern.
The type witness is still missing.
The type witness is still missing: create a new one.
The type-check of the constructor body will introduce default initializations of the members.
The type-checker doesn't care about how these are grouped.
The type-info class for ObjC blocks, which are represented by an ObjC / heap pointer.
The type-of-rvalue must be loadable.
The typedecl of the base expression of the member ref expression.
The types are different, or there was an optionality change resulting in a change in representation.
The types are equivalent.
The types may not be compatible in the presence of unreachable code.
The types must match.
The types of use vars are looked up from the index, but we don't currently do anything to try to track closure static local types.
The uint32_t is used to hold RDS offsets for constants
The unconditional path avoids some failure logic.
The unconditional_addr_cast can be skipped, if the result of a cast is not used afterwards.
The unconditional_cast can be skipped, if the result of a cast is not used afterwards.
The uncurried function calls all of the intermediate function levels and so throws if any of them do.
The uncurried input types.
The underlying library may return zero length null ptr's to indicate an empty string (since the isNull check above would tell if it were actually NULL).
The underlying text is kept alive by an CompletionSink.
The underlying type could be a bridged type, which makes any sort of casual assertion here difficult.
The uniquing structure for ObjC class-wrapper metadata.
The uniquing structure for existential metatype type metadata.
The uniquing structure for existential type metadata.
The uniquing structure for function type metadata.
The uniquing structure for metatype type metadata.
The uniquing structure for tuple type metadata.
The unresolved member itself is the function.
The unwinder will unwind through VMs nested under this one first, making it safe to assume that we can sync the VM registers here.
The upcast from the concrete type to an existential type for the protocol requires packaging the payload together with type metadata and witness tables.
The update box is specified by the center coordinates of its first cell.
The upper 32 bits of the result will be in r2 and the lower 16 bits will be in r1.
The upper two digits for control characters are always 00.
The use of testbim and testlim here is little-endian specific but it's "ok" for now as long as nothing else is read or written using the same pointer.
The user defined value in the first argument will be available to hphpalloc in the yyextra field.
The user did not specify a module name, so determine a default fallback based on other options.
The user error handler fataled or threw an exception, print out the error message directly to the log
The user has a chance to override it with an option.
The user has requested a module, so generate one and treat it as top-level output.
The user has to think harder about this.
The user is an RCIdentical user of our Pin result and only has /    RCIdentity preserving insts, mark dependence, or the unpin we are /    trying /    to remove as users.
The user is the unpin we are trying to remove.
The user marks a dependence.
The user must be the terminator we are trying to jump thread.
The user of the typed GEP may but we will catch that via the dataflow.
The uses hanging off the tuple_element_addr are going to be counted as uses of the struct or enum itself.
The value are set using send_long_data so we don't have to do anything here
The value are store (or copy_addr) instructions, which store the current value.
The value can actually be a tuple if the / abstraction is opaque.
The value for this enumeration element
The value goes first.
The value is already a native metatype.
The value is already incref'd.
The value is expressed as bits.
The value is live at the end of a predecessor block but not in the frontier block itself.
The value is live in the block but not at the end of the block.
The value is not live in any of the successor blocks.
The value is not live in some of the successor blocks.
The value is out-of-line, but we can't take it, since it may be shared.
The value is tail-allocated after the SwiftError record with the appropriate alignment.
The value may need truncation if its type had an abstract size.
The value must be fully initialized at all escape points.
The value must not be KindOfUninit.
The value must not be define in the same basic block as the switch enum user.
The value of semaphore 1 (SYSVSEM_USAGE) is a count of the number of processes using the semaphore.
The value of the object's address at the point of allocation.
The value requirement that triggered inference.
The value type of the map is a list of offset ranges, so a single line with several sub-statements may correspond to the bytecodes of all of the sub-statements.
The value was already consumed so there's nothing to release.
The value was produced at +1, but pinning is only a conditional retain, so we have to leave the cleanup in place.
The value was produced at +1, so to produce an unbalanced autorelease we need to leave the cleanup intact.
The value was produced at +1, so to produce an unbalanced release we need to leave the cleanup intact and then do a *second* release.
The value we are attempting to discover memory behavior relative to.
The value we provide is the one we've already got.
The value witnesses selected by this step of the solution.
The value won't be live but it's ok to use it to track down the guard.
The value-witness table for BridgeObject.
The value-witness table for UnsafeValueBuffer.
The value-witness table for pointer-aligned unmanaged pointer types.
The value-witness table for raw pointers.
The values in the original function that are promoted to stack references.
The values incoming into Arg.
The values must have been fully initialized before we close over them.
The values to use to initialize the arguments structure.
The variable may have its lifetime extended by a closure, heap-allocate it using a box.
The variable was filtered out on the server, using text.
The variable-length output codes are re-sized at this point, and a special CLEAR code is generated for the decompressor.
The variables in this class are all JNI global references and are intentionally leaked because we assume this library cannot be unloaded.
The variables in this pattern have not been initialized.
The variables used to return semantic value and location from the action routines.
The various invokeFoo functions are the entry points here.
The vastly most common case is memory allocations that are not tuples, so special case this with a more efficient algorithm.
The vector contains a list of maybeIntercepted flags for functions with this name.
The vector of found declarations.
The verifier is basically all assertions, so don't compile it with NDEBUG to prevent release builds from triggering spurious unused variable warnings.
The verifier will check they are only created at the appropriate times.
The version number used to be stuck as 199905, and was thus basically content-free.
The version of brotli we are using does implement these helper methods that we need.
The version range for the false branch should never have any versions that weren't possible when the condition started evaluating.
The visitor should return true if / the attribute is invalid and should be marked as such.
The vlower() implementations may allocate scratch blocks and modify instruction streams, so we cannot use standard iterators here.
The vmJitCalledFrame() check below is only important if we might throw before returning to the TC, which is guaranteed to not happen in this situation.
The volume (actually 2-norm) of the box
The vtable entry must be ABI-compatible with the overridden vtable slot.
The wasted elements are never initialized.
The way it works is as follows: - Iterate through CFG to identify variables with at least one typecheck.
The way the algorithm works, whatever is in here must be factual (even if it is not complete information), because we may deduce other facts based on it.
The way this works is to do a backward dataflow analysis, computing "will_be_used_again" information.
The way we compute isEndOfSequence relies on the assumption that the sequence-folding algorithm never recurses with a prefix of the entire sequence.
The way we maintain correctness here is to never move or eliminate reference counting operations unless we know about at least /two/ references to the object being counted.
The web request may have timed out while we were waiting for I/O.
The whitelist of classes and functions from the stdlib, whose specializations we want to preserve.
The whole TV is loaded into a single SIMD reg.
The whole TV is stored in a single SIMD reg.
The wildcard spec '*' represents the minimum deployment target, so there is no need to create a refinement context for this query.
The witness can produce a 'nil' that won't be handled by / callers of the requirement.
The witness could be removed by dead function elimination.
The witness from which the first type witness was inferred.
The witness from which the second type witness was inferred.
The witness handles 'nil', but won't ever be given a 'nil'.
The witness has an IUO that can be removed, because the / protocol doesn't need it.
The witness has an IUO that should be translated into a true / optional.
The witness is a constructor which is more failable than the / requirement.
The witness is less accessible than the requirement.
The witness is less available than the requirement.
The witness is not rethrows, but the requirement is.
The witness is storage whose setter is less accessible than the / requirement.
The witness method CC passes Self as a final argument.
The witness must not be more mutating than the requirement.
The witness requires optional adjustments.
The witness table parameter is not used.
The witness throws, but the requirement does not.
The witness we matched.
The work array elements have to be INT32s, so the work array would need 256Kb at our recommended precision.
The work array need be only as big as the subbox, so the memory usage problem is solved.
The work list of not yet handled blocks.
The worker should exit gracefully
The worklist of arguments that we still need to visit.
The worklist of the constants that could be folded into their users.
The writeback scope closing will propagate the value back up through the writeback chain.
The xed library will add operand size suffixes on any opcode that affects memory.
The year is divided into 12 months of 30 days each.
The zend_hash_find() interface itself is theoretically non-const and callers may write directly to the value.
The zend_startup_strtod from hphp/runtime/base/zend-strtod.h uses the HPHP namespace, is used for other purposes, and predates the EZC extensions.
The zlib notes say output buffer size should be (input size) * 1.01 * 12 - we'll use 1.02 to be paranoid.
The zombie state happens if an array is "moved from"---the only legal operation on a zombie array is to decref and release it.
TheMemory - This holds information about the memory object being / analyzed.
TheMemory - This is either an alloc_box or alloc_stack instruction.
TheRawPointerType lowers as i8*, not i8**.
Their destructors will automatically call the appropriate Zend destructor.
Their presence requires significant modifications to the way the rest of the algorithm works.
Then add any arguments that are captured in the closure to the function's argument type.
Then add the BB as a subregion to its parent region.
Then add the parent to NewNodes to be added to our list.
Then adds the breakpoint to client's list and sends this command to the server so that it too can update it's list.
Then all the other sets that May-Alias S must have their lower bound reduced as well.
Then append the unique identifier of our literal.
Then attempt to look up the enum state associated in our SILValue in the predecessor we are processing.
Then attempt to lookup the corresponding (SILValue, BottomUpState) from SuccBB.
Then attempt to lookup the corresponding (SILValue, BottomUpState) from SuccRegion.
Then attempt to lookup the corresponding (SILValue, TopDownState) from PredBB.
Then attempt to lookup the corresponding (SILValue, TopDownState) from PredRegion.
Then attempt to sink code from predecessors.
Then build the class RO-data.
Then change all of the original predecessors to target Preheader instead of header.
Then change the immediate dominator of the header to be the pre-header.
Then check if the required specialization can be found elsewhere.
Then check that we have a global.
Then communicates with the server to retrieve source information.
Then count the number of rows with the same kind of pattern.
Then create the pre-header and connect it to header.
Then delete all user instructions.
Then demangle types until we fail.
Then emit the case body into the caseBB.
Then erase this instruction.
Then figure out what was actually constant propagated.
Then for each (SILValue, Enum Tag) that we are tracking...
Then for each exiting region ER of the Loop L...
Then for each incoming value, fixup the branch, cond_branch instructions.
Then for every stored field...
Then g() is evaluated and then the set happens.
Then get the ini and hdf cli strings again, in case the tier overwrites overrode any non-tier based command line option we set.
Then go through the projection tree constructing aggregates and replacing uses.
Then go to user-level `__set`.
Then grab the previous instruction (if it exists).
Then grab the terminator of Pred...
Then if succ iterator is not succ end, we are a non local edge if that value is Non Local.
Then if we have a struct address...
Then if we have an enum...
Then insert a release in all non failure exit BBs if our partial apply was guaranteed.
Then it is not possible for CallB / to not share any states with CallA.
Then just as many characters of the MD5(pw,salt,pw)
Then look at any uses of V that potentially could act as a typed access oracle.
Then make sure that the rcid of the retain is the same as our release.
Then make sure that this incoming value is from a BB which is different from our BB and dominates our BB.
Then make sure that we have a type that can be substituted for the callee.
Then our magic string
Then parse all the library files.
Then parse any conformances until we find an underscore.
Then perform any updates to the arguments of NewF.
Then perform the basic block optimization.
Then perform the dataflow.
Then perform the function signature specialization.
Then perform the optimizations.
Then perform the region optimization.
Then print dependencies we've picked up during compilation.
Then recursively add direct subclasses of already added subclasses.
Then recursively process it first before trying to inline it.
Then renumber integer keys.
Then return true if along the edge from the SEI to BB, RCIdentity has a non-payloaded enum value.
Then rewrite successors of all exits.
Then run through every ClassInfo, and for each of its parent classes clear the AttrNoOverride flag if it has a different Func with the same name.
Then see if BB has one predecessor...
Then see if we already have a specialized version of this function in our module.
Then sends the command back to the client as confirmation.
Then setup the leaf list by iterating through our Nodes looking for live leafs.
Then something really weird...
Then test the boundary from representable index to unrepresentable index.
Then the mean color in each remaining box becomes one of the possible output colors.
Then they are processed one at a time with a set of "legal transformation rules".
Then they evaluate to their body.
Then this function can be processed in one iteration, i.e. no need to generate the genset and killset.
Then try to load from the environment
Then try to load the fallback function
Then try to lookup the innermost loop that BB belongs to.
Then type check the function itself.
Then until our worklist is clear...
Then until the worklist is empty...
Then until we find a node that is not complete...
Then until we finish the worklist...
Then until we have no work left...
Then updates this command with the source information and sends it to the server in order to retrieve the source text from the server.
Then use the molads to find Tishri 1 of the current and following years.
Then we also autoprime B when it gets used, which advances C past some perfectly valid data.
Then we call f(), then we turn the unnamed local into an 'A' so that autoload handlers will run after f().
Then we can make it fragile.
Then we can reuse the work.
Then we check the options array that could overwrite the default
Then we copy the input string.
Then we do not need to use projection to check for whether all non-trivial fields are covered.
Then we mangle the types of the arguments that the partial apply is specializing.
Then we move on to running the next set of consecutive module transforms.
Then we redirect those preds to those new basic blocks.
Then we transfer the body of F to NewF.
Then we unmap and map the lower portion of the RDS at the same address.
Then, analyze indirect subclasses.
Then, if we have an int and the underlying type is a string, convert it to a string so the output type is right.
Then, it converts any DecRef instruction on tmps whose must-alias-sets say they "will_be_used_again" to DecRefNZ.
Then, print labels if we have any.
Then, we convert the argument to a string.
Theoretically reading this block comment first will make the rest of this file make more sense.
Theoretically, hue 0 (pure red) is identical to hue 6 in these transforms.
Theoretically, this could be stored within the frameData itself, but that's probably not worth the runtime memory penalty so we take the performance hit now.
There appears to be no other parameters in this call, so we'll expand replacement for trailing closure and cover call parens.
There are 3 cases that can happen here.
There are a LOT of them, so they're separated out into include files, leaving this source file for actual implementation.
There are a bunch of places where we want to ensure that there's a materializeForSet accessor.
There are also some special cases for SetM for different base types: 1.
There are arguments following the filename, so copy them.
There are clearly better ways to do this.
There are currently two kinds of freelist entries: entries where there is already a valid SmallNode on the list (case b), and entries where there isn't (case c).
There are enough details to discuss it futher in next several sections of this doc.
There are imm() overloaded methods for each type of operand used by any Vinstr.
There are invalid bytes.
There are multiple children and they have the same base, but empty projection paths.
There are multiple values from multiple predecessors, set this as a covering value.
There are no alignment requirements.
There are no conformance tables.
There are no exported functions in ext/date to this in a more native fashion
There are no predecessors where it is not clear if they are dominated by a success or failure branch of DomBB.
There are no protocol conformance tables.
There are no spaces, the entire string is the command
There are no spare bits in an opaque storage type.
There are only two distinct booleans - false and true (0 and 1).
There are post-send functions that can run.
There are potentially infinitely growing types when we're using union_of to merge states, so occasonially we need to apply a widening operator.
There are quicker ways to do this conversion, but it's necessary to follow this to match the functionality of fbcode/multifeed/text/TokenizeTextMap.cpp.
There are several reasons this loop can execute:
There are some instructions besides the branch.
There are some rules about the order it needs to have at runtime, which we set up here.
There are some unknown users of the partial_apply.
There are suggestions that it was to skip a leap year ever 100 years like the Gregorian calendar.
There are three cases we need to handle here: parameters, initialized (or bound) decls, and uninitialized ones.
There are two classifications of types that copy forwarding applies to: address-only types and references.
There are two different ways this can go.
There can be multiple substitutions, but the first one is the Self type.
There can be no other function with this name on `cls', and we already ruled out the case where dispatch should've gone to a private function with the same name, above.
There can be the case that we see a callee argument as pointer but not the caller argument.
There can currently be no more than one immvector per instruction, and we need access to the size of the immediate vector for NUM_POP_*, so the member vector guy exposes a vecImmStackValues integer.
There can only be one of these per object type.
There can only be one such parameter.
There doesn't appear to be a complete definition of this type anywhere, so just return the incomplete object representation.
There exists some more types in this enum like MYSQL_TYPE_TIMESTAMP2, MYSQL_TYPE_DATETIME2, MYSQL_TYPE_TIME2 but they are just used on the server
There is a MayDecrement instruction.
There is a chance another thread deletes the key when this thread is converting the object.
There is a child iterator so that the children do not need to be store separately.
There is a counter in getRCIdentityRootInner that ensures we don't do too many.
There is a function with the required name.
There is a must alias store.
There is a potential problem if the start or end of daylight saving time occurs during the current period.
There is a potential race here.
There is a read to a LSLocation, expand the LSLocation into individual / fields before processing them.
There is a read to a location, expand the location into individual fields / before processing them.
There is a self-recursion.
There is a slight redundancy here but we can live with it.
There is a small race condition here with HttpServer::reset in program-functions.cpp, but it can only happen if we get a signal while shutting down.
There is a store into this property.
There is a trade-off to this: With / shadow copies, we lose the precise lifetime.
There is a write to a LSLocation, expand the LSLocation into individual / fields before processing them.
There is a write to a location, expand the location into individual fields / before processing them.
There is ambiguity with expressions (e.g. "break x+y") but since the expression after the break is dead, we don't feel bad eagerly parsing this.
There is ambiguity with expressions (e.g. "continue x+y") but since the expression after the continue is dead, we don't feel bad eagerly parsing this.
There is an edge from node to next, and next has not been visited.
There is an extra node on the end of the offsets to allow this routine to work right.
There is an infinitesimally small chance that the first four bytes will happen to be the length of the rest of the string.
There is an inout 'self' when we have an instance method of a value-semantic type whose 'self' parameter is a pointer-to-non-const.
There is an outer loop around the parser that will reinvoke the parser at the top level on each statement until EOF.
There is at least one projection path that leads to a type with reference semantics.
There is more then one assignment to a given global variable.
There is no Any equivalent since they keys need to be hashable.
There is no KindRefVarParam.
There is no SIL instruction to create a class or box by aggregating values.
There is no VarDecl for a SILGlobalVariable, and thus also no context.
There is no callback.
There is no current array addr value.
There is no declaration.
There is no known better way to extract this information out.
There is no location we can point to.
There is no need to bitcast from the enum address.
There is no need to do toKey() conversion, for a key that is already in the array.
There is no need to hoist Destroy for these.
There is no need to retain it separately.
There is no particularly good way around this in the case that all 256 8-bit shades are used, but one could write some custom 16-bit code to handle the case where there are gdFree palette entries.
There is no point in continuing to compare the first declaration to others.
There is no point in recording a new one.
There is no point in storing this value into the cache so just return it.
There is no point in updating the pointsTo if the To node will be merged to another node eventually.
There is no scanning required (or desired) for the block that defines the memory object itself.
There is no such thing as an EOF return.
There is nothing more that we can do, return.
There is nothing more to do.
There is nothing more we can do.
There is nothing special about the source type.
There is nothing to do for this value...
There is one WarmupRequestHandler per-thread, but we want to track request count across all threads.
There is one XenonRequestLocalData per thread, stored in thread local area
There is one anonymous class per closure body.
There is one of these for each block entry.
There is only 1 children node and its value's projection path is not empty, keep stripping it.
There is only one container (not counting container1) so we can just call containerKeysToSetHelper() to build the Set.
There is only one container (not counting container1) so we can just call containerValuesToSetHelper() to build the Set.
There is plenty of room for any possible stack (stack used to be 8000 characters).
There is some custom type checking here.
There is some sort of control flow here that we do not understand.
There is some type-specific hackery here for:
There is the thread currently processing an interrupt, plus any other threads stacked up in blockUntilOwn() (represented in the m_threads set).
There isn't a canonical invalid pthread_t, but this is only used for the assert in lookup() and it's ok to have false negatives.
There isn't a nice way to get CPU seconds on OS X that I've found, outside of setitimer, which has its own configurability issues.
There isn't a really strong reason for this, though.
There isn't much value in caching more than one of these.
There may be EHEnt regions covering the fault funclet, but if an exception occurs in the funclet it can also propagate to any EH region from the code that entered the funclet.
There may be gaps between instruction ranges that have been added by the relocator, e.g. adding nops.
There may be multiple nodes / for a function in case the function is inlined into different callers.
There may be only a single block whose predecessor we didn't see.
There may be only one instruction before the branch.
There may still be threads in existing interrupts, though.
There might also be a class with this name already.
There might be valid types within a subprogram definition, but we deliberate ignore those.
There might not be any.
There must be a generic type with one argument.
There must be a property named "pointee".
There must be an output filename for each source file.
There must be enum elements.
There must not already be a class method with the same selector.
There seem to be cases where we lower them as unowned.
There should always be at least one release for an allocated object.
There should be at least one SILCombine+SimplifyCFG between the ClosureSpecializer, etc.
There should only ever be one of these in a set of constraints related to a dependent type, so the ordering among other types does not matter.
There shouldn't be any other parameters at this depth.
There shouldn't be anything interesting in them.
There was a sign extension bug in older revisions of this function.
There was an explicit witness available, but it failed some / criteria.
There was at least one non-OrdStr use
There was no argument to claim.
There was no witness available.
There we always just create a declaration and then later / deserialize the actual function definition if we need to.
There were never any numeric indices.
There were no digits at all so scanning has failed and we are done.
There were no forward jumps that referenced this label
There were no lowercase letters, so this is an acronym.
There will (currently) never be spare bits embedded in the payload.
There's ABSOLUTELY NO WARRANTY, express or implied.
There's a corresponding hack in MultiPayloadEnumImplStrategy::completeEnumTypeLayout to ignore spare bits of dependent-typed payloads.
There's a fair bit of complexity here right now, for these reasons:  o Sometimes we're 'logically' inlining a php-level call to a function that contains a NativeImpl opcode.
There's a method somewhere in the hierarchy, but none which are accessible.
There's an ignored i8* parameter.
There's an interesting special case where we can do the initialization idempotently and thus avoid the need for a lock.
There's at least one non-default param which wasn't passed
There's deliberately no BUILTIN clause here so that we'll blow up if new builtin categories are added there and not here.
There's no actual function pointer to capture, and we semantically can't cache dispatch, so we need to perform the message send in the partial application thunk.
There's no concept of vector in PHP (yet), so return an array in both cases
There's no corresponding Clang type for that.
There's no great way to do this.
There's no harm in doing this even if the cast fails.
There's no need to copy it.
There's no need to hold it over the longer operation to set breakpoints in each file later.
There's no need to incref since it came from m_this.
There's no pattern to link.
There's no point in doing this for fixed-sized types, since we'll allocate an appropriately-sized buffer for them statically.
There's no point in performing the fast-path token check here because we've already checked the cache variable.
There's no point in trying to emit anything else.
There's no reason for code to do this but we should still avoid crashing.
There's no reason for us to be starting on the entry block when it's not our current block.
There's no reason not to do more later.
There's no reason to do the same for nonzero_result because the only meaningful value remaining would be zero.
There's no reason to generate code to try to go to the next part of it.
There's no reason to use the full capacity, since static/uncounted arrays are not mutable.
There's no way to change them without creating a new cursor
There's nothing special to do if the operand isn't optional and we don't need any bridging.
There's nothing to do for them.
There's nothing to do.
There's one MustAliasSet for each frame's context, no matter how many times we see loads of it.
There's only a no-payload element if the type is empty.
There's only one extra inhabitant, 0.
There's only one such position, because of SSA.
There's still a placeholder to claim if the target type is thick or there's an error result.
There's two extra NUL chars, plus either a '*' for protected, or the classname for private.
Therefore UNDEFINED can be defined as 0 in situations where only unsigned numbers are desired.
Therefore assumes `this` has been request-heap allocated.
Therefore at the time of emitting the actual goto instructions we can reliably tell which finally blocks to run.
Therefore generate a simple unconditional_checked_cast_aadr.
Therefore it does not remove bodies of any external functions / that are alive, because LLVM may analyze their bodies to determine their / side-effects and use it to achieve a better optimization.
Therefore it increases the number of remaining cases to be handled by the default case handler.
Therefore it is safe to make a negative decision at compile-time.
Therefore it is sufficient to just retain the argument at the site of the original partial_apply.
Therefore it's important *not* to return true if the TypedValue.m_aux field in memory has important data.
Therefore the assertion below must hold.
Therefore the invariant holds of all the successors, and we can queue them up if we haven't already visited them.
Therefore the overflow flag is known to have a value of 0 if / simplification was successful.
Therefore the sign bit of a result is always 0.
Therefore there's no risk on this function being called by the iterator wrapper destructor function and not finding the memory of this iterator allocated anymore.
Therefore we bail if there are any writes in the loop.
Therefore we can simply ask SSAUpdater for the reaching store.
Therefore we do it lazily.
Therefore we don't know its value.
Therefore we have to check if both, the normal and the error block, are empty and lead to a common destination block.
Therefore we have to define it as escaping.
Therefore we let WarmupRequestHandlerFactory track the global request count.
Therefore we map all the extra callee parameters to the callee operand of the apply site.
Therefore we need /    LLVM's constant propagation prior to deciding on stack promotion.
Therefore we need a thunk which converts from the re-abstracted function back to the original function with indirect parameters/results.
Therefore we still have to check it.
Therefore we will potentially see a load of the array struct if there are mutating functions in the loop on the same array.
Therefore when constructing a class object, either the metatype must be statically derived (rather than an arbitrary value of metatype type) or the referenced constructor must be required.
Therefore, SSA guarantees no intersection.
Therefore, any indexed type with such an action can immediately be marked as pointer followable, which helps us reach a fixed point faster.
Therefore, blocks cannot be empty.
Therefore, compute s_cactiveLimitCeiling here in order to amortize the cost of introspecting footprint and MemTotal.
Therefore, if a normal load in this function sees a weak reference count of 1, it cannot be racing with a weak retain that is not racing with deallocation:
Therefore, if the variable is a constant, the value is guaranteed valid as well.
Therefore, in this case, we use the address of the lazy-cache function.
Therefore, just mark the function.
Therefore, move the reference from tvRef to tvRef2, so that the reference will be released one iteration later.
Therefore, only colors that are within minmaxdist of some part of the box need be considered.
Therefore, per RFC 2616, they *should* consist entirely of US-ASCII characters, so use of QString::fromLatin1 here is safe.
Therefore, such borrowings must be "unforwarded" / during the emission of such jumps by disabling the new cleanups / and re-enabling the outer cleanup.
Therefore, tell initSchema() to verify that the database is writable.
Therefore, the current cast fails for sure.
Therefore, the default case is not known.
Therefore, the representation must remain / consistent across all abstraction patterns.
Therefore, there is no need to clone the BB for SuccessPreds.
Therefore, they have to be computed.
Therefore, we can adjust the number of remaining specializations very easily.
Therefore, we can perform a completely naked load here.
Therefore, we copy the original block, update it, and replace it in the region.
Therefore, we ensure that only one store per block is present in the StoredLocations.
Therefore, we must typically force the initialization of / a class when emitting a reference to it.
Therefore, we need Impl to be initialized statically before main() starts.
Therefore, we need to ensure they appear in the dynamic table.
Therefore, we only enforce the maximum access if the extension has a 'where' clause.
Therefore, we only include the function body along with the DV init if both (a) the function has a single proflogue, and (b) the size of the function is within a certain threshold.
Therefore, we will reprocess FooSomeEnumeration at the end, once "Foo" is available.
These / may indirectly access the struct's elements.
These 16 integers are fed through 320 invertible modifications, where each modification changes one integer.
These 16 words are fed through 320 invertible modifications, where each modification changes one word.
These 4 rules can delay the start of the year by as much as 2 days.
These LayoutErrors are gathered and reported together at the end of processing.
These actually perform some sort of operation against the operand or can use the value in some way.
These always produce lvalues.
These archetypes can be / represented by a refcounted pointer instead of an opaque value buffer.
These are RAII so that the scope gets popped when the NodeScope is destroyed.
These are a list of basic blocks that we actually processed.
These are all expected to be equal.
These are all of the variables that we are tracking.
These are an / implementation detail of type metadata access functions.
These are an / implementation detail of witness table lazy access functions.
These are basically the madnesses that boost::variant has to go through, with the advantage of address-invariance.
These are both initialized to the same zval, but that's okay because.
These are conditions independent of the call graph.
These are conservative, but we're testing them that way.
These are created as part of type-checking "return" in an initializer.
These are defined in ext_socket, but Zend has them in network
These are for settings/callbacks only settable at startup.
These are for settings/callbacks that the script can change during the request.
These are functions that we don't want to copy from the module.
These are important uses that we'll visit, but we don't consider them definition points for liveness computation purposes.
These are in order according to the binary encoding of the X64 condition codes.
These are instructions that are always interp-one'd, or are always no-ops.
These are instructions that cannot observe the reference count and so we can sink IncRefs across them regardless of their lower bounds.
These are instructions that push an output type that is always the same, i.e. where an AssertT is never going to add information.
These are just some last resort values that might match some Un*x system if building this version of gd separate from graphviz.
These are keywords that we accept as attribute names.
These are made visible to non-reentrant scanners for convenience.
These are mostly for the class creation path.
These are not commonly used and cause noise and confusion when showing among the members of the underlying type.
These are not types, and cannot be preceded by "u" to make them unsigned.
These are only meaningful after we do dataflow.
These are ostensibly bools, but for historical reasons are expressed as ints
These are placed last because they become the first curry level of the SIL function.
These are private so that we don't accidentally copy and later double-delete one of of the pointers in children.
These are rare situations, and so we just punt to the interpreter.
These are sets of SSATmp names that are known to alias the same object, in a "semi"-flow-insensitive way (see below).
These are somewhat dubious, and shouldn't really occur:
These are special and can't have extensions.
These are stored explicitly for two reasons:  o When inserting phis, we need to see the state on each edge coming to a join point to know what to phi.
These are tests for some unrepresentable bit combos.
These are the amounts to shift an input value to get a histogram index.
These are the blocks that have an RC instruction to process or it blocks / some RC instructions.
These are the edges that create loops.
These are the list of SILValues that are actually released.
These are the only interesting cases where we could be doing better.
These are the paths from blocks with known out-availability to the BB.
These are the possible outputs:
These are the same kind of type, we need to disambiguate them
These are used when we can make an accurate prediction of where execution should flow, eventually, and when we want to let the program run normally until we get there.
These aren't distinguishable from unowned for trivial types.
These arenas tend to have proportionally large memory usage fluctuations because requests clean up nearly all allocated memory at request end.
These array semantics calls do not capture anything.
These asserts ensure that the state transition works.
These asserts make sure that the startedCheck work.
These booleans indicate whether this is currently the first or second pass over the global scope (or neither, if we're in a context where we only visit each decl once).
These builtins don't care about their argument:
These can end up as non-archetypes because of multiple levels of equality.
These can include paths from a release back to the alloc_box in a loop.
These can't appear on overridable declarations.
These cannot be encoded as UTF-16 surrogate pairs, so UTF-32 doesn't allow them.
These cases are /not/ in the version in TypeCheckExpr, since they never appear in operator position.
These cases are differentiated using the bottom 3 bits of the pointer.
These cases should be handled by clients of this API.
These cases will never be promoted to value bitcast, thus will cause the subsequent runtime cast to fail.
These characters need to be escaped.
These constants are mainly used with ImagickPixel.
These constants don't correspond to method families we care about yet.
These conventions don't require changes to the formal error type.
These conventions leave the formal result alone.
These conventions make the formal result type ().
These conventions replace the result type.
These conventions wrap the result type in a level of optionality.
These conversions are between concrete types that don't need further resolution, so we can consider them immediately solved.
These could also return pointers to collection elements but those don't exist in AliasClass yet.
These could be thrown into a macro, but there aren't very many cases
These could be valid utf-8, but cannot be represented as modified UTF-8, due to the 20-bit limit on that representation.
These could belong to the control flow statement we are folding (ex: while loop).
These days it is often faster than table lookups or integer arithmetic.
These declarations are only included in the debug info.
These declarations are uniqued by signature, so it is totally random (determined by the hash function) which of the equivalent declarations (across multiple modules) we will get.
These definitions are coped from the Zend formatted output conversion files so that we only need to make minimal changes to the Zend formatted output conversion functions that are incorporated here.
These definitions are not necessarily loop invariant, because their destination SSATmps may have types that depend on the position in the program.
These do not call NSArray methods.
These do not have any spare bits because they can contain Obj-C tagged pointers.
These do prevent removal.
These don't actually work.
These don't have any extra implicit parameters.
These don't need a register because their values are static or unused.
These don't need to be exposed, but make dealing the breakpoints less verbose.
These don't prevent removal.
These each may depend on computations from previous functions, so be careful changing the order here.
These entrypoints don't modify any compiler-visible state.
These expansion steps can foil / the general mid-level optimizer, so they are done very, very, late.
These explosions must follow the same schema as ClassExistentialTypeInfo, i.e. first the value, then the tables.
These form dipthongs when preceding H
These four dual-inherit from DeclContext.
These four methods all have the same(ish) signature, but don't fit nearly into a template, so I went hacky...
These functions try to take their first parameter by reference but they also allow expressions that cannot be taken by reference (ex. an array literal).
These functions use murmurhash2 in its 32 and 64bit forms, which are differentiated by the constants defined below.
These global references are created manually instead of using global_ref from References.h to avoid circular dependency.
These have names and linkages, so we must record them.
These index the known object types in various ways to allow for the proper lookup of an object type according to its linkage.
These instructions all read from the ActRec.
These instructions are ok but count as mutations.
These instructions can only get at tvRef when given it as a src.
These instructions do not cause the address to escape.
These instructions do not use other values.
These instructions do read or write memory, get memory accessed.
These instructions don't have any effect on escaping.
These instructions end a unit after executing the bytecode instruction they correspond to.
These instructions never load tvRef, but they might store to it.
These instructions only cause the value to escape if they are used in a way that escapes.
These instructions return pointers to memory which can't be a destination of a store.
These instructions should not reach here based on the pass ordering.
These instructions will emit a special SyncReturnBC instead to fixup the call frame to contain the inlined frame.
These invalidate enums so "write" memory, but that is not an essential operation so we can remove these if they are trivially dead.
These is missing from cygwin ipc headers.
These just help propagate exceptions so ignore those.
These keywords are only active in SIL mode.
These keywords don't start a decl or a statement, and thus should be safe to skip over.
These kinds are only similar to the same kind.
These last-ditch exception handlers write to the C stderr because who knows what kind of state Qt is in.
These layouts can exist in both decl blocks and sil blocks.
These letters are passed through unchanged
These little wrappers keep the const_casting out of the main line of code below.
These locals will be populated by DV init funclets but they'll start out as Uninit.
These logged stacks can be then gathered via php a call, xenon_get_data.
These make C and G soft
These maps always have an entry for each public static property declared in this class, so it can also be used to check if this class declares a public static property of a given name.
These may be due to the return from turning tracing on.
These may be overridden below.
These may change across compiler versions.
These methods are not mutating and pass the array owned.
These methods use special implementations
These modes can be pushed on the PDA stack.
These modes have no frontend-generated output.
These need to be lowercase...
These notices must be retained in any copies of any part of this documentation and/or software.
These numbers have the appearance of being un-relocated addresses, but its in the final executable.
These only apply to the generic type if they don't start a new line.
These only occur in traits, so we don't need to do better than this.
These opcodes leave a single value on the stack that becomes part of the generator's stack.
These opcodes require an object descending from WaitHandle.
These operate only on `this' and not its children.
These optimizations differ enough from both DCE and PDCE to require a separate pass.
These prevent GH from becoming F
These probably are generally string keys and this should probably be ArrayInit::Map.
These properties must be dynamic because you can't declare a property with a non-string name.
These references are used in generating new instructions that extract from the aggregate.
These remaining instructions are ok and don't count as mutations.
These require special handling
These retain instructions return their argument so must be processed specially.
These routines are concerned with the time-critical task of mapping input colors to the nearest color in the selected colormap.
These routines provide selection of a custom color map for an image, followed by mapping of the image to that color map, with optional Floyd-Steinberg dithering.
These routines work with a list of "boxes", each representing a rectangular subset of the input color space (to histogram precision).
These settings are NOT system settings.
These should already have accessor functions.
These should already have been diagnosed by type-checking but we may still get here after recovery.
These should be the same.
These should never be encountered because they don't represent independent allocations.
These should never fail.
These shouldn't occur in expandable struct types.
These specializations are generated during -O compilation of / the library, but only used only by client code compiled at -Onone.
These static strings are the same as the ones in hphp/compiler/type_annotation.cpp, where the typeAnnotArrays are originally generated.
These strings should stay in sync with the types in type-scan.h.
These technically have side effects, but not ones that matter in a block that we shouldn't really reach...
These terminator instructions block.
These transformations are safe to perform as we know the layouts at maximal.
These two instructions don't touch memory we track, except that they may re-enter to construct php Exception objects.
These two operations must follow the same rules for column placement because 'arguments' are parallel to the matrix columns.
These two routines are coupled---most cases in findWeakActRecUses should have a corresponding case in performActRecFixups to deal with the frame being removed.
These type matching functions are currently only used for assertions, so it's ok to leave them out.
These type-scanners will then be compiled into a shared object which can be loaded at start-up if GC is enabled.
These typealiases frequently create a many-to-one mapping, so just use the first type that mapped to a particular underlying type.
These types are always class references.
These types cannot be expressed in swift yet.
These types don't actually get used to make Calling Convention choices - originally we were leaving them all at Normal...
These typevars come into them when the body does name lookups against the parameter decls.
These values cache the function_ref so we don't emit multiple of them.
These values can be / propagated to the get_element method if we can prove that the array value / has not changed until reading the array value's element.
These values must go toward their conservative state.
These variable sets are used to compute the transfer function for the global liveness analysis in global_dce.
These vectors are completely parallel, but the switch instructions want only the first information, so we split them up.
These will be assigned SIMD registers later.
These will do the right thing for either R,G,B or B,G,R color order, but you may not like the results for other color orders.
These work whenever they are suggested.
These would start an encoding for something that couldn't be represented with UTF16 digraphs, so Unicode rejects them.
They / should be never inlined.
They accomplish this by forward-propagating the block input states from a FuncAnalysis to each instruction in the block prior to doing the backward iteration.
They all affect some locals, but are otherwise the same.
They all should be loads, so that we can replace it.
They also make IOCtx calls look better...
They also may generally write to the eval stack below an offset (see alias-class.h above AStack for more).
They also ought to kill /something/ on the stack, because of possible re-entry.
They always require an initial value, so they always allow unspecified types.
They are adjusted to not be l-values.
They are defined in php_mongo.h
They are equivalent along all paths.
They are implemented afterwards in order to guarantee that the desired vasm is already defined or else it'll fallback to the templated emit function.
They are in a normal function, but didn't come from a VarDecl, or came from one that was autogenerated or inlined from a transparent function.
They are in a transparent function.
They are listed below and how we work around / them: / / 1.
They are marked mutable so that getObject() can remain const.
They are not imported directly.
They are now dominated by the check block.
They are only mutable in designated initializers.
They are only used for determining whether it is necessary to add parentheses in a fix-it.
They are only used when generating profiling translations.
They are part of the variable or subscript.
They are replaced with _.
They are:  (*) Ignore -- Scanner is trivial.
They aren't available independently.
They better be ABI-compatible, since we can't emit a thunk.
They can all re-enter the VM and access arbitrary heap locations.
They can also invoke the user error handler and go do whatever they want to non-frame locations.
They can be moved to the loop pre header without changing the program's semantics.
They can be used to highlight the location of the current breakpoint in the edit window of an attached IDE, for example.
They do not, however, necessarily have any spare bits.
They don't add value.
They don't affect the structure.
They don't need protection by retain/release.
They don't need to be relocated like normal VdataPtrs, so bind them here.
They don't participate in the ordering relation.
They forgot to leave room for the EOB's.
They have bytecode bodies that just fatal, so it won't hurt return type inference (we'll just add an extra TBottom to the return type union).
They have to be non-local because otherwise we'll get warnings when a particular x-macro expansion doesn't use one.
They however don't return IrrelevantEffects because we assume (in refcount-opts) that IrrelevantEffects instructions can't even inspect Countable reference count fields, and several of these can.
They include context about why and where the error occurred.
They make the systems different, but don't affect ranking.
They may be attached to an operator declaration or a function.
They may have uses of SSATmps that no longer have defs, which can break how the simplifier chases up to definitions.
They may not unlink the block containing the CheckType instruction they are visiting.
They may occur if the body of a closure was not visited while pre-checking because of an error in the closure's signature
They may reject some Statics in some situations, where we only guard using the type tag and not by loading the count field.
They must all have keywords.
They must also define a function called collectionVsNonObj() which is used when comparing collections with non-object types.
They need to both be spill frames affecting the same addresses, or both not be spill frames.
They produce valuable information for optimizations that's lost across region boundaries.
They require that the appropriate ObjectData::Attribute has been checked first, and return false if they refused to run the magic method due to a recursion error.
They should all happen after self.init is invoked.
They should all happen after super.init is invoked.
They should be rare, so for now we'll do the most conservative thing and completely bail out, doing no dead code elimination.
They should be structurally equivalent.
They should be the same now.
They should go into RequestInjectionData.
They should not prevent load promotion, and will allow promoting values like X in regions dominated by "...
They shouldn't prevent us form forming a complete call.
They still can't be captured without doing unsafe stuff, though.
They use this to determine the pointer to the Zend resource (the pointer is normally null).
They will be implicitly emitted by SILGen into the generated initializer.
They will override the KindOfUninit values set by scalar initialization.
They'll be rechained to go to the new pre-header.
They'll only be visited if there are no other possible solutions.
They're all going to be the same, but still, ick.
They're insignificant here.
They're of the same kind: fix the name.
Thick and ObjC metatypes look like pointers with extra inhabitants.
Thick functions (TODO: conditionally) get bridged to blocks.
Thick functions consist of a function pointer and nullable retainable / context pointer.
Thick metatypes are represented with a metadata pointer.
Thick metatypes are sources of metadata.
Thick metatypes look like pointers with spare bits.
Thin metatypes are always free.
Thin metatypes are empty, so they look like the empty tuple type.
Thin metatypes are empty.
Thin to thick function has no non-callee arguments.
Thin types have a trivial representation.
Things earlier in the list are considered to have higher specificity (and thus, higher priority) than things lower in the list.
Things that may be read in the block
Things that may be written in the block
Things that maybe we should collect from the command line: - relocation model - code model FIXME: We should do this entirely through Clang, for consistency.
Things we can determine before we seek
Things we can determine when we seek
Third case: conformance needs both default requirements to be filled in
Third, try to get magic file relative to dll location
This "always fails" diagnosis makes no sense when paired with the CF one.
This "static empty mixed array" is only used internally within the HashCollection implementation and it's never exposed outside of the HashCollection implementation.
This (and the IGM itself) will get deleted by the IGMDeleter as long as the IGM is registered with the IRGenerator.
This (throwing away the data) is overly conservative, but works for now.
This / assumes that field and global-variable bindings always bind at / least one name, which is probably a reasonable assumption but may / not be adequately enforced.
This / helps generating the genset and killset.
This / is designed to work with RValue ManagedValue bases that are either +0 or +1.
This / means that from an RC use perspective, the object can be ignored since it is / up to the frontend to communicate via fix_lifetime and mark_dependence these / dependencies.
This / provides a convenient place to specify the refined range when it is / different than the declaration's source range.
This / returns the new instruction if it inserts one, otherwise it returns null.
This / simplifies functions that need to differentiate a tuple from the input / part of a function type.
This AI is a strong entrance for its return value.
This API does /not/ actually guarantee a copy occurs, but if it does any assoicated strong iterators must be moved.
This API does /not/ actually guarantee a copy occurs.
This API should be sunk down to LLVM.
This ASTWalker explores an expression tree looking for expressions (which / are DeclContext's) and changes their parent DeclContext to NewDC.
This Archetype comes from an enclosing context -- proceed to bind the generic params form all parent contexts.
This BB copy branches to SuccessBB.
This BB copy branches to a FailureBB.
This BlockState contains concrete values for all the expanded locations, collect and reduce them into a single value in the current basic block.
This BlockState does not contain concrete value for any of the expanded locations, collect in this block's predecessors.
This CheckType should've been optimized away but wasn't, presumably because certain optimizations are off or haven't run yet.
This DIE is the first one which contains some data within the begin/end range, so that must be the first one to begin recursion at.
This DecRef may rely on one of the IncRefs, since we aren't handling may-alias stuff here.
This DecRef never saw a refcounted type during profiling, so call the stub in cold, keeping only the type check in main.
This LoweredValue corresponds to a SIL address value.
This SILValue may be a BB arg, if it was a cast between optional types.
This SILValue may be null if we were unable to find a specific RCIdentity that the instruction "visits".
This access pattern is used when the field offset depends on generic parameters.
This actually let us ignore the loop bypass edge in the length calculation for the loop's parent scope.
This address is of the substituted type.
This affects cases where we're able to eliminate control flow while inlining due to the parameter types, and the AttrMayUseVV flag was due to something happening in a block we won't inline.
This affects how unqualified identifiers are processed.
This affects may-load, may-store, and kills information for the instruction.
This algorithm assumes we don't have both literal and literal-type-match at the start of the list.
This algorithm comes from pnmcrop (http://netpbm.sourceforge.net/) Three steps: - if 3 corners are equal.
This algorithm treats the exceptional live-out states differently from the live-out states during normal control flow.
This all applies only for direct calls to assert() -- dynamic calls don't get this special logic, and don't in PHP7 either.
This allocates copies of / the ParamDecls, so they can be reparented into a new DeclContext.
This allowed the color conversion math to be done only once per colormap entry, not once per pixel.
This allows "self reassignment" to happen in super init method chains, which is important for interoperating with Objective-C classes.
This allows CompilerType::IsSwiftMethod to work properly off the swift Type.
This allows a Swift module to extend a Clang module of the same name.
This allows a fairly fast implementation of the "brute force" approach of computing the distance from every colormap entry to every histogram cell.
This allows all of the map implementations to be tested with shared implementations of helper routines.
This allows downstream pattern / detection like induction variable analysis to succeed.
This allows for better diagnostics, and keeps the closure expression type well-formed.
This allows for significant reductions in the size of the state transition table.
This allows for subsequent rollback.
This allows for un-accepted connections to be queued and then wait until all queued requests are actively being processed.
This allows for use of popular specialized functions from the standard library, which makes the non-optimized builds execute much faster.
This allows max_acquire to be set and track the PHP code without having a global init routine or external semaphore init code.
This allows mixed compilation, where some units were compiled DEBUG and others compiled RELEASE, to successfully link.
This allows operations with underscores in them, like "icmp_eq".
This allows the `region' to originally contain blocks stored in ProfData, which may be reused later with different guard-relaxation decisions.
This allows the user to break out of (or restart) the entire construct.
This allows type declarations and other things to be parsed, name bound, and type checked in batches, similar to immediate mode.
This allows us to avoid diagnosing DI / errors in synthesized code that turns out to be unreachable.
This allows us to avoid materializing copies of existentials.
This allows us to cope with zero-parameter methods with selectors that are longer than "init".
This allows us to have reasonable DeclContexts for any closures that may live inside of initializers.
This allows us to heuristically filter large overload sets better.
This allows us to initialize object properties very quickly because we can just memcpy and we don't have to do any refcounting.
This allows us to perform typo correction on the labels.
This allows us to skip the very expensive ratchet operation after intermediate operations.
This allows us to structurally unify disparate protocol members during overload resolution.
This also adds a connection to "servers" for each new node
This also allows a faste implementation of getText()
This also applies to nextRetrans and prevRetrans.
This also determines whether it is a leap year.
This also enforces that SIL bodies can only be at the top level.
This also ensures that we are locally identified and non-escaping since we only allow for specific ARC users.
This also has the bonus feature that the value of __FUNCTION__ inside the created function will match Zend.
This also more correctly handles the implicit ReturnStmt injected into single-expr closures.
This also needs to happen for memory safety.
This also simplifies the handler code because it doesn't have to worry about saving its arguments somewhere while executing the exit trace.
This always involves an action on the client and usually, but not always, involves the server by sending this command to the server and waiting for its response.
This analysis is basically normal, but slightly modified from the usual in order to deal with the way exceptional control flow is represented in our CFG (with factored edges).
This applies to nested metatype levels, so if A : P then A.Type : P.Type.
This approach assumes that expression patterns can't refer to bound arguments.
This are a list of exnNodes that inherit from each other.
This aren't actually allowed, but we recover better if we skip over them.
This arg and all args that follow are intended for the PHP application
This array contains the bytes used to pad the buffer to the next 64-byte boundary.
This array holds the actually closest colormap index for each cell.
This array holds the distance to the nearest-so-far color for each cell
This array lists the candidate colormap indexes.
This array must be kept in the same order as the WIXSTDBA_PAGE enum.
This assert just makes sure they don't overflow.
This assert self documents our precondition that Context is always nullptr.
This assertion documents this assumption.
This assertion gets messed up by variadic methods that we've imported as non-variadic.
This assertion means you manually created a catch block, but didn't put an exceptionStackBoundary after an update to the stack.
This assertion should always fail, per the user's request, and should not be converted to llvm_unreachable.
This assigns a value register to constants defined by DefConst, because some HHIR instructions require them.
This assumes that a TupleType's explosion schema is always the concatenation of its component's schemas.
This assumes that any re-initialization of the alloc_stack will be obvious in the function.
This assumes that the SIL / is already in SSA form.
This assumes that the chunk size is the same as APInt's.
This assumes that we won't even try to touch the value in such cases, although we may touch the cleanup (enough to see that it's not present).
This assumes the data section is near the current code section.
This attribute exports the ctor symbol, so ReadableNativeArray to be constructed from other DSOs.
This avoids a bunch of complication around numeric-string array-index semantics.
This avoids creating a spurious _: () argument.
This avoids issues where Builtin types end up on expr nodes and pollute diagnostics.
This avoids re-calculating the dominator tree for each optimized checked_cast_br.
This avoids somewhat more complicated logic in the inner loops.
This avoids unreachable blocks appearing to be reachable, which would cause translateRegion to process them.
This bans some trickery that the redefinition types enable, but is a more sane model overall.
This behavior is undocumented and Bison users should not rely upon it.
This binop was synthesized when typechecking an expression pattern.
This block aborts the program, if something bad happens when handling exceptions, thus keeping this function noexcept.
This block contains concrete values for some but not all the expanded locations, recursively call collectLocationValues to materialize the value that reaches this basic block.
This block could be empty if it's terminator has been folded.
This block does not have a retain.
This block executes whenever we want to treat the fault as if it was freshly thrown.
This block is copied from hphp_switch_to_buffer.
This block is copied from yy_switch_to_buffer.
This block must be the only successor of all the predecessors.
This block of code, performs the pop back and also if the Node has been invalidated, skips until we find a non invalidated value.
This branch is only executed if no STREAM_FILTER* args were passed, so we always create a READ filter.
This branch might be folded by exitFalse if it turns out that that point is unreachable.
This breaks infinite recursion, which will be diagnosed separately.
This bridging is more powerful than usual block bridging, however, so we use the ObjCMethod representation.
This builds argument values for all the inner indirect results.
This caching system is somewhat /   more efficient than what IGF provides, but it's less general, and it /   should probably be removed.
This callback may be used to provide output indicating that the task began.
This can actually happen both before and after LoadModules()
This can also expose opportunities in the successors of the merged block.
This can be a bridging upcast.
This can be an early release for a conditional initializer.
This can be called multiple times, and this function leaves the proxy usable by request threads which may still be handling an interrupt.
This can be called multiple times.
This can be done / one of two ways: / /  1) recursively scalarize down the initialization on demand if the type of /     the RValue is tuple type and the initialization supports it.
This can be done unconditionally here because we maintain the invariant throughout that either tvRef is KindOfUninit, or tvRef contains a valid object that result points to.
This can be empty, meaning that values of this / type are not know to implement any protocols, although we do / still know how to manipulate them.
This can be extended in the future.
This can be improved later, e.g. by walking the untype-checked body to look for things that could possibly be used.
This can be removed when all the backend options are recorded in the IR.
This can be seen as a "simulation" of several optimizations: SROA, mem2reg and constant propagation.
This can be turned into an assert again once we have guaranteed preheader insertions.
This can cause further scalarization.
This can cause side effects.
This can depend on all of their interior function bodies having been type-checked.
This can explode copy_addrs, so the use list may change size.
This can get better results than just merging into stateIn in place, basically because of the way we represent the locations that need phis.
This can happen due to either substitution reabstractions or bridging.
This can happen due to either:
This can happen if this property is private or if it is internal and WMO mode is used.
This can happen if two threads were racing to create the counter.
This can happen if we are trying to debug an eval() call or a call issued by debugger itself.
This can happen under solaris when a dir does not have read permissions but *does* have execute permissions
This can happen when an overlay overloads an existing selector with a Swift-only signature.
This can happen when ptr is TBottom from a passthrough instruction with a src that isn't TBottom.
This can happen when there is a load of an empty struct.
This can happen when they are actually different types, because they exist in different scopes (e.g. everyone names their type parameters 'T').
This can happen when type-checking a different conformance deduces a different type witness with the same name.
This can happen, in case the replicaset name was not given, but just bool(true) (or string("1")) in the connection options.
This can help / to discover disjoint lifetimes and we can try to stitch them together.
This can include retains which is why we always attempt to move releases up the CFG before sinking code from predecessors.
This can involve chasing a chain of such type DIEs.
This can legitimately fail due to multiple input files having identical contents.
This can modify both selfValue and subs.
This can obviously be problematic if the expression in question is not an application.
This can occur because we haven't run DCE before DI and this may be a synthesized statement.
This can occur for extensions to ObjC classes.
This can only be done after binding all the value parameters, and must be done even for non-polymorphic functions because of imported Objective-C generics.
This can only be done after binding all the value parameters.
This can only happen at the function level scope.
This can only happen if the array is backed by an Objective-C array.
This can only remove from the function entry filter
This can only remove from the function exit filter
This can only remove from the line filter
This can originate if the client initiated shutdown.
This can really only when a guard is relaxed away to Gen because we knew something was a BoxedCell statically, but we may need to keep information about what inner type we were predicting.
This can relocate it if it wasn't allocated with swift_allocateGenericClassMetadata.
This can result in arcWeight to be negative here.
This can return multiple results for var decls that bind to multiple / values, structs that define a struct decl and a constructor, etc.
This can store to globals or locals, but we don't have globals supported in AliasClass yet.
This can't actually be a property of the obj because apache does weird things on object destruction that will cause the link to be destroyed twice.
This can't happen because we picked a reachable block from the workQ.
This candidate has wrong # arguments.
This cannot be an overridden property, so just eat the token.
This cannot be done for general function types, since function_ref's SILFunctionTypes do not have archetypes associated with it.
This cannot be fixed until the attributes are correctly specified.
This cannot be tok::unknown, since that is a token the lexer could produce.
This cannot happen on a top-level call, so AI should be non-null.
This case handles all types other than "array", "var" and "enum".
This case handles the release of an array buffer that is loaded from a local array struct.
This case is only hit for non-Int input types anyway.
This case is querying the init function as member
This case is where we're logically supposed to do stdClass promotion.
This case occurs when the current target class `cls' and the class we saw last time in mceKey have some shared ancestor that defines the method, but neither overrode the method.
This case should only happen if something successfully stat'd the file, but then it was gone by the time we tried to open() it.
This cast is always false.
This cast selects between two paths: one that calls the slow dynamic dispatch and one that calls the specific method.
This catches cases where we compare e.g. a non-escaping pointer with another (maybe escaping) pointer.
This catches the case where the last path piece we saw was an Extension path piece, which is not a valid way to end a path.
This causes an assertion to go off in BridgeJSC.cpp Instance::createRuntimeObject.
This causes the apply to become a sink barrier for ref count increments.
This causes the function's reference count to be incremented causing it to be alive unnecessarily.
This causes us to only perform alias queries when we are at a lattice state where the alias queries will actually be used.
This character could be either '"'or '-'
This character is not found in valid UTF-8 sequences and is rarely used in popular 8-bit character encodings.
This character isn't allowed in Swift source.
This check assumes that either the storage type of a type is an llvm::StructType or it has a single-element explosion.
This check doesn't require special casing for variadics, because it's not ok to turn a variadic function into a non-variadic.
This check ensures that the target block BB post-dominates the switch_enum block.
This check is really hinky, but it's what PHP does.
This check makes sure that if we run into any such residual null pointers, we skip them.
This check makes sure we don't record a (dummy) source location in this case.
This check relies on the fact that we cannot have nested extensions.
This check will always fail.
This check will determine if the gap belongs to another instruction or not.
This check will hold because we have canonicalized the path above to remove ..
This check_header() function is copied from zlib 1.2.3 and re-factored to work with in-memory buffers (than file streams).
This class caches the collation element results for the ASCII subset of / unicode.
This class declaration is technically a parse error, so do not type check.
This class implements a method
This class implements a simple type recursive traverser which queries a / user-provided walker class on every node in a type.
This class implements support for -verify mode in the compiler.
This class isolates our access to private internal methods of MessageFormat.
This class maintains the table of scoped clones of itself, and if we create a new scoped clone, we need to map it there.
This class provides an interface to target-dependent attributes of interest to Swift.
This class reimplements the setlocale() and localeconv() functions in a thread-safe manner and provides stronger symbols for them than would be available from the glibc shared library.
This class stores global state that we use when computing redundant load and / their replacement in each basic block.
This class transforms a hoistable loop nest into a speculatively specialized / loop based on array.props calls.
This closes and deletes the File associated with the given token.
This closure returns the length of a called function.
This closure will be able to be eliminated easily and the / overhead is gone.
This code assumes there is / only one edge between the two basic blocks.
This code does the right thing for R,G,B or B,G,R color orders only.
This code doesn't try to prove tricky validity constraints about whether it is safe to push the destroy_addr past interesting instructions.
This code doesn't try to prove tricky validity constraints about whether it is safe to push the release past interesting instructions.
This code ensures that version 2 messages are received only by receivers that previously sent a version 1 message (thus indicating their ability to deal with version 2 messages).
This code implements the AUTODIN II polynomial The variable corresponding to the macro argument "crc" should be an unsigned long.
This code is taken from http://www.acm.org/jgt/papers/SmithLyons96/hwb_rgb.html, an article on colour conversion to/from RBG and HWB colour systems.
This code is very conservative.
This code should not be hit normally since we add witness tables to the lookup cache when we create them.
This code should not be touching BBIDs directly.
This code, for some reason, reads the whole file from 0 to EOF, and then resets to the position the file was at prior to reading
This comes up with generic reabstraction thunks which have shared linkage.
This commonly happens across php calls right now, where values must be reloaded from memory because SSATmps can't span calls.
This communicates to the LLVM level ARC / optimizer not to touch this value.
This complexity should be lifted elsewhere.
This composes such a key.
This comprises / the protocol descriptor, and for ObjC interop, references to the descriptor / that the ObjC runtime uses for uniquing.
This computes `rArr + rIdx * sizeof(TypedValue) + sizeof(ArrayData)`.
This concludes the conditional scope.
This const version is static const in the compiled php extension.
This constant has a non-scalar initializer, meaning it will be potentially different in different requests, which we store separately in an array living off in RDS.
This constraint is not active.
This constructor moves values, no inc/decref is necessary.
This constructor reassociates the ArrayData with the collection, so no inc/decref is needed for the array.
This contextual conversion constraint doesn't install an actual type.
This continuation matched.
This copies all 128 bits in XMM, thus avoiding partial register stalls
This copies m_lenAndHash (8 bytes), the characters (m_len bytes), add the trailing zero (1 byte).
This copy will have its ownership in the 1:1 corresponding ZendUserIniData structure.
This corresponds to one of the function's formal parameters, so it's on the stack.
This could be Opts.Optimize if we would also unique DIVariables here.
This could be a single input tuple, with one or more arguments inside, but guaranteed to not have inout types.
This could be an array value.
This could be avoided by computing reachability on-the-fly / for each alloc_box by walking backward from mutations.
This could be for a breakpoint, stepping, etc.
This could be generalized in the future, but needs further design.
This could be handled in processNonTrivialRelease some day.
This could be improved by doing an "isCaptured" analysis when emitting address-only let constants, and emit them into an alloc_box like a variable instead of into an alloc_stack.
This could be made more aggressive through appropriate alias analysis and usage of LLVM's function attributes to determine that a function does not touch globals.
This could be moved out of the outer loop, but doing it here avoids another loop with getBlockInfo() calls.
This could be revisted later.
This could be slightly generalized to cases where there's multiple tag bits and exactly one no-payload case in the highest used tag value.
This could change the type of any local.
This could happen when we are at a known leaf of a config node.
This could share code with apc_load_impl_compressed, but that function should go away together with the shared object format.
This count can be propagated to the / count method if we can prove that the array value has not changed until / reading the array value's count.
This creates a second / insertion point that most blocks should be inserted before.
This creates a second loop nest.
This creates the right type for a getter or setter.
This currently invalidates the CFG since parts of PHI nodes are stored in / branch instructions and we replace the branch instructions as part of this / operation.
This currently means that we first show that TI cannot indirectly use Ptr and then use alias analysis on the arguments.
This cuts down on duplicates.
This data array can be directly used by the Leptonica Pix in-memory image format.
This data is never touched by the scanner.
This deals with the case where the called function has a by ref param at the index of the unpack (because we don't want to box the unpack itself).
This decl attribute has been moved to being a type attribute.
This define is here because some versions of libintl redefine setlocale to point to libintl_setlocale.
This definition is needed to avoid triggering a gcc compiler error about an overloaded virtual when only overriding the one parameter version from File.
This deletes the breakpoint
This depends on the inner details of the matching algorithm and will need to be updated if we substantially alter it.
This deserves an explanation as brotli's documentation is really incomplete on the topic.
This design has meant some duplication to what glibc already does in parsing the string locales but this should be OK because setlocale would never be called enough to be a bottleneck.
This destroys the position numbering, so we can't use interval positions after this.
This destructor is called, for example, in the course of deleting the CallbackMap s_system_ini_callbacks, which happens after the end of the request.
This difference only matters for objects that resurrect themselves in their destructors, so make sure count is consistent here.
This disambiguates the dynamic uncertainty with a runtime check.
This doc comment is going to explain a few concepts, interleaved with discussion on how they are used by the various analysis and optimization passes in this module.
This doc will be freed by xsltFreeStylesheet.
This does no type-checking except for the bare minimum to / disambiguate semantics-dependent pattern forms.
This does not / pop the cleanup stack.
This does not affect correctness, but it's worth being aware of.
This does not affect the methodNames() vector.
This does not and MUST NOT change the CFG without updating the dominator tree to reflect such change.
This does not discard the current input buffer.
This does not result in deadlock, because the Map accessor is released by m_vars.erase.
This does not use the SSAUpdater::RewriteUse API because it does not do the right thing for local uses.
This does some type checking to validate that the call will succeed.
This doesn't apply to autoclosures.
This doesn't copy them yet, but will do COW if they are modified
This doesn't handle Unicode symbols, but maybe that's okay.
This doesn't handle specialized decls since they are processed when the UnresolvedSpecializeExpr is seen.
This doesn't need to account for ActRecs on the fpiStack, because no instruction in an FPI region can ever consume a stack value from above the pre-live ActRec.
This doesn't need to be done in RepoAuthoritative mode due to trait flattening ensuring that added methods are already present in the preclass.
This doesn't use for_each because paramNames shouldn't be checked when the function is anonymous.
This doesn't work for the full generality of OptionalEvaluationExpr, but it works given that we check the result for certain forms.
This doesn't work with symlinks with alternate names, but we can't detect 'swift' vs 'swiftc' if we try and resolve using the actual executable path.
This doubling scheme keeps the total block size a power of two, which should be good for memory allocators.
This drops the empty list from the doc comment body.
This eases the implementation of intersection operator in the data flow.
This effectively performs a Copy at the same time as converting to mixed.
This element is now provided.
This emits a diagnostic with a fixit to remove the attribute.
This enables a type to retroactively model or directly conform to a protocol only available on newer OSes and yet still be used on older OSes.
This enables better recovery in the parser.
This enables some really simply local / peepholing in cases where you can't just do that with the lowered value.
This enables us to get enum information from switch_enum and cond_br about the value that an enum can take in our block.
This enables us to know that if we see a retain before any decrements that the retain is known safe.
This enables us to splice efficiently basic blocks in between functions.
This encapsulates the intermediate data structures used during the allocation phase of the algorithm so we don't have to pass them around everywhere.
This encompasses:  1) Updating the type guards on the affected blocks.
This enforces that m_blocks will be a topological order in case the region is acyclic.
This enqueue call would be safe from any thread because as the JobQueueDispatcher is synchronized
This ensures main() represents the entire run, even if we run out of log space.
This ensures that all instructions that may read from the destination address depend on CopyDest.
This ensures that all instructions that may write to destination address depend on CopyDestRoot.
This ensures that an "unexpected diagnostic" and "expected diagnostic" in the same place are emitted next to each other.
This ensures that any uses of them get appropriate types.
This ensures that filters do not corrupt areas of constant color.
This ensures that given an alloc_stack and a gep from that alloc_stack, we say that they partially alias.
This ensures that in many cases this function will exit early and quickly.
This ensures that old clients can still get a stack trace from a newer server, and vice versa.
This ensures that splitAllCriticalEdges() will not invalidate our predecessor lists.
This ensures that the debugger knows about the sandbox, and adds the thread to the set of threads currently active in the sandbox.
This ensures that the generic params are visible.
This ensures that the pretty stack trace in the verifier is included with the back trace when the verifier crashes.
This ensures that we always propagate the empty set from loops.
This ensures that we don't lose it when generic types get reverted.
This ensures that we don't return into jitted code and gives the system the proper chance to interpret blacklisted tracelets.
This ensures that we record all known protocols in the AST.
This ensures we do not shrink the lifetime of the old partial /    apply.
This ensures we only ever recompute post dominating releases on the first iteration.
This entry point is equivalent to the `crypt' function in Unix libcs.
This enum declaration is technically a parse error, so do not type check.
This enum must be kept in the same order as the vrgwzPageNames array.
This enum represents a relationship between two operands.
This enum_switch instruction is exhaustive.
This error will be extremely rare in general, though.
This evaluates arbitrary code, so it's best to be paranoid about iterators on the stack.
This exact bit can't be set anymore (because the caller of this function cleared it via a call to drop_support_bit, if we had a meta).
This exact cast will fail.
This exact cast will succeed.
This existential-to-concrete cast might bridge through an Objective-C class type.
This expects to get passed clang nodes in source-order (at least within the same header).
This exposes the copy that the function does to the optimizer.
This extra call is for the other command line options that may have been overridden by a tier, but shouldn't have been.
This extra info is / used to enhance the diagnostics.
This feature is much less relevant since HTTPS does not allow proxies to remove headers.
This field of the structure is documented as private, and sure enough it's gone in the latest libjpeg, replaced by something else.
This file contains 2-pass color quantization (color mapping) routines.
This file contains code for emitting code associated with types: - methods - ObjC dispatch thunks - SIL v-tables - etc.
This file contains code from MurmurHash, by Austin Appleby.
This file contains implementations of parts of the compiler driver.
This file contains utility methods for parsing and performing semantic on modules.
This file defines a generator that produces code to verify that IRGen's static assumptions about data layout for a Swift type correspond to the runtime's understanding of data layout.
This file defines all of the diagnostics emitted by Swift.
This file defines data structures for API availability.
This file defines external functions that can be called to explicitly instantiate the CFG printer.
This file defines function pointer symbols for runtime entries.
This file defines routines relating to abstraction patterns.
This file defines routines relating to bridging Swift types to C types, working in concert with the Clang importer.
This file defines several version-related utility functions for Swift.
This file defines the DiagnosticEngine class, which manages any diagnostics emitted by Swift.
This file defines the LangOptions class, which provides various language and configuration flags.
This file defines the Parameter class, the ParameterList class and support logic.
This file defines the SILCoverageMap class, which is used to relay coverage mapping information from the AST to lower layers of the compiler.
This file defines the SILVTable class, which is used to map dynamically dispatchable class methods and properties to their concrete implementations for a dynamic type.
This file defines the SILWitnessTable class, which is used to map a protocol conformance for a type to its implementing SILFunctions.
This file defines the SwiftTargetInfo abstract base class.
This file defines the data structure that holds all the debug info we want to emit for types.
This file defines the high-level BasicBlocks used for Swift SIL code.
This file defines the high-level SILInstruction classes used for SIL code.
This file defines the logic to pretty-print SIL, Instructions, etc.
This file defines the native Swift ownership transfer conventions and works in concert with the importer to give the correct conventions to imported functions and types.
This file defines the primary routines for creating and emitting functions.
This file does ugly things with macros so include last.
This file has not been truncated.
This file hasn't been included yet, so we need to parse the file
This file implements AST-level diagnostics.
This file implements IR debug info generation for Swift.
This file implements IR generation for algebraic data types (ADTs, or 'enum' types) in Swift.
This file implements IR generation for archetype types in Swift.
This file implements IR generation for class types.
This file implements IR generation for dynamic casts.
This file implements IR generation for existential types in Swift.
This file implements IR generation for function signature lowering in Swift.
This file implements IR generation for function types in Swift.
This file implements IR generation for global declarations in Swift.
This file implements IR generation for local and global declarations in Swift.
This file implements IR generation for opaque values and value witness operations.
This file implements IR generation for polymorphic operations in Swift.
This file implements IR generation for protocols in Swift.
This file implements IR generation for struct types.
This file implements IR generation for the assorted operations that are performed by builtin functions.
This file implements IR generation for the initialization of coverage related variables.
This file implements IR generation for the initialization of local and global variables.
This file implements IR generation for tuple types in Swift.
This file implements IR generation for type metadata constructs.
This file implements IR generation for types in Swift.
This file implements IR generation for value witnesses in Swift.
This file implements IR generation of type metadata for struct/class stored properties and enum cases for use with reflection.
This file implements REPL-specific semantic analysis rules.
This file implements Type::walk.
This file implements a default caching implementation that never evicts its entries.
This file implements a recursive traversal of every node in an AST.
This file implements a verifier of AST invariants.
This file implements algorithms for laying out structures.
This file implements application of a solution to a constraint system to a particular expression, resulting in a fully-type-checked expression.
This file implements basic setup and teardown for the class which performs IR generation for function bodies.
This file implements bridging to Objective-C.
This file implements constraint generation for the type checker.
This file implements declaration name demangling in Swift.
This file implements declaration name mangling in Swift.
This file implements declaration specialized name mangling for SIL.
This file implements diagnostics for the type checker.
This file implements dumping for the Swift ASTs.
This file implements general IR generation for control flow.
This file implements generation of Clang AST types from Swift AST types for types that are representable in Objective-C interfaces.
This file implements implicit derivation of the Equatable and Hashable protocols.
This file implements implicit derivation of the ErrorProtocol protocol.
This file implements implicit derivation of the RawRepresentable protocol for an enum.
This file implements interfaces for performing name lookup.
This file implements name binding for Swift.
This file implements name lookup within the type checker, which can involve additional type-checking operations and the implicit declaration of members (such as constructors).
This file implements name mangling for IRGen entities with linkage.
This file implements optimizations for reference counting, object allocation, and other runtime entrypoints.
This file implements parser state persistent across multiple parses.
This file implements printing for the Swift ASTs.
This file implements routines for arbitrary Swift-native heap objects, such as layout and reference-counting.
This file implements routines for finding and caching local type data for a search.
This file implements routines for searching for ways to find metadata from other metadata.
This file implements routines for working with extra inhabitants.
This file implements routines relating to declaration attributes.
This file implements semantic analysis for Swift declarations.
This file implements semantic analysis for attributes.
This file implements semantic analysis for declarations.
This file implements semantic analysis for expressions, analysing an expression tree in post-order, bottom-up, from leaves up to the root.
This file implements semantic analysis for patterns, analysing a pattern tree in both bottom-up and top-down ways.
This file implements semantic analysis for protocols, in particular, checking whether a given type conforms to a given protocol.
This file implements semantic analysis for statements.
This file implements semantic analysis to ensure that errors are caught.
This file implements several PrettyStackTraceEntries that probably ought to be in LLVM.
This file implements several Swift-specific implementations of PrettyStackTraceEntry.
This file implements simplifications of constraints within the constraint system.
This file implements solution ranking heuristics for the constraint-based type checker.
This file implements support code for ClusteredBitVector.
This file implements support for Swift name lookup tables stored in Clang modules.
This file implements support for generics.
This file implements support for importing Clang declarations into Swift.
This file implements support for importing Clang types as Swift types.
This file implements support for inferring when globals can be imported as members
This file implements support for loading Clang modules into Swift.
This file implements support for loading modules serialized into a Mach-O AST section into Swift.
This file implements support for translating some kinds of C preprocessor macros into Swift declarations.
This file implements the ASTContext class.
This file implements the ASTNode, which is a union of Stmt, Expr, and Decl.
This file implements the ConcreteDeclRef class, which provides a reference to a declaration that is potentially specialized.
This file implements the ConformanceLookupTable class.
This file implements the Decl class and subclasses.
This file implements the DeclNameLoc class.
This file implements the DiagnosticConsumer class.
This file implements the DiagnosticVerifier class.
This file implements the Expr class and subclasses.
This file implements the GenericSignature class.
This file implements the Identifier interface.
This file implements the IterativeTypeChecker class, which performs iterative type checking by tracking the set of outstanding type-checking requests and servicing them as needed.
This file implements the Lexer and Token interfaces.
This file implements the Module class and subclasses.
This file implements the Pattern class and subclasses.
This file implements the PrintingDiagnosticConsumer class.
This file implements the RemoteAST interface.
This file implements the SerializedDiagnosticConsumer class.
This file implements the Stmt class and subclasses.
This file implements the Substitution class and operations on it.
This file implements the Swift parser.
This file implements the Type class and subclasses.
This file implements the TypeCheckRequest type, which describes a request to the type checker to compute certain information.
This file implements the TypeRefinementContext class.
This file implements the TypeRepr and related classes.
This file implements the availability specification AST classes.
This file implements the caching mechanism using darwin's libcache.
This file implements the constraint solver used in the type checker.
This file implements the entrypoints into IR generation.
This file implements the interface to the Builtin APIs.
This file implements the lookupVisibleDecls interface for visiting named declarations.
This file implements the platform kinds for API availability.
This file implements the playground transform for Swift.
This file implements the portions of the IterativeTypeChecker class that involve declarations.
This file implements the portions of the IterativeTypeChecker class that involve name lookup.
This file implements the portions of the IterativeTypeChecker class that involve types.
This file implements the protocol conformance data structures.
This file implements the remangler, which turns a demangling parse tree back into a mangled string.
This file implements the small amount of code for the heterogeneous stack and list classes.
This file implements the swift::performTypeChecking entry point for semantic analysis.
This file implements utilities associated with default arguments.
This file implements utilities for working with words and camelCase names.
This file implements validation for Swift types, emitting semantic errors as appropriate and checking default initializer values.
This file is part of the Independent JPEG Group's software.
This file is part of the PhantomJS project from Ofi Labs.
This file provides EnumInfo, which describes a Clang enum ready to be imported
This file provides high-level entry points that use constraint systems for type checking, as well as a few miscellaneous helper functions that support the constraint system.
This file provides support for reasoning about CF types
This fires the initial session started interrupt to the client after it first attaches.
This first branch is the only thing we'd be able to omit if we were doing AddInt.
This first day of the year will be the day of the molad unless one of 4 rules (called dehiyyot) delays it.
This force-casts the incoming address to NativeObject assuming the caller has performed all necessary checks.
This forces any errors to appear upfront, and helps eliminate some nasty lag after the first statement is typed into the REPL.
This form is used with tuples that have elements with no names or default values.
This format is designed to accurately represent API (and, in future, ABI) of a Swift module.
This frame was called by translated code so we can't interpret out of it.
This frame wasn't called from the TC, so it's ok to return using the interpreter.
This function / returns true if a change was made.
This function appends a new KindOfRef to the array with the next available integer key, boxes v if it is not already boxed, and points the new value to the same RefData.
This function appends a new value to the array with the next available integer key, if there is a next available integer key.
This function assumes that 'globals' only contains GlobalValue values for the entities that it will look up.
This function assumes the object and object/array down the tree have no internal references and do not implement the serializable interface.
This function changes any boxed local into a BoxedInitCell type.
This function checks a few cases to ensure combining array type bits leaves it predefined.
This function clears the read preference before adding tagsets.
This function conceptually should check that the portions of the specialized information on the intersection of the stagBits for the two classes may overlap.
This function creates an accessor function (with no body) for a computed / property or subscript.
This function deletes all of the loads and stores except / for the first load and the last store.
This function determines how those two parameters are interpreted in f_substr.
This function doesn't actually prove that the taken branch is a side exit.
This function ensures that if two exit heads have a common successor we will phi their frame pointers.
This function goes through all the blocks' `data' and marks as deleted the ones that are equivalent (per the `equivalent' function above) to another block after relaxing the guards.
This function goes through the arguments of F and sees if we have anything / to optimize in which case it returns true.
This function happens-after a point where the strong reference count was 0.
This function has copy/grow semantics.
This function inspects a sil / value and strips trivial conversions such as values that are passed / as arguments to basic blocks with a single predecessor or type casts.
This function inspects the instruction and prepares it for potentially being inserted to the instruction stream.
This function is a substitute for real alpha channel operations, so it doesn't pay attention to the alpha channel.
This function is called from hphplex_destroy(), so don't allocate here.
This function is called from yylex_destroy(), so don't allocate here.
This function is called many times.
This function is called once, when a class is first loaded, so it is not performance critical.
This function is called repeatedly by rl_completion_matches.
This function is expected to be called after all calls to appendParam are complete.
This function is logically 'readnone': the caller does not need to reason about any side effects or stores it might perform.
This function is named the same and similar in implementation to that in php-src:php_zip.c One difference is that we canonicalize here whereas php-src is already assumed passed a canonicalized path.
This function is necessary because for semantic / analysis, the parser attaches attributes to declarations other / than those on which they, concretely, appear.
This function is only entered when the machine being debugged is paused.
This function is sometimes called more than once on the same buffer, such as during a hphprestart() or at EOF.
This function is sometimes called more than once on the same buffer, such as during a yyrestart() or at EOF.
This function is to ensure that the OS won't schedule the process to different processors, which would make values read by rdtsc unreliable.
This function is used when another thread is segfaulting---we just want to wait forever to give it a chance to write a stacktrace file (and maybe a core file).
This function isn't meant to perform the actual comparison at compile-time.
This function may also throw an UnknownInputException if the reffiness cannot be determined.
This function may not be called without first calling Escalate.
This function may return a new array if it decided to COW due to cowCheck().
This function needs to be kept in sync with its counterpart, abstractSyntaxDeclForAvailableAttribute().
This function needs to be kept in sync with its counterpart, concreteSyntaxDeclForAvailableAttribute().
This function never returns error.
This function recursively visits each node in an expression, keeping track of where to jump if an "and" or "or" expression short circuits.
This function refines, rather than invalidates, the old prediction.
This function requires 'properties' to contain all props declared in the class and all props being public.
This function return false if we are certain instantiating rleaf would be a fatal at runtime.
This function returns an array containing two keys "file" and "line" which indicate the the filename and line number where the "caller" called the "callee".
This function returns its first argument so that in some cases we can do tails calls (or maybe avoid spills).
This function returns the File associated with the given token.
This function returns the offset of instruction i's branch target, which is the offset corresponding to the branch being taken.
This function should not be called / on metadata objects that are in the process of being initialized.
This function should only be called for instructions that read the current FPI
This function sorts the `blockData' vector in decreasing order or weight, and keeping the deleted ones at the end.
This function tries to infer the weight of any arc in the arcVec given the weights of other arcs in the list and totalWeight, which is the known sum of all their weights.
This function will allocate the stack if necessary.
This function will create a immutable copy of this Map (if it doesn't already exist) and then return it
This function will create a immutable copy of this Set (if it doesn't already exist) and then return it
This function will create a immutable copy of this Vector (if it doesn't already exist) and then return it
This function will only return when the debugger is letting the thread continue execution, e.g., for flow control command like continue, next, etc.
This function will return the / required buffer length as a result.
This function will rewrite any / existing external declaration to the address point as an alias into the / full metadata object.
This function's data flow would converge in 1 iteration.
This functions would simplify the code as following:
This generally involves inserting the right kind of type conversions to satisfy PHP semantics.
This generates a movq x86 instruction, which zero extends the 64-bit value in srcReg into a 128-bit XMM register
This generates code to destroy the elements / that are known to be alive, ignore the ones that are known to be dead, and / to emit branching logic when an element may or may not be initialized.
This gets it's own thread, and polls the client once per second to see if there is a signal, i.e., if the user has pressed Ctrl-C, etc.
This gets tricky: - if we had a ref-counted type, and it was converted to a Bool, Int or Dbl above, we explicitly DecReffed it (in coerce_value).
This gives a return value similar to that from fcvt, except that trailing zeros are suppressed, and ndigits can be negative.
This gives a return value similar to that of ecvt, except that trailing zeros are suppressed.
This gives arrays a chance to change to a kind that supports sorting.
This gives the flexibility to / find exactly which part of the store is alive and which part is dead.
This gives us minimum bounds on the size and alignment of the aggregate.
This global is not initialized by a simple constant value at this moment.
This guarantees eventual termination.
This hacks mustBeRef() to return false for the first parameter of extract(), current(), key(), and array_multisort().
This handler also cleans and syncs vmRegs for us.
This handles "falling off the end of the function" logic.
This handles an optional source wrapped within an existential that Optional conforms to (Any).
This handles generically retains/release.
This handles import directives and forward references.
This handles parameter decls in ClosureExprs.
This handles returns, suspends, and exceptions.
This handles skipping over null entries in the / worklist.
This handles the BraceStmt in non-single-expr closures, so we don't walk into their body.
This happens automatically for dynamically-linked programs, but in this case we have to take additional measures.
This happens because yy_g_n_b() sees that we've accumulated a token and flags that we need to try matching the token before proceeding.
This happens e.g. if a public class contains a (dead) / private method.
This happens e.g. if it is a generic class.
This happens for instance if we have cleared all of the state we are tracking.
This happens for properties and global variables in libraries.
This happens if it can be proven that generated / checked_cast_br instructions cover all other possible cases.
This happens if we have a cycle in the call-graph.
This happens in foreach silgen (see rdar://15532779) and needs to be resolved someday, either by changing silgen or by teaching DI about destroy events.
This happens when CSDiags nukes a type.
This happens when binding an address only parameter to an argument, for example.
This happens when class witnesses implement non-mutating protocol requirements.
This happens with the unowned conversions.
This happens, for example, when constructors are inlined.
This happens, for example, with ambiguous OverloadedDeclRefExprs.
This has a set of TrackedLocs, and an availability mask to determine which ones are currently valid.
This has the effect of an intersection since we already checked earlier that RefCountedValue was not blotted.
This has the effect of an intersection.
This has the effect of performing a use and a decrement.
This has the effect that a succession of list commands that specify no parameters will scroll sequentially through the source code in blocks of DebuggerClient::CodeBlockSize.
This has to apply to exactly the same / levels of sugar that were stripped off by lookThroughIdentityExprs.
This has to be a macro since it needs to be able to break away from the for loop we're in.
This has to be a stack instead of just a pointer because simplify is reentrant.
This has to be bug-compatible with the original implementation, so only encode 23 of the 24 bytes.
This has to be factored out like this in order for MSVC to actually disable the warning, as MSVC only allows this warning to be disabled at function boundaries.
This has to be inactive until the variable is initialized.
This has to be inactive until the variable is initialized: if control flow exits the before the value is bound, we don't want to destroy the value.
This has to happen after building jobs, because otherwise we won't even emit .swiftdeps files for the next build.
This has to happen before requestEventHandler shutdown hooks, because it can run user code which may need to access other RequestLocal objects (such as the stream registry).
This has to happen before we start hooking up the Jmps on predecessors, because the block could be one of its own predecessors and it might need to send this new dst into the same phi.
This has to happen before we write the first param.
This has to match up with layout algorithms used in IRGen and the runtime, and a bit of SIL type lowering to boot.
This has to occur first during type checking, because the extensions need to be wired into the AST for name lookup to work.
This has two purposes: 1.
This helper for weaken_decrefs reports uses of reference-counted values that imply that their reference count cannot be zero (or it would be a bug).
This helper is reached via call from the various freeLocalHelpers.
This helper should only be called for the Object, Self, and Parent cases
This helps generating the genset and killset.
This helps in generating / the genset and killset.
This helps our pruning later.
This helps to avoid 'widening' the favored type to the default type for the literal.
This helps to avoid phase ordering issues (simplify-cfg *should* / catch this).
This helps to simplify the creation of an enum from an integer raw value.
This helps us avoid parsing the body of the string / as program tokens, which will only lead to massive confusion.
This heuristic also simplifies which regions we want to specialize on.
This how we recognize which colors are actually used.
This ignores statements and other non-expression / children.
This ignores the concrete types of the arguments, looking only at the argument labels etc.
This ignores the concrete types of the arguments, looking only at the argument labels.
This ignores type prefixes for acronyms, e.g., the 'NS' in 'NSURL'.
This implementation is copied here to avoid a new dependency on compiler-rt on Linux.
This implements partial-redundancy elimination for stores.
This implements the lattice merge operation for 2 optional DIKinds.
This implements the object representation of the standard ErrorProtocol protocol type, which represents recoverable errors in the language.
This implements the very late (just before code generation) lowering / processes that we do to expose low level performance optimizations and take / advantage of special features of the ABI.
This implicitly adds a trailing null.
This implicitly communicates with the dominance resolver configured in emitSILFunction.
This implicitly converts objects Note that our vectors will leak if object conversion fails and PHP ends up with a fatal error and calls longjmp as a result of that.
This implies for every /    specialized call site, we insert an additional retain for each captured /    argument with reference semantics.
This implies it is known safe.
This implies that a ref count operation on the aggregate is / equivalent to a ref count operation on this field.
This implies that all implementing functions are alive.
This implies that lookupClsMethod, given the same class and the same method name, will never return MagicCall*Found or MethodNotFound.
This implies that the creation of the / actual arguments in the function is in populateCloned.
This incidentally cannot coincide with most of the awkward cases, like having parent metadata.
This includes all writes of the sub loops and the loop itself.
This includes any use of an SSATmp that implies the pointer isn't already freed.
This includes builtins that aren't even declared in Builtins.def, i.e. all of the LLVM intrinsics.
This includes creating the IR type as well as capturing variables and performing calls.
This includes creating the IR type as well as emitting the basic access operations.
This includes creating the IR type as well as emitting the primitive access operations.
This includes creating the IR type, collecting IR attributes, performing calls, and supporting prologue and epilogue emission.
This includes if we hit the timeout set below.
This includes local declarations.
This includes scopes for values and loads as well as the generation.
This includes the initial load of the file.
This includes uses of objects where the allocation is stored to.
This increments the string's refcount twice, once for the key and once for the value
This indicates that we should do a step out after our step completes if the stack depth has increased.
This indicates to the producer of the cell that the it is considered used if it could be the last reference alive (in which case the destructor would be run on Pop).
This induces conversions to occur within closures instead of outside of them wherever possible.
This information (FIXME) will be used by IRGen to lay out class vtables, and can be used by devirtualization passes to lower class_method instructions to static function_refs.
This information is (FIXME will be) used by IRGen to create witness tables for protocol dispatch.
This informs diagnostics and is a hint for various performance optimizations.
This informs our recursion that tuple stores are not scalarized outside, and that stores should not be treated as partial stores.
This initialization is thread-safe because program-functions.cpp must call Debugger::StartClient (which ends up here) before any additional threads are created.
This instruction blocks this RC root.
This instruction does not block the release.
This instruction does not block the retain code motion.
This instruction doesn't actually load but SpillFrame cannot be pushed past it
This instruction is essentially a PureLoad, but we don't handle non-TV's in PureLoad so we have to treat it as may_load_store.
This instruction is specified to be a no-op.
This instruction may release something, bail out conservatively.
This instruction primarily exists to assist in optimizing away unused activation records, so it's usually not going to happen anyway.
This intentionally ignores all stores, which (if they got emitted as copyaddr or assigns) will eventually get rewritten as assignments (not initializations), which is the right thing to do.
This invocation should happen at the common dominator of all loads inside this function.
This is *amazingly* unprincipled.
This is / basically only reasonable when processing all the different / top-level code declarations.
This is / called on a basic block's state and then any other successors states are / merged in.
This is / called on a region's state and then any other successors states are merged / in.
This is / designed to work with ManagedValue 'base's that are either +0 or +1.
This is / really only useful when writing prologue code.
This is / simply the information that would be passed to a generic function / that takes the (thick) parent metatype as an argument.
This is 1:1 with php::Class iff the php::Class has AttrUnique.
This is HH-specific as well but code depends on the old name.
This is NOT a leaf node and it has multiple children, but they have the same value base.
This is NOT a leaf node, we need to construct a value for it.
This is O(N), but so is Dequeue on a mixed array, because it needs to renumber keys.
This is UIActionSheet's designated initializer.
This is UIAlertView's designated initializer.
This is a 'let', so we can make guarantees.
This is a / function that lazily instantiates the type metadata for all of the / types of the stored properties of an instance of a nominal type.
This is a / simple heuristic used to guide comparison related diagnostics.
This is a StoreInst, try to see whether it clobbers any forwarding value
This is a Swift to ObjC cast
This is a base class for passes that are based on function liveness / computations like e.g. dead function elimination.
This is a bit conservative as we could be missing forwarding opportunities.
This is a bit of a misuse of this field but the API doesn't allow one direct access to an not-yet-opened stream resource so it should be safe.
This is a bit silly, because you can't have something like "case x, y:" anyway.
This is a bit ugly: when PHP7 picked up Hack-style return types, they inverted the syntax for a long-form closure with both a "use" clause and a return type.
This is a blocking instruction for the rcroot.
This is a boolean value
This is a candidate for a callee, along with an uncurry level.
This is a case for the select_value.
This is a class constant that needs an 86cinit to run.
This is a common case for functions returning multiple values.
This is a common case that comes up.
This is a common source / of confusion, so we force an explicit self.
This is a complex type involving other associatedtypes, we'll fail to resolve and get a special diagnosis in finalize.
This is a consequence of the fact that a DoCatchStmt with a non-throwing body will type check even in a non-throwing lexical context.
This is a conservative list of functions that we are certain won't inspect the caller frame (generally by either CallerFrame or vm_call_user_func).
This is a fall through into BB, emit the fall through branch.
This is a fast-patch check.
This is a generic function as noted above.
This is a great way to make mmap fail, since it hates a length of 0 bytes.
This is a guess to the size of the info array.
This is a hack for callers that don't have access to the module.
This is a hack to ensure we always consider the protocol requirement itself when calling something that has a default implementation in an extension.
This is a handled context.
This is a helper / to keep the Uses data structure up to date for aggregate uses.
This is a helper class that performs optimization of string literals / concatenation.
This is a kind of hacky way to avoid hitting an assert in recordGdbStub when we call it with stub - 1 as the start address.
This is a leaf node, we must have a value for it.
This is a little cleanup that ensures that there are no jumps out of a defer body.
This is a little safety check for instances when we are dealing with a regenerated session that was not yet written to disk
This is a little trickier than the getters in Mongo and MongoDB...
This is a little tricky, because "unordered" is a thing.
This is a local allocation.
This is a lot like Pattern::print, but prints typed patterns and / parenthesized patterns a bit differently.
This is a macro rather than a lambda because it contains a return.
This is a map from each partial apply to a set of indices of promotable box variables.
This is a map from each partial apply to a single index which is a promotable box variable for the alloc_box currently being considered.
This is a map of uses that are not loads (i.e., they are Stores, / InOutUses, and Escapes), to their entry in Uses.
This is a mapping from VarDecls to the if/while/guard statement that they / occur in, when they are in a pattern in a StmtCondition.
This is a mapping from an OpaqueValue to the expression that initialized / it.
This is a member lookup, which generally means that the call arguments (if we have any) will apply to the second level of parameters, with the member lookup binding the first level.
This is a metadata accessor for a fully substituted generic type.
This is a microbenchmark to get cpu frequency the process is running on.
This is a new context for this name.
This is a no-op when asserts are disabled.
This is a non-strict computation.
This is a partial_apply of a re-abstraction thunk.
This is a partially dead store.
This is a perfect match for the arguments.
This is a pre-order traversal.
This is a predicate that classifies constraints according to our priorities.
This is a private or a module internal class.
This is a pseudo-copy of the logic in enterTCHelper: it sets up the simulator's registers and stack, runs the translation, and gets the necessary information out of the registers when it's done.
This is a pseudo-copy of the logic in sync_regstate.
This is a really trivial cost model, which is only intended as a starting point.
This is a release on a guaranteed parameter.
This is a release on an owned parameter and its not the epilogue release.
This is a scalar-to-tuple conversion.
This is a separate function so that it shows up in stack traces.
This is a separate step, because this merge can cause changes to other may-alias sets at each stage (it may pessimize all the sets in some situations).
This is a shallow size function, not a recursive one
This is a similar case to lookup for functions in FPushFunc or FPushObjMethod.
This is a simple form of jump threading.
This is a simple scanner, capable of recognizing nested parentheses and string literals but not much else.
This is a simple, if hacky, peephole that's useful for the code in emitInPlaceTypeMetadataAccessFunctionBody.
This is a singleton class.
This is a small and fast implementation of memcpy with a constant count.
This is a special entry point that allows destructure inputs to handle / self correctly.
This is a store, invalidate any location that this location may alias, as their values can no longer be forwarded.
This is a streamlined copy of Variant.constructValHelper() with no incref+decref because we're moving v to this array.
This is a stronger guaranteed than we actually need.
This is a stupid encoding since it causes collisions but it matches php5
This is a super-common case for single-element structs, but is also a general answer for arbitrary structs and tuples as well.
This is a temporary limitation.
This is a terrible hack to get around the fact that typeCheckExpression() might change subExpr to point to a new OpenExistentialExpr.
This is a tool for reading sil files and running sil passes on them.
This is a type-safety problem.
This is a use of an uninitialized value.
This is a variadic template, so sanity check it.
This is a version of the initializer which receives a pre-allocated buffer as first argument.
This is a viable result.
This is a weird situation for throwing: we've partially torn down the ActRec (decref'd all the frame's locals), and we've popped the return value.
This is achieved using the wait semaphore, which is acquired here, in the background thread, and released in WebServerResponse::close() i.e. the foreground thread
This is actually "wrong" for bools, but it works
This is actually the SIL helper function.
This is all blocks that aren't part of a fault funclet.
This is all of the forward referenced functions with / the location for where the reference is.
This is allowed for abstract functions
This is also an error, but the code below will diagnose it.
This is also part of "provides-member".
This is also problem for encoding like UTF-7/UTF-8/ISO-2022 which a single char can be more than 4 bytes.
This is also required for SSA construction in dominatorBasedSimplifications' jump threading.
This is also why I used std::string instead of the HHVM provided type.
This is also why passing them as the final argument isn't bad for performance.
This is always a GEP of a GlobalVariable with a nul terminator.
This is always a local edge since non-local edges can only have loops as heads.
This is always just a bare pointer.
This is always legal to do since address-to-pointer pointer-to-address implies layout compatibility.
This is always modeled as: (postfix_unary_expr (declrefexpr ++), (inoutexpr (lvalue))) if not, bail out.
This is always true until the slow exits below are implemented
This is an O(n) search, but only happens when producing an error diagnostic.
This is an ObjC to Swift cast.
This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
This is an abstract class constant or typeconstant
This is an address type, take it object type.
This is an aggregate node, construct its value from its children recursively.
This is an apply or try_apply.
This is an artifact of a time when we did not spill registers onto the native stack.
This is an artifical upper limit to keep resources in check and minimize the possibility of exploits
This is an awful hack.
This is an easy way to cope with cycles in the SSA graph.
This is an error case, where we're trying to use type inference to help us determine which declaration the user meant to refer to.
This is an implementation of the RPO version of the global value numbering algorithm presented in the 1996 paper "SCC-based Value Numbering" by Cooper and Simpson.
This is an implicit getter.
This is an important micro-optimization for Optional, since the .None case doesn't need to be cleaned up.
This is an initialization for a box.
This is an initialization for an address-only existential in memory.
This is an inout type.
This is an interface over the standard OSF uuid library that gives UUIDs sane value semantics and operators.
This is an intersection / operation.
This is an override, so mark it as such.
This is an unpopulated slot that may occur from capacity being larger.
This is assumed to be 29 days 12 hours and 793 halakim for calendar purposes.
This is at best a getter with an implicit fallthrough off the end.
This is at least one word, and potentially more than that, past the start of the actual global structure.
This is automatically handled / when a function is created with this as part of its argument list.
This is available iff it's available in both states
This is b/c it was passed at +0 originally and we need to balance the initial increment of the newly created closure.
This is bad, only one self.init call is allowed.
This is bad, only one super.init call is allowed.
This is based on what is defined in hphp/runtime/ext_zend_compat/php-src/main/php_config-*.h And also what I know is present under MSVC.
This is based only on the type of the representative.
This is basically TypeLowering::emitStoreOfCopy, except that if we have a known incoming value, we can avoid the load.
This is basically just for assertions right now.
This is because (a) switch statements are equivalent to a series of if-elses, and (b) Zend has some weird evaluation order rules.
This is because MongoDB wants the name of the command as first element in the array.
This is because a backtrace from another destructing object during this unwind may try to read them.
This is because aggregate types (various array subtypes) could have some parts become more refined when inferring it in a context-sensitive way, while other parts are less refined.
This is because at runtime they are currently hphp arrays, which will treat leading integer keys as numbers.
This is because even if we don't do anything, we will still pair the retain, releases and then the guaranteed parameter will ensure it is known safe to remove them.
This is because extensions may wish to assign to properties after a typehint guard, which is going to fail without HardTypeHints.
This is because it may involve invoking an object's __toString() method, which can have side-effects.
This is because perf does not seem to handle more than three counters very well.
This is because the current exception escapes the exception handler where it was thrown.
This is because the driver can't handle this at the moment.
This is because we currently don't memoize fault funclets other than finally fault fuclets.
This is because we only handle the single init_existential_addr case.
This is because we only handle the single open_existential_addr case.
This is because we rely on loop canonicalization to canonicalize / multiple backedge loops into separate loops.
This is because we're not supposed to run destructors for objects that are live at the end of a request.
This is believed to be the year of creation.
This is beneficial if we can then match them up with an increment in some of the predecessors.
This is best for palette images, and libpng defaults to it for palette images anyway, so we don't need to do it explicitly.
This is better to be attribute driven, a la rdar://15587352.
This is borrowed from FreeBSD's strndup.c, with minor CS changes
This is called "growing", since it may be used if an array is out of capacity for new elements---but it is also what happens if an array needs to change kinds and can't do that in-place.
This is called at the end of BBs and if we run into an unknown / call.
This is called from the QObject::destroyed signal and does not need to (indeed, must not) do the monkeying with signals that changeCurrentFrame does.
This is called in a few places to be consistent with old minstrs, and should be revisited once they're gone.
This is called on clone, so we treat it like how Zend would treat a clone, following zend_objects_store_clone_obj().
This is called when a predecessor of a block is dropped, to simplify the / block and add it to the worklist.
This is called when a thread interrupts for either session- or request-started, as these each signal the start of debugging for request and other threads.
This is called when each instruction is generated during initial IR creation.
This is called when we store into a BoxedCell.
This is character-set independent
This is cheating, assuming server has same list of extensions.
This is checked later.
This is classified as InitOrAssign (not PartialStore), so there are only a few instructions that could reach here.
This is cleanup goop run on the various paths where type checking of the pattern binding fails.
This is codetables for different Cyrillic charsets (relative to koi8-r).
This is computed by the successor having a greater / post order number than the exit.
This is computed once for each unit and stashed here.
This is conservative, but without it, we would need a runtime check to decide whether or not to forward the lsb class
This is considerably more verbose than just using xmlCreateFileParserCtxt, but it allows us to bypass the external entity loading path, which is locked down by default for security reasons.
This is correct behavior for reading a series of images from one source.
This is correct for typical "arithmetic shift" instructions that shift in copies of the sign bit.
This is correct: we want to /disprefer/ the mplus.
This is currently only associated with structs.
This is currently true from this place, but we need to be careful if this function is ever called before user's rpaths are emitted.
This is dead code in NonFixedStructTypeInfo.
This is dead code in NonFixedTupleTypeInfo.
This is defined in php_mongo.h
This is dictated by a special file extension.
This is different from ignore_all where ignore_all will still process base classes as normal, but whitelisted will not process anything, even base classes.
This is done / so that we do not bloat SIL IR.
This is done as a second phase to / avoid invalidating the use iterator.
This is done as a separate pass from the work in processSpillExits() to reduce complexity.
This is done before KindOfContinue testing.
This is done by means of calling _forceBridgeFromObjectiveC or _conditionallyBridgeFromObjectiveC_bridgeable from the Target type.
This is done by using DirectToStorage semantics above, with the understanding that the access semantics are with respect to the resilience domain of the accessor's caller.
This is done only for entry points using a new calling convention or for those entry points which explicitly require it.
This is done so we don't waste precious time in connecting to unreachable nodes
This is done to "extend" the life-time of original partial_apply arguments, as they may be destroyed/deallocated before the last use by one of the apply instructions.
This is done to reduce the amount of IO from the swift module file.
This is easy if we're not currently at an offset.
This is either a init_existential_addr or the source of a / copy_addr.
This is either a non-local allocation or a local allocation that escapes.
This is either part of a super.init sequence, or a general superclass access.
This is either to successor BBs, / or as far down the current BB as possible
This is enforced by semantic analysis, so the early exit here is a performance optimization and also prevents us from erroneously including those protocols before they get diagnosed.
This is enough for our purposes.
This is equivalent to Zend's zend_objects_store_del_ref_by_handle_ex() in the case where the object is deleted.
This is equivalent to android.os.SystemClock.elapsedRealtime() in native
This is essential so that we don't accidentally double-count a key (after various conversions) that occurs in the container more than once.
This is essentially the bitvector implementation of global availability, but disallowing the cases where we can't find/create a suitable store.
This is even possible if the block does not dominate the loop exit block.
This is everything the llvm::GraphWriter needs to write the call graph in / a dot file.
This is exactly the pattern for an enum with integer raw value initialization.
This is expected for incomplete types or the strange "other" types sometimes seen, but an error otherwise.
This is expected to non-zero.
This is extremely subtle: simplifyArgs will not change the CFG iff the DT is null.
This is fast, but may be brittle.
This is fine so long as this parameter and all of those parameters up to (and including) the previously-bound parameter are either variadic or have a default argument.
This is flow insensitive.
This is for backwards-compatibility with modules that still rely on the "HasUnderlyingModule" flag.
This is for big-endian machines only, PPC and Sparc specifically.
This is for historical reasons from libmemcached
This is for use in the translator.
This is fundamentally required because the callee can side-exit or throw an exception without a catch trace, so everything needs to be balanced.
This is generally only valid for specific kinds of / ObjC reference, like superclasses or category references.
This is generally the metatype pointer, but may / instead be a reference type.
This is generated using the table in ir-opcode.h.
This is going to be the last basic block this program is going to execute and this block is inert from the ARC's prospective, no point to do any releases at this point.
This is guaranteed to at least stop at the nul at the end of the buffer.
This is handled in the runtime, so it doesn't need a special cast kind.
This is hella gross but saves us having to implement ObjCMethod-to-Explosion lowering and creating a thunk we don't want.
This is helpful because type checking a subexpression can lead to replacing the nodes in that subexpression.
This is helpful when there's several things wrong at once.
This is here for testing purposes via sil-opt
This is highly dubious in terms of error recovery, but is useful for code completion and SIL parsing.
This is hit if -k is set or there is no match
This is how tuples with "interesting" types are described.
This is ignoring the possibility that we may have a loop with an interesting terminator but for which, we are going to clear all state (since it is a loop boundary).
This is implemented via a TVCoercionException, which is not a user-visible exception.
This is important because CC lowering isn't the only purpose of this conversion.
This is important because the list is processed in order and eliminating a nested inlined return may allow us to eliminate outer layers of nesting.
This is important because things need to be in a consistent state in case the user error handler throws.
This is important because we may add additional parameters after the Self parameter of witness methods.
This is important because while we cannot both define a new frame with DefInlineFP and phi it with an incoming frame from another side exiting block in the same block.
This is important if we want to be able to update analyses in a clean manner.
This is important in a non-reentrant scanner so the next time hphplex() is called, initialization will occur.
This is important in a non-reentrant scanner so the next time yylex() is called, initialization will occur.
This is important so we can determine covering switches for enums that have cases without payload.
This is in declaration order mirroring the php::Class interfaceNames vector, and does not include inherited interfaces.
This is in glibc, which isn't a problem, except for the trampoline code in .plt, which we dealt with in the linker script
This is in php5 xdebug, but not in the spec.
This is included only for createLazyResolver().
This is intended to be a / small, easily-computed type that can be passed around by value.
This is just a shortcut to the isUnsafe test for a specific array below.
This is just following the lead of existing (and not terribly easy to follow) code.
This is just like setType() except that typeSrcs are preserved, so the new type may be derived from the old type.
This is just part of this struct for convenience when stepping through RCAnalysis results.
This is just the / default implementation.
This is just to be conservative when faced with the unknown of future changes.
This is lame, but gcc doesn't optimize U8_NEXT very well
This is like C++ / move-initialization, except the old object will not be destroyed.
This is like a load from a ref_element_addr.
This is like a ref_element_addr.
This is logically wrong, but propagating l-values within RValues is hard to avoid in custom argument-emission code without making ArgumentSource capable of holding mixed RValue/LValue tuples.
This is mainly testing global variables to make sure all handling are thread-safe.
This is map between LSLocations and their available values at the / beginning of this basic block.
This is map between LSLocations and their available values at the end of / this basic block.
This is more likely to succeed than / type checking the original expression.
This is more likely to succeed than type checking the original / expression.
This is mostly a lie -- we don't use zend_fcall_info_cache, so don't set its members.
This is necessary as when we perform the RLE in the last iteration, we must handle loops, i.e. predecessor blocks which have not been processed when a basic block is processed.
This is necessary because FailureDiagnosis::diagnoseExprFailure doesn't do this for closures.
This is necessary because libmemcached doesn't reset hash/distribution options on false case, like it does for MEMCACHED_BEHAVIOR_KETAMA (non-weighted) case.
This is necessary because we might remove e.g. tuple elements from the path.
This is necessary since the functions may reference each other.
This is necessary since x86_64 can load only the byte and do not touch the other bits of destination register
This is necessary so that the boost command line parser doesn't choke on args intended for the PHP application.
This is needed for code that uses parent:: to call through to the correct underlying function
This is needed in case we converted some indirect parameters/results to direct ones.
This is needed to balance the implicit release of all captured arguments that occurs when the partial apply is destroyed.
This is needed to correctly lex the token if it is at the beginning of the line.
This is needed to determine the delta memory usage
This is needed to keep track of which elements have been inserted.
This is needed to track currentStackDepth correctly (and we also assert all the jumps have the same depth).
This is noinline with asm("") to preserve this frame in stack traces.
This is not a / StructTypeInfoBase at all, since we don't know anything about / the struct's fields.
This is not a compound name.
This is not a correctness assertion, but we want to know if we get it wrong because it'll be a subtle perf bug:
This is not a correctness check, but we only want to the optimization if the condition gets dead after moving the cond_fail.
This is not a formal parameter, so it's in the ExtraArgs.
This is not a leaf node, reduce the next level node one by one.
This is not a leaf node, try to find whether all its children are alive.
This is not a malloc/realloc check.
This is not a problem if we are not using authentication, but it is if we are.
This is not a type-safety / problem.
This is not a type-safety problem.
This is not a very efficient algorithm.
This is not actually used, but is here for completeness, in case someone wants to use the HWB stuff for anything else...
This is not an optimization.
This is not efficient, but this is graphing code...
This is not feasible in DOS machines.
This is not illegal for trivial reasons, because object __destruct methods can ressurect an object in PHP.
This is not reflected in clang types.
This is not required for flow use an or to avoid introducing another branch
This is not space efficient for large text.
This is not strictly necessary, but it makes it easier to read the output from a dump.
This is not supported since nominal types cannot capture values.
This is not the case for a potentially aliased array because a release can cause a destructor to run.
This is not the case with the regular post-dominator tree.
This is not the last loop level, therefore the current iterator should be freed.
This is not the linkage we are looking for.
This is not the right way to get output size...
This is not true of HH files.
This is notably *not* the semantics of the x86 shift instructions, so we need to do some comparison logic here.
This is of course very much so not true.
This is often faster.
This is okay, since all IterAdvance() impls handle this correctly, but it means that EmptyArray::IterAdvance() is reachable.
This is only a BB local analysis for now.
This is only allowed on a single direct result.
This is only an estimation, because e.g. it does not consider potential aliasing.
This is only an optimization, so the criteria does not need to be exact.
This is only called right after dispatchBB, so the VM regs really are clean.
This is only done for a limited whitelist of instructions that are safe and cheap to sink.
This is only for promoting primed values to in-memory values, so it's basically not a real problem, but ...
This is only legal when debugger support is on.
This is only meaningful in an IPC implementation.
This is only needed if we have guaranteed parameters.
This is only needed in cases where we synthesize a function which returns a generic value.
This is only possible for vars.
This is only really necessary for imported source, but that's a very convenient thing to do in -i mode.
This is only required for ObjC interoperation.
This is only responsible for the control-flow aspect of the Ret: getting to the destination's translation, if any.
This is only set by the jemalloc stats sync which we don't enable until after this has been called.
This is only used for debug tracing, and is currently the first instruction (in an rpo traversal) that defined a tmp in the must-alias-set.
This is only used for diagnostics, so always use KnownPrivate.
This is ordered by std::greater, so we'll generally visit blocks before their predecessors.
This is our opportunity to complete the connection and make it ready to use.
This is out of line so the debugger can find it.
This is over-conservative.
This is part of hphp/runtime/base so the symbols are always available in the main binary and hence act as be a global replacement for calls even from other shared objects like ICU/etc.
This is particularly common when testing optionals.
This is particularly important for syncing vm regs where we read the marker to eagerly sync vmpc().
This is populated as we go through the optimize pass, and doesn't need to be flow-sensitive since it only contains a RegInfo for virtual Vregs.
This is populated by the flow-sensitive analyze_physical pass.
This is populated in a topological order of dependencies between the definitions.
This is possible after we expand release instructions in SILLowerAgg pass.
This is potentially dumb.
This is potentially expensive since we need to perform additional stripping on the argument provided to this argument from each predecessor BB.
This is presently used to work around other location processing bugs.
This is pretty nasty since things can get added to it *later*, but there's not much we can do.
This is primarily intended for use for debugging and development on the JIT.
This is probably a conversion from a value of labeled tuple type to a scalar.
This is probably not necessary anymore, but we added it originally because a store sinking prototype needed to know it can't push StLocs past a DefInlineFP, because of reserved registers.
This is really *bad* because it will modify the status time of the file...
This is really an implicit 'init' MemberRef, so point at the base, i.e. the TypeExpr.
This is really only useful for writing testcases.
This is really the entire point of having the dummy sandbox.
This is redundant with a check in ifRefCounted, but we check earlier to avoid emitting profiling code in this case.
This is redundant with a check in ifRefCountedNonPersistent, but we check earlier to avoid emitting profiling code in this case.
This is relying on undocumented feature of Windows API LoadLibrary().
This is removing the copy_addr, but explodeCopyAddr takes care of removing the instruction from Uses for us, so we return false.
This is represented by returning an empty ProjectionPath.
This is required for correctness by the x64 code relocator.
This is required to preserve the lifetime of its argument, which could be e.g. a partial_apply instruction capturing some further arguments.
This is safe (it uses the array id) because they must already be inserted in the array table builder.
This is safe because instanceofs don't take reference counted arguments.
This is safe because we are running on the executor's thread: it won't destruct until after it's been unregistered (which we check above) and that will happen on this thread
This is safe in a postorder walk since we visit blocks after visiting successors.
This is safe since we are hashing the operands using the actual pointer values of the values being used by the operand.
This is safe to do since when erasing in a BlotSetVector, we do not invalidate the iterators.
This is safe without any extra dominator checks because we know that there are no preds that don't have the value available.
This is safe, because the bool src is not reference counted.
This is semantically required.
This is separated from the version above to speed it up by a few cycles
This is set to true by default.
This is set-only as far as we're concerned
This is similar to returning an empty-string for standard configuration options.
This is similar to what we do with instancetype in Objective-C.
This is slightly tricky because, unlike our other control constructs, the refined region is not lexically contained inside the construct introducing the refinement context.
This is slow and works badly.
This is so a reference to the file can be stored in an XML context object as a void*.
This is so xgettext sees the translatable formats that are constructed on the fly.
This is something that is implicit in the partial_apply design that will be revisited when partial_apply is redesigned.
This is somewhat hacky.
This is somewhat inefficient but the only way to find the corresponding name without the index, and the number of parameters in a call is normally very low.
This is specialization of the memcpy line below with specialization for values of 1, 2 and 4.
This is still better than nothing.
This is straightforward if the superclass is Swift.
This is sufficient for our purposes because at a use, the width will always be a single-bit constraint or Any (i.e., no constraint).
This is sufficient to allow us to identify EBCDIC text and to distinguish between old-style and internationalized examples of text.
This is supposed to be handled by just not enqueuing things twice, but that gets tricky with synthesized function bodies.
This is the "Composite Document File" format, and not the "Compound Document Format", nor the "Channel Definition Format".
This is the "newValue" name (for setters) followed by the index list (for subscripts).
This is the / maximum number of iterations we run.
This is the LocalAvailability / plus the information merged-in from the predecessor blocks.
This is the LocalSelfConsumed / plus the information merged-in from the predecessor blocks.
This is the More Correct path.
This is the SILType of the memory object.
This is the Value for the current base.
This is the approximate beginning of a month.
This is the authoritative map that determines which typehints require special handling.
This is the authoritative map that drives Hack's auto-importation mechanism for core types and classes defined in the HH namespace.
This is the beginning of a child frame, recursively write it
This is the body of the closure, preceded by code that pulls the object's instance variables into locals.
This is the case e.g. if the class has no subclasses.
This is the case for MixedArray elements, Map elements, and RefData inner values.
This is the case for the entry block and any blocks not reachable from the entry block.
This is the case for the function entry block.
This is the class reference downcasted into subclass SubType.
This is the common case in repo mode.
This is the default for the select_value.
This is the delta between the current and the previous jemalloc reading.
This is the difference - make a file based on size of chunks.
This is the easy case.
This is the end frame, write it then return its index
This is the entry point for offline bytecode generation.
This is the entry point to the swift compiler driver.
This is the entry point.
This is the failure path.
This is the final inlining decision.
This is the first 64 bits.
This is the first class that declares the method
This is the first class to declare this property
This is the first compilation unit to begin printing from.
This is the first instruction in the block.
This is the first instruction, we are done.
This is the first non-prologue instruction in the entry block.
This is the first or last character
This is the first unpassed arg with a default value, so this is where we'll need to jump to.
This is the function that actually relaxes the guards of all the blocks in `blockData' in case that's considered profitable according to `relaxIsProfitable'.
This is the function that performs real in-place conversion of the string between charsets.
This is the general algorithm but it will only loop twice for loop-free graphs.
This is the general purpose conversion function.
This is the implementation of the method to be used if the exact class of the instance would be CD.
This is the implementation of the swift interpreter, which takes a source file and JITs it.
This is the label to jump to if the pattern fails to match.
This is the last iteration, compute BBWriteSetOut and perform DSE.
This is the last iteration, compute BBWriteSetOut and perform the dead store elimination.
This is the last loop level to continue out of.
This is the last loop to break out of.
This is the last thing that happens before asserting that the struct type doesn't have a mapping.
This is the length of the matched pattern
This is the limit for the number of subclasses (jump targets) that the speculative devirtualizer will try to predict.
This is the list of base classes for this class in inheritance order.
This is the list of candidates identified.
This is the list of new interface parameters of the cloned function.
This is the list of traits that this transformation might preserve.
This is the main entry point for the use walker.
This is the message string with escapes expanded.
This is the name of the callee as extracted from the call expression.
This is the new function name.
This is the new tail translation, so store the fallback jump list in case we translate this again.
This is the non-typechecked AST for the generated interface source.
This is the number of witnesses that all conforming types must provide.
This is the only ABI we currently support for Android.
This is the only interface implemented by the classes that implement it.
This is the only known occurance of ParamCoerceModeNullByte, so we treat it specially using an explicit tvCoerce call
This is the output of the optimization's analysis phase.
This is the per-instruction analyze routine for rc_analyze, also used for build_graphs.
This is the place that should be jumped to if the pattern fails to match.
This is the priority order in which we handle constraints.
This is the same as typeCheckChildIndependently, but works on an arbitrary / subexpression of the current node because it handles ClosureExpr parents / of the specified node.
This is the same check that PHP5 performs, no validation needed.
This is the same operation as 'copy', but works on +0 values that don't / have cleanups.
This is the smoothest way to get overridden properties right.
This is the special "imported headers" module.
This is the standard clone handler, which, confusingly, does NOT call the clone handler in the object bucket.
This is the synchronous implementation of the command, the asynchronous part is managed by XDebugServer::pollSocketLoop.
This is the white-list of accepted syntactic forms.
This is tightly coupled with the implementation of array.uninitialized.
This is to avoid unnecessary typechecking that can occur if the TypeResolver is set before.
This is to check that instruction substitutions will not clobber any potential uses of status flags.
This is to get DV funclets.
This is to handle object types with "flexible array members".
This is to match zend 5.5 behavior.
This is to prevent creating multiple large regions containing the function body (starting at various DV funclets).
This is to prevent the refcount from going to zero when the destructor returns.
This is tracked in post-order and unravelled as subsequent applications complete the call (or not).
This is tricky since the behavior's parameter type may be dependent on the property type, so we'd need to clone the closure expr for each var to re-type-check it.
This is true if a '*' constraint is present to say that the diagnostic may appear (or not) an uncounted number of times.
This is true if definite initialization has finished processing assign / and other ambiguous instructions into init vs assign classes.
This is true if the class or any of its ancestors: - is generic, - is resilient, - has a parent type which isn't emittable as a constant, - or has a field with resilient layout.
This is true in structs and for final properties.
This is true in the fast path, but in the slow path we need to manually save caller-saved registers.
This is true when there is a destroy on a path where the self value may / have been consumed, in which case there is nothing to do.
This is true when there is an ambiguous destroy, which may be a release / of a fully-initialized or a partially-initialized value.
This is true when there is an ambiguous store, which may be an init or / assign, depending on the CFG path.
This is unapplicable to thin_to_thick_function /    since they do not have any captured args.
This is undocumented in Zend, and several extensions get it wrong.
This is unfortunate but necessary since splitCriticalEdge may change IDs.
This is unfortunate, but it feels wrong to put in an API into SILBuilder that only takes in arguments.
This is used below to recursively relax the constraint on the source, if needed.
This is used by assignment operators.
This is used for persistent classes and functions, so they are always defined, and always visible to all threads.
This is used for the generic case, for callers who can't tell us the size of the allocation at free time.
This is used in situations where the / compiler detects obvious attempts to mutate a constant.
This is used to / diagnose 'autoincrementing from' messages.
This is used to / optimize the time for computing genset and killset.
This is used to allow for concisely selecting collections with dotted names.
This is used to avoid duplicate error reporting in case we reach the same instruction from different entry points in the WorkList.
This is used to ensure progress and eliminate the chance of going into an infinite loop in cases where (for example) we have recursive type-based specialization happening.
This is used to find the extents of each handler for find_fault_funclets.
This is used when generating layouts, but after that, layout_index will index into the layout table for the actual layout to use.
This is used when we're actually acting on information we discovered during liveness analysis.
This is useful / when part of the mangling is done independently, e.g. when an / optimization pass modifies a pass.
This is useful for ContRaise, which should throw from the context of the lowest generator.
This is useful for function exit breakpoints, which are implemented by blacklisting the RetC opcodes.
This is useful for the image dimensions
This is useful for tools which want to extract subtrees from mangled strings.
This is useful since in certain cases / due to dataflow issues, we cannot properly propagate the last use / information.
This is useful, e.g. for rawValue or hashValue of C-like enums.
This is usually not what HHBC opcodes do, and could be a bug.
This is valid because we run on architectures where all pointers are the same size, and we always generate the heap scanners at the same time we're building everything else.
This is very conservative, but safe.
This is very similar to transparency of expressions.
This is weird but required by sema apparently.
This is weird, but this is also what PHP does, so *shrug*.
This is well-typed but may cause code to be emitted redundantly.
This is where the context parameter appears.
This is where we create the actual specialized BB Arguments.
This is why there's two fairly different mechanisms for handling the effects of defining ops on base types.
This is why we have to check that the unspecialized type is at least as big as the srcType.
This is why, for example, shuffling a TupleExpr creates a TupleShuffleExpr instead of just making a new TupleExpr with the elements in different order.
This isn't a control character, so we don't need to escape it.
This isn't a generator
This isn't a valid IPv6 address, so bail.
This isn't as bad as it seems though, because most of these will be diagnosed by expr diagnostics.
This isn't bulletproof, but at the point we emit conformance tables, we're far enough along that we should have emitted any metadata objects we were going to.
This isn't consistent with general class resilience, however.
This isn't correct for all blocks, but block storage type should only be converted for function signature lowering, where the parameter types do not matter.
This isn't currently "wrong", because calling it would be a fatal, but note that resolve_method needs to be pretty careful about privates and overriding in general.
This isn't exactly true after type-checking, but it's close enough for now.
This isn't expected to change very often.
This isn't foolproof but should catch the common case of optional class types.
This isn't great, in that a variable captured by multiple closures will be boxed for each one.
This isn't likely to come up much, though.
This isn't necessarily optimal.
This isn't necessary if *both* operands of a binary instruction are the same virtual register, but is still correct.
This isn't really complete, but good enough.
This isn't really complete, but is good enough, and matches how Clang's Command handles escaping arguments.
This isn't really needed until pass 2, but again it is FAR storage.
This isn't required for correctness, but it may allow removing stores that otherwise we would leave alone.
This isn't strictly necessary (the rest of the logic will work fine without it), but fail fast if it looks like we don't have any debug info enabled.
This isn't trivial to strength reduce, without a "flip two top elements of stack" opcode.
This isn't valid in a protocol, but we parse and then reject it, for better QoI.
This isn't valid, and most implementations can't read it.
This isn't valid, but the developer almost certainly meant to use "0.4".
This iteration order is nondeterministic but has no impact.
This just ignores the provided value.
This just walks the type hierarchy, marking the contained object type (if any) as being pointer followable.
This just wraps vmodify() with some accounting logic for `env'.
This keeps the proxy alive in the server case, which drops the result of this function on the floor.
This keeps track / of SIL branch arguments so that they can be lowered to LLVM phi nodes.
This keeps track of instructions in the use list that touch multiple tuple / elements and should be scalarized.
This keeps track of the weights of blocks and arcs in a Vunit.
This keeps us from leaking information about the original filename while still providing uniqueness.
This kernel fixed a panic when using MADV_HUGEPAGE.
This label is used only to access EOF actions.
This lead to an 11 day shift in the calendar with respect to the seasons by the 16th century when the Gregorian calendar was created to replace the Julian calendar.
This leads to a year that is 365.25 days long, but the current accepted value for the tropical year is 365.242199 days.
This leads to more efficient code because the service request stubs will patch jumps in the main trace instead of off-trace.
This leaves us in the unenviable position of having to support both.
This led to a lot of code relying on accessing properties that were improperly cased.
This lets us distinguish between a protocol member and a protocol extension member that have the same type.
This lets us enforce the invariant that if we have a delegate set, we should be using it.
This lets us omit having to allocate a temporary full horizontal stretch of the src image.
This library intrinsic is generic, so we need to form substitutions and compute the resulting type.
This limitation allows us to recover from common errors though.
This linear search probably limits the usefulness of this implementation to cache sizes of a few tens of elements.
This list is ordered so that for nested inlining the most nested return appears first.
This list must be kept in alphabetical order.
This literal type must conform to the (non-builtin) protocol.
This little helper function is used to consume a separator comma if present, it returns false if it isn't there.
This loads from a file, a stack of x509/crl/pkey sets
This loads the FrameState for the IR block corresponding to the start of this region block, and it also sets the map from BC offsets to IR blocks for the successors of this block in the region.
This location is alive.
This logic feels like it belongs in the simplifier, but the generated code for this case is pretty different, since we don't need the pre-live ActRec trick.
This looks through expect intrinsic calls and applies the ultimate expect call inverted to the condition.
This lookup is very efficient and doesn't even require us to parse the prefix.
This loop is too slow for normal use, but can be enabled to debug packed arrays.
This loop will repeatedly recurse on the RHS until it encounters an expression other than a list assignment expression.
This macro does zero padding so that the precision requirement is satisfied.
This macro really ought to take a parameter, but we do it the disgusting crufty way forced on us by the ()-less definition of BEGIN.
This macro was not mandated originally: define only if we know we won't break user code: when these are the locations we know.
This made gcc generate better code at the time it was done (saving a spill).
This makes a strong assumption that the allocated object is released on all paths in which some object initialization occurs.
This makes diffing large sections of SIL significantly easier.
This makes it dangerous to use this manager and a different destination manager serially with the same JPEG object, because their private object sizes may be different.
This makes it difficult / to reason about pointer equality though, so undo it as an initial / canonicalization step.
This makes it easier to share the same database between the mangling and demangling tests.
This makes it easy to reuse the load from the first such projection for all subsequent projections on the same value decl or index.
This makes it possible for a type to conform to an Objective-C protocol that is missing annotations but whose requirements use types that are less available than the conforming type.
This makes some inner loops simpler and sometimes saves work during multiplications, but it often seems to make things slightly slower.
This makes sure it's emitted before 'str' is destroyed.
This makes sure it's emitted before the message text buffers are destroyed.
This makes sure that none of the registers eventually used by the dynamic linker are used by generated code.
This makes sure that on another loop pass we will treat the fault just as if it was freshly thrown.
This makes sure that the project_box dominates the partial_apply.
This makes sure that we properly handle Array vs.
This makes the exit path more expensive, so we try to allocate spill space as late as possible to avoid pessimising fallbackcc/bindjcc instructions unless it's really necessary.
This makes them good candidates for mapping with huge pages.
This map is flattened across the inheritance hierarchy.
This map memoizes reachability of IR blocks during tracelet formation.
This mapping is logically trivial, but making it go fast enough requires considerable care.
This maps a module to all its imports, recursively.
This maps out a portion of our executable We need to be very careful about what we do until we replace the original code
This maps to the structure on how mongos expects them
This marker update is to make sure rbx points to the bottom of our stack if we enter a catch trace.
This matches zend behavior.
This matrix associates subpattern rows to their / corresponding guard expressions, and associates destination basic block / and columns to their associated subject value.
This may be a deserialized or clang-imported decl.
This may be at a different stack depth, though, especially if we've moved from the original function to the resumable.
This may be called from any thread wishing to stop the proxy, for any reason.
This may be different than the IR type returned by the call itself due to ABI type coercion.
This may be different than the size because of flexible array members (which sometimes start within the object).
This may be the first character of a range, so don't add it yet.
This may capture any content of the released object, but not the pointer to the object itself (because it will be a dangling pointer after deallocation).
This may cause user code to run.
This may change in the future, if we start using PGO for ordering of checked_cast_br checks.
This may come up when a generic type with payload is instantiated on an empty type.
This may fail if the frontier is located on a critical edge which we may not split (no CFG changes in SILCombine).
This may involve splitting some edges.
This may let us recursively avoid work.
This may load garbage values, but they are not used until the final check_unowned succeeds.
This may need modifications after we allow php values to span calls in SSA registers.
This may need to change at some point, in which case the uncurry logic can probably migrate to that case.
This may not / be the innermost declaration containing the range.
This may not be as / accurate but it's only until we have typechecked the AST.
This may not be consistent with other numbering schemes.
This may not be desirable and should be re-evaluated.
This may not be quite the closest entry to the actual input color, but it's almost as good.
This may not be true by the end of a request.
This may only be a source file, or it may be a SIL file, which requires pumping the parser.
This may place multiple internal breakpoints, and it may place them more than one frame up.
This may require to create new nodes or to merge existing nodes in this graph.
This may trigger other node merges.
This means a fixed-layout indirect enum is always loadable and nontrivial.
This means all these incoming branches are about to go away anyway ...
This means even if we're not in RepoAuthoritative mode, as long as this code is reachable it will always use the same closure Class*, so we can just burn it into the TC without using RDS.
This means if we have to fallback from the currently-translating translation we jump to the "anchor" translation (which just is a REQ_RETRANSLATE).
This means it might not be safe to throw an exception right now (see discussion in jitReturnPost).
This means it's safe to elide their inlined frame, as long as we adjust their markers to a depth that is guaranteed to not stomp on the caller's frame if it reenters.
This means m_savedRip in our ActRec must have been callToExit, which should've been returned by jitReturnPost(), whether or not we were called from the TC.
This means no transformations were possible for the analyzed instruction.
This means retains and releases do not affect the object since we do not support object resurrection.
This means sort the array by values, but keep the keys associated with the values they used to be associated with.
This means spare bits cannot be used if the payload value is address-only, because there is no way to strip the spare bits in that case without modifying the value in-place.
This means that UINT64 will not be available to be constructed in a sourcekitd message.
This means that after calling global_dce on a function, the type information in the block input states in the associated FuncAnalysis can no longer be considered accurate.
This means that all successor regions of any region /cannot/ be a region representing a loop.
This means that any array type we create can only contain nested array RepoAuthTypes that have smaller array ids (they must already have been created when we create the outer array type).
This means that at worst b.used() will return a slightly stale value.
This means that between the fork/exec and the waitpid, the LightProcess could fork/exec more processes for different requests.
This means that comparing the start of the string token to the end of an embedded expression will fail.
This means that for now we do not handle early exits.
This means that if the given day number falls in the 3rd month or on the 30th day of the 2nd month the length of the year must be found, but in no other case.
This means that if we cancel the source and then wait on the timer group, when we are done waiting, we know the source is completely done and it's safe to free memory (e.g., in the destructor).
This means that isRhsFirst() has no effect in PHP7 mode.
This means that it is not valid until we finish visiting / the expression.
This means that it is possible to deliberately cause a header collision, which an attacker could use to sneak a header past a proxy that would either overwrite or filter it otherwise.
This means that one can then use pointer equality to check for equality between two object types.
This means that the / instruction is safe only if all of its users are safe.
This means that the block they are in should be treated as a live out for cross-block analysis purposes.
This means that the callee will always be the first frame in its nested VM.
This means that the object is never passed to objc_setAssociatedObject, so its destructor cannot be extended at runtime.
This means that the operands are equal after we move the instruction into the successor block.
This means that there is a single-branch block for each enum case which branch to BB.
This means that this block could not have multiple predecessors since otherwise, the edge would be broken.
This means that this can happen: - The user sees a SIL diagnostic in one function - The user edits another function in the same file and introduces a typechecking error.
This means that unlike with specialized emitters above, enum constructors use the AST-level abstraction pattern, to ensure that function types in payloads are re-abstracted correctly.
This means that we can only look through cond_br/br.
This means that we'll continue to just conservative scan everything.
This means the block contains a last use of the value.
This means the location "owns" a reference in the normal sense---i.e. the count on the object is at least one on account of the pointer in that location.
This means there are no aliases accessible within this function scope.
This means there's no connection between this range and any subsequent one, so we can safely break the interval after the first range without making things worse.
This means they can only be in a subclass relationship if that specialized data is.
This means they can't simply be hoisted to a loop preheader, and it also means that computations depending on the destination can't be hoisted.
This means they must be defined not just declared.
This means this code is fine for now, but if we implement #3837503 (non-static strings with values in the type system) it will need to change.
This means we are allowed to chain the current exception with the previous one (if it exists).
This means we can't deal with situations where we have different stags, and right now we also don't try to deal with situations that have the same stag in a combinable way.
This means we don't need a ton of redundant entries in the map.
This means we end up having to do / a pretty delicate dance to manage the active set of cleanups.
This means we have to copy the section into a temporary file and then dlopen() that.
This means we have to pessimize public static property types for the entire program.
This means we implicitly get caching, but that type lowering needs to override this case.
This means we might have duplicate factored exits now, so we need to remove them.
This means we need to be able to insert phi nodes.
This means we need to track all active property getters and ensure we aren't recursing for the same one.
This means we should iterate.
This means you need to use the default field to Bind and can't statically initialize them.
This member is accessed off of it.
This method enforces that, for each region block, all its successor have distinct SrcKeys.
This method implicitly adds a null terminator.
This method is called in post-order over the AST to validate that / methods are fully applied when they can't support partial application.
This method is from a class.
This method is invoked when the HTTP library encountered some error before it could completely parse the headers.
This method is the master for selecting the correct algorithm for the order of servers in which to try the candidate servers that we've previously found
This method is to be used when an instruction is found to be dead, replaceable with another preexisting expression.
This method is used to support get_defined_functions().
This method is used when no profiling information is available.
This method must return a char* which is owned by the IniSettingMap to avoid issues with the lifetime of the char*
This method reads the message header for a database response It returns failure or success and throws an exception on failure.
This method unlinks 'self' from the containing SILFunction and deletes it.
This method will already be called for all individual statements, so don't repeat that checking by walking into any statement inside this one.
This might be a bridged upcast.
This might be a one, two, or three-byte encoding.
This might be cleaner if we split off a new UnresolvedSubscriptExpr from SubscriptExpr.
This might be worth doing specifically for the zend.assertions setting, for which the emitter emits an ini_get around every call to assert().
This might box the local, we can't tell.
This might help users who are refactoring code by adding names.
This might just / not be supportable at all.
This might need more than one try in case we need to move the allocation out of a stack-alloc-dealloc pair.
This might need to be written to metadata if it depends on resilient types.
This might not be a legal SIL type.
This might not be necessary though.
This might not be strictly necessary any more, but it's probably still a good idea.
This might not be the most elegant solution, since you could fetch 100 results, get the first one, close the connection, get 99 more, and suddenly not be able to get any more.
This might overwrite the hash table, but won't go beyond the space allocated for the MixedArray, assuming `malloc()' always allocates multiple of 16 bytes.
This might overwrite the hash table, but won't overrun the allocated space as long as `malloc' returns multiple of 16 bytes.
This minimizes the size of the tRNS chunk and thus the size of the PNG file as a whole.
This minimum value can be interpreted as a minimum value of the actual integer in memory at each point, if the program were not modified by this pass.
This mode is not supported: Displacement will be embedded on Index
This modifies the Vinstrs in `unit' by setting their `pos' members, in addition to producing the block-to-range map.
This module contains an assembler implementation for HHBC.
This module contains code to perform both local DCE and global DCE.
This module implements the well-known Heckbert paradigm for color quantization.
This module implements two code layout strategies for sorting a Vunit's blocks:  1) rpoLayout() implements a simple layout that sorts the blocks in reverse post-order.
This module needs some understanding of both types, and both of these types of stores affect memory support, but in different ways.
This module provides completions to the immediate mode environment.
This module supports the implementation of two region selectors: hotcfg and wholecfg.
This more than covers the period when the calendar was in use.
This must be a backedge.
This must be called on the same thread on which the constructor was called.
This must be called while holding the lock.
This must be checked before we IncRef the context below, because the slow exit will want to do that same IncRef via InterpOne.
This must be consistent with the extra inhabitant calculation implemented in the runtime's getHeapObjectExtraInhabitantIndex function in KnownMetadata.cpp.
This must be consistent with the extra inhabitant calculation implemented in the runtime's storeHeapObjectExtraInhabitant and getHeapObjectExtraInhabitantIndex functions in KnownMetadata.cpp.
This must be consistent with the extra inhabitant calculation implemented in the runtime's storeHeapObjectExtraInhabitant function in KnownMetadata.cpp.
This must be consistent with the extra inhabitant count produced by the runtime's getHeapObjectExtraInhabitantCount function in KnownMetadata.cpp.
This must be done while holding a lock that blocks insertion of new Classes into their class lists, but in practice most Classes will already be created by now and this process is very fast.
This must be done with a thunk.
This must be set after recording the constructor in the map.
This must go here because YYSTYPE and YYLTYPE are included from bison output in section 1.
This must happen after rechaining the predecessors, because that's where the types come from.
This must happen after we do sinits for consistency with the interpreter about o_id assignments.
This must happen before checking its members.
This must happen here (instead of in resetAllocator), because the sweep routine may use g_context.
This must stay in sync with diag::access_control_setter_more.
This must stay in sync with diag::access_control_setter_read_only.
This must stay in sync with diag::associated_type_access.
This must stay in sync with diag::generic_param_access.
This mutex must be non-reentrant so when the child process tries to unlock it after a fork(), the call to pthread_mutex_unlock() will succeed.
This mutex protects actually allocating from RDS (the above statics).
This neatly sidesteps the problem of concurrent modification and execution, as well as the problem of 19- and 26-bit jump offsets (not big enough).
This needs special handling because the behavior varies depending on whether the object has a toString() method or not.
This needs to be kept in sync with getTypeMetadataStrategy.
This needs to get created first.
This needs to happen outside of the cleanups scope we're about to push.
This needs to kept in sync with hasRequiredTypeMetadataAccessPattern.
This new layout is different.
This node can be null (ParentTy()), / indicating that custom logic elsewhere will handle removing / the context when needed.
This node is the end of a defer-edge path with no pointsTo connected.
This notice may not be removed or altered from any source distribution.
This number will be 0 or the actual number of children if IsArray() or IsObject().
This object type is done, so recurse into any nested classes.
This object was just a wrapper around a FILE* or fd owned by someone else, so don't close it except in explicit calls to close().
This occurs when a swift_name'd entity becomes a member of an entity that follows it in the translation unit, e.g., given:
This occurs when you have nested increments.
This one is special because lookup is performed against the base module, rather than against the previous link in the path.
This one's default value changed recently
This only / works for loadable enum types.
This only applies to immediate imports of the top-level module.
This only can happen if we need more than the available registers at a single position.
This only cares about declarations of noescape function type.
This only checks more than one element in ill-formed code, so the linear search is acceptable.
This only eliminates existing arguments, replacing them / with casts.
This only expands one level of the copyaddr.
This only happens when we call define on a non static string.
This only makes sense because we're not trying to fulfill associated types this way.
This only matters for stored properties.
This only stops release motion.
This opens dead-function-removal opportunities for called functions.
This operation creates a callback to write / the l-value back.
This operation is only valid after name / binding.
This opportunity frequently results from a calling convention that transfers object ownership from caller to callee.
This optimisation fails on a zero key (which is weak and has bad parity anyway) in order to simplify the starting conditions.
This optimization specializes loops with calls to / "array.props.isNative/needsElementTypeCheck".
This optimization will early-initialize the copy dest, so we can't allow aliases to be accessed between the initialization and the return.
This order keeps the labels from dangling on weird sides of .try_fault or .try_catch braces.
This ordering is required so that -1 is returned for NaNs (to match PHP7 behavior).
This ordering was chosen to satisfy my aesthetics of having "simpler" scanners come first.
This ought to be supportable if the behavior allows for DI-like initialization.
This ought to use HWB, but we don't have an alpha-aware version of that yet.
This parameter is always implicitly bound.
This parameter is always present which is evident since we always grab a type to cast to, but sometimes after the polymorphic arguments.
This part is basically the same as File::TranslatePath(), except relative_to is optionally a parameter instead of coming from g_context
This pass collects the count of all instructions and reports them
This pass does not know how to do this yet.
This pass does some analysis to try to avoid PureLoad instructions, and avoid "hidden" loads that are part of some instructions like CheckLoc.
This pass eliminates store only alloc_ref objects that have destructors without side effects.
This pass happens / before the definite initialization pass so that it doesn't see infeasible / control flow edges.
This pass looks for shadow allocations and removes them.
This pass performs a simple dominator tree walk that eliminates trivially redundant instructions.
This pass performs removal of external function definitions for a sake of / reducing the amount of code to run through IRGen.
This pass performs straight-forward copy propagation, along with stateful copy propagation of values through physical registers.
This pass performs the last part of stack promotion for array buffers.
This pass prints a bottom-up ordering of functions in the module (in the sense that each function is printed before functions that call it).
This pass prints all the callsites of every function in the module.
This pass prints the callees of functions as determined by the BasicCalleeAnalysis.
This pass prints the tree of inlined instructions.
This pass promotes AllocStack instructions into virtual register references.
This pass relies on having no critical edges in the unit.
This pass sinks instructions close to their users.
This pass tests type expansion, memlocation expansion and memlocation reduction.
This pass tries to merge blocks and cleanup the CFG.
This pass will reset the state / after an instruction that may modify any array allowing removal of redundant / checks up to that point and after that point.
This pattern is typical for method chaining code like obj.method1().method2().etc()
This peephole only applies if the address being destroyed is the result of an alloc_stack.
This performs a dfs search and identifies / back edges as edges going to an ancestor in the dfs search.
This performs either / getAddrOfSwiftMetaclassStub or getAddrOfObjCMetaclass, depending / on whether the class is published as an ObjC class.
This picks up the default "w" through the properties of MongoCollection and MongoDb, but only if w is still 1 - as otherwise it was perhaps overridden with the "w" (or "safe") option.
This pointer will be set if we need to store the extended method type encoding.
This portion of DCE cannot be turned off, because it restores IR invariants, and callers of fullDCE are allowed to rely on it for that.
This potentially causes us to perform multiple mmaps under contention, but it keeps the fast path pristine.
This predicts that subsequent executions will go the same way as the first execution.
This prefers exact matches over matches that require renaming, for example.
This prevents assignments from becoming infinite loops.
This prevents color / escape sequences from interfering with editline's internal state.
This prevents gdb from trapping updates to the DWARF files emitted by HHVM
This prevents potential ambiguities with trailing closure syntax.
This prevents recursion when we allocate a temporary ZendResourceData before calling the Zend destructor.
This prevents stack slots from the caller from being sunk into the callee.
This prevents the custom scanners from being emitted (silently), which causes all sorts of problems.
This prevents us from removing members of lhs that weren't present in rhs, but would be casualties of removing certain bits in lhs.
This probably means we tried to compare IRInstructions with extra data that had no equals function.
This probably means we tried to hash an IRInstruction with extra data that had no hash function.
This probably only saves a few stat system calls at the start of each log period, but it might as well be done.
This probably should be initialized somewhere, but I didn't find a suitable place so it's wrapped in a function for now
This processes one or more 64-byte data blocks, but does NOT update the bit counters.
This produces a very simple programming model which is great to use, but relies on the optimizer to promote by-ref captures to by-value (i.e. by-copy) captures for decent performance.
This product includes software developed by the Apache Group for use in the Apache HTTP server project (http://www.apache.org/).
This profiler is very, very slow.
This profiler uses a very large amount of memory.
This program simulates LLDB importing modules from the __apple_ast section in Mach-O files.
This property is initialized in the MongoCollection (which we extend) ctor
This protocol declaration is technically a parse error, so do not type check.
This pushes a / CleanupUninitializedBox cleanup that will be replaced when / initialization is completed.
This puts complete items at the end of our list.
This pvalid will point to something we can move into the first slot if alreadyValid is false.
This raises an error, and so can't be folded.
This re-enters to call extension-defined instance constructors.
This re-synchronizes the parser so we can at least parse the body correctly.
This reads valueClass from the inputs so it used to need to happen after readMetaData.
This really just provides us a structure to match against.
This reanalyzes every function using our now-very-updated Index, and then runs optimize_func with the results.
This recgonizes such cases and ensures we have internal breakpoints to cover the destination(s) of such instructions.
This record is not part of the GenericParamList.
This records the overload for use later.
This reduces the recommended histogram size from 256Kb to 128Kb, which is a useful savings on PC-class machines.
This reference must outlive the uses of nameToPopularity.
This reflects the order in which code will be printed.
This regex does not handle comments and folding whitespace.
This release for sure is not the final release.
This release generates.
This releases ownership from the unique_ptr, and passes the pointer, and ownership of it, to HybridData which is managed by the java GC.
This relies on the following bytecode invariants:  - All fault funclets come after the primary function body.
This remains here temporarily to ease the transition to the new meaning of YYERROR, for GCC.
This removes pin/unpin pairs / within a basic block that are not interleaved by a may-release.
This represents AnyPatterns / (that is, 'var (_)') that bind to values without storing them.
This requirement doesn't have a default implementation.
This requires /   serializing globals.
This requires splitting critical edges and will naturally handle redundant branch targets.
This restriction is no problem because only stack promotion result in this alloc-release-dealloc pattern.
This result is converted from indirect to direct.
This results in better SILGen.
This results in things going extremely slowly when run under gdb, because gdb spends all its time rescanning its symbol tables.
This retain is known safe if the operand we are tracking was already known incremented previously.
This returns / true for single-expression closures, where we want the body to be considered / part of this larger expression.
This returns DAK_Count on failure.
This returns TAK_Count on failure.
This returns a / null type if one of the ParamDecls does not have a type set for it yet.
This returns a SILValue to save a little bit of compile time since we already compute that value here.
This returns a global reference (JNIEnv::NewGlobalRef).
This returns a null type if one of the / ParamDecls does not have a type set for it yet.
This returns its first argument just so we can tail call it.
This returns the / true, false, and continuation block.
This returns true on invalid.
This routine claims the argument.
This routine counts the weak uses of inlined frames and marks them dead if they have no non-weak uses.
This routine is based in part on code from Dale Lutz (Safe Software Inc.) and in part on demo code from Chapter 15 of "PNG: The Definitive Guide" (http://www.cdrom.com/pub/png/pngbook.html).
This routine is based in part on the Chapter 13 demo code in "PNG: The Definitive Guide" (http://www.cdrom.com/pub/png/pngbook.html).
This routine uses Heckbert's "locally sorted search" criterion to select the colors that need further consideration.
This routine uses Thomas' incremental distance calculation method to find the distance from a colormap entry to successive cells in the box.
This rule ensures we get a reasonable syntax error message when unexpected characters occur inside XHP tags
This saves having to also do it in the array lookup (since it will be stored as an int there).
This search is potentially slow, so we do it last and only if the reference declaration context is a type or global context.
This search will not modify the declaration.
This section can reasonably be suppressed in builds that don't need to support Objective-C.
This section name is magical for the Darwin static and dynamic linkers.
This securely "cleans" the file.
This seems like a good choice for now because it operates efficiently in blocks rather than bytes, and  the data returned from the collation iterator comes in 4byte chunks.
This seems to be a pre-1.8 MongoDB installation, where we need to default to 4MB
This seems to be a pre-2.4 MongoDB installation, where we need to default to two times the max BSON size
This seems trivially true in all cases but converting arrays to objects.
This seems trivially true in all cases but converting objects to arrays.
This seems unlikely to affect real-world usage.
This selects one of the six possible month length configurations listed above.
This set is generally very small because claiming a note removes / it.
This sets up a guard for each piece of translated code to ensure we punt to the interpreter when the debugger is attached.
This setting is actually an int, but setting to a bool that returns false for now.
This setting is especially relevant to arena 0, which all the service requests use.
This shortened the year by 3 days per 400 years, giving a year of 365.2425 days.
This should *really* be a ValueDecl.
This should also potentially reduce the number of live registers during call sequences.
This should always be a child of an ApplyExpr and so will be emitted by SILGenApply.
This should always be called once we're attached to a machine.
This should always be called under the mutex lock.
This should always be the case, but let's be on the safe side.
This should always be true, so just assert it.
This should be a tail call in opt build.
This should be after FSO.
This should be an invariant based on the check in isCollectionLiteralStartingWithLSquareLit().
This should be called after calling relocate on all relevant ranges.
This should be called after filtering the candidate / list.
This should be called in top-down order of each def that needs its uses / rewrited.
This should be constant-initialized, but this is safe.
This should be done even for local variables, as they might otherwise be expanded by user macros.
This should be enough to unique Git hashes for the time being, and certainly enough for SVN revisions, while keeping the version string from being ridiculously long.
This should be expanded in the future.
This should be filtered out earlier right now.
This should be handled by IRGen emitting the enum strategy explicitly.
This should be kept in sync with ArchetypeBuilder::getAllArchetypes().
This should be kept in sync with GenericParamList::deriveAllArchetypes().
This should be pretty rare, but let's go ahead and merge the two equivalence classes into one.
This should be refactored alongside with the getLastError redirection in collection.c/append_getlasterror.
This should be refactored alongside with the getLastError redirection in db.c/MongoDB::command.
This should be removed.
This should be the last option, for convenience in checking output.
This should be treated like an error, but we don't want clients like lldb to crash because of corrupted input.
This should be unreachable
This should be used only for debugging/logging purposes.
This should cause the proxy to disconnect from us.
This should fail downstream healthchecks.
This should get the original (unexpanded) location back.
This should have been a word all along
This should have been overwritten by the creation function.
This should however get done in a different diff, since it could impact perf in a negative way (#3145038)
This should make our test results less verbose.
This should never be called since mangling parameter kinds have influence on the payloads.
This should never be called since mangling parameter payloads require knowing what the parameter kind is.
This should never be the type of an argument or field.
This should never call the magic methods __get or __set.
This should never cause a deallocation.
This should never happen because the trie should only ever contain prefixes of fixed-size network addresses, so the trie should never be any deeper than the network address size.
This should never happen, but handle it anyway.
This should never happen, but when it does we have to bail out, since there's no sensible way to send data at this point and trying to do so will horribly corrupt memory.
This should never happen.
This should only accept as an operand type single-refcounted-pointer types, class existentials, or single-payload enums (optional).
This should only be done in the prologue.
This should only be possible with loops.
This should only be used after a successful trylock of a lock with rank r.
This should only happen if we get OPEN request while the previous document is not closed.
This should probably be split into two methods...
This should probably just go to the Local repo always, except that our unit test suite is currently running RepoAuthoritative tests with the compiled repo as the Central repo.
This should produce a specific and tailored diagnostic saying that the type mismatches with expectations.
This should really be described as a DW_TAG_variant_type.
This should really only happen during debugging.
This should return false if the MArrayIter is in the reset flag state.
This should run after specialization and inlining because we don't want to specialize a call that can be inlined.
This should still be 2.
This should take care of initializer with flags
This should theoretically have no effect on the caller.
This shouldn't be necessary, but emitOrigToSubstValue can get upset.
This shouldn't be reached.
This shouldn't happen, but if it does don't get into an inconsistent state.
This shows how desperately we need a better HTTP Server
This shows up frequently because it corresponds to 'Self' in protocol requirement generic signatures.
This shuffles values to the right in a canonical order to need less overloads.
This silences downstream diagnostics checking to make sure that some PBD's that require initializers actually had them.
This silly cast below avoids a C++ warning.
This simplifies SILGen.
This simplifies later dominance based processing.
This situation can arise due to conservatively reducing the lower bound, or due to pure stores happening before IncRef instructions that raise the lower bound for that new pointer.
This situation is represented by GroupContext.isEnable().
This situation most commonly happens when we interpOne a RetC due to having a VarEnv or some other weird case.
This slightly reduces the number of wasted vtable vector entries at runtime.
This software is based in part on the work of the Independent JPEG Group.
This software is provided "as is" without express or implied warranty.
This software is released under Microsoft Reciprocal License (MS-RL).
This solution might be worse than the best solution found so far.
This source code is licensed under the BSD-style license found in the LICENSE file in the root directory of this source tree.
This source file is part of the Swift.org open source project
This special exception was added by the Free Software Foundation in version 2.2 of Bison.
This speeds things up.
This stable sort will keep the blocks only reachable from DV entry points after all other main code, and move fault funclets after all that.
This starts to prevent inlining at about 800 - 1000 caller blocks.
This state inserts a Halt node in each of the RC flowgraphs, and stops all optimizations along that control flow path: it prevents us from doing anything else in any successor blocks.
This state will be propagated into all of our predecessors, allowing us to be conservatively correct in all cases.
This step allows us to hoist dependent chains of checks as if they were a single check.
This step unrelaxes guards that were relaxed but whose block couldn't be merged with any other block.
This stops the diagnostic cascade.
This store must preserve the kind bits in the WaitHandle for correctness.
This string doesn't have anything we need to escape, so print it directly
This string is what PHP considers as "data" or "info" which is basically the string of "PHP1xx" where xx is country code that uses this timezone.
This strtod returns a nearest machine number to the input decimal string (or sets errno to ERANGE).
This struct carries some context information needed for the invocation, as well as a place for the return value of invoking the file.
This struct declaration is technically a parse error, so do not type check.
This struct is not used in this scanner, but its presence is necessary.
This struct represents a constraint on the range of some values in some / basic blocks in the program.
This struct represents an analyzed function pointer to determine the / candidates that could be called, or the one concrete decl that will be / called if not ambiguous.
This structure gathers a php and async stack trace when log is called.
This structure gets fed into build_graphs to create our RC graphs.
This structure is linked to a block of instructions (usually starting at a label), and tracks the current stack depth in this block.
This structure is used to store a section of a Jpeg file.
This structure stores Exif header image elements in a simple manner Used to store camera data as extracted from the various ways that it can be stored in a nexif header
This stub is hot, so make sure to keep it small.
This subclass cannot be handled.
This subclass has its own subclasses and they will use this implementation or provide their own.
This suggests the debugger client has made an error.
This suggests we've missed the exit event for Bar() and have the exit event for Foo() in hand.
This suppresses the error about missing return value in a non-void function.
This switch does a "break" when the instruction can be skipped and is interesting, and a "continue" when it is a retain of the same pointer.
This switch was never executed during profiling.
This symbol is only exported by the runtime if the platform uses isa masking.
This table is mutable as well since its a cache.
This table maps each EBCDIC character to an (8-bit extended) ASCII character, as specified in the rationale for the dd(1) command in draft 11.2 (September, 1991) of the POSIX P1003.2 standard.
This table maps the 128 ASCII characters into the 32 character classes.
This table reflects a particular philosophy about what constitutes "text," and there is room for disagreement about it.
This takes a little digging, so compute on first use and cache it.
This tends to produce less IR, but might be evil.
This thread is now the one the proxy considers the current thread.
This throws an error for the following cases: 1) "self" or "parent" in any namespace.
This timer has been removed from the pool by one of the callbacks.
This token starts before the edited range, but doesn't end before it, we need to adjust edited line range and clear the affected syntax map line range.
This tracking can take two forms: - Absolute depth: the depth of the stack is exactly known for this block - Relative depth: the depth of the stack is unknown for now.
This tracks how close the candidates are, after filtering.
This transformation is only appropriate if we believe the check failing is very unlikely, because it can cause new regions to be generated that duplicate portions of the loop body.
This trick lets us avoid special-casing unordered.
This turns out to be rather cunning.
This type check should have created a non-dependent type.
This type is a template which should not be instantiated on any req allocated types.
This type is too large to fit in a register.
This type of "rounding" allows us to avoid calculating the length of the year in most cases.
This type should be ignored (used for system types we can't modify).
This type variable is only currently associated with the function being applied, and the only constraint attached to it should be the disjunction constraint for the overload group.
This type variable should be in the equivalence class of its representative.
This type will be expressed in terms of the archetypes of the conforming context.
This typehint will always fail.
This typically reduces the INT_MAX default value to something more reasonable.
This unbalances the return stack buffer, but if we're intercepting, we probably don't care.
This under-represents any functions still on the stack.
This use is a copy of CurrentDef.
This use looks something like:
This used to be a conditional around just the two extra args, but that might be undefined if yyoverflow is a macro.
This used to be an fputs(), but since the string might contain NUL's, we now use fwrite().
This uses an if-then-else instruction in ARMv7, which should be cheaper than a full branch.
This uses getLocation() instead of getRange() because we don't want to replace the "(set)" part of a setter attribute.
This uses the dominator tree, since the a parent loop's header must dominate the headers of its children loops.
This uses the parent declcontext (not the closure) since the initializer expression is evaluated before the closure is formed.
This usually happens if it thinks the template isn't "used".
This utility is meant to help simplify the extraction of test cases from sil files by removing (currently only) functions that do not match a string.
This value could be NULL if there are / multiple deallocations.
This value is beyond our precision, so rounding it is pointless
This value is computed by adding up the profiling weights of all the Profile translations that may execute immediately before the Profile translation containing the loop header.
This value is uninitialized (and unbound) if it has a pattern binding decl, with no initializer value.
This value should be enough bytes to emit a REQ_RETRANSLATE: lea (4 or 7 bytes), movq (10 bytes), and jmp (5 bytes).
This value will only be filled in if there are one or more enum elements that have a non-zero byte size
This var may be unused depending upon options.
This variable is used to signal when a cache was generated and it is correct to avoid a new scan.
This variable's lifetime needs to be for the whole function, but is only valid with Objective-C interop enabled.
This version does not attempt to produce an output file with transparency in some of the palette indexes, which, in practice, doesn't look so hot anyway.
This version has the slow path inlined.
This version is derived from the original implementation of FreeSec (release 1.1) by David Burren.
This version of furc_hash is fairly insensitive to key length since additional bits are generated by re-hashing the initial MurmurHash64A.
This version performs Floyd-Steinberg dithering
This version performs no dithering
This violates the invariant that the value of m_data doesn't matter in a KindOfNull TypedValue.
This visits each attribute on a decl early, before the majority of type / checking has been performed for the decl.
This vtable has no contents.
This waits for interrupts from the server (and responds to polls for signals).
This walks the generic signature's requirements, similar to Solution::computeSubstitutions but with several differences: - It does not operate within the type constraint system.
This was a bug in PHP, see PHP bug #45028 We currently rely on the old behaviour
This was a bug in PHP, see PHP bug #48284 We currently rely on the old behaviour
This was a module reference.
This was an exhaustive do body, so bound our throwing kind by its throwing kind.
This was causing a crash
This was contained inside of a bound generic structure type that was expecting two types.
This was optimized from a Constant, or ClassConstant use the original string
This was really a NUL.
This was the 'else' case, we can't really 'detect' it
This was using the implicit Variant(bool) ctor.
This way SILCombine will visit from the top of the function down.
This way the DW_AT_APPLE_runtime_class(DW_LANG_Swift) attribute can be used to differentiate them from C++ and ObjC classes.
This way the Last-Modified header will not show in response.
This way, debug_info is preserved at Onone.
This way, php_pollfd_for will return a mask with POLLOUT if the connection is successful and with POLLPRI otherwise.
This way, we get rid of pass dependence on DCE.
This way, we won't create needless conversion constraints for elements whose equivalence classes have been merged.
This will also cause the runtime to lay us out.
This will also help us with self-recursion.
This will always succeed since we have an entry for each BB in our RPOT.
This will always succeed since we have an entry for each BB in our post order.
This will be a dataflow error if we can reach here.
This will be block that will contain the check whether to execute the 'native swift array' loop or the original loop.
This will be correct as long as we don't ever have self-referential Types.
This will be disabled automatically when the thread completes the request
This will be eliminated by DCE.
This will be ignored for the rest of the ARC optimization.
This will be ignored in the rest of the optimizer.
This will be initialized on every entry into the loop header and consumed by the loop body.
This will be recontextualized to a method we synthesize during type checking.
This will be removed in the future.
This will be removed when Loop ARC is finished and Block ARC is removed.
This will be resolved (or rejected) by sema when the overall refutable pattern it transformed from an expression into a pattern.
This will be stored here so the checking of the Callee can use the same code in both cases.
This will be the proper successor block set by setSuccIRBlocks.
This will be used to exit early in later control-dependence queries.
This will be useful for type checker diagnostics when a user tries to use the Objective-C/C type instead of the Swift type.
This will call print_crash_message and then reraise the signal (so the exit code will be accurate).
This will cause cmds like Next and Out to just let the program run, which is appropriate.
This will clear the error both on the stmt and connection so we make sure it closed now.
This will create the singleton only when all the parameters are given
This will eliminate struct_extracts/tuple_extracts from the newly created aggregate and have them point directly at the argument.
This will enable us to recover the original edge if we need to.
This will ensure that it is considered ambiguous.
This will ensure that the code is updated when we hit the cast failure in debug builds.
This will ensure that we always exit on the same path on both proxy and client threads, and remove any spurious output form ths test case.
This will ensure the previous DIE gets freed (because of the above SCOPE_EXIT).
This will ensure we can do indentation inside the braces.
This will ensure we can properly annotate TypeRepr with a usr in AnnotatedDeclarationPrinter.
This will free the locals for us in the normal case.
This will frequently become a dead store.
This will further enable to sink strong_retain_unowned instructions, which provides more opportunities for the unowned-optimization in LLVMARCOpts.
This will get default initialized to nil.
This will get default initialized using the protocol's initStorage() method.
This will give the local proxy time to recgonize the bad cmd, terminate, and wait for the client to stop.
This will go away soon.
This will handle freeing the locals in the normal case.
This will have just used up the first values in the list, pop them off.
This will help us compute a / "best common type" from the expression types.
This will leak blocks if anything's been added since the corresponding call to makeScratchBlock(), but it's harmless.
This will let us elide uses of the register for 'tvRef2', until the Jmp we're going to emit here.
This will let us reach the fixed point in less iterations.
This will live / only until a proper mapping is added.
This will load if the value is not address-only.
This will make comparison between locations easier.
This will make sure we produce an error later.
This will make the unserializer to reserve an id for the element but won't allow referencing the element via 'r' or 'R'.
This will need revision if we ever add goto.
This will need to change if we ever start using it in an hhas file.
This will normally correspond to the main function entry (for normal, regular bytecode), but it may not be for irregular functions written in hhas (like array_map and array_filter).
This will not "hook up" the relocated code in any way, so is safe to call before the relocated code is ready to run.
This will only be called on strategies for loadable types.
This will only schedule the given command if it has not been scheduled and if all of its inputs are in FinishedCommands.
This will populated derived protocols and / synthesized protocols, add the new variable and pattern bindings, and / create the inits parameterized over a raw value /
This will prefer the SDK alongside the Swift found by "xcrun swift".
This will present the prompt, wait for user input, and execute commands, then rinse and repeat.
This will prevent someone from doing a build without debug info and silently getting conservative scanning for everything.
This will probably error elsewhere, but there's nothing we can do.
This will reject some things, but allow other things we don't want.
This will remove this instruction and all its uses.
This will require to merge the content nodes (and maybe other content nodes as well), because of the graph invariance 4).
This will return 0 if the breakpoint is not in the set and so the breakpoint is not unmatched
This will return an array of String with the possible completions
This will return an empty SILValue if we found something we do not understand.
This will short-circuit the work done in phpDebuggerOpcodeHook() and ensure we don't interrupt on this source line.
This will silence "variable unused" and "could be marked let" warnings for it.
This will skip DV Funclets if they were already retranslated w/ the prologues:
This will sort in ascending order.
This will tell the connection to begin listening for events.
This will update a single range that was not relocated, but that might refer to relocated code (such as the cold code corresponding to a tracelet).
This will walk the frames upward until we find a TC frame.
This will warn, error, or do nothing depending on what the user chose for the option.
This won't be possible once task #4076399 is done.
This won't be set until we write the actual file data later on.
This works because each type category only has at most one sub-type to check.
This works fine for GCC, but not Clang.
This works only for Arrays but not e.g. for ArraySlice.
This would actually be Monday, because the Jewish day is considered to begin at sunset.
This would be a great place to verify the checksum...
This would change if we introduced a native runtime-hookable mechanism.
This would happen if we delete the instruction it is pointing to.
This would invalidate a plain ValueUseIterator.
This would just cause a confusing definite initialization error.
This would mean we've been asked to eval in a frame which is beyond the top of the stack.
This would require typechecking or at least name lookup, if the nested class is in an extension.
This would then create an additional copy.
This wrapper temporarily turns off the exception throwing bit if it has been set (by calling mongo_cursor_throw() before).
This, hopefully, will help / ARC sequence opt to remove retain and release pairs without worrying too / much about control flows.
This, in turn, works better with our error recovery because we won't diagnose an end curly quote in the middle of a straight quoted literal.
Thomas in chapter III.1 of Graphics Gems II (James Arvo, ed.
Thomas' article also describes a refined method which is asymptotically faster than the brute-force method, but it is also far more complex and cannot efficiently be applied to small subboxes.
Those *should* be irrelevant for all the cases where this is wrong, but...
Those cases, and others, if it's MOpFlags::Define, will set the base to a null value in tvScratch.
Those core APIs are explicitly provided by the Foundation module overlay.
Though seems to be wasting memory a lot, we have to realize most of the time this function is called with small strings, or fragments of HTMLs.
Thread Sanitizer only works on OS X and the simulators.
Thread local config options
Thread might have already exited.
Thread the loop clones by redirecting the loop latches to the successor iteration's header.
Thread-local globals.
Thread-private ascii ringbuffer.
Threads for the dummy sandbox and signal polling can't destroy the proxy directly, since the proxy owns them and will want to destroy them.
Threads may race through the following calls, but the last call made by any idling thread will correctly restore lg_dirty_mult.
Three supported cases: - metatype to metatype - metatype to object - object to object
Three-byte-character lead byte followed by two trail bytes.
Throw a fatal exception if it does.
Throw a fatal exception if one does.
Throw away as much memory as possible.
Throw exception - error code is 20 + above value.
Throw exception - error code is 25.
Throw exception in case we have no connection
Throw is not marked as a STMT_KEYWORD.
Throw out the witness table pointers.
Throwing functions must map to a particular error convention.
Throws XDebugError::EvaluatingCode on failure.
Throws an error if the symbol is not found
Thunks are always emitted by need, so don't need delayed emission.
Thunks for class method witnesses dispatch through the vtable allowing inherited witnesses to be overridden in subclasses.
Thus all we need to do is gather up the interesting instructions from our subregions.
Thus an intersection.
Thus as long as we use indices, we will visit all exiting block edges appropriately and not deal with touching stale memory.
Thus if the encoded value is above Threshold, the value after decoding is also above Threshold.
Thus if we find / one go through all of its uses and see if they are all loads and address / projections (in many common situations this is true).
Thus if we see an unknown call we merge together all retains and releases before.
Thus it is using return false to mean two different things, error a failure occurred and this is a declaration.
Thus musage in the example code may well substantially exceed m_stats.usage.
Thus the 320 modifications involve, overall, 320 additions, 320 xor's, and 320 rotations.
Thus the fields could be accessed directly.
Thus we /    insert a release right before any exit from the function.
Thus we allocate one slab and divide it between the various blocks.
Thus we can just return false since in none of the aforementioned cases we cannot alias, so return false.
Thus we check here / that no mutating struct_extract users exist.
Thus we drop all instruction references before we erase.
Thus we need to check the field/struct decl which are not operands.
Thus we only need to check the field no and tuple type which are not represented as operands.
Thus we only need to check the field/struct decl which are not operands.
Thus we pass in a lambda that performs the work for us.
Thus we wouldn't want to make a substitution.
Thus, EmptyArray::IterRewind() is not reachable.
Thus, a proactive measure like this self-test is needed.
Thus, an indirect call through the class_method cannot be eliminated completely.
Thus, the cursor_id is set to 0, so no more results will be fetched.
Thus, this implementation just accepts php expressions.
Thus, we can analyze these methods first to determine the initial types of properties with non-scalar initializers, and these need not be be run again as part of the fixedpoint computation.
Thus, we maintain a mapping from internal token IDs to stable "user token IDs" and only expose the user token IDs to the PHP application.
Thus, we must force it to run again in order to be able to observe all the updates.
Thus, we optionally deviate from the correct algorithm just enough to avoid such collisions.
Thus, we'll have at most two destinations.
Time interval, in microseconds
Time is stored if profiling, tracing, or collect_time is enabled, but it only needs to be collected on function exit if profiling or if computerized tracing output is enabled
Time spent in children Iterate until we find the end frame
Timeout is in seconds.
Timestamp (microseconds)
Timestamp is 4 bytes of seconds since epoch and 4 bytes of increment.
Tishri           The first month of the Jewish year.
Tishri 1 must never be Sunday, Wednesday or Friday.
Tishri 1 will be the day of the molad unless it is delayed by one of the following four rules (called dehiyyot).
Title: Affine transformation
Title: Crop  A couple of functions to crop images, automatically (auto detection of the borders color), using a given color (with or without tolerance) or using a selection.
Title: Matrix Group: Affine Matrix
Tmps defined by DefConst are always available and may be assigned to registers if needed by the instructions using the const.
To accomplish this it / relies on knowledge of all array operations within the loop.
To account for newlines in the T_WHITESPACE
To apply the bridged casts optimizations.
To apply the bridged optimizations, we should ensure that types are not existential, and that not both types are classes.
To apply the bridged optimizations, we should ensure that types are not existential, and that one of the types is a class and another one is a struct.
To assist debugging parser crashes, tell us the location of the / current token.
To attach the line number to for error reporting.
To avoid copies, evaluate it directly into the box, being careful to stage the cleanups so that if the expression throws, we know to deallocate the uninitialized box.
To avoid dirtying memory, only write to the global ivar offset if it's actually wrong.
To avoid doing it more than once for any given join point, this keeps track of what we've added so if it's needed in more than one place we can reuse it.
To avoid exposing the pattern binding declaration to the user, get the descriptive kind from one of the VarDecls.
To avoid recursion, use a loop instead.
To avoid repeated crashes, used to notify the service to delay typechecking / in the editor for a certain amount of seconds.
To avoid this issue, addqi and subqi are the only vasms that will be lowered directly by using rAsm on its emission.
To avoid this problem we update the return BC offset to refer to the outer frame and fix it up in the catch trace when we restore the rbp chain.
To be able to assume it is actually counted it if used to be static, we need to add code checking for keys that are one of the "illegal offset type" of keys.
To be called during process startup ONLY, before threads are spun up.
To be called when we enter a fresh namespace.
To be compatible with a variadic interface, params from the variadic onwards must have a compatible typehint
To be conservative, we only wish to allow for casts to appear in the common parts of projections.
To be consistent with PHP5, we need to make a distinction between null strings and empty strings for the prefix.
To be implemented when we have more image formats.
To be safe in case we failed to get prevFp.
To be safe we close the socket so that if nobody else is listening the OS starts rejecting requests but if somebody is listening we let them receive the requests.
To check for query reply status
To conform to PHP behavior, we invalidate all strong iterators when an element is added to the beginning of the array.
To conform to PHP behavior, we invalidate all strong iterators when an element is removed from the beginning of the array.
To conform to PHP behavior, we need to set the internal cursor to point to the next element.
To conform to PHP5 behavior, the pop operation resets the array's internal iterator.
To conform to PHP5 behavior, we need to set the internal cursor to point to the next element.
To conform to PHP5 behavior, when array's integer keys are renumbered we invalidate all strong iterators and we reset the array's internal cursor (even if the array is empty or has no integer keys).
To construct the calendar for a year, you must first find the length of the year by determining the first day of the year (Tishri 1, or Rosh Ha-Shanah) and the first day of the following year.
To copy in 32-byte chunks, we add 24 bytes to the length.
To determine the time of the start of the next period add just enough to move beyond the start of the next period and then determine the time of the start of that period.
To disambiguate other cases of "identifier :", which might be part of a question colon expression or something else, we look ahead to the second token.
To distinguish between non-payload cases, load the payload value and strip off the spare bits.
To do better we could either run this pass before semantic inlining, or we could also handle calls to array.init.
To do everything in integer math, we must use integer scale factors.
To do not bloat normal filling code I added a 2nd private function.
To do so would force the type variable to be adjacent to itself.
To do this, we need the metadata for the associated type.
To do this, we search / forward in the current block from the copy that initializes the value to the / point of deinitialization.
To do what PHP 5.x in these cases, use the RuntimeOption
To ease migration, the 'array' type constraint will implicitly cast collections to arrays, provided the type constraint is not soft and the parameter is not by reference.
To ensure no retains occur / within the loop, it is necessary to check that the array does not escape on / any path reaching the loop, and that it is not directly retained within the / loop itself.
To ensure this we do not want them to be added to the constants table.
To force the compressor stop at the byte boundary one can write an empty meta-block.
To get around that, we wrap the initialization in a function so s_impl will get initialized the first time it gets called.
To get around these problems, we apply Thomas' method to compute the nearest colors for only the cells within a small subbox of the histogram.
To get the same result as in PHP we thus need to replicate the PHP algorithm more closely than in the other versions of array_unique.
To get this behavior, we have to bind and then re-inject the result.
To give other consumers a chance.
To grant universal access to a web page attribute "WebSecurityEnabled" must be applied during the initializing security context for Document instance.
To handle covering value, we need to go to the predecessors and materialize them there.
To handle mutations of public statics where the name is known, but not which class was affected, these always need to be unioned with values from IndexData::unknownClassSProps.
To handle this case correctly, we get spare bits from the unsubstituted type.
To handle top-level code properly, we look through the TopLevelCode decl on the use (if present) since the vardecl may be one level up.
To have a parameter name here, we need a name.
To help deserializing the context generic params, we serialize the outer-most list first.
To implode an address-only tuple, we need to create a buffer to hold the result tuple.
To implode loadable tuples, we just need to combine the elements with TupleInsts.
To improve the visual quality of the results, we actually work in scaled RGB space, giving G distances more weight than R, and R in turn more than B.
To keep DI happy, initialize stored properties before computed.
To keep alive as long as command is alive Attach the source, const cast is due to xml interface
To keep things simple we only analyse up to this number of nested loops.
To maintain a fully accurate histogram, we'd need to allocate a "long" (preferably unsigned long) for each cell.
To maintain this property, we have to start one past the sentinel kInvalidTransID, which is -1.
To make our output deterministic, we sort local successor indices.
To make sure we can do this split all critical edges from instructions that don't support block arguments.
To make this work, we need to do some weird things in the catch trace.
To match hphpc, we silently ignore functions defined in user code that have the same name as a function defined in a separable extension
To mimic PHP5 should return empty array at failure.
To minimize output, only print the line and column number for everything but the first instruction.
To model this, we emit an unreachable instruction and then have SIL diagnostic check this.
To optimize this process, we also compute the AvailSetMax at particular point in the basic block.
To pick a mongos we therefore simply pick the "nearest" mongos node.
To preserve the invariant that the lsb class is an instance of the context class, we require that f's class is an instance of the context class.
To prevent extra large output files, e.g. when compiling the stdlib.
To prevent mistakes, assert that here.
To prevent these separators from being replaced with a space, we use the SKIP_LONG_HEADER_SEP_MBSTRING to skip over them.
To prevent this, compute the actual masks up front
To reduce the amount of output, we only dump the memory behavior of selected types of instructions.
To save memory we load these mappings lazily from the repo and cache only the ones we actually use.
To save much memory, we overlay the table used by compress() with those used by decompress().
To save space, we don't include the source trait in the requirement.
To set up irSPOff, we want the FPInvOffset for the new fpValue and spValue.
To simplify induction variable.
To solve this problem, when RLE detects that a load instruction / can be replaced by forwarded value, it will try to find minimum # of / extractions necessary to form the forwarded value.
To support this, inside inheritance clauses we allow references to protocols that are unavailable in the current type refinement context.
To tell whether a property is declared as private in the context
To track that information, we set the `hint' on phi uses to the corresponding phidef variable (or one of the two, in the case of phijcc), then let the hint back propagation pass handle it.
To trigger this, one would need a terminator that uses a reference counted value and only has one successor due to critical edge splitting.
To use ArrayIdx, we require either constant non-int keys or known integer keys for Map, because integer-like strings behave differently.
To use the ClangImporter to create the module loader, we need to properly set the runtime library path.
To verify that a date is valid, convert it to SDN and then back and compare with the original.
Todo: Replace the color/YUV functions with our own and simplify that should boost the conversion a bit as well, not only for palette image.
Together with the class for / which the function implements the method.
Token at end of string
Tokenize w/o fixing split tokens
Tokenize with fixing split tokens
Tolerate being passed an address here.
Too bad C++ doesn't have nice Swift-style enums.
Too many arguments passed, raise a warning ourselves this time
Too many gosh-darned arguments passed.
Too many translations
Too many weak uses for us to know we can optimize it away.
Top level entry point
Top level merging function for predecessors.
Top of the region hierarchy - allocate a fresh control target.
Top-level code implicitly handles errors.
Top-level entrypoint.
Top-level global variables in the main source file and in the REPL are not lazily initialized.
Top-level types, for various consumers.
Trace information about interface conflict sets and the vtables computed from them.
Trace start of SourceKit operation
Trace start of perform sema call, returns OpId
TraceProfiler Walks a log of function enter and exit events captured by TraceProfiler and generates statistics for each function executed.
Tracing return lambdas.
Track a high water mark, and incrementally map each huge page we low_malloc with a huge mapping.
Track a specific VarDecl
Track all known array users with the exception of struct_extract users (checkSafeArrayElementUse prohibits struct_extract users from mutating the array).
Track all stores of refcounted elements per address projection.
Track all the managed elements whether or not we're actually emitting to an address, just so that we can disable them after.
Track all users that extend the lifetime of the object.
Track all uses in the block arguments.
Track any inout arguments that are emitted.
Track printed names to handle overlay modules.
Track stack types and pre-live ActRecs.
Track the AST location of the component.
Track the AST location of the generic arguments.
Track the AST location of the new component.
Track the base for member declarations.
Track the lifetime, release points, and released values referenced by a newly allocated object.
Track the new location and value.
Track the original end location of the expression we're trailing so we can warn about excess newlines.
Track the parameters of the function.
Track the projections of the box.
Track the stack depth while emitting to determine maxStackDepth.
Track the value up the dominator tree.
Track this new store.
Track those type variables that the caller cares about.
Track when we are checking type witnesses.
Track whether all fields in this record can be referenced in Swift, either as stored or computed properties, in which case the record type gets a memberwise initializer.
Track whether this record contains fields that can't be zero- initialized.
Track whether this record contains fields we can't reference in Swift as stored properties.
Track whether we had parentheses around the string literal.
Track whether we've added any storage to our layout.
TrackCPU means: prefer clock_gettime, but fall back to getrusage.
TrackVtsc means: require clock_gettime, or else no data.
Tracked just for an assertion in lookup().
TrackedStore is used to keep track of which stores are available at the beginning and end of each Block.
Tracks if the pass changed ApplyInsts.
Tracks if the pass changed branches.
Tracks the depth of the stack in a given block of instructions.
Tracks the inlined FP currently in use for each block within the inlined region.
Tracks the max depth of elem stack + desc stack offset inside a region where baseValue is unknown.
Tracks the min depth of the elem stack inside a region where baseValue is unknown, and the line where the min occurred.
Tracks the potential version range when the condition is false.
Trailing closures are not considered siblings to other args.
Trait aliases can increase method count.
Trait flattening is supposed to happen only when we have awareness of the whole program.
Trait has not been 'inlined' into using class so context is not available
Trait method typehints, self and parent, need to be converted
Trait used to write the on-disk hash table for the / globals-as-members mapping.
Trangle filter, default radius 1
Transcode the string to UTF-16 to get its length.
Transfer attributes of the calling thread, such as QOS class, os_activity_t, etc.
Transfer control to the resume address.
Transfer function for dataflow analysis.
Transfer ownership of obj to the ActRec
Transfer ownership of the MemoryBuffer to the SourceMgr.
Transfer the result into our buffer if it wasn't emitted in-place already.
Transfer the results to the local breakpoint list.
Transfer the witness table pointers.
Transform a function value.
Transform a metatype value.
Transform a tuple value.
Transform an arbitrary value.
Transform as many times as possible.
Transform each of the catch clauses:
Transform generic parameters.
Transform input type.
Transform requirements.
Transform result type.
Transform the ClosureExpr representation into the "expr + return ()" rep if it isn't already.
Transform the body of the 'do'.
Transform the body of the catch clause.
Transform the error pattern.
Transform the guard expression if present.
Transform the input and output types.
Transform this now to simplify later code.
Transform this type node.
Transforming the inlined-at SIL scope to a location means skipping the inlined-at scope.
Transforms in_array with a static haystack argument into an AKExistsArr with the haystack flipped.
Transforms state based on block.
Transient state for the current Def valid during forwardCopiesOf.
Transition from SHUTDOWN_NONE to DRAINING_READS needs to happen explicitly through `stopListening`, not here.
Transition the generator into either the Priming state (if we were just created) or the Running state (if we were started).
Transitive module imports are not handled at the declaration level.
Transitively collect all the values that make up this location and / create a SILArgument out of them.
Translate AST default argument kind to the Serialization enum values, which / are guaranteed to be stable.
Translate C++ to Java Exception
Translate LLVM function attributes to Swift function attributes.
Translate a single value and add it as an output.
Translate a single value and initialize the given temporary with it.
Translate and reabstract the index values by recursively walking the abstracted index type.
Translate from SMLoc ranges to column ranges.
Translate from the AST ParameterConvention enum to the / Serialization enum values, which are guaranteed to be stable.
Translate from the AST ResultConvention enum to the / Serialization enum values, which are guaranteed to be stable.
Translate from the AST associativity enum to the Serialization enum / values, which are guaranteed to be stable.
Translate from the AST function representation enum to the Serialization enum / values, which are guaranteed to be stable.
Translate from the AST ownership enum to the Serialization enum / values, which are guaranteed to be stable.
Translate from the Serialization associativity enum values to the AST / strongly-typed enum.
Translate from the Serialization function type repr enum values to the AST / strongly-typed enum.
Translate from the requirement kind to the Serialization enum / values, which are guaranteed to be stable.
Translate from the serialization DefaultArgumentKind enumerators, which are / guaranteed to be stable, to the AST ones.
Translate from the serialization Ownership enumerators, which are / guaranteed to be stable, to the AST ones.
Translate from the serialization ParameterConvention enumerators, / which are guaranteed to be stable, to the AST ones.
Translate from the serialization ResultConvention enumerators, / which are guaranteed to be stable, to the AST ones.
Translate implicitly unwrapped optionals into strict optionals.
Translate input hash to sortable index
Translate the "nullability" notion from API notes into an optional type / kind.
Translate the alignment to a mask.
Translate the arg to a memoize key
Translate the argument values from the requirement abstraction level to the substituted signature of the witness.
Translate the argument values.
Translate the context.
Translate the current start state into a value that can be later handed to BEGIN to return to the state.
Translate the given operator character into its mangled form.
Translate the owning declaration into a DeclContext.
Translate the result values.
Translate the return values from the Source object: 0 is EOF, -1 is error
Translate the unit filename to match xdebug's internal format
Translate the unit filepath and then break
Translate the value from an enum representation to a possibly-null representation.
Translate to dst origin (0,0)
Translate values and collect them into a single optional payload.
Translate values and store them to a result tuple in memory.
TranslatePath() will canonicalize the path and also check whether the file is in an allowed directory.
Translates operator fixity to demangler operators.
Translation unit context.
Transliterator to convert UnicodeStrings to lower case.
Transmute the checked cast into a coercion expression.
Trap BBs leak all reference counts and do not reference semantic objects in any manner.
Traversal - This class implements a simple expression/statement / recursive traverser which queries a user-provided walker class / on every node in an AST.
Traverse the "access" path for V and check that it starts with "let" and everything along this path is a value-type (i.e. struct or tuple).
Traverse the actual block layout, and find out the intervals for each exception region in the tree.
Traverse the chain of predecessors.
Traverse the children in the dominator tree inside the loop.
Traverse the children in the dominator tree.
Traverse the dominator tree starting at the loop header.
Traverses the code bottom up, keeping track of the currently live (single) status-flag register, or InvalidReg if there isn't one live, then iterates to a fixed point.
Treadmill solution for the SharedVariant memory management
Treat 'unavailable' implicitly as if it were 'optional'.
Treat StoredWithTrivialAccessors the same as Stored unless we're printing for SIL, in which case we want to distinguish it from a pure stored property.
Treat _ as a word on its own.
Treat a call to a load of a variable as a call to that variable, it is just the lvalue'ness being removed.
Treat a copy_addr as a load + store
Treat a missing file as "no previous build".
Treat a newly-added hash as up-to-date.
Treat any inherited protocols as constraints on `Self`, and gather conformances from the containing type.
Treat as if it's "thismodule"
Treat both open and close brackets equally
Treat empty input file as fatal error
Treat everything apart from GET and HEAD as a post to be like php-src.
Treat extensions methods as deprecated if their extension is deprecated.
Treat global variables from the same source file as local when completing at top-level.
Treat it as a typedef.
Treat keywords that could be the start of a pattern specially.
Treat null as an empty path.
Treat signals as timeouts
Treat stdlib_binary_only specially.
Treat this as the end of the value size.
Treat tmps defined by DefConst as always defined.
Treat unannotated declarations as always available.
Treating this as a successful operation, turn a CMV into a +1 MV.
Trie node representing a sequence of unsigned integer indices.
Trie of stored locations.
Tries to evaluate the integer constant of a value.
Tries to infer stream type based on getsockopt() values.
Tries to optimize a given apply instruction if it is a / concatenation of string literals.
Tries to read the contents of the file whose path is specified in m_file.
Tries to remap the location from a previous snapshot to the latest one.
Trigger delayed parsing, no need to continue.
Trim exit traces off the front of the log.
Trim leading and trailing underscores.
Trim off anything that follows a non-space character
Trim the completion list to the terminal size.
Trivial and loadable.
Trivial and, in the case of a take, bitwise-takable payloads, can all share the default path.
Trivial case: empty parameter list.
Trivial case: empty string.
Trivial case: if there are no archetypes, just use the canonical type pointer.
Trivial case: no generic arguments.
Trivial case: same type in both cases.
Trivial payloads don't need any work.
Trivial removal of pin/unpin instructions.
Trivial types don't have destructors.
Trivially unmergeable.
True globals (no need for thread safety)
True if CSE is done on high-level SIL, i.e. semantic calls are not inlined / yet.
True if CheckedCastBrJumpThreading::numUnknownPreds is not 0.
True if LICM is done on high-level SIL, i.e. semantic calls are not / inlined yet.
True if a function's signature in LLVM carries polymorphic parameters.
True if a generated accessor needs to be registered as an external decl.
True if a pattern is a wildcard, meaning it matches any value.
True if a type has a generic-parameter-dependent value witness table.
True if analysis has concluded that deshadowing cannot happen.
True if any instructions were changed or generated.
True if temporaries are not created yet.
True if the call site for this callee syntactically has a trailing / closure specified.
True if the discriminator matches the specified element.
True if the given type value is nonnull, and the represented type is NSError / or CFError, the error classes for which we support "toll-free" bridging to / ErrorProtocol existentials.
True if the global stored property requires lazy initialization.
True if the storage is dynamic or imported from Objective-C.
True if the type has known CoreFoundation reference counting semantics.
True if the type, or the referenced type of an address / type, is address-only.
True if the type, or the referenced type of an address type, is / address-only.
True if the value is only valid, because a constant is passed to the callee.
True if the value is valid, i.e. could be evaluated to a constant.
True if there's a non-empty intersection of the two stack slot intervals.
True if this constructor delegates to a peer constructor with self.init().
True if this is a completely unapplied super method call
True if we shouldn't complain about problems with this conformance / right now, i.e. if methods are being called outside / checkConformance().
True if we're converting a function parameter, property type, or / function result type, and can thus safely apply representation / conversions for bridged types.
True, if the whole method is alive, e.g. because it's class is visible / from outside.
TrueBB has already been inserted somewhere unless there's a continuation block.
Truncate down to i32 if necessary.
Truncate name to next format code or end of string
Truncated back to the same bits we started with.
Trust an explicit attribute.
Trust that the witness table template already has the correct size.
Trust the explicit attributes.
Try HHVM_REPO_CENTRAL_PATH
Try Repo.Central.Path
Try adding an "e" and look for that as a verb.
Try again, skipping any meta groups like "expr-specific" in case that lets us order
Try all three types of maps, but start with the specified one
Try and construct a FixIt for the argument label.
Try and guess for non-wsdl clients and servers
Try closing the existential, if there is one.
Try consulting the 'class' map first, but don't call the failure callback unless there was an uncaught exception or a fatal error during the include operation.
Try each of the bindings in turn.
Try each of the constraints within the disjunction.
Try grabbing the memory
Try it as a keyword type.
Try larger offsets first to avoid false matches from earlier data that happen to look like strings.
Try looking up a concrete conformance.
Try looking up an enum element in context.
Try lvalue qualification in addition to rvalue qualification.
Try move retains either to the next BB, or the end of this BB.
Try next offsets, in case this match is in the middle of a string.
Try old style class name constructors.
Try open the log file and error if it's not working
Try ordering based on module name, first.
Try performing a dominator-based jump-threading for / checked_cast_br instructions.
Try re-type-checking the expression without the contextual type to see if it can work without it.
Try searching the metadata for a member with the given name.
Try sink a retain as far as possible.
Try some easy cases, then bail back to the general case.
Try splitting a Boolean "Animated".
Try splitting after the last preposition.
Try the special 'swift' substitution.
Try the specific type first.
Try the tuple-to-tuple conversion.
Try to / combine those applies with this partial_apply.
Try to CSE the users of the current open_existential_addr instruction with one of the other open_existential_addr that dominate it.
Try to apply the bridged casts optimizations
Try to apply the string literal concatenation optimization.
Try to authenticate with the newly set credentials, and fake return values to be backwards compatible with previous driver versions.
Try to avoid calling bzero by specializing for these values.
Try to avoid checking for flags, width or precision
Try to avoid making an empty tuple value if it's obviously going to be ignored.
Try to become the writer.
Try to cast the object to the destination existential.
Try to check if the exact dynamic type of the instance is statically known.
Try to claim an argument for this parameter.
Try to classify a conversion from non-existential type / into an existential type by performing a static check / of protocol conformances if it is possible.
Try to classify the dynamic-cast relationship between two types.
Try to classify the implementation of functions that we have local knowledge of.
Try to coalesce the EH regions we create for in those cases.
Try to construct a SILValue for the current LSLocation.
Try to construct a fix it using for-each: Verify that there is only one loop variable, and it is declared here.
Try to consume a bareword.
Try to convert definition into declaration.
Try to convert indirect incoming parameters to direct parameters.
Try to convert the first indirect result to a direct result.
Try to convert the source into the expected ObjC type first.
Try to convert to a pattern.
Try to create a new debug_value from an existing debug_value_addr.
Try to create a select_value.
Try to create an optimized function based on the signature analysis.
Try to create as few aggregated stores as possible out of the locations.
Try to create missing directories on the path of filename.
Try to define a default case for enum_select based on the default case of enum_switch.
Try to delete dead closures.
Try to demangle a child node of the given kind.
Try to derive the concrete type of self and a related conformance from the found init_existential.
Try to derive the concrete type of self from the found init_existential.
Try to derive the type from the copy_addr that was used to initialize the alloc_stack.
Try to derive the type witness.
Try to desugar one level...
Try to determine a hint via the first phi use in the interval.
Try to determine the outcome of the cast from a known type to a protocol type at compile-time.
Try to determine the size of the object we're deallocating.
Try to determine whether text is in some character code we can identify.
Try to devirtualize a witness_method if it is statically possible.
Try to devirtualize the static class of instance if it is possible.
Try to diagnose the first missing type witness we encountered.
Try to dig out the conversion constraint in question to find the contextual result type being specified.
Try to do this in the order in which we needed them, since they can require other protocol definitions recursively.
Try to do this without making cache entries for obvious cases.
Try to emit the given application as initializer delegation.
Try to find a "necessary column".
Try to find a better dominating 'open' for the i-th instruction.
Try to find a clang method declaration for the given function.
Try to find a parent SwitchEnumInst for the current predecessor of BB.
Try to find a property offset for the given key in baseClass.
Try to find a register again.
Try to find a single literal "true" case.
Try to find a tracked free block of a suitable size.
Try to find a type to add this as a static property to
Try to find a unique inout argument in a tuple.
Try to find an element which doesn't exist.
Try to find an overridden entry.
Try to find available values of a set of subelements of the current value, / starting right before the specified instruction.
Try to find if the function have __Native("VariadicByRef")
Try to find it in the cache first.
Try to find the breakpoint's function
Try to find the cached file.
Try to find the conformance of the value type to _BridgedToObjectiveC.
Try to find the contextual type in a variety of ways.
Try to find the init_existential, which could be used to determine a concrete type of the self.
Try to find the location of the 'var' so we can produce a fixit.
Try to find the member.
Try to find the metatype in local data.
Try to find the point where to insert the deallocation.
Try to fold a destroy_addr of a dynamic alloc_stack into a single destroyBuffer operation.
Try to fold the user.
Try to fully unroll the loop if we can determine the trip count and the trip / count lis below a threshold.
Try to get by with floating-point arithmetic.
Try to get codec for encoding
Try to get needed context info.
Try to get the ObjC type which is bridged to source type.
Try to get the ObjC type which is bridged to target type.
Try to get the class name from a LdCls
Try to get the list of substrings and display a warning if failed.
Try to get the size and alignment of this element.
Try to get this table as a constant pointer.
Try to grab needed context information.
Try to grab the breakpoint
Try to handle the builtin at the type level.
Try to handle the command.
Try to hoist all releases, including epilogue releases.
Try to hoist the existing AI again if we move it to another block, e.g. from a loop exit into the loop.
Try to import a macro.
Try to import the superclass.
Try to infer a member function
Try to infer a member variable
Try to infer from containing file name.
Try to infer the type of the constant expression that the user operates on.
Try to inline CPP builtin functions.
Try to insert the property in the map at the next available index.  If the entry already exists, it won't change.
Try to iterate over the tree until we find item with description/mimetype.
Try to keep it such that we do not have to resize the array
Try to link existing specialization only in -Onone mode.
Try to load all libraries until we stop making progress.
Try to load it while we're not holding the lock.
Try to load the dependencies file for this job.
Try to load the first function
Try to load the function from other modules.
Try to load the module.
Try to load the script from the network if script is a URL NB: For security, this will only work in debug builds
Try to look up an existing specialization in the specialization cache.
Try to look up the data handle for it.
Try to look up the state for the first pred BB.
Try to lookup a VTable for Class from the module...
Try to lookup insertion points for this region.
Try to lookup the SILFunction implementation from the VTable.
Try to lookup the cached regex entry, and if successful, just pass back the compiled pattern, otherwise go on and compile it.
Try to mangle the entire name as a substitution.
Try to map the value of a select_enum directly to an int type with a simple cast from the tag value to the result type.
Try to match a cond_fail on "XOR , (SLE Start, End), 1".
Try to match the derived requirement.
Try to open the module documentation file.
Try to open the module file first.
Try to open the output file.
Try to optimize string concatenation.
Try to parse a compound name.
Try to parse the string literal as an Objective-C selector, and complain if it isn't one.
Try to perform cast optimizations.
Try to perform the cast to the destination type, producing an optional that indicates whether we succeeded.
Try to perform the propagation.
Try to position this field.
Try to preserve the PatternBindingDecl structure.
Try to print a comment from Clang.
Try to print as a reference to the static type so that we will get a USR, in cursor info.
Try to print user-visible types if they are available.
Try to produce a specific error message about the inout use.
Try to propagate them to find out the real substitutions required to invoke the method.
Try to provide a decent diagnostic.
Try to put a new TypeCheckData into the map.
Try to put the constant in a position that can get imm-folded.
Try to read a file list file.
Try to read more data.
Try to receive finished events without blocking.
Try to recover if we've made any progress.
Try to remove StrongUnpinInst if its input is available.
Try to remove the cond_fail based on previous overflow checks.
Try to replace the first pointer operand.
Try to replace the second pointer operand.
Try to resolve the behavior to a protocol.
Try to resolve the dependent member type to a specific associated type.
Try to resolve the type witness via this value witness.
Try to resolve the witness via defaults.
Try to resolve the witness via derivation.
Try to resolve the witness via explicit definitions.
Try to resolve this type witness via name lookup, which is the most direct mechanism, overriding all others.
Try to restore access, modification times if read it.
Try to return the physical register that would coalesce `ivl' with its hinted source.
Try to run single RescheduleWaitHandle from the queue.
Try to satisfy the protocol requirements from the property's traits.
Try to see if enum_switch covers all possible cases.
Try to simplify checked_cond_br instructions using existential metatypes by propagating a concrete type whenever it can be determined statically.
Try to simplify irrelevant details of function types.
Try to simplify the argument
Try to sink identical arguments coming from multiple predecessors.
Try to sink it and move on to the next block.
Try to sink literals that are passed to arguments that are coming from / multiple predecessors.
Try to sink values from each of the arguments to the basic block.
Try to solve for the actual type of the expression.
Try to solve the system with this option in the disjunction.
Try to solve the system.
Try to speed up the trivial case of single release/dealloc.
Try to split outgoing edges of each reachable block.
Try to strip "Mutable" out of a type name.
Try to strip off pointer casts and reference forwarding.
Try to strip off the RCIdentityPreservingArg for IV.
Try to substitute into the base type.
Try to transitively deserialize everything referenced by NewFn.
Try to transitively deserialize everything referenced by this function.
Try to translate the given Clang declaration into a context.
Try to typo correct to a nested type name.
Try to unroll innermost loops.
Try to unwrap implicitly unwrapped optional types.
Try to use a standard function.
Try to use common type layouts exported by the runtime.
Try to use the constraint to remove the overflow check.
Try to use the predecessor edge-value.
Try to use the winner.
Try to use this information to remove other cond_fails.
Try user-provided library search paths first.
Trying to close the active existential, if there is one.
Trying to consume a boxed value without a guess for the inner type.
Trying to consume a value without a precise enough type.
Tune dirty page purging for new arena.
Tuneable horizontal and vertical resolution in dots per inch
Tuple and nominal-type patterns are not themselves directly refutable.
Tuple construction is simply tuple conversion.
Tuple elements are siblings.
Tuple elements must match.
Tuple instructions have two different syntaxes, one for simple tuple types, one for complicated ones.
Tuple lengths and elements match
Tuple representations are limited outside of function inputs.
Tuple types are ABI-compatible if their elements are.
Tuple types are default-initializable if all of their element types are.
Tuple types are subtypes of their optionals
Tuple value witness tables are instantiated by the runtime along with their metadata.
Tuple-to-scalar conversion.
TupleType if we are visiting a tuple.
Tuples are ABI compatible if their elements are.
Tuples are also represented as structs.
Tuples are lowered elementwise.
Tuples depend on their elements.
Tuples do not alias non-tuples.
Tuples don't have compound-name members.
Tuples don't have member types.
Tuples need to have their component types substituted by these / same rules.
Tuples preserve variance.
Turn BOOL and DarwinBoolean into Bool in contexts that can bridge types losslessly.
Turn a param list into a symbolic and printable representation that does not / include the types, something like (_:, b:, c:)
Turn an OptionalTypeKind into an index into one of the caches.
Turn any debug-info-only function declarations into zombies.
Turn block pointer types back into normal function types in any context where bridging is possible, unless the block has a typedef.
Turn it into a block pointer.
Turn off commits, because we don't want systemlib to get included
Turn off debugging while parsing other modules.
Turn on optimizations and remove all runtime checks.
Turn on stack traces for coredumps
Turn on the store bit at the block which the stack slot is deallocated.
Turn the error into an ErrorProtocol value.
Turn the formal SIL parameters into IR-gen things.
Turn the layouts into C++ code, writing to the specified ostream.
Turn the next flag on.
Turn the parameter clause into argument and body patterns.
Turn the pointer into an address.
Turn the subexpression into an rvalue.
Turn this also into an index_addr.
Turn this into a computed property.
Turn this into a computed variable.
Turn this into a stored property with trivial accessors.
Turning on the genset and killset can be costly as it involves querying the AA interface.
Turns on the Xenon Surprise flag for every thread via a lambda function passed to ExecutePerThread.
Turns the argsList linked list of TypeAnnotation into a positioned static array.
Twelve of these alternating 29-30 day months gives a year of 354 days, which is about 11 1/4 days short of a solar year.
Two allocations of a mutable array struct cannot reference the same / storage after modification.
Two arrays can generally be the same even if they aren't the same SSATmp, because we might have loaded it from more than one place, and we have linear chains in array modification instructions.
Two boxed cells can generally refer to the same RefData.
Two calls are necessary to properly initialize the stayopen flag in glibc.
Two reasons for converting a try_apply to an apply.
Two variants of each instruction are generated.
Two-byte-character lead-byte followed by a trail-byte.
Type Expansion Analysis.
Type Parsing and AST Building
Type aliases are always defined at top-level scope, so they're not allowed to reference "self" or "parent" (and "static" is already disallowed by the parser, so we don't need to worry about it here).
Type aliases don't have requirements themselves.
Type aliases may not have an underlying type yet.
Type arguments cannot be optional.
Type assertions can't currently handle Init-ness.
Type check a function body (defined with the func keyword) that is either a named function or an anonymous func expression.
Type check a parameter list.
Type check any var decls in the initializer.
Type check each VarDecl that this PatternBinding handles.
Type check each of the subexpressions in place, passing down the contextual type information if we have it.
Type check hoisting moves type checks higher up in the CFG, allowing the check's type information to be used by more instructions.
Type check the argument first.
Type check the body of each of the function in turn.
Type check the body of the getter and setter.
Type check the constructor parameters.
Type check the destination first, so we can coerce the source to it.
Type check the expression.
Type check the function declaration, treating all generic type parameters as dependent, unresolved.
Type check the function subexpression to resolve a type for it if possible.
Type check the function that contains the expression.
Type check the generic parameters, treating all generic type parameters as dependent, unresolved.
Type check the getter declaration.
Type check the parameters and return type again, now with archetypes.
Type check the type parameters in an UnresolvedSpecializeExpr.
Type checking listener for for-each binding.
Type checking listener for pattern binding initializers.
Type checking must be deferred until IRGen so Builtin.isUnique can be called from a transparent generic wrapper (we can only type check after specialization).
Type constants with the low bit set are already resolved and can be returned after masking out that bit.
Type doesn't have a builtin comparison operator because the ordering is rather arbitrary and application dependent.
Type expansion analysis.
Type failures in here will generally not cause type failures in the 'catch' clauses.
Type implementation for fixed-size but non-loadable tuples.
Type implementation for loadable tuples.
Type implementation for non-fixed-size tuples.
Type info for error existentials, currently the only kind of boxed / existential.
Type of the actual function to be called with substitutions applied.
Type of the actual function to be called.
Type of the argument list, if knowable.
Type of the user-provided expression for LookupKind::ValueExpr / completions.
Type parameters are statically opaque.
Type should be bound unless it's type erased.
Type should be loadable
Type specialized comparison operators
Type substitution preserves structural type structure, and the type-of-reference is only different in the outermost structural types.
Type sugar for arrays.
Type sugar for dictionaries.
Type visitor doesn't handle unresolved types.
Type-check an entire function body.
Type-check each top-level input besides the main source file.
Type-check paren patterns by checking the sub-pattern and propagating that type out.
Type-check the 'do' body.
Type-check the body of the loop.
Type-check the body statements.
Type-check the case blocks.
Type-check the cast as a condition.
Type-check the clause body.
Type-check the constructor declaration.
Type-check the destructor declaration.
Type-check the expression.
Type-check the for-each loop sequence and element pattern.
Type-check the initializer, then flag that we did so.
Type-check the initializer.
Type-check the protocol conformances of the enum decl to instantiate its derived conformances.
Type-check the protocol conformances of the struct decl to instantiate its derived conformances.
Type-check the raw values of the enum.
Type-check the subject expression.
Type-check the type parameter.
Type-check this conditional case.
Type-indices are handed out on a per indexed type basis.
Type-scanners are never generated for countable types, it is assumed their scanners will be hand-written.
TypeAliasDecls need to be mangled.
TypeBase*'s are not necessarily unique, but name mangling is too expensive to do every time.
TypeExpr's are relabeled by CSGen.
TypeExpr's that produce the same metatype type are identical.
TypeInfo for dynamically-sized enum types.
TypeInfo for fixed-layout, address-only enum types.
TypeInfo for loadable enum types.
TypeSourceSets are merged a join points by unioning the type sources.
TypeSubstCloner, SILClonerWithScopes, and SILCloner desperately need refactoring and/or combining so that the obviously right things are happening for cloning vs.
Typecheck the function.
Typechecking arrays can blow up the stack currently.
Typed GEPs do not use pointers.
Typed access based TBAA only occurs on pointers.
Typedef declarations might be CF types that will drop the "Ref" suffix.
Types and properties can only have nullary names.
Types are local or metatype members.
Types are not instance members.
Types cannot be defined in a protocol extension.
Types don't have compound names.
Types imported by Clang don't need this, because we can synthesize it later.
Types in this set should not be processed by this pass anymore.
Types never refer to 'Self'.
Types supported by PHP 7 scalar type RFC
Types that cannot be mapped into Swift, and probably won't ever be.
Typically called between requests in non-RepoAuthoritative mode when function renaming is enabled.
Typically this is achieved by using a class_method instruction, which performs an indirect invocation.
Typically this will be called by HPHP::Extension::moduleInit to load an extension-specific systemlib file, or to load the main systemlib.
Typically, we do have a type-checked AST when trying to infer the types of unresolved members.
Typo correction is handled in a later pass.
U+FDD0...U+FDEF are also reserved
U8_APPEND_UNSAFE updates dstPosBytes.
U8_NEXT would increment
U8_NEXT would increment this
U8_NEXT() advances sourceBytePos by 1-4 each time it's invoked.
U8_NEXT() is guaranteed to advance sourceOffset by 1-4 each time it's invoked.
UDateTimePatternConflict
UDateTimePatternField
UNumberFormatAttribute
UNumberFormatPadPosition
UNumberFormatRoundingMode
UNumberFormatStyle constants
UNumberFormatTextAttribute
URIs don't have an include path
URL-based units are not currently cached in memory, but the Repo still caches them on disk.
USRs aren't supposed to reflect implementation differences like stored vs.
UTF-16 surrogate pair values are not valid code points.
UTF-8 decoding finishes successfully.
UTF8 can encode these, but they aren't valid code points.
Ubuntu 14.10's editline does not include the wide character entry points needed by the REPL yet.
Ugh, the statement below creates a new object and adds it to an array...
Ugly, but behavior is different for serialize
UiThreadProc - entrypoint for UI thread.
Ultimately, the only thing that can interfere / with make_mutable is a retain of the array.
Un-disable builtin wrapper
Un-escape escaped single quotes.
Unalign the native stack.
Unambiguous top level decls.
Unary operators also include prefix/postfix.
Unbias by subtracting one.
Unblock parents and possibly take fast path to resume parent.
Unblocked after notification.
Unbound generic type can override a method from a bound generic class, but this unbound generic class is not considered to be a subclass of a bound generic class in a general case.
Unchecked casts are free.
UncheckedTakeEnumDataAddr is additionally a mutation.
UncheckedTakeEnumDataAddr is safe to apply to Optional, because it is a single-payload enum.
Uncommon case: after calling the return hook, follow the slow path.
Uncommon, asked for more than 64 chars worth of precision
Unconditional deprecated.
Unconditional unavailability.
Unconditional unavailable.
Unconditionally destroy existing arrays -- possible dirty data
Unconstrained protocol extensions are always usable.
Uncounted are not ref counted but will be deleted at some point.
Uncurry the arguments in calling convention order.
Undefined behavior, so we might as well constant propagate whatever we want.
Undefined hues always match...
Under the assumption that input will be rounded nearest, mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.
Under these conditions if x is loadable then we can even load the given value and pass it as a scalar instead of an address.
Under these conditions, the call can neither / mutate the array nor save an alias for later mutation.
Undo effects of setting up yytext.
Undo the NUL-termination kindly provided by process() but leave at least one byte to look at
Undo the allocation of propVec
Undo the effects of YY_DO_BEFORE_ACTION.
Undocumented, but Zend returns false for streams where fstat is unsupported
Unflag ourselves as waiting.
Unfortunate collision with access control keywords.
Unfortunate special case for Systemlib units.
Unfortunately program_functions.cpp was not at all written with this in mind.
Unfortunately there's not much that can be done about this, but we want to catch it quickly so that we can try to work around it.
Unfortunately we cannot always detect this, but we can for certain cases.
Unfortunately, Clang's getMethodFamily() never / considers a method to be in a special family if its result / doesn't satisfy isObjCRetainable().
Unfortunately, MSVC doesn't support computed gotos, so use a switch instead.
Unfortunately, PHP returns "NULL" (upper case) for gettype().
Unfortunately, due to generator delegation, this can be pretty far back...
Unfortunately, it needs a work array to hold the best-distance-so-far for each histogram cell (because the inner loop has to be over cells, not colormap entries).
Unfortunately, it's at a different offset in various OSes, so try multiple offsets.
Unfortunately, not a good way to detect this.
Unfortunately, the uses being valid / doesn't mean that the memory is actually initialized on all paths leading to / a release.
Unfortunately, there is no initialization order guarantees for the statically and globally constructed objects.
Unfortunately, there's no way to do the equivalent of dlopen() on data within another file, or even in memory.
Unfortunately, we can't actually get to the end of the token without using the Lex library, which would be a layering violation.
Unfortunately, we can't check this invariant until we get to IRGen, since the AST and SIL don't know anything about type layout.
Unfortunately, we can't rely on either depTy or type actually being the marked witness type in the generic signature, so we have to ask the generic signature whether the types are equal.
Unfortunately, we don't have any of that data.
Unfortunately, we don't have enough info to add the attribute to DeclAttributes.
Unicode escapes of various lengths.
Unify to a common ancestor if possible.
Uninit is folded to init.
Uninitialize the current state.
Union fields should only be available indirectly via a computed property.
Union in the effects of doing the set if the array was empty.
Union operations are guaranteed to be commutative, so if there are two non-None stags, we have to consistently choose between them if we're going to keep one.
Unique inline locations.
Unique the given set of type variables.
Unique the type string into an identifier since PrintLiteralString is building an AST around the string that must persist beyond the lifetime of PrefixString.
Uniquing set to catch symbol name collisions.
Unit contents to check: o bc o lines o UnitLitStr table o UnitArray table o UnitSourceLoc table o Classes o Functions
Unix Standard tar archive
Unknown - Something potentially crazy is going on here.
Unknown accessor kind.
Unknown connection string option
Unknown drilldown cases that need pointer type
Unknown encode/decode
Unknown identifier data, which this version of the compiler won't use.
Unknown index kind, which this version of the compiler won't use.
Unknown input kind, possibly for use by a future version of the module format.
Unknown metadata record, possibly for use by a future version of the module format.
Unknown metadata sub-block, possibly for use by a future version of the module format.
Unknown operator kind.
Unknown options record, possibly for use by a future version of the module format.
Unknown record, possibly for use by a future version of the module format.
Unknown requirement kind.
Unknown sub-block, possibly for use by a future version of the API notes format.
Unknown sub-block, which this version of the compiler won't use.
Unknown target, Non-Zero LB: We don't know where the store is going, but we can account for balancing the possibly-new pointer.
Unknown top-level block, possibly for use by a future version of the module format.
Unknown xref path piece.
UnknownCppException class
UnknownCppException object
Unless CHECK_ALL_PREFIX_DIRS is defined, we save the directory of the last file tested -- any common prefix should exist.
Unless its guaranteed to be all position independent, its "fixups" should have been passed into a relocate call earlier.
Unless the class is abstract, this must exist at this point or the bytecode is ill-formed.
Unless the client has disabled them, perform syntactic checks on the expression now.
Unless there were bad matches, prefer camel case matches.
Unless we called ArrayObject::offsetExists, there's nothing more to do.
Unless we go through this branch, the string was just freshly created, so the following mutation will be safe wrt its internal hash caching.
Unless we have fallback at the highest level, print a diagnostic when we fail
Unless we're always supposed to consume the input, release the input if we need to now.
Unless we're always supposed to consume the input, retain the object because the witness takes it at +1.
Unless we're compiling multiple modules at once, or if the other module re-exports this one, it shouldn't be possible to have a dependency from that module on anything in this one.
Unless we're looking at a nonmutating existential member.
Unless we've already done this, retypecheck the specified child of the / current expression on its own, without including any contextual / constraints or the parent expr nodes.
Unless we've already done this, retypecheck the specified subexpression on / its own, without including any contextual constraints or parent expr / nodes.
Unless we've already stopped, send the shutdown message
Unless you know an array can't cow, you don't know if the TRef will stay a TRef or turn back into a TInitCell.
Unlike DefInlineFP it does not load the SpillFrame, which we hope to push off the main trace or elide entirely.
Unlike UnsafeRefBitCast, this also supports raw pointers and words.
Unlike a usual LICM algorithm, we don't need to iterate to identify the invariant code.
Unlike opaque / existentials, a class existential does not need to store type / metadata as an additional element, since it can be derived from the / class instance.
Unlike opening code completion, this is not a semantic request.
Unlike other declarations, extensions can be used without referring to them by name (they don't have one) in the source.
Unlike static variables, there can be multiple definitions, but we'll only take the first information we see.
Unlike the Java version, we truncate from the end of the string, rather than the beginning.
Unlike the above, this only searches the already loaded ones.
Unlike the above, we might be calling down to a subclass that is not related to the current instance.
Unlike the canonical Linux implementation, this does not distinguish between whether we wanted real seconds or CPU seconds -- you always get real seconds.
Unlike the non-ref case, we don't need to do anything to the stack/local because any load of the box will be guarded.
Unlike with assignment expression below, nothing needs to be added to the scope's constant table
Unlikely case is we end up having to check whether the first byte of the string is equal to '0'.
Unlikely for a function to return a value despite throwing an exception, but if it did, I suppose we would have to clean up here
Unlikely: shifting by a negative amount.
Unlink and redirect the outgoing pointsTo edge.
Unlink backward pointers.
Unlink the outgoing defer edges.
Unlink the predecessors and redirect the incoming pointsTo edge.
Unlink this instruction from its current basic block and insert it into / the basic block that Earlier lives in, right after Earlier.
Unlink this instruction from its current basic block and insert it into / the basic block that Later lives in, right before Later.
Unlock a mutex. A return value of 0 indicates success
Unmanaged references are plain pointers with extra inhabitants, which look like thick metatypes.
Unmanaged types have the same spare bits as managed heap objects.
Unnamed bitfields are just for padding and should not inhibit creation of a memberwise initializer.
Unnamed entities cannot be found by name lookup.
Unnamed locals are segregated (they all come after the named locals).
Unnamed parameters don't require any storage.
Unnamed parameters must be written as "_: Type".
Unordered and unknown values are not allowed.
Unowned parameters are only guaranteed at the instant of the call, so we must retain them even if we're in a context that can accept a +0 value.
Unowned types have the same extra inhabitants as normal pointers.
Unpack and handle nontrivial payloads.
Unpack our extra tag bits, if any.
Unpack our inner payload, if any.
Unpack the extra bits, if any.
Unpause the polling thread when we leave the command loop.
Unpinning takes responsibility for the +1 handle.
Unprocessed assigns just lower into assignments, not initializations.
Unqualified lookup can find operator names within nominal types.
Unqualified lookup case.
Unreachable blocks don't matter to the analysis.
Unreachable code could result in a null return here.
Unregister our options so they don't interfere with the command line parsing in CodeGen/BackendUtil.cpp.
Unregister request-specific wrapper
Unregister request-specific wrappers entirely
Unregister the top-level function emitter.
Unresolved member syntax '.Element' forms an EnumElement pattern.
Unresolved member: find the resolved overload.
Unresolved/Anonymous ClosureExprs are common enough that we should give them tailored diagnostics.
UnresolvedType is a placeholder for an unknown type used when generating diagnostics.
UnresolvedTypes propagated their unresolvedness to any witnesses.
Unroll 1 to 3 byte UTF-8 sequences, use loop to handle longer ones.
UnsafeMutablePointer can be converted from an inout reference to a scalar or array.
UnsafePointer can also be converted from an array or string value, or a UnsafePointer or AutoreleasingUnsafeMutablePointer.
Unserialize happens in the request thread where we can allocate smart pointers Use this opportunity to marshal the saved data from persistent data structures into per-request data.
Unset InsertPt so we remove retain release pairs instead of performing code motion.
Unset does define intermediate dims but with slightly different rules than sets.
Unset the state local in order to correctly fall through any future finally blocks
Unsettable storage decls always produce rvalues.
Until IE's user base drops to nill or problem is fixed this code must remain enabled for all systems.
Until SILDebugScopes are properly serialized, bare functions are allowed to not have a scope.
Until perflab can automatically scale the values we give it to an appropriate range, we have to fudge these numbers so they look more like reasonable hardware counter values.
Until that point, we have to bail because ImportDecl won't be able to re-map this.
Until the job actually starts once we receive the headers we don't need to register a pending onComplete()
Until the rest of the pipeline can handle it without regressing, try to not break tracelets in the middle of new minstr sequences.
Until then, only promote to a heap object dest.
Until then, we hack the mapping here.
Until this is fixed, we need to / also hash the ArgNo here.
Until we do not remove any instructions or have nested increments, decrements...
Until we hit the last '_' in our specialization info...
Until we no longer have a type node, keep demangling.
Until we reach the top of the class hierarchy...
Until we see the code completion token, collect identifiers.
Until, either ArrayObject moves to HNI or a special case is added to reflection unset should be turned off.
Unused closure class.
Unused sequence length.
Unused tag bits in the physical size can be used as spare bits.
Unused, to keep memory and peak_memory the same size
Unwinding of C++ exceptions proceeds as follows:  - Discard all PHP exceptions pending for this frame.
Unwinding proceeds as follows:  - Discard all evaluation stack temporaries (including pre-live activation records).
Unwrap ObjC class objects.
Unwrap UnresolvedPatternExprs.
Unwrap a value of a wrapped integer type to get at the juicy / Builtin.IntegerN value within.
Unwrap an inout type.
Unwrap any specializations, constructor calls, implicit conversions, and '.'s.
Unwrap closures with explicit capture lists.
Unwrap implicitly indirect types and types that are passed by reference only at the SIL level and below.
Unwrap one level of optionality from each.
Unwrap optionals, but remember that we did.
Unwrap single element structs.
Unwrap the original optional value.
Unwrap zero or more metatype levels
Upcast to a superclass.
Upcasting doesn't require type metadata.
Update AsmState accordingly.
Update BC markers on the main trace to use the parentFP, parentFP relative offsets, and the call SrcKey
Update FP's in all blocks reachable from the exit heads
Update HHBC mappings for the TransDB.
Update HHIR mappings for AsmInfo.
Update Loop Information - we know that this block is now in the current loop and all parent loops.
Update SILDeclRef to point to the right Decl.
Update SSA form for values that are used outside the region.
Update SSA form for values used outside of the copied region.
Update SSA of use with the available values.
Update UnhandledOnceCallee and InitializerCount by going through all "once" / calls.
Update UnhandledOnceCallee and InitializerCount by going through all "once" calls.
Update `inl' and return the region if it's inlinable.
Update `m_blocks' vector.
Update `region' based on the optimization result in `blockData'.
Update a lookup table with members from newly-added extensions.
Update all branch instructions in the predecessors to pass the new argument to this BB.
Update all original uses by the new value.
Update all servers with user, password and dbname
Update all the servers
Update any indexes into the actual stack that pointed to or past this element.
Update based on these conformances.
Update bcOff here so any guards or assertions from metadata are attributed to this instruction.
Update block succ to either use the FP from pred, phi the FP from pred with FPs of other predecessors, or define a new FP.
Update checksum -- must be after transform to avoid fouling up last message block
Update constants to their real values and sync some runtime options
Update context for start of inlining.
Update cookies in memory
Update current value with the converted value.
Update dominance info.
Update dominator information
Update haveUnfulfilledParams, because we may have fulfilled some parameters above.
Update it if possible.
Update it in the ForwardSetIn of the / current basic block.
Update it in the MaxAvailForwardSet of the / current basic block.
Update it in the genset and killset of the / current basic block.
Update keys to location in realloc'd buffer
Update linkage for global addressors to make it pass verifier.
Update m_pos, now that compaction is complete
Update marker to ensure newly-pushed value isn't clobbered by DecRef.
Update names and locations.
Update native stack pointer.
Update next free element.
Update number of bits
Update our internal state for this being gone.
Update our own cache to match.
Update outside used instruction values.
Update outside used phi values.
Update result to point to relocated reference.
Update semantic info for open editor documents of the same module.
Update stats for boxes
Update strong iterators now that compaction is complete.
Update the "largest" statistics if this system is larger than the previous one.
Update the "result" variable above.
Update the BlockState based on the given instruction.
Update the SILLinkage here if this is a definition.
Update the SrcKeys used in fixup maps to be relative to the Func* in the live ActRec.
Update the active and inactive lists for the start of `current'.
Update the aggregate alignment
Update the aggregate size
Update the alternate declaration as well.
Update the argument label and base name.
Update the base's location with the new array.
Update the best score we've seen so far.
Update the cache and return.
Update the callee information for this function.
Update the callees for each method of a given class, along with / all the overridden methods from superclasses.
Update the callees for this method and all the methods it overrides by adding this function to their lists.
Update the callsite information for the callee.
Update the callsite to pass in the correct arguments.
Update the caption if there are any formatted strings in it.
Update the class extents on the new metadata object.
Update the condition with the backedge count.
Update the current DeclContext to be the closure we're about to recurse into.
Update the current funcd, if we have a new one.
Update the current sandbox in the current machine.
Update the depth accordingly.
Update the dominator tree after rotating the loop.
Update the dominator tree.
Update the edited line range.
Update the element type.
Update the entry now that we've resolved the declaration.
Update the entry now that we've resolved the macro.
Update the genset and kill set.
Update the hash with the compiler version.
Update the hashtable to reflect the fact that everything was moved over one position
Update the instructions that touch the memory.
Update the last instruction to consider when looking for ARC uses or decrements in predecessor blocks.
Update the last known number of sections to scan.
Update the linkage of shared functions/globals.
Update the lists of all conformances to remove superseded conformances.
Update the locations with available values and their values.
Update the locations with available values.
Update the lookup table to introduce members from extensions.
Update the max store set for the basic block.
Update the method type with the new result type.
Update the numbers if we change CapCode::Threshold
Update the output set.
Update the overload set.
Update the owner to reflect inheritance here.
Update the parent fields in the instructions.
Update the predecessors / successors if things change
Update the predicted type for `l'.
Update the recorded requirement source when a new requirement / source provides the same requirement.
Update the replica set name in the parsed "servers" struct so that we can consistently compare it to the information that is stored in the connection hashes.
Update the requirement source appropriately.
Update the single-swift-refcounted check, unless we already ruled that out.
Update the size and alignment of the aggregate..
Update the stack depth if we didn't set it yet for the block.
Update the string pointer to point just after the number read.
Update the top of stack with the rough conservative approximate of the intersection of stackT and tcT
Update the type appropriately.
Update the type for `l' as a result of an operation that might change the value.
Update the type for `l' to reflect a possible change in the value---but when we don't have that value.
Update the type for `l' to reflect new information that we've obtained from guards, assertions, or the like.
Update the types of parentheses around the tuple expression.
Update the value (and type) for `l'.
Update to record all explicit and inherited conformances.
Update to record all potential conformances.
Update use counts and def instructions for to-be-added instructions.
Update use counts for to-be-removed instructions.
Update values for this accessor kind.
Update various other metadata
Update vmfp() and vmFirstAR().
Update: I talked with Cokus via email and it won't ruin the algorithm
Updates `j' to refer to the same instruction after the code insertions.
Updates the breakpoint list in the proxy with the new list received from the client.
Updates the dominator tree with the cloned blocks.
Uploaded file exceeded MAX_FILE_SIZE
Uploaded file exceeded upload_max_filesize
Upon return both will converted to KindOfNull anyway.
Upper bound for this type variable.
Uppercase the first letter, append the rest.
Usage: (gdb) call phpbreak("idx") (gdb) continue
Use "__ObjC" as default for implicit decls.
Use "admin" as the default db if none selected yet.
Use 86ctor(), since no program-supplied constructor exists
Use AFDT to synchronously shut down the old server's satellites so we can take their ports using accept.
Use Appending linkage so it doesn't get optimized out.
Use Builtin.NativeObject just as a stand-in.
Use BytesPtr to avoid a range check subscripting on the StringRef.
Use InOutExpr to convert it to an explicit inout argument for the receiver.
Use IsObject() before using this method.
Use OneTypeOneOperand layout where the field number is stored in TypeID.
Use Optional(nullptr) to represent more than one.
Use POD value witnesses for operations that do an initializeWithTake.
Use POD value witnesses.
Use RValue's forward-into-initialization code.
Use SILOneOperandLayout to specify the function type and the function name (IdentifierID).
Use SILOneOperandLayout to specify the type and the literal.
Use SILOneOperandLayout.
Use SILOneTypeValuesLayout.
Use SILOneTypeValuesLayout: the type is for condition, the list contains value for condition, hasDefault, default basic block ID, a list of (Value ID, BasicBlock ID).
Use SILOneTypeValuesLayout: the type is for condition, the list has value for condition, hasDefault, default basic block ID, a list of (DeclID, BasicBlock ID).
Use SILOneTypeValuesLayout: the type is for condition, the list has value for condition, result type, hasDefault, default basic block ID, a list of (DeclID, BasicBlock ID).
Use SILOneTypeValuesLayout: the type is for condition, the list has value for condition, result type, hasDefault, default basic block ID, a list of (Value ID, Value ID).
Use SILOneTypeValuesLayout: the type is for condition, the list has value for condition, result type, hasDefault, default, basic block ID, a list of (Value ID, Value ID).
Use SILOneTypeValuesLayout: type, Attr, SILDeclRef (DeclID, Kind, uncurryLevel, IsObjC), and a type.
Use SILOneTypeValuesLayout: type, Attr, SILDeclRef (DeclID, Kind, uncurryLevel, IsObjC), and an operand.
Use SILOneValueOneOperandLayout.
Use SILTwoOperandsLayout: type, (DeclID + hasOperand), and an operand.
Use TRC of the storage rather the current TRC when walking this function.
Use Tarjan's strongly connected components (SCC) algorithm to find / the SCCs in the call graph.
Use Type::findIf() to walk the types, finding type variables along the way.
Use UnqualifiedLookup to look through all of the imports.
Use a SmallPtrSet to make sure only emit a particular candidate once.
Use a builtin to produce a zero initializer, and assign it to self.
Use a fixed offset if we have one.
Use a generic DOMNode as fallback for now.
Use a given cdecl name for native-to-foreign thunks.
Use a hash of the basename of the source file as our discriminator.
Use a key with non-zero span, because otherwise a key right at the base of a range will be treated as before the range (bad) rather than within it (good).
Use a non-implicit attribute so it shows up in the generated interface.
Use a null decl to represent the module.
Use a priority queue keyed on dominator tree level so that inserted nodes are handled from the bottom of the dom tree upwards.
Use a random location.
Use a scope to ensure that any temporary stack allocations in the subexpression are immediately released.
Use a set of ad hoc rules to tell whether we should run a pessimistic / one iteration data flow on the function.
Use a slightly smaller number to allow for a few compiler-allocated temporary stack slots.
Use a special IR type for passing block pointers.
Use a specialized diagnostic if we couldn't find any such member.
Use a stand-in conformance for a type that looks like a metatype value if the metatype can be bridged.
Use a temporary QWebPage to load the JSON configuration in this Object using the 'configurator' above
Use access specifiers from the declarations, if possible.
Use addr2line to get line number info.
Use alloc_ref to allocate the object.
Use alloc_ref_dynamic since we should only ever get here in ObjC protocol extensions currently.
Use an 'Ordinary' reference kind so that the reference may resolve to any unary or binary operator based on context.
Use an array to initialize the Map only when all the following conditional are met: 1.
Use an array to initialize the Set only if all the following conditional are met: 1.
Use an index-based loop because new owners can come in as we're iterating.
Use an iterative data flow to compute whether there is an available value at a given point, we do not yet care about what the value is.
Use as many args as specified
Use branch information for eliminating condfails.
Use custom function to get replacement string and its length.
Use default glob semantics
Use depth-first recursion to get the output order correct.
Use depth-first recursion to output the most deeply nested stack frame first.
Use different rules for types imported from C.
Use dirty hacks to reconstruct the BB from the 'self' pointer of the trait.
Use find_if instead of remove_if since we know there can only be one match in the vector.
Use flag for each registers.
Use information of a stack cell.
Use it as the initializer for an anonymous constant.
Use it if `len' can often be large enough to require cap code encoding.
Use lambdas wrapping the ctype.h functions because of linker weirdness on OS X Mavericks.
Use machine dependent bytes of input
Use matchCallArguments to determine how close the argument list is (in shape) to the specified candidates parameters.
Use memcpy for large numbers of properties.
Use memcpy if that's legal.
Use moduleLoad() for settings that are system-wide and cannot change per request (e.g. PHP_INI_SYSTEM)
Use non-specialized release call so ArrayTracer can track its destruction
Use our own map to find it and answer the question.
Use parse_url - if it returns false, we return NULL
Use protected visibility for public symbols we define.
Use relaxed memory order because we don't need memory barriers.
Use sizeof(double) bytes of input
Use sizeof(float) bytes of input
Use special representation for special protocols.
Use specialized emitters for SIL builtins.
Use strcspn instead of strpbrk because the latter doesn't report when it's terminated due to a null byte in haystack in any manageable way.
Use strcspn instead of strpbrk because the latter doesn't report when its terminated due to a null byte in haystack in any manageable way.
Use the "constructor prefix" heuristic from Maranget to pick the necessary column.
Use the "name" to delete only the right one, otherwise all of them.
Use the Apple System Log facility.
Use the Clang importer to mangle a Clang declaration.
Use the ForwardValIn as we are currently processing the basic block.
Use the ObjC entry point
Use the SILGen name only for the original non-thunked, non-curried entry point.
Use the SM to figure out the actual line/column of a SourceLoc.
Use the StackPromoter as a wrapper for the function.
Use the VAX insv instruction to insert each code in turn.
Use the `self` space we skipped earlier if it's time.
Use the address of the c_Generator object as a tag for this stepping operation, to ensure we only stop once we're back to the same resumable.
Use the alias name (the "Ref" name), only.
Use the apply instruction as the retain.
Use the appropriate map according to the object type's linkage.
Use the archetype's parent relationship first if possible.
Use the attributes and calling convention from the static definition if we have it.
Use the child node value if the child is alive.
Use the clang type for the receiver type.
Use the common basic header info to make the image object.
Use the constant's underlying value as its raw value in Swift.
Use the context generic parameters of the original declaration.
Use the copy constructor if no clone() function was supplied.
Use the current array key to give a little help in the log message
Use the current offset to form the this pointer for the method call.
Use the data flow results, come up with places to insert the new inst.
Use the declaration name if we still have that sugar.
Use the declaration's availability for the context when checking the bodies of its accessors.
Use the dynamic thunk if dynamic.
Use the end address of the last instruction range to assign an empty range to this element.
Use the extra inhabitants mask from the payload.
Use the first InputAction as our BaseInput.
Use the first Job's BaseInput as our BaseInput.
Use the first string label which references a registered type.
Use the first successor as the base condition.
Use the generated 86ctor.
Use the generic parameters from the substituted type.
Use the generic type parameter types for an unbound generic type.
Use the header from the transport if it is available
Use the inline buffer.
Use the length of the non-empty identifier.
Use the lowered return type of the foreign getter.
Use the magic __getInstanceSizeAndAlignMask method if we can see a declaration of it
Use the mangled name of the protocol to lookup the partially deserialized value from the default witness table list.
Use the most significant result from the arguments.
Use the name of the action to determine what it is:
Use the name of the given witness table to lookup the partially deserialized value from the witness table list.
Use the non-repr external type, but reuse the TypeLoc printing code.
Use the parsed guard expression if possible.
Use the pointer not the obj
Use the pointer/pointer and pointer/int casts if we can.
Use the property accessors if the variable has accessors and this isn't a direct access to underlying storage.
Use the raw type for the debug type, but the storage size from the enum.
Use the remangler to generate a mangled name from the type metadata.
Use the row pattern, if it has one.
Use the runtime to allocate a box of the appropriate size.
Use the runtime to dynamically switch.
Use the runtime to initialize dynamic cases.
Use the same code that was in the REPL code to track the indent level  for now.
Use the saved index if applicable.
Use the singleton element's storage type if fixed-size.
Use the singleton param info we prepared before.
Use the start location for the ReturnKind.
Use the string instance we created above.
Use the subexpression as the function.
Use the sugared version of the type, if there is one.
Use the timer group as a semaphore.
Use the type as bridged to Objective-C unless the element type is itself a collection.
Use the type of the enum from context.
Use the type of the individual varargs argument, not the overall array type.
Use the type of the method we were type-checked against, not the type of the overridden method.
Use the type witness.
Use this as a base to replace values in current function with their leaf values.
Use this as a general "out of stream" error
Use this bit as a payload tag bit.
Use this for commenting out debug-print statements.
Use this if the `len' is expected to be small.
Use this special diagnostic if it's actually a reference type but just isn't Optional.
Use threadInit() for settings that can change per user request (e.g., PHP_INI_ALL, PHP_INI_USER)
Use type lowering to lower the copyaddr into a load sequence + store sequence appropriate for the type.
Use typedefs we set up for SIMD vector types.
Use typo correction to find the best matches.
Use userspace rand() function because it handles auto-seeding
Use xsi:type if it is defined
Use zend_strtod() instead of strtod() here since JSON specifies using a '.' for decimal separators regardless of locale.
Used by __construct for Vector and ImmVector Used by addAll for Vector only
Used by include_impl.
Used during enum raw value checking to identify duplicate raw values.
Used during enum raw value checking to identify the source of a raw value, / which may have been derived by auto-incrementing, for diagnostic purposes.
Used for arrays, where we compute the layout once, but want to insert it for the number of elements in the array.
Used for auto completion.
Used for calculating the start of the next period.
Used for static_assert.
Used for the allocateSpillSpace() pass which inserts the instructions that create spill space on the stack.
Used locally for exec options
Used only when debugging GIF compression code
Used to be m_pendingJump, but that's been removed.
Used to check for discarded expression values: in the REPL top-level / expressions are not discarded.
Used to create an initial state before we merge in other / predecessors.
Used to deserialize entries in the on-disk Objective-C method table.
Used to deserialize entries in the on-disk decl hash table.
Used to deserialize entries in the on-disk func hash table.
Used to deserialize the on-disk globals-as-members table.
Used to determine if we can add branch-over edges by checking the pre-conditions of the successor block.
Used to find the last uses of partial_apply, which is need to insert releases/destroys of temporaries as early as possible.
Used to limit the / size for stack promoted objects.
Used to provide unique names to ObjC categories generated by Swift / extensions.
Used to serialize the on-disk Objective-C method hash table.
Used to serialize the on-disk decl hash table.
Used to serialize the on-disk func hash table.
Used to test SimplifyCFG::simplifyArgs with sil-opt.
Used to test critical edge splitting with sil-opt.
Used to test splitBBArguments with sil-opt
Used to track how many times a given function has been (partially) optimized by the function pass pipeline in this invocation.
Used to walk the code string
Used to walk the replacement string
Useful for pushing an Objective-C type through swift.
Useful for the xdebug_call_* functions.
Useful only for detecting the presence of the pprof/symbol endpoint.
Useless copies of address-only types look like this:
Useless copies of references look like this:
User defined/internal
User did not import the library module that contains the type we want to substitute.
User-provided base type for LookupKind::Type completions.
UserAttributes are stored exclusively on the PreClass.
UserFile, to match Zend, should not call stream_close() unless it was ever opened.
Users typically don't want to specify these parameters.
Uses SILOneTypeValuesLayout.
Uses of inout argument values are lvalues.
Uses of values with lvalue type produce their rvalue.
Uses the client to send this command to the server, which will update its breakpoint list with the one in this command.
Uses the provided Builder to insert a try_apply at the given / SILLocation and generates control flow to handle the rethrow.
Uses the rules above.
Using "Objective-C Garbage Collection" as the key here is a hack, but LLVM's object-file emission isn't general enough to collect arbitrary keys to put in the
Using Variant so exceptions will decref them
Using YYLLOC is tempting, but would change the location of the lookahead.
Using declarations are not imported.
Using eager vmreganchor for all helper calls is a perf regression.
Using macro to commonlize vasms lowering
Using sbrk to ensure its in the bottom 2G, so we avoid the need for trampolines, and get to use shorter instructions for tc addresses.
Using static instance
Using the basename makes the discriminator invariant across source checkout locations.
Using the new protocol, so variables contain only names.
Using the new protocol.
Using the object address here could interfere with a moving GC algorithm.
Using the object address here would interfere with a moving GC algorithm.
Using the results of this analysis, we can add to the lower bound of some must-alias-sets when we see loads from locations that are known to be balanced at that program point.
Using this function is equivalent to adding your key to apc_prime.so.
Using this module, you can emit pretty much any sort of not trivially-illegal bytecode stream, and many trivially-illegal ones as well.
Using this static empty mixed array allows us to always assume data() is non-null, and it is better than calling MakeReserveMixed because it avoids doing any allocation.
Usually called outside of the lock.
Usually llvm can eliminate this code again because the user's safety check should be constant foldable on llvm level.
Usually needs to flush buffer.
Usually nodes have few predecessor nodes and the graph depth is small.
Usually zero, but sometimes a very low number.
Utilities for reporting errors to stderr, system console, and crash logs.
Utility class for building values that contain witness tables.
Utility class for performing universal layout for types such as / tuples, structs, thick functions, etc.
Utility functions to make the template solveDataFlow compilable for a block list containing references _and_ a list containing pointers.
Utility to just extract the kind field from an arbitrary Header ptr.
V is the incoming value for the SILArgument A on at least one path.
VALID RANGE  Although this software can handle dates all the way back to the year 1 (3761 B.C.), such use may not be meaningful.
VALID RANGE  These routines only convert dates in years 1 through 14 (Gregorian dates 22 September 1792 through 22 September 1806).
VAX exponent range is so narrow we must worry about overflow here...
VIRTUALPIXELMETHOD constants
VPXEncode: Takes a Y, U, V data buffers (with color components U and V subsampled to 1/2 resolution) and generates the VPX string.
Valid if the corresponding boolean is true
Valid journal_mode values: delete, truncate, persist, memory, wal, off.
Valid pointers are 8-aligned, so test the low 3 bits.
Valid synchronous values: 0 (OFF), 1 (NORMAL), 2 (FULL).
Validate 'static'/'class' on functions in extensions.
Validate 'static'/'class' on properties in nominal type decls.
Validate availability spec list, emitting diagnostics if necessary.
Validate raw video data
Validate that everything's still okay.
Validate that the 'mutating' bit lines up for getters and setters.
Validate that the contextual type conforms to ArrayLiteralConvertible and figure out what the contextual element type is in place.
Validate that we used the right decl.
Validate the argument tuple elements as nominal type pattern fields.
Validate the behavior protocol and all its extensions so we can do name lookup.
Validate the capture list.
Validate the contents of any referenced nominal types for SIL's purposes.
Validate the context.
Validate the contextual type conforms to DictionaryLiteralConvertible and figure out what the contextual Key/Value types are in place.
Validate the declaration.
Validate the generic argument.
Validate the generic arguments and capture just the types.
Validate the generic parameters for the last time.
Validate the generic type parameters.
Validate the generic type signature.
Validate the given pattern binding declaration.
Validate the mutating attribute if present, and install it into the bit on funcdecl (instead of just being a DeclAttribute).
Validate the nominal type declaration being extended.
Validate the opcode name, and do opcode-specific parsing logic based on the opcode we find.
Validate the parameters.
Validate the parent type.
Validate the representation.
Validate the requirement.
Validate the result type, if present.
Validate the resulting type.
Validate the subscript or property because it might not be type checked yet.
Validate the type of this inherited clause entry.
Value is on the stack.
Value is potentially in the ExtraArgs/VarEnv.
Value member lookup has some hacks too.
Value parameter pointers can't alias or be captured.
Value type metadata only requires dynamic initialization on first access if it contains a resilient type.
Value types hold the parent metadata as a far relative indirectable pointer.
Value types only have allocating initializers.
Value users - this happens if we start with a value object in V.
Value uses are generally safe.
Value witness methods for an arbitrary trivial type.
Value witnesses are (predominantly) functions that implement the basic operations for copying and destroying values.
Value-to-optional and optional-to-optional.
Value-type elements (anything other than objects and resources) of an immutable collection "inherit" the collection's immutable status.
ValueIsPHI - Check if the instruction that defines the specified register / is a PHI instruction.
ValueUses records the uses of CopySrc in reverse order.
Values are in reverse order since they come from the stack, which grows down.
Values for TAG_PHOTOMETRIC_INTERPRETATION
Values imported / from Clang can also appear in any module.
Values of mode other than 0-9 are treated as mode 0.
Values should be the same
Var doesn't affect the type.
VarDecl constants require an explicit kind.
VarDecls are popped before we see their TypeRepr, so if we pass the token nodes now they will not change from identifier to a type-identifier.
VarDecls are walked via their NamedPattern, ignore them if we encounter then in the few cases where they are also pushed outside as members.
VarDecls get added / to this when the declaration is seen.
VarEnv is attached to eval or debugger frame, other than the current frame.
VarEnvs are allocated with req::make, so they aren't first-class heap objects.
Variable name might not exist.
Variable scope so that goto doesn't cross definitions
Variable to guarantee that fallback exceptions have been initialized early.
Variable used in pseudomain
Variable/function/subscript requirements.
Variables are imported as...
Variables for Floyd-Steinberg dithering
Variables for accumulating image statistics
Variables in this set should not be processed by this pass anymore.
Variables might be stored or computed.
Variables must have materializable type, unless they are parameters, in which case they must either have l-value type or be anonymous.
Variables, null if unused.
Variadic arguments handled below.
Variadic arguments never contribute to 'rethrows'.
Variadic bit must match.
Variadic bits must match.
Variadic capture params don't need types because they'll be treated as Arrays as far as HNI is concerned.
Variadic capture params don't need types since they'll be Arrays as far as HNI is concerned.
Variadic parameters can be unfulfilled.
Variadic tuple elements match the rest of the input elements.
Variadic tuples are not permitted.
Variant of the above used in constructor failure paths.
Various minstr opcodes that take a PtrToGen in src 0, which may or may not point to a frame local or the evaluation stack.
Various standard witness table for tuples.
Various types that we want to do something interesting to after / importing them.
Vars are simply lvalues of their rvalue type.
Vector instruction helpers
Vectors are VecNxT, where "N" is the number of elements and T is the element type.
Vectors that we use to sort our local successor/predecessor indices to make our output deterministic.
Verification utilities.
Verify class name before passing it to __autoload()
Verify common invariants.
Verify consistency of all of the nodes in the graph.
Verify declarations without names everywhere.
Verify imported modules.
Verify metatype uses.
Verify noescape parameter uses.
Verify some basis structural stuff about an instruction's operands.
Verify source ranges if the AST node was parsed from source.
Verify stack depth along all control flow paths
Verify that / its uses are ok.
Verify that a default witness table follows invariants.
Verify that a global variable follows invariants.
Verify that a purpose was specified if a convertType was.
Verify that a vtable follows invariants.
Verify that a witness table follows invariants.
Verify that all created non trivial values are array values and that they are released before mutation.
Verify that all of our uses are in this function.
Verify that all of the constraints in the constraint system are accounted for.
Verify that all of the variable were assigned exactly once.
Verify that all types match the overload filter.
Verify that any expected fix-its are present in the diagnostic.
Verify that it isn't the super.init marker that failed.
Verify that meth has at least as many parameters as imeth.
Verify that method is not abstract within concrete class.
Verify that none of the class properties are TBottom, i.e. any property of type KindOfUninit has been initialized (by 86pinit or 86sinit).
Verify that our type variable map/vector are in sync.
Verify that the adjacency map/vector haven't gotten out of sync.
Verify that the constraint graph is valid.
Verify that the constraint map/vector haven't gotten out of sync.
Verify that the encoded size is as expected.
Verify that the encoding was actually minimal.
Verify that the extra inhabitant representations are consistent.
Verify that the field type is valid as an outlet.
Verify that the information still exists.
Verify that the list of all archetypes matches what we would derive from the generic params.
Verify that the loop variable is invariant inside the body.
Verify that the member types haven't gotten out of sync.
Verify that the mutating bit is correct between a protocol requirement and a witness.
Verify that the optionality of the result type of the initializer matches the failability of the initializer.
Verify that the pragma had the desired effect.
Verify that the submodule exists.
Verify that the type variables are either representatives or represented within their representative's equivalence class.
Verify that the typehints for meth's parameters are compatible with imeth's corresponding parameter typehints.
Verify that the types match up.
Verify that there are no diagnostics (in MemoryBuffer) left in the list.
Verify that there is no non_condbr critical edge.
Verify that this method came from this module.
Verify that this use does not otherwise allow the alloc_box to escape.
Verify that we don't have a static function.
Verify that we don't have label shadowing.
Verify that we've checked types correctly.
Verify the SourceFile.
Verify the classification and string.
Verify the file and line of the diagnostic.
Verify the file to be extracted is actually in the zip file
Verify the module, if required.
Verify the set of cases we dispatch on.
Verify the set of enum cases we dispatch on.
Verify the static initializer.
Verify the validity of the current character as a base-2 digit.
Verify there was only a single predecessor to ContBB.
Verify type layout if we were asked to.
Verify warn_unqualified_access uses.
Verify we don't have both mutating and nonmutating.
Verify we have a single integer or pointer type.
Verify we have a single integer, floating point, or pointer type.
Verify we have enough data to match magic type
Version 1 of this command means we want the names of all variables, but we don't care about their values just yet.
Version 2 of this command means we're trying to get the value of a single variable.
Version 3.31 of the file command considered a file to be ASCII if each of its characters was approved by either the isascii() or isalpha() function.
Version components can't be empty.
Version, Passes, and Digest Length
Very similar with the above case: handles MemoryRef and Immed, but also stores the result in the memory.
Very slow on a palette destination.
View takes ownership.
Virt is the block containing the slow virtual call.
Virtual Hosts have to be iterated in order.
VirtualHost acquires global mutexes in its constructor, so we allocate s_default_vhost lazily to ensure that all of the global mutexes have been initialized before we enter the constructor.
Visit all blocks in a predictable order, hopefully close to topological.
Visit all blocks reachable from the entry block of the function.
Visit all instructions of the current block.
Visit all nodes in the defer web, which don't have the right pointsTo set.
Visit all of the inherited types.
Visit all of the nominal types we know about, discovering any others we need along the way.
Visit all of the potential archetypes.
Visit all the instructions, looking for apply sites.
Visit any var decls in the initializer.
Visit each function referenced by the VTable.
Visit each non-terminator arc relevant instruction I in BB visited in reverse...
Visit each of the generic parameters.
Visit each of the members.
Visit each of the requirements, adding them to the builder.
Visit each of the types in the inheritance list to find protocols.
Visit each one of our predecessor regions and see if any are blocks that can use reference counted values.
Visit each retain/release that is matched up to our operand over and over / again until we converge by not adding any more to the set which we can move.
Visit edges that have an unprocessed from() block if we walk the blocks in a RPO.
Visit every instruction and modify its Vreg operands to the physical register that was assigned.
Visit every virtual-register typed operand in `unit', and rename it to its assigned physical register.
Visit in source order.
Visit nested potential archetypes.
Visit now, so we can both eval LTR and assign LTR.
Visit only SubstitutableTypes, skipping DependentTypes.
Visit param conformance
Visit part of a type, such as the base of a pointer type.
Visit the bridging header's lookup table.
Visit the closure itself, which produces a function type.
Visit the lookup tables.
Visit the loop nest hierarchy bottom up.
Visit the next successor.
Visit the protocols in the order we established.
Visit the protocols inherited by this protocol, adding them as implied conformances.
Visit the protocols referenced by the given type, which was / uttered at the given location.
Visit the sub-expression.
Visit the subexpression.
Visit the top-level expression generating constraints.
Visit the type of the capture, if it isn't a class reference, since we'd need the metadata to do so.
VisitNodeFunction gets used for Function, Variable and Allocator:
Visitor class for renaming registers.
Visitor class to determine if a metatype should use the empty / representation.
Visitor class to format the operands of a Vinstr.
Visitor class to set the WasAbstract flag of any MetatypeTypeRefs / contained in the given type.
Visitor for Defs and Uses used to compute liveness information.
Visitor that determines the memory behavior of an instruction relative to a / specific SILValue (i.e. can the instruction cause the value to be read, / etc.).
Visits a SIL Function and generates LLVM IR.
Visits a requirement type to match it to a potential witness for / the purpose of deducing associated types.
Visits defs of an instruction, updates their liveness, adds live ranges, and adds Uses with appropriate hints.
Visualize the Unicode string
Void pointers aren't usefully indirectable.
Vptr struct supports fancy x64 addressing modes.
Vregs that are constants or have forced registers (e.g. VmSp) are skipped.
W before a vowel, else dropped
WARNING: Anything you put in this function will only be run when the VarDecl is fully type-checked within its own file.
WATCH OUT: unlike php5, a Mode is not necessarily a bit mask.
WBMP ---- WBMP Level 0: B/W, Uncompressed This implements the WBMP format as specified in WAPSpec 1.1 and 1.2.
WBMP Type 0: B/W, Uncompressed bitmap
WH becomes H, WR becomes R W if followed by a vowel
WITH_FB_MEMORY_PROFILING
WIter* instructions may leave the value locals as either refs or cells, depending whether the rhs of the assignment was a ref.
Wagner All rights reserved.
Wait 10 times to give it a chance on especially overloaded computers.
Wait for VMs to shutdown
Wait for a resonse from the user
Wait for a response from the client
Wait for a response from the client.
Wait for a socket event.
Wait for all threads.
Wait for commands from the debugger client and process them.
Wait for consumers to finish.
Wait for it to finish.
Wait for one to be ready (in any context).
Wait for pending external thread events...
Wait for sem 1 to be zero .
Wait for server ack before closing pipe.
Wait for the notification that semantic info is available.
Wait for the pid to be set.
Wait for the server socket thread to stop running
Wait for the server to actually start
Wait on socket availability with a timeout  Returns: 0 on success -1 on failure, but not critical enough to throw an exception 1..
Wait until all of our producer threads have finished.
Wait until all of our threads have finished.
Wait until all of our workers threads have finished.
Wait until polling thread gets the memo and exits.
Wait until the main thread is ready to join us.
Wait until the second pass, when all the raw value expressions can be checked together.
Wait until this thread is the one this proxy wants to debug.
Wait until we've processed all the forward predecessors before looking at the Phi node.
Waits until this thread is the one that the proxy considers the current thread.
Wakeup the sandbox thread so it will notice the stopped flag
Walk a member reference expression, checking for availability.
Walk all dom tree children of Root, inspecting their successors.
Walk an assignment expression, checking for availability.
Walk an expression condition normally.
Walk an inout expression, checking for availability.
Walk backwards deleting instructions that should be safe to delete in a block that ends with unreachable.
Walk backwards from an unsafeGuaranteedEnd builtin instruction looking for a / release on the reference returned by the matching unsafeGuaranteed builtin / ignoring releases on the way.
Walk backwards in BB looking for last use of the value.
Walk backwards in BB looking for strong_release or dealloc_box of the given value, and add it to Releases.
Walk backwards in BB looking for the last use of a given value, and add it to the set of release points.
Walk down the dominator tree inside the loop, removing redundant checks.
Walk down to the base NormalProtocolConformance.
Walk each of the entries.
Walk each parameter's decl and typeloc and default value.
Walk forward looking for a release of ArrayLoad or element of ArrayUserSet.
Walk from the terminator up the BB.
Walk into all the catch clauses.
Walk into parenthesized expressions to update the subexpression.
Walk into tuples to update the subexpressions.
Walk our ancestor expressions looking for the appropriate place to insert the RebindSelfInConstructorExpr.
Walk our input, determine what kind of poll() operation is necessary for the descriptor in question, and put an entry into fds.
Walk over the blocks, and compare the new block's exnNode path to the active one.
Walk over the function and find all the locations accessed by this function.
Walk the Dom tree in search of a defining value:
Walk the TypeRepr to find the type in question.
Walk the arrays of base classes until they match.
Walk the base expression to ensure we erase any existentials within it.
Walk the base in a getter context.
Walk the blocks in rpo.
Walk the checked initializer and contextualize any closures we saw there.
Walk the expression to associate labeled arguments.
Walk the expression, generating constraints.
Walk the function expression, which should produce a reference to the callee, leaving the final curry level unapplied.
Walk the given basic block to find all the epilogue releases.
Walk the given expression in the member access context.
Walk the inheritance hierarchies of all of the protocols.
Walk the initializers for all properties declared in the type with an initializer.
Walk the list of diagnostics, pulling out any fixits into an array of just them.
Walk the members of any context that can have nested members.
Walk the parents of the specified expression, handling any ClosureExprs.
Walk the pattern, to check to see if any of the VarDecls included in it have storage.
Walk the post-dominator tree from the query block down, building the set of blocks that the given block is control-dependent on.
Walk the stack and find any return address to jitted code and bash it to the appropriate RetFromInterpreted*Frame helper.
Walk the type recursively to look for substitutions we may need.
Walk the type to see if we have any archetypes that are *not* open existentials and that aren't type-erased.
Walk the type tree to find the a sub-type who's convertible to the found nominal.
Walk the updates backwards and "undo" them.
Walk the use list of the pointer, collecting them into the Uses array.
Walk the use list of the pointer, collecting them.
Walk them manually here so that they end up as child nodes of enum case.
Walk through all of the archetypes in the generic parameter lists, matching up their conformance requirements with those in the
Walk through and promote all of the alloc_box's that we can.
Walk through non-binding patterns.
Walk through the arguments, determining if any were bound to parameters out-of-order where it is not permitted.
Walk through the destination expression, resolving what the problem is.
Walk through the given block, undoing any fallbackcc/bindjcc optimizations that happen in an area where spill space is live.
Walk through the operand list and delete any random instructions that will become trivially dead when this instruction is removed.
Walk through the reachable blocks and erase any preds that weren't found.
Walk through the variables list and account for all points where copies or spills need to be made.
Walk to the inherited class or protocols.
Walk up m_classVec for both classes to look for a common ancestor.
Walk up the context stack to find the topmost applicable context.
Walk up the dom tree until we reach the same loop nest level.
Walk up the dominator tree looking for a range check ("SLE Start, End").
Walk up through the chain of current contexts.
Walk up through the type scopes to find the context where the type declaration was found.
Walking the C++ stack doesn't work in simulation mode.
Walks an expression sub-tree, and collects information about expressions / whose types are mutually dependent upon one another.
Walks through address projections and (optionally) collects them.
Walks up from a potential callee to the enclosing CallExpr.
Warn about 'try' expressions that weren't actually needed.
Warn about any property access in the getter.
Warn about stores in the setter, but allow loads.
Warn if nothing threw within the body, unless this is the implicit do/catch in a debugger function.
Warn if we reach a return inside a noreturn function.
Warn on tuple splat, which is deprecated.
Warning to rewrite it to _ is more annoying than it is useful.
Warnings are currently sampled.
Was a change made while running the optimization.
Was inFile, but won't be anymore.
Was not able to remove this branch.
Waste one element of value and location stack so that they stay on the same level as the state stack.
Watson  Cygwin has a compat layer in place and does its own core dumping, so we still call setrlimit for core dumps
Watson to make a crash dump.
We "freeze" (i.e. do not attempt to remove or move) such releases if / FreezeOwnedArgEpilogueReleases is set.
We "know" that we're inside a ParenExpr, because ParenExprs are required by the syntax and locator resolution looks through on level of them.
We *do* allow these if they are escaped with backticks though.
We / could for example store an NSArray array struct on top of the array.
We / handle this by doing some lookahead in common situations and emitting a / diagnostic with a fixit to add wrapping parens.
We / leave those connections in place for our parent loop to fix up.
We / only do this if the destination BBs have only the switch enum as its / predecessor.
We / remove these back edges and instead represent them as unknown control flow / edges.
We / simplify each argument recursively one step at a time.
We accomplish this with req nodes at level 2 for all asets that could be boxed before we see builtin calls (we could do it only to the ones that could be args, but we don't bother).
We achieve that by *intentionally* creating the object on heap and never delete it.
We actually know that any other type will fail causing us to side exit but there's no easy way to optimize for that
We add 1 to the cap, to make it use up all the memory to be allocated, if the original cap has been maximized.
We add a pointer to an error function.
We add it at a specific spot to get it in before any accessors, which SILGen seems to want.
We add the "_Tt" prefix to make this a reserved name that will not conflict with any valid Objective-C class or protocol name.
We add the MONGO_NODE_STANDALONE and MONGO_NODE_MONGOS here, because that's needed for the MULTIPLE connection type.
We added the sizes of all members of the group to the group leader.
We allocate these expressions on the stack because we know they can't escape and there isn't a better way to allocate scratch Expr nodes.
We allow OptionalToBoolean fixes with an opened type to refer to the Boolean conformance.
We allow a type to conform to a protocol that is less available than the type itself.
We allow it here so that emitted code is valid.
We allow strong on optional-qualified reference types.
We allow the right operand of the conditional operator to begin with 'try' for consistency with the middle operand.
We allow the use of clases from nullable objects because emitPropSpecialized() explicitly checks for null (when needed) before doing the property access.
We already checked operands and types.
We already consumed self, but there may be subsequent loads if the call to 'super.init' or 'self.init' involves instance variables.
We already emitted a diagnostic about the bridging header.
We already found the destination node through another path.
We already had an entry for this bool value.
We already handled the block.
We already have this requirement.
We already merged these two types, so this constraint is trivially solved.
We already parsed the right operand as part of the 'is' production.
We already processed it.
We already provided a definitive completion--nothing else to do.
We already visited the children.
We also Compute the max store set at the beginning of the basic block.
We also add the threaded and edge block to the worklist now that they (likely) can be simplified.
We also assume all the locals in the mayReadLocalSet must be added to the live local set, and don't remove anything from it.
We also assume that the partial apply does not capture any addresses.
We also can only cache these values if the Func* and Class* can't be deallocated, so this is limited to:
We also can't store `msg' directly on the object as it'll be freed after the result() method returns.
We also decrement ArgOffset since we have one less argument now.
We also do not handle indirect results currently in the closure so make sure that does not happen at this point.
We also do not want to emit diagnostics for code that was transparently inlined.
We also do this when the thread is at PSPEnded because the thread is done.
We also don't want to change the convention of the original closure.
We also don't want to enumerate it.
We also ensure that nativeDataWakeup is invoked regardless of whether or not serialized native data exists within the serialized content.
We also give up for array initializations.
We also have to check the method declaration's accessibility.
We also have to constrain the sources for Check instructions, and we share this codepath for that purpose.
We also have to invert to match PNG's convention in which 255 is opaque.
We also insert retains here at the location of the original closure.
We also know the new function can't be static, because the last one wasn't.
We also make an exception for main, which, albeit it does not have a Swift name, does appear prominently in the source code.
We also need to drop all references if instructions are allocated using an allocator that may recycle freed memory.
We also need to look up the types of use vars from the index.
We also need to open-code if the witness is defined in a protocol context because IRGen won't know how to reconstruct the type parameters.
We also need to pass it indirectly.
We also need to release the partial_apply instruction itself because it is consumed by the apply_instruction.
We also need to visit the index expressions as loads though.
We also only /want/ to do it if the Check is guaranteed to be executed in the loop body (assuming another hoistable Check doesn't fail).
We also printed it first, just in case one of the detailers wanted to segfault.
We also refuse to have name-only resolutions of enums, so that all name only resolutions can be treated as objects.
We also support nullable objects for the base.
We also suppress in script mode (where setting the minimum deployment target requires a target triple).
We also treat it as loading an entire ActRec-sized part of the stack, although it only loads the slot containing the Func.
We also use a box for delegating constructors, since the delegated-to initializer may also replace self.
We always create generic type parameters with a depth of zero.
We always emit an access function for conformances, and in principle it is always possible to just use that here directly.
We always have at least one entry.
We always have bounds checks for the default, so it doesn't count against the case limit.
We always merge right into left, so scan-only should be merged into no-scan-only.
We always need a continuation block because we might fall out of a catch block.
We always need a default block if the enum is resilient.
We always need a different success block.
We always need to reset the insertion point in case we delete the first instruction.
We always need two end-of-buffer characters.
We always report the dependencies, even if the hash is known.
We always set the low bit to indicate this is a Swift class.
We always tell them that they can silence the warning with an explicit type annotation (and provide a fixit) as a note.
We always unroll the final `kNumFreeLocalsHelpers' decrefs, so only loop until we hit that point.
We always want these methods to be cloned with new funcids in subclasses so we can burn Class*s and Func*s into the translations
We analyze the body of globalinit_func to see if it can be statically / initialized.
We appear to benefit from odd numbers.
We append our own newline so ignore any newlines in the msg.
We are about to go back to translated code, check whether we should stick with the interpreter.
We are about to modify header names for the SERVER variable.
We are about to translate something known to be blacklisted by debugger, exit early
We are abusing the fact that a block can only be a local successor.
We are adding an edge between two pointers which point to different content nodes.
We are allowed to assume the type annotation on the property is accurate, although nothing is currently checking that this is the case.
We are allowed to see through exactly one "partial apply" instruction or one "thin to thick function" instructions, since those are the patterns generated when using auto closures.
We are applying generic parameters to a generic type.
We are being conservative here since we could make this more general by allowing for intervening non-arg releases in the sense that we do not allow for race conditions in between destructors.
We are being more conservative than most likely necessary.
We are busy whenever we are actively serving a request
We are conservative in the case of / multiple open_existential_addr.
We are conservative in the face of / having multiple init_existential_addr.
We are conservative, / any instruction that may write the size of an array (ie.
We are currently emitting code for '_convertFromBuiltinIntegerLiteral', which will call the builtin and pass it a non-compile-time-const parameter.
We are doing the actual DSE.
We are done once the current projection dominates the insert point.
We are duplicating the header instructions into the end of the preheader.
We are either casting between address-only types, or cannot promote to a cast of reference values.
We are either removing everything or nothing.
We are emitting a case in a finally epilogue, therefore skip the current try region and start from its parent
We are essentially using this optional to represent 3 states: true, false, and n/a.
We are getting the element type from a compound type.
We are going to add a new check instruction in front of the Load.
We are going to bluntly remove these instructions.
We are going to check conformance once we hit commit_to_conversions below, but we have to add a token restriction to ensure we wrap the metatype value in a metatype erasure.
We are going to mess with Tok to do reparsing for interpolated literals, don't lose our 'next' token.
We are going to produce an error on all unreachable instructions not eliminated by DCE.
We are going to reuse the TO-WMI, so make sure it dominates the call site.
We are guaranteed to have an ini file given how m_configFileName is set above
We are ignoring generic functions and functions with out parameters for now.
We are just doing this to avoid extending lifetimes across php calls, which currently always leads to spilling.
We are not allowed to do load promotion in an escape region.
We are not freeing *rp itself, as that's not always a pointer
We are not going to transfer ownership of obj to the iterator, so arrange to decRef it later.
We are not in a loop.
We are not interested in handling that case anyways.
We are not moving epilogue releases.
We are not trying to handle this case here, so simplify by just bailing if we detect it.
We are not verifying anything here.
We are now either at the end of the string, or at / where the dbname starts.
We are only dealing with options that have a - in them.
We are only interested in the latter case and want to ignore the setup code.
We are only interested in types implementing protocols.
We are only invalidating the analysis that we use internally.
We are only invoking ::fixup() from contexts that were known to be called out of the TC, so this cannot happen.
We are only simplifying cases where all predecessors are unconditional branch instructions.
We are passing the packed registers to asyncRetCtrl unique stub, which expects both rType and rData to be i64 regs.
We are performing dynamic lookup.
We are reallying on C++11's guaranteed of thread safe static variable initialization.
We are running as a subcommand, try to find the subcommand adjacent to the executable we are running as.
We are storing the rdSrc value into the static, but we don't need to inc ref it because it's a bytecode invariant that it's not a reference counted type.
We are therefore ready to move on.
We are transferring ownership of the array to the iterator, therefore we do not need to adjust the refcount.
We are updating SSA form.
We are using the write lease + whether the code is already smashed to determine which thread should free the SmashLoc---after getting the lease, we need to re-check if someone else smashed it first.
We are working on an architecture that supports 64-bit integers since php is 32 bit by design, we bail out with warning
We aren't allowed to pass aliased memory to 'in', and we have pass at +1.
We aren't allowed to promote loads in blocks reachable from an escape point.
We aren't in that business here, so we don't need to record anything.
We assert'd at the top of this function that the metatype cannot be Mixed
We assign local, unique indexes to each thread, with hopes that they are densely packed.
We assign slots greedily, so sort the interface list so the most frequently implemented ones come first.
We assign unique negative ID's to all new blocks---these correspond to invalid TransIDs.
We assume conformances in non-SourceFiles have already been checked for availability.
We assume for performance reasons in repo authoriative mode that we can see all the sets to private properties in a class.
We assume it to be 16 characters (that's what it is in SunOS 5.x and Linux).
We assume ranges are non-overlapping.
We assume that / Start and End are both in the same basic block.
We assume that Start and End / are both in the same basic block.
We assume that Start and End are both in the / same basic block.
We assume that `other', if it represents an SSA variable, is not live at the start of `current'.
We assume that all of our loops have been canonicalized so that /all/ loop exit blocks only have exiting blocks as predecessors.
We assume that cold block take very long to execute.
We assume that right shift corresponds to signed division by 2 with rounding towards minus infinity.
We assume that the importer translates all of the following types directly to structs in the standard library.
We assume that there's no interesting reabstraction here beyond a layer of optional.
We assume that this method always removes one level of pattern and replacing it with its direct sub-patterns.
We assume that we don't have to check if the match starts a new word in the string.
We assume that we've already filled in the class's generic arguments.
We assume that whatever is in the local is dead and doesn't need to be refcounted before being overwritten.
We assume the buffer is at least ndigit long.
We assume the new value is already retained.
We assume the previous credentials will work on this database too, or if authSource is set, authenticate against that database
We assume we're starting from the 'x' in a '0x...' floating-point literal.
We assume writes are partial writes, so the result is always either Read or ReadWrite.
We auto-alias classes only on HH mode.
We automatically hoist a load of the context to the beginning of every region.
We bail out in this case.
We better not have strong iterators associated with uncounted arrays.
We blot them after the loop in order to ensure that we can still find the ends of switch regions.
We break regions at resumed Await/FCallAwait instructions, to avoid duplicating the translation of the resumed SrcKey after the Await.
We cache opened bfd file pointers that in turn cached frame pointer lookup tables.
We cache this because we might repeatedly need the bitcast.
We cache under the unbound type, which should never collide with anything.
We call checkGenericParamList() on all lists, then call finalizeGenericParamList() on all lists.
We call get_server_flags to the maxBsonObjectSize data
We call it *indivisible* because it / cannot be broken down to more LSLocations.
We call iter_advance() without checking if m_pos is the canonical invalid position.
We call the per-callee portion a "prologue."  Also, we are called from two distinct environments.
We called lookupClsMethod with a NULL this and got back a method that may or may not be static.
We came across a try region, need to run a finally block.
We can "take" since the parameter is +0.
We can (and must) hoist cond_fail instructions if the operand is invariant.
We can CSE function calls which do not read or write memory and don't have any other side effects.
We can access the isas of pure Swift classes directly.
We can afford to wait a long time here, since we've already started the dispatcher for this server.
We can also count all of them as redefined.
We can also hit this when code-completing in a closure body.
We can also remove any Persistent Class/Func*'s, and any requires of modules that are (now) empty
We can always capture the storage in these cases.
We can always switch over to using a StringMap.
We can always take from the copy.
We can always trust the dst type of the load.
We can always use the expand map to find stack locations that may alias our class.
We can analyze the class hierarchy rooted at it and eventually devirtualize a method call more efficiently.
We can assume it's by value, because either we're calling a function that doesn't exist (about to fatal), or we're going to an __call (which never takes parameters by reference).
We can assume that loading a const global variable doesn't involve an ownership transfer.
We can assume that the address of Proto does not alias because the calling convention is In or In-guaranteed.
We can assume that this never relocates the metadata because it should have been allocated properly for the class.
We can assume the once predicate is in the "done" state now.
We can assume we are running on at least the minimum deployment target.
We can at least glean the best available static information from the payloads.
We can avoid a re-lookup in the very common case of this being equivalent to the r-value type.
We can be fairly smart here.
We can cast to ObjC existentials.
We can cheat here since we fill in constants a while after runtime options are loaded.
We can claim ownership of the parameter and clean it up when it goes out of scope.
We can compute an upper bound for the size of the result in advance and so we can prepare the buffer we pass to `sha256_crypt_r'.
We can compute an upper bound for the size of the result in advance and so we can prepare the buffer we pass to `sha512_crypt_r'.
We can conditionally cast from NSError to an ErrorProtocol-conforming type.
We can conservatively see through the store
We can consider sharing the header files to avoid this copy-paste.
We can copy-initialize the source over the destination, then primitive-store the zero extra tag (if any).
We can defer to this initialization.
We can directly reuse the address.
We can do a better job here when dependent types are related to their generic signatures.
We can do that particular trick because class instances' metadata have their generic parameters instantiated with real metadata.
We can do this by emitting blocks using a simple walk through the successor graph.
We can do this safely because we are optimistically assuming that all incoming elements in a cycle will be the same.
We can do this unconditionally in a safe way since we are only dealing with cond_br, br.
We can either have a split backedge as our latch terminator.
We can end up here if we have two retains in a row and then a release.
We can end up with them because the solver bails out as soon as it sees a Failure.
We can fold if the value being cast is a constant.
We can forward to this use.
We can get a more precise output type for interpOne if we know all of its inputs, so we still populate the rest of the instruction even if this is true.
We can get back V if our analysis completely fails.
We can get here if we are memory profiling, since we override the normal sync settings and sync anyway.
We can guarantee our own box to the callee.
We can guard on StaticStr but not CountedStr.
We can handle "conflicts" where one form is unavailable.
We can have a loop subregion that has multiple exiting edges from the current loop.
We can have either a store directly to the address or to an index_addr projection.
We can have entries such as UniqueStubs with no SrcKey These are ok to process.
We can have native-to-foreign thunks over closures.
We can have native-to-foreign thunks over global or local native functions.
We can hit this case in specialized functions even for correct user code.
We can hoist address projections (even if they are only conditionally executed).
We can however insert generic loads in the loop pre-header and replace these instructions with AssertTypes.
We can ignore mayTrap().
We can ignore most use kinds here.
We can ignore retains, cond_fails, and dealloc_stacks.
We can ignore the dealloc_stack.
We can in /    the future by introducing alloc_stacks.
We can just borrow the enclosing one if we're in a nested context.
We can just change the Type param of the original check rather than inserting a bunch of control flow.
We can just check the most recent redeclaration, which will inherit any attributes from earlier declarations.
We can just drop Any values.
We can just handle potential users normally, since if we handle the user we already saw a decrement implying that we will treat this like a guaranteed use.
We can just load the cache now.
We can just move forward and recur.
We can just null it out since we're fatalling.
We can just primitive-store the representation for the empty case.
We can kill the frame if all uses of the frame are counted as weak uses.
We can localize the store to an alloc_stack.
We can make it sync for the fp and rip in `context' by putting them in a fake ActRec here on the native stack, and passing a pointer to it.
We can match a prefix so long as everything following the match is a number.
We can match a tuple pattern with a tuple type.
We can match the suffix of the type so long as everything preceding the match is neither a lowercase letter nor a '_'.
We can move this entity to an extension.
We can never consume it.
We can never have associated strong iterators, so we don't need to do anything extra.
We can not build a projection path from the base to the derived, bail out.
We can not find a retain in a block with no predecessors.
We can not move a release above the instruction that defines the released value.
We can not perform the forwarding as we are at least missing some pieces of the read location.
We can not prove the 2 locations do not alias.
We can now convert cond_br(select_enum) into switch_enum
We can now do member-wise comparison of the types within these types.
We can now go back and convert all MergeKind::Class entries to MergeKind::UniqueDefinedClass, and all hoistable classes to their Class*'s instead of PreClass*'s.
We can now remove the cond fail on the increment the above comparison guarantees that the addition won't overflow.
We can nuke the entire location filter here since we'll re-install it when we get back to the old level.
We can omit the payload check if this is the only case represented with the particular extra tag bit pattern set.
We can omit the uninit check for properties that we know may not be uninit due to the frontend's type inference.
We can only allow them / in simple pattern-like expressions, so we reject anything complex here.
We can only break down an associated-type path.
We can only bridge from class or Objective-C existential types.
We can only burn in the Class* if it's unique or in the inheritance hierarchy of our context.
We can only constprop here if we know for sure this is exactly the correct class.
We can only create a value projection from an object.
We can only create an address projection from an object, unless we have a class.
We can only do a good job with the fix-it if we have the whole call expression.
We can only do this for the current thread.
We can only get group information from deserialized module files.
We can only get source orders from deserialized module files.
We can only handle the simple cases of lvalue++ and ++lvalue.
We can only inline at normal FCalls.
We can only move instructions if we know that we are not partial.
We can only optimize settings that are system wide since user level settings can be overridden during the execution of a request.
We can only produce a fixit if we're talking about ++ or --.
We can only project destructively from an address-only enum, so copy the value if we can't consume it.
We can only subtract paths that have the same base.
We can only synthesize implicit constructors for classes and structs.
We can only take the value if the box is a bridged NSError, in which case owning a reference to the box is owning a reference to the NSError.
We can optimize this by localizing the initialization to an alloc_stack and loading from it.
We can potentially convert from an UnsafeMutablePointer of a different type, if we're a void pointer.
We can potentially use the argument as-is if the parameter is bound as a 'let' without cleaning up.
We can process the basic blocks in any order.
We can promote the init_existential_addr allocation into a / dedicated allocation.
We can quickly tell if this object is a collection, which lets us avoid checking for each class in turn if it's not one.
We can reference the canonical metadata for native value types directly.
We can remove the check.
We can represent all integers provided here since getIntegerIndex only returns 32 bit values.
We can return multiple decls, for now, we use the first lookup result.
We can return right away for a truecolor image as deallocating colours is meaningless here
We can rewrite the code to check the condition before entering the loop, and side exit if it fails.
We can safely assume that either VerifyRetTypeC will throw or it will produce a value whose type is compatible with the return type constraint.
We can safely handle anything else as an escape.
We can see all the callees.
We can share a type info for all dynamic-sized heap metadata.
We can share box info for all similarly-shaped POD types.
We can share box info for all single-refcounted types.
We can sink fix_lifetime instructions if there are no reference counting instructions in the loop.
We can skip the catch body, since bounding the result by None is guaranteed to give back None, which leaves our Result unchanged.
We can skip the incref for static closures, which have a Cctx.
We can skip the rest, since their contained Vregs are untyped.
We can stay packed if the index is m_size, and the operation does the same thing as LvalNew.
We can still delete instructions in such cases though.
We can still do something more sophisticated with this.
We can still overflow the stack if there is a loop when using spl_autoload_call directly, but this behavior matches PHP5.
We can store into an AllocStack (but not the pointer).
We can store tags for the empty elements using the inhabited bits with their own tag(s).
We can strip the load that might even occur in the loop because we make sure that no unsafe store to the array's address takes place.
We can strip the module prefix.
We can throw in a weird situation where the ActRec is already on the stack, but this bytecode isn't done executing yet.
We can trivially create substitutions for Array and Optional.
We can uncomment later if we want this feature.
We can unroll a loop if we can duplicate the instructions it holds.
We can use Objective-C generics in limited ways without reifying their type metadata, meaning we don't need to capture their generic params.
We can use any representative ClassInfo for the context class to check this, since the private method list cannot change for different realizations of the class.
We can use the latter to terminate the walk down the dominator tree early.
We can use the payload area with a tag bit set somewhere outside of the payload area to represent cases.
We can use unsafe because we know the codepoint is in valid range and that 4 bytes is enough for any unicode point
We can't add new uses to reference counted types without a more advanced availability analysis.
We can't apply indirect offsets without metadata.
We can't assume anything about external functions.
We can't bridge thin types at all.
We can't build SSA for method values that lower to objc methods.
We can't call mongo_cursor_throw after deregister as it frees up bits of memory that mongo_cursor_throw uses to construct its error message.
We can't call the offsetGet method on `base` because users aren't expecting offsetGet to be called for `isset(...)` expressions, so call the method on the base ArrayObject class.
We can't change the state of an array / through a value use.
We can't clear it here as there is no way to abort the transport and we need to be around to receive any data it may try to send
We can't conditionally take, since UncheckedTakeEnumDataAddr invalidates the enum.
We can't constprop with this eval_cell, because of the effects on locals.
We can't currently handle wrapping so make sure this isn't happening.
We can't define these overrides if we have any uninitialized stored properties.
We can't delete it while it's in use anyway.
We can't delete the object if its destructor has side effects.
We can't do a byte load here---we have to sign-extend since we use `type' as a 32-bit array index to the destructor table.
We can't do bridging here.
We can't do this as we're parsing because we may want to resolve naming conflicts between the things we've parsed.
We can't do this for types within a namespace because namespaces are open and thus we can't force a global numbering of all types within it.
We can't do this on MSVC, it's all debug or all release.
We can't dump any more of the buffer, unfortunately, because we don't keep track of the size.
We can't fix this situation.
We can't form a Hashable conformance if Int isn't Hashable or IntegerLiteralConvertible.
We can't generate direct StLoc and LdLocs in pseudomains (violates an IR invariant).
We can't handle the 'thin' case yet, but it shouldn't really even be interesting.
We can't handle the payload case here due to the flow problems caused by the dependency in between the enum and its data.
We can't handle this as part of the constant folding logic, because there is no value they can produce (other than empty tuple, which is wasteful).
We can't have a phi of two openexistential instructions of different UUID.
We can't import a property if there's already a method with this name.
We can't inherit from a non-class, non-protocol type.
We can't inline FCallArray.
We can't inline external declarations.
We can't just bitcast if there's an error parameter to forward.
We can't just consume it because we're in conditionally-executed code (and because this might be a non-final use).
We can't just put the address of iter_next_cold in the table below right now because we need to get a nullptr into the third argument register for it.
We can't just reference the data in the TemporaryFiles vector because that could theoretically get copied to a new address.
We can't keep a's data, since it contains unknown non-empty arrays.
We can't look at the request locals then, as: 1.
We can't make that assumption about imported ObjC types.
We can't move f over d or we'll clobber the Vptr we need to load from.
We can't move retains before them and they aren't "interesting".
We can't really know this for a fact: even if it started as a "side-exit", real computation could've been moved into the branch.
We can't really test the high-byte regs here because they can't be used any time we have a REX byte.
We can't reliably call such things, so error out.
We can't reliably filter a C enum without additional knowledge that the type has no undeclared values, and won't ever add cases.
We can't rely on GMP's auto-base detection as it doesn't handle cases where a base is specified AND a prefix is specified.
We can't rely on the DeclContext hierarchy climb above because properties do not introduce a new DeclContext.
We can't remove the support bit, and we have no way to account for the reduction in lower bound.
We can't represent this struct completely in SIL anymore, but we're still able to define a memberwise initializer.
We can't return Float80, but we can receive a pointer to one, so switch the return type and the out parameter on strtold.
We can't save the Class* since it moves around from request to request.
We can't set breakpoints in generated functions
We can't simplify this away.
We can't simply forward 'self' because the partial apply is conditional.
We can't simply use (0, object size) because we do not want to include base classes, nor padding which we know can't contain any fields.
We can't sink instructions that may read or write to memory or side effects because it can change the semantics of the program.
We can't take or destroy the value out of the box since it might be shared.
We can't tell if two objects could be the same from here in general, but we can rule out simple cases based on type.
We can't use arr.lvalAt(name), because arr may have been modified as a side effect of an earlier iteration.
We can't use emitClassFieldOffset() here because that creates an invariant load, which could be hoisted above the point where the metadata becomes fully initialized
We can't use parseMatchingToken if we're in just-checking mode.
We can't use the empty type as an index into DenseMap.
We can't use this specialized class without making a guard more expensive, so don't do it.
We cannot add requirements to archetypes from outer generic parameter / lists.
We cannot analyze without target.
We cannot apply the solution with unresolved TypeVars, because they will leak out into arbitrary places in the resultant AST.
We cannot call accessors.
We cannot call operators with a postfix parenthesis syntax.
We cannot catch these errors with SIL verification because they may legitimately occur during code specialization on dynamically unreachable paths.
We cannot close m_file because there may be other threads still writing to it.
We cannot code complete anything here -- we expect an identifier.
We cannot conservatively prove that this instruction cannot decrement the ref count of Ptr.
We cannot construct RelativeDirectPointer instances, so define a "shadow" struct for that purpose
We cannot determine the value for global variables which could be changed externally at run-time.
We cannot devirtualize in cases where dynamic calls are semantically required.
We cannot devirtualize unbound generic calls yet.
We cannot duplicate blocks with AllocStack instructions (they need to be / FIFO).
We cannot express how to forward variadic parameters yet.
We cannot extend sugared types.
We cannot go offline until they are finished as we own their dispatcher and event base.
We cannot handle generic apply yet.
We cannot handle overlapping fixits, so assert that they don't happen.
We cannot handle such cases yet, so bail.
We cannot have additional cases after a default clause.
We cannot import this as an initializer anyway.
We cannot import when the base name is not an identifier.
We cannot just _return_ the operand because it is not necessarily an instruction.
We cannot just serialize a declaration to a shared_external function since shared_external functions still have linkonce_odr linkage at the LLVM level.
We cannot open it, but we were able to stat it.
We cannot override individual accessors.
We cannot override operators as members.
We cannot promote destroys of address-only types, because we can't expose the load.
We cannot shutdown until they stop because we own their dispatcher and event base.
We cannot use ConvObjToBool here because that has special behavior in certain cases, which we do not want here.
We care about whether the parameter list of the callee syntactically has more than one argument.
We changed files in the middle of a scope.
We cheat slightly in the lexer by turning T_ELSE T_WHITESPACE T_IF into T_ELSEIF  This makes the AST flatter and avoids bugs like https://github.com/facebook/hhvm/issues/2699
We check for "not master" error codes.
We check for additional information as well, in the "wnote" property
We check if the value is present as a key in the map.
We checked every other elt of the tuple and did not find any non-trivial elt except for ourselves.
We checked every other field of the struct and did not find any non-trivial fields except for ourselves.
We classify an argument mismatch as being a "near" miss if it is a very likely match due to a common sort of problem (e.g. wrong flags on a function type, optional where none was expected, etc).
We clone methods with static locals into derived classes, but the clone still points to the class the method was defined in (because it needs to have the right context class).
We collected the blocks in reverse order.
We completed the root.
We compute the squared-c0-distance term, then add in the other two.
We compute this ahead-of-time because it has to be encoded as a ULEB128, which is variable size.
We consider a normal class better than an interface, because it might influence important things like method dispatch or property accesses better than an interface type could.
We consider a null byte an invalid sequence.
We consider global functions to be "type level"
We consider incompatible function types to be near so that functions and non-function types are considered far.
We consider it logically const to extend with default-constructed stack values.
We consider it safe to take `pageFreeFactor` percent of cached pages (excluding those used by the current process, estimated to be equal to the current RSS)
We consider it to conform to all protocols, since the intended type might have.
We consider popping an ActRec and args to be synced to memory.
We consider relaxation profitable if there's not a single dominating type that accounts for RuntimeOption::EvalJitPGORelaxPercent or more of the time during profiling.
We consider the "FCall" instruction part of the FPI region, but the corresponding push is not considered part of it.
We consider the current type-matching problem to the "solved" by this addition, because this new constraint will be solved at a later point.
We consider the option of either including the DV funclets in the same region as the function body or not.
We consume refs on a2 and also produce references, so there's no need to inc/dec a2.
We converted the block-end instruction to a different one.
We copy declAttrs into propAttrs for each loop iteration so that we can safely add AttrDeepInit to propAttrs without mutating the original declAttrs.
We could also look at the object type and see if it is known that it can't have a user-defined destructor.
We could also make this configurable if needed
We could avoid a little duplicated work during warmup with more complexity but it's not worth it.
We could be changing the value of any local, but we won't change whether or not they are boxed or initialized.
We could check for specialized objects to see if they don't declare a user-defined destructor, but currently don't.
We could check witnesses that don't involve the failed associated types.
We could compute the action everytime we needed it, but they're stored in this table for memoization.
We could conceivably let you use static memory and have our own thread local here that users can change and then reset it back to the default, but we haven't built that yet.
We could consider changing the implementation to be lest branchy in the future.
We could diagnose it specifically here, but the general logic does a fine job so we let it do it.
We could duplicate whatever code in takenBlk in block, but we only do it if takenBlk contains only a cheap instruction.
We could emit a noreturn call here instead which would provide more information to the optimizer.
We could figure this out and check for it, but it's good enough just to see that the opcode has the prefix we expect.
We could further optimize by storing more type info.
We could get even more extra inhabitants from the witness table pointer(s), but it's unlikely we would ever need to.
We could get into the situation where we're constructing class D extends B, and B has an old-style ctor but D::B also exists.
We could have two arrays in a surrounding container so we can only strip off the 'array struct' project.
We could in theory handle assembly or LLVM input, but let's not.
We could in theory support these if they come up but it'd be messy.
We could iterate over the all the frame locals and set corresponding bits, but that seldom adds value.
We could load an arbitrary type using some extra bitcasting.
We could not find a visible declared property.
We could not prove anything.
We could potentially be dropping a type, but that's okay.
We could print an error about "v" instead of "v.0" when "v" has tuple type and the whole thing is accessed inappropriately.
We could produce a fixit hint with a parent map, but this is a lot of effort for a narrow case.
We could punt, but it's better to assert for now because if we change this in hhbbc it will be on-purpose...
We could support dest addrs here, but it can't actually happen with the current limitations on default arguments in tuples.
We could support this with compile-time string literals, but it's not yet implemented.
We could theoretically reject cases where the set of conformances is known (say the protocol or classes are private or internal).
We couldn't find a source of metadata even in the bindings, so we won't be able to get to this metadata at runtime.
We couldn't find a suitable node by climbing the DeclContext hierarchy, so fall back to looking for a top-level declaration that contains the reference range.
We couldn't find an appropriate spec for the current platform, so rather than refining, emit a diagnostic and just use the current TRC.
We couldn't find any information about the argument in the pattern, this means it's an extra argument.
We couldn't find any normal declarations.
We couldn't get a prologue address.
We couldn't import the member, so we can't reference it in Swift.
We couldn't resolve the locator to a declaration, so we're done.
We couldn't resolve the nested type yet, so create an unresolved associated type.
We couldn't solve this constraint.
We create SILGlobalVariable here.
We create TypeAliasTypes with invalid underlying types, so we need to propagate recursive properties now.
We create a points-to edge for the first node which doesn't reach a points-to edge yet.
We create accessor entities so we can implement the functionality of libclang, which reports implicit method property accessor declarations, invocations, and overrides for properties.
We create an edge to pointsTo (agreed, this changes the structure of the graph but adding this edge is harmless).
We create defer-edges from the partial_apply values to the arguments.
We create the set by / sorting, uniquing at the appropriate time.
We currently actually check their persistent bit here, which will let both static and uncounted strings through.
We currently assume this is done.
We currently disable optimizing the initializer if a globalinit_func is called by "once" from multiple locations.
We currently do not handle address types.
We currently do not handle early exits, but do handle trapping blocks.
We currently do not special case ArrayObjects / ArrayIterators in reflectionClass.
We currently don't serialize these locations.
We currently have no mechanism to reclaim this.
We currently never import C++ code, and we should be able to kill Expand before we do.
We currently only allow subtype contractions for the purpose of  parameter binding constraints.
We currently only handle locally identified values that do not escape.
We currently only support explicit specialization of generic types.
We currently only support final on var/let, func and subscript declarations.
We currently only support static invoke functions.
We currently provide no mechanism for this to be audited.
We currently represent a function with one n-tuple argument as an n-ary function.
We decrease NumCurrentImportingEntities only after pending actions are finished, to avoid recursively re-calling finishPendingActions().
We defer making a copy of the parent method until the end because it might get overriden below.
We define the main trace for a DefInlineFP-InlineReturn pair as the set of blocks on any path from DefInlineFP to InlineReturn.
We delay this operation until after simplification to avoid re-insertion.
We delay this until we *know* we will have a need to create new translations, instead of just trying to win the lottery at the dawn of time.
We delete uncounted keys while iterating the cache, which is OK for AtomicHashArray, but not OK for other containers, such as std::unordered_map.
We depend on having resolved the inherited type.
We detect duplicates by marking freed stubs
We did A already case 'A': case 'a':
We did consume, so reinitialize.
We did not find a value in the cache for our destructor.
We did not find an entry.
We did not find this type, thus it is not mapped.
We did not transfer ownership of the array to an iterator, so we need to decRef the array.
We didn't consume, so reassign.
We didn't find a visible declared property in this's property map
We didn't find an 'in', backtrack to where we started.
We didn't find an existing value for the key.
We didn't find any methods with the specified name in cls's method table, handle the failure as appropriate.
We didn't find any side effects.
We didn't find anything.
We didn't find the cursor so we add it to the list.
We didn't find the end of the string literal if we ran to end of line.
We differentiate this from a BigNode using the size field in either structure (they overlap at the same address).
We directly read zend.assertions here, so that we can get its INI value in order to know how we should emit bytecode.
We disable then enable the breakpoints before/after the evaluation in order to prevent a breakpoint from being hit within this check
We discard functions that don't have external linkage, e.g. deserialized functions, internal functions, and thunks.
We divide the corresponding region block's profile counter by the following factors, depending on the code area the block is assigned to.
We do a case-sensitive sort here, then do a case-insensitive sort after any name-based grouping.
We do a little bit-flipping magic, repeating the MSB as the LSB, to ensure that 0 maps to 0 and 127 maps to 255.
We do a variant of Knuth's algorithm D (vol.
We do actually mean exact type equality here.
We do all of this conservative merging to simplify things during each block's analysis.
We do continue tracking the types in locals, however.
We do have a parent type.
We do have to do this after checking fix-its, though, because the diagnostic owns its fix-its.
We do lock the slow path because the SectionsToScan data structure is not concurrent.
We do need to be careful with uses with ref count inputs.
We do not care about branch inst, since if the branch inst's argument is dead, LLVM will clean it up.
We do not care about local IDs, we only process non-local IDs.
We do not care about trivial parameters (for now).
We do not care if the predecessor list is sorted, just that it is unique.
We do not create a retain if this ApplyInst is a self-recursion.
We do not currently handle generating a / new Clang struct type for Swift struct types that are created / independently of importing a Clang module.
We do not diagnose here: a diagnostic will already have been emitted by the parser.
We do not do any optimization for the JIT and it has problems with external symbols that get merged with non-external symbols.
We do not function signature specialize it.
We do not handle applies that take in multiple closures at this time.
We do not handle guaranteed parameters here since those are handled in the code in GlobalARCPairingAnalysis.
We do not handle these for now.
We do not insert the new mapped arguments into the value map since there by definition is nothing in the partial apply user function that references such arguments.
We do not keep processing since the code below cannot properly sink ref counts over switch_enums so we might as well exit early.
We do not know what this instruction is, do a simple check to make sure that it does not decrement the reference count of any of its operand.
We do not need it to have the argument anymore, but we do need the instruction to be non-null.
We do not need to check if call is nullptr, since this was checked earlier in isSafeArraySemanticFunction.
We do not need to consider extra sources.
We do not need to do anything with these.
We do not need to retain the value since the value is already being deallocated.
We do not need to summarize a function since it is the outermost loop.
We do not need to track the value itself, as we can always go to the predecessors BlockState to find it.
We do not need to update the available BitVector here as they should have been initialized and stabilized in the processBasicBlocksWithGenKillSet.
We do not need to worry about the throw block, as the return value is only going to be used in the return block/normal block of the try_apply instruction.
We do not optimize overflow checks across instructions with side effects because we don't want to delay the trap past user-visible changes.
We do not optimize this function at all.
We do not process unreachable block, instead we set their liveouts to nil.
We do not push basic block into the worklist if its already  in the worklist.
We do not push basic block into the worklist if its already in the worklist.
We do not push its next level projection into the worklist, if we do that, we could run into an infinite loop, e.g.
We do not recompute for now since we only look at the top function level for post dominating releases.
We do not specialize strings with a length greater than 32.
We do not support nested indexed data types in native SIL.
We do not support partial specialization.
We do not support symbolic projections yet, only 32-bit unsigned / integers.
We do not support this case since canonicalization failed.
We do not try to analyze this case.
We do not walk over the function and find all the possible LSValues in this function, as some of the these values will not be used, i.e. if the LoadInst that generates this value is actually RLE'ed.
We do not want to split arguments that have less than 2 non-trivial projections.
We do not want to split arguments with less than 2 projections.
We do not want to visit that loop subregion multiple times.
We do not want type constants to be available at run time.
We do not worry about th implicit #0 in case of index_addr, as the ProjectionPath never allow paths to be compared as a list of indices.
We do not, conversion is trivial.
We do that simply by setting the source node of the defer-edge to escaping.
We do that, for instance, by making a class extension / and running the code in a function in that extension.
We do this /    right after the old call site where the original partial apply was /    called.
We do this after deleting the old applies because otherwise we hit verification errors in the linking code due to having non-cond_br critical edges.
We do this after visiting all users to ensure we don't invalidate the uses iterator.
We do this by looking up the exiting blocks and finding the outermost region which the block is a subregion of.
We do this even for a parameter.
We do this here so we can process the resulting / loads/stores.
We do this in a separate pass over Builtins.def to avoid creating a bunch of identical cases.
We do this in dominance order for the constTracker.
We do this in explicit closures, not autoclosures, because otherwise the transparence of autoclosures is lost.
We do this in parallel: all the shared information is queried out of the index, and each thread is allowed to modify the bytecode for the function it is looking at.
We do this in the same order as leaf types since ProjTree expects that the order of leaf values matches the order of leaf types.
We do this last so that the region ends up in (quasi-)topological order (it'll be in topological order for acyclic regions).
We do this late since it is a pass like the inline caches that we only want to run once very late.
We do this now since it is FAR storage and may affect the memory manager's space calculations.
We do this once and keep the CFG critical-edge free during our transformations.
We do this regardless of whether the base is trivial because even a trivial base may be value-dependent on something non-trivial.
We do this to avoid eliminating apparently redundant assert opcodes that may become useful after prior guards are relaxed.
We do this with a simple linear scan, because transparent functions that reference each other have already been flattened.
We do want to preserve the original source order, but that's done by having previously added all the primary blocks to the LLVM function in their original order.
We don't / need to check how it is initialized here, because that will show up as a / store to the local's address.
We don't accumulate the benefit instead we max it.
We don't actually Bind the option here though, since its runtime value can be changed and is per request.
We don't actually consume them in writeback().
We don't actually demangle the function or types for now.
We don't actually know whether we did this switch during EOF (yywrap()) processing, but the only time this flag is looked at is after yywrap() is called, so it's safe to go ahead and always set it.
We don't actually need to emit the outer parameters because they should have been emitted as part of the outer context.
We don't actually track the U flavor (we treat it as a C), because there's nothing important to do with it for emission.
We don't actually use it.
We don't actually use these because we're not recursively rewriting the partial applies we find.
We don't actually want to "yield" anything here.
We don't allow 'where' guards on a 'default' block.
We don't allow a filename of just ".ini"
We don't allow appending with an interior pointer, although we may be asked to append less than the whole string in an aliasing situation.
We don't allow binary operators to combine specs.
We don't allow inlined functions in the region.
We don't allow leading pluses to match PHP
We don't assume the XDebugCommand will stick around before the node is sent.
We don't attempt to hoist non-class element type arrays.
We don't bother with free lists for local RDS because we aren't sensitive to its layout or compactness.
We don't care about exception handlers in resumables being driven at the same level.
We don't care about implicit ones because they don't have useful source location information.
We don't care about source ranges on implicitly-generated decls.
We don't care about source ranges on implicitly-generated expressions.
We don't care about source ranges on implicitly-generated patterns.
We don't care about source ranges on implicitly-generated statements.
We don't care about the result so although we assign it to a var, we only do that to handle errors and return it so that the calling function knows whether a connection could be obtained or not.
We don't care about these types being a bit verbose because we don't expect them to come up that often in API names.
We don't care which failure it was, it just failed
We don't care which failure it was, it just failed and the error_message has been set
We don't change anything yet so that the dominator information remains valid.
We don't check doubles yet.
We don't compute SPA for another call-level.
We don't cross the streams.
We don't currently do anything different for nullsafe query ops.
We don't currently enforce the UIEvent part.
We don't currently support intersecting RepoAuthType::Arrays (t4473238), so we might be here because srcType and typeParam have different RATArrays.
We don't currently support using the 'r' encoding to refer to collection keys, but eventually we'll need to make this work to allow objects as keys.
We don't debug RPC requests, so we need to detach XDebugHook if xdebug was enabled.
We don't default-initialize anything else.
We don't do stack promotion.
We don't do this for generic parameters, because those are validated as part of their context.
We don't do this in compilation modes because defaulting to the latest SDK may not be intended.
We don't even care that it's the same method we're asking for, just that it has the right selector.
We don't even need keep the init bit for the element precise.
We don't expect it to be already there, but it has been observed during development.
We don't expose a non-inbounds GEP operation.
We don't handle inner-array types with unset yet.
We don't handle these instructions if we see them in store addresses.
We don't handle these two cases, because we don't compile functions containing them:
We don't handle those in our method regions for now---they'll get handled by the tracelet compiler and then may branch to the main entry point.
We don't have StMem in here since it sometimes stores to RefDatas.
We don't have a concrete class to attach Objective-C category metadata to.
We don't have a destructor body, so hunt for the SIL function for it.
We don't have a great cost model at the SIL level, so we don't want to blissly duplicate tons of code with a goal of improved performance (we'll leave that to LLVM).
We don't have a guess for the current ActRec.
We don't have a lot of great options here, so (if all else fails), we'll attempt to diagnose the issue as though the first option was the problem.
We don't have a mode, so determine a default.
We don't have a type witness for this associated type.
We don't have a way to represent instancetype in DWARF, so we emit the static type instead.
We don't have an existing class, but we /do/ have a file in script mode.
We don't have an output from an Action-specific command line option, so figure one out using the defaults.
We don't have any better indication of name, so fall back on the module name.
We don't have anything else to do in this case.
We don't have enough information to find the associated type.
We don't have intimate enough knowledge of CF refcounting to check for that dynamically yet.
We don't have profile data for this Switch, most likely because it saw some weird input type during profiling.
We don't have the class or the typedef, so autoload.
We don't have the information to form them again on exit, so tolerate them here.
We don't have the time to disentangle the real mangler from the compiler right now.
We don't have these yet in Swift, but if we do we need to add an extra check here.
We don't have to destroy the source, because it was nil.
We don't just assert here since there is the potential for a conformance without a witness table to be passed to this function.
We don't know either's sign bit so we can't say anything about the result.
We don't know how to deal with other extended types.
We don't know how to deserialize this kind of attribute.
We don't know how to deserialize this kind of decl.
We don't know how to deserialize this kind of type.
We don't know how to handle this specialization.
We don't know how to serialize decls represented by sub-blocks.
We don't know how to serialize types represented by sub-blocks.
We don't know if the user just forgot a label on a defaulted value.
We don't know the name, but we know something about the class.
We don't know the types of all the global declarations in the first pass, which means we can't completely analyze everything.
We don't know the value of the alloca until we find the first store.
We don't know what happened.
We don't know what this field is.
We don't know what to do with this.
We don't know which memory is read in the callee.
We don't know which parameter to the thunk was originally 'self'.
We don't link any LLVM libs into the runtime, so define this here.
We don't maintain an all_mistate set so there's nothing to do here but avoid hitting the assert below.
We don't model these in DWARF.
We don't necessarily start at a top-level frame so we need to continue iterating until we run out of frames
We don't need a ConditionalDominanceScope here because (1) there's no code in the other condition and (2) we immediately return.
We don't need a conformance constraint because we wouldn't have found the declaration if it didn't conform.
We don't need any / of the requirements, because they will be inferred.
We don't need full flow-sensitive analysis for SILGen-ed code.
We don't need more bits than the size of the result.
We don't need the cached block offsets anymore.
We don't need the object anymore.
We don't need the requirement if both types are above the method depth, or non-dependent.
We don't need the requirement if the constrained type is above the method depth.
We don't need to NUL terminate here, printing handles it
We don't need to autoload classes because it is impossible to have an instance of a class if it's not defined.
We don't need to capture anything from non-local contexts.
We don't need to capture types.
We don't need to check for space for the ActRec (unlike generally in normal re-entry), because the ActRec isn't on the stack.
We don't need to copy the full capacity, since the array won't change once it's uncounted.
We don't need to decref value---it's a bytecode invariant that our Cell was not ref-counted.
We don't need to destroy it because we know that on that path it is nil.
We don't need to do anything fancy if we don't have a label.
We don't need to do anything for collect.publicStatics because we'll analyze the included pseudo-main separately and see any effects it may have on public statics.
We don't need to do anything if we have no protocols to conform to.
We don't need to do anything to handle the Swift parameter-ABI attributes here because we shouldn't be trying to round-trip swiftcall function pointers through SIL as C functions anyway.
We don't need to do anything too fancy about emission if we don't have a label.
We don't need to emit dependent conformances.
We don't need to have explicit cases for any case tags which produce the same result as the default branch.
We don't need to link to the try_apply's normal result argument, because we handle it separately in setAllEscaping() and mergeCalleeGraph().
We don't need to merge the litstrs in the array, because rats in arrays in the array type table must be using global litstr ids.
We don't need to merge the source subgraph of nodes which have the global escaping state set.
We don't need to pass anything extra as long as all of the archetypes (and their requirements) are producible from arguments.
We don't need to re-create the object file.
We don't need to retype the DefLabel in the actual loop header, because it must already contain the types for these incoming values.
We don't need to set the in state on the new edge-splitting block, because it isn't in our env.rpoBlocks, so we don't ever visit it for the optimize pass.
We don't need to side exit here, but it's cleaner, and we assume that division by zero is unikely
We don't need to test whether NumRemainingSpecializations is AlwaysRefutable before decrementing because we only ever test this value against zero.
We don't need to worry about any of the passed parameter locals, because the caller must have checked for that in its maxStackCells().
We don't need to worry about non-opaque patterns because the type-checker forbids non-thick function types from having generic parameters or results.
We don't need to worry about sil_witness_tables since witness tables reference each other via protocol conformances and sil_vtables don't reference each other at all.
We don't really care about this.
We don't really care if this worked or not.
We don't really pass a return value via the stack, but enterTCHelper is going to want to store the rret() regs to the top of the stack, so we need the stack depth to be one deeper here.
We don't rely on any other LLVM ARC transformations, but we do need ARC contraction to add the objc_retainAutoreleasedReturnValue assembly markers.
We don't require a prefix or pattern for the default
We don't run PHP destructors while we're unwinding for a C++ exception.
We don't see the bodies of initializers from a different module unless all of them are fragile.
We don't serialize the body of stdlib_binary_only functions so we can't mark them as Shared (making their visibility in the dylib hidden).
We don't sink stack allocations to not destroy the proper nesting of stack allocations.
We don't specialize setting pair elements.
We don't support JIT compiling functions that use some super-dynamic php variables.
We don't support adding non-static strings yet.
We don't support couldBe intelligently for interfaces quite yet, so here's a test that will start failing if we ever do:
We don't support getting the runtime name for nested classes.
We don't support inlining a function that binds dynamic self because we have no mechanism to preserve the original function's local self metadata.
We don't support nested types in generics yet.
We don't support this yet.
We don't track cells pushed by interp one except the top of the stack, aside from the above special cases.
We don't track those, so it's returning AEmpty for now.
We don't try to cache negative responses for generic patterns.
We don't try to limit the load effects to argument locals here, though, and just union in all the locals.
We don't try to track when a BoxedStaticStr might be converted to a BoxedStr, and we never guard on staticness for strings, so boxing a string needs to forget this detail.
We don't update tracked local types for pseudomains, but we do care about stack types.
We don't use allocateStack because we're not allocating this in stack order.
We don't use enough attributes to justify generalizing the RuntimeFunctions.def FUNCTION macro.
We don't use parseList() because we want to provide more specific diagnostics disallowing operators in version specs.
We don't use the iterator if we have a delegate generator (as iterators mess with the internal state of the generator), so short circuit and dont init our iterator in that case.
We don't use the iterator when the delegate is a generator though, so even if the param tells us to free it we should just ignore it.
We don't vend the runtime name for generic classes for now.
We don't want a new execution context to cause any request-heap allocations (because it will cause us to hold a slab, even while idle).
We don't want an abstract entry because, if one exists, we'll just end up here again recursively.
We don't want redundant calls.
We don't want side exits when profiling, so only allow instructions that consume refs at the beginning of the region.
We don't want that our unoptimized version will be linked instead of the optimized version from the stdlib.
We don't want the decision about whether to rename the decl to depend on what exactly the user has imported.
We don't want to cast the function here because it interferes with LLVM's ability to recognize and special-case this function.
We don't want to complain about it twice.
We don't want to complain about them, because we might already have complained about redeclarations based on Swift matching.
We don't want to convert to strings if either was already a string.
We don't want to do that again.
We don't want to duplicate the whole original preheader it might contain instructions that we can't clone.
We don't want to end up emitting the type metadata for Int by chasing through N layers of metadata just because that path happens to be in the cache.
We don't want to exit here with a dead cleanup on the stack, so push the scope first.
We don't want to have an arbitrary limit in the size of the password.
We don't want to jump-thread through headers.
We don't want to leave sensitive data from our actual password hash computation on the stack or in registers.
We don't want to leave them around in the system because later diagnostics will assume they are unsolvable and may otherwise leave the system in an inconsistent state.
We don't want to match the release with both retains in the example below.
We don't want to modify the CFG in SILCombine.
We don't want to propagate parens from arguments to the result type.
We don't want to recurse into declarations or statements.
We don't want to recurse into most local declarations.
We don't want to remove allocations that are required for useful debug information at -O0.
We don't want to report these errors immediately, as we want to gather them up and report them all at the end.
We don't want to rotate such that we merge two headers of separate loops into one.
We don't want to send speculative (or worse, repeat) requests to the autoloader, so do our due diligence here.
We don't want to sink instructions into loops.
We don't want to specialize on arg types for builtins
We don't want to touch those.
We don't want to visit blocks outside of the region.
We don't want two copies of Archetype being serialized, one by serializing genericArgs, the other by serializing the Decl.
We don't yet have a name, assign one.
We don't yet support raw values on payload cases.
We dont want these compiler generated functions to appear in backtraces.
We downcast back to RuleBasedBreakIterator because clone() always returns a icu::BreakIterator, which doesn't implement getRuleStatus().
We duplicate the file descriptor, because fclose on a tmpfile will delete the file, but any open descriptors can still access the phantom inode.
We effectively inline most of CompilerInstance::ExecuteAction here, because we need to leave the AST open for future module loading.
We either have extra inhabitant 0 or no extra inhabitant (-1).
We either just created a new destroy, forwarded a copy, or will continue propagating from this dead-in block.
We emit Switch even for absurdly small cases to allow the jit to decide when to lower back to comparisons.
We emit a completely different pattern for foreign classes.
We emit a special native allocating constructor though.
We emit an empty asm string with the side-effect flag set, and with a unique integer argument for each cond_fail we see in the function.
We emit an empty fallback case with a comment to encourage the developer to think explicitly about whether fallback on earlier versions is needed.
We emit the counter for exiting the do-block here, as we may not have a valid insertion point when falling out.
We emit the epilog at the current insertion point.
We emit these as part of the PatternBindingDecl.
We encountered a try block - a finally needs to be run before returning.
We encountered another try block, jump to the corresponding finally, freeing any iterators on the way.
We ended up skipping over the source location entirely, which means that it points into whitespace.
We ensure this by setting the edge on nodes which have no defer-successors (see above).
We entered this frame in the TC but the jit is now disabled, probably because a debugger is attached.
We enumerate all values in a SILFunction beforehand to correctly / handle forward references of values.
We eventually want this to work) and make a reference to that declaration be an implicitly unwrapped optional.
We exclude continuation opcodes which transfer control out of the function, which allows cmds to get a chance to alter their behavior when those opcodes are encountered.
We exempt Objective-C initializers from this requirement because there is no equivalent to 'required' in Objective-C.
We expect SIL_FUNC_NAMES first, then SIL_VTABLE_NAMES, then SIL_GLOBALVAR_NAMES, then SIL_WITNESS_TABLE_NAMES, and finally SIL_DEFAULT_WITNESS_TABLE_NAMES.
We expect these parameters to be replaced by stack address / references.
We expect to get a type variable back.
We expect to see a function type here, but if we don't, use the colon.
We expected SetElem's base to not be a Str but might be wrong.
We explicitly check for the stringified version of "true" here, as "true" has a special meaning.
We fail if there is no solution.
We failed to constant propagate...
We failed to prove anything, it could be read or written by the deinit.
We failed to prove anything.
We failed to prove that the two objects are different.
We filter out some cases to avoid too much noise.
We finally know the base value.
We find out whether the machine we connected too, is actually the one we thought we were connecting too
We first map the full size to make sure the memory area is available.
We first serialize our number as a string, then we need to serialize any other public properties as an array after that.
We force a recheck, because "expr" is likely in our table with the extra contextual constraint that we know we are relaxing.
We force first type of a func declaration to be a tuple for consistency.
We force mustBeRef() to return false for array_multisort().
We forward declare the mangled names, wrapped in an extern C block.
We found a nominal decl (for example, the closure is used in an initializer of a property).
We found a place to insert the stack deallocation.
We found a split point.
We found a user that we can't handle.
We found a visible property, but it might not be accessible.
We found an ambiguity.
We found an entry with a negative value.
We found an enum initialization.
We found an open instruction that DominatingOpen dominates:
We found an opening curly quote in the source file.
We found differing projections, but we need to make sure that there are no casts in the symmetric difference.
We found no more handlers in this frame, so the nested fault count starts over for the caller frame.
We found only one operator declaration, so we know whether this should be a prefix or a postfix operator.
We found only one trivial field.
We found some potential reference decrementing instruction.
We found the diagnostic, so remove it...
We found the same solution.
We found the type alias, check if an object of type cls is compatible
We found this declaration via dynamic lookup, record it as such.
We frequently generate a generic load, followed by a generic IncRef, followed by a CheckType that refines that temporary or otherwise branches to a block that's going to do a ReqBindJmp.
We generally do this by creating a REPL metavariable (e.g. r4) to hold the result, so it can be referred to in the future.
We generally walk into declarations, other than types and nested functions.
We generate initializers specially for unions below.
We generate this pattern after switching the Word type to an explicit Int32 or Int64 in the stdlib.
We get invalid note locations when trying to describe where a module is imported and the actual location is in Swift.
We get the Fix-It location from the PatternBindingDecl unless the VarDecl has attributes, in which case we get the start location of the VarDecl attributes.
We get this from the beginning of htab.
We give the proxy a short period of time to wait for any threads it owns.
We go through ObjC lookup to deal with potential runtime magic in ObjC land.
We got a bad exponent ('e' and maybe a sign).
We got an explicit content-type header, trust if it says soap or xml
We got an illegal character so we are done accumulating.
We got external information (probably from static analysis) that conflicts with what we've built up so far.
We had a counted inner array---we need to do an O(N) copy to get the collection into the request local heap.
We had more than kNumSIMDRegs doubles, but less than numGPRegArgs INTs.
We handle accessibility explicitly.
We handle all other instructions conservatively.
We handle decReffing obj and name in fPushObjMethodImpl
We handle decReffing obj in fPushObjMethodImpl
We handle emitting the variable storage when we see the pattern binding.
We handle our own overriding/shadowing filtering.
We handle the var error in sema for a better fixit and inout is handled later in this function for better fixits.
We handle this by splitting the multi-element case into its component parts and treating each separately.
We handle this conservatively by just pushing all DecRef markers where the DecRef is from a function other than the outer function down to a safe re-entry depth.
We handle value propagation from cond_br and switch_enum terminators.
We hang on to the last slab instead of freeing it so that we don't keep allocating and freeing slabs in the common steady state.
We hash the enum by hashing its kind, element, and operand if it has one.
We hash the enum by hashing its kind, element, and operand.
We have a RIFF container.
We have a bit of state for each physical register this pass tracks.
We have a call that can potentially be specialized, so attempt to do so.
We have a case here where we know neither the class nor the static property name.
We have a chain in progress, but it's not done.
We have a closure created by a closure's invoke method, which means it should inherit the outer closure's context, so we have to know that first.
We have a compound name.
We have a debugger guard, so all jumps to us funnel through this.
We have a declaration.
We have a designated initializer.
We have a difference.
We have a few special names that we form on entry.
We have a folly::Optional just to keep the result type DefaultConstructible.
We have a found multiple type aliases that refer to the same thing.
We have a function name.
We have a matching ref count inst.
We have a new token to deal with, jump to the beginning of the loop, but don't fetch the next token, hence the goto.
We have a parsed extension that we can't resolve well enough to get any information from.
We have a persistent Class.
We have a primary input, so use that as the basis for the name of the serialized diagnostics file.
We have a reference to 'self'.
We have a reference to an initializing constructor, but we will actually be using the allocating constructor.
We have a requirement/witness match.
We have a resilient conformance.
We have a safe container if the array container is passed as a function argument by-value or by inout reference.
We have a suffix, so determine an appropriate name.
We have a trivial move constructor, so we copy when we move.
We have a true successor.
We have a type constructor.
We have a value for the parent, remove all the values for children.
We have already checked that the operands match.
We have already checked that the operands of our struct_element_addrs match.
We have already checked that the operands of our struct_extracts match.
We have already checked the operands.
We have already compared the operands/types, so we should have equality at this point.
We have already ensured a single store per block, and all release points occur after all stores.
We have already processed all of our subloops, so everything there has already been properly setup.
We have already seen an entry for this index bail.
We have already summarized all subloops of this loop.
We have already visited all of its potential children loops.
We have already visited this node and it is in our dfs search.
We have an argument name mismatch.
We have an array of value handles, but we need an array of constants.
We have an exit for Foo(), but we were in Bar().
We have an implicit assumption here that the first MemberRefExpr encountered walking (pre-order) is the Dest is the destination of the write.
We have an indirect schema.
We have an intervening nominal type context that is not the declaration context, and the declaration context is not global.
We have better results.
We have built a projection tree and filled it with liveness information.
We have cases for addressors here because we might reasonably allow them as protocol requirements someday.
We have cases where a private typealias was used in a mangled variable name.
We have cases where we statically know the type but need the value from native call.
We have computed the available value bit, now go through every basic block and compute the forwarding value locally.
We have copied the threaded block into the edge.
We have either no matches or an ambiguous match.
We have enough double args to hit the stack but we haven't finished filling the GP regs yet.
We have ensured that clean_file will be added to a relative path by the time we get here.
We have entries for this context.
We have exactly the pattern that we expected.
We have extra inhabitants if the first element does.
We have found a non trivial member that is not the member we are extracting, fail.
We have found our target if the range of the node we are visiting is contained in the range we are looking for.
We have four cases to deal with here:
We have internal breakpoints setup, but we haven't hit one yet.
We have just completed an Await, so the new AsyncFunctionWaitHandle is now available, and it can predict where execution will resume.
We have more post data if a) there's some in the queue or b) the client EOM hasn't come yet
We have multiple non-trivial types violating our condition.
We have no reason to continue running the interpreter if there's no FPI region active.
We have no source file for the function.
We have no valid positions---no one should call this function.
We have not processed any extensions yet, so there's nothing to do.
We have potentially cloned a loop - invalidate loop info.
We have processed this SILValue before.
We have proven that they do not protect anything of value.
We have reached the end
We have remaining argument clauses.
We have seen this member before.
We have seen: for ...
We have some special translations for common combinations that avoid extra conversion calls.
We have something function-like, so we want to strip off the 'self'.
We have special profiling and logic to decide which arcs from a Switch are eligible for inclusion in the region.
We have state for whether any of it is valid (before we've analyzed for it, or if the program contains /any/ modifications of static properties where both the name and class are unknown).
We have stripped off struct_extracts.
We have succesfully sent the POST request
We have the available value bit computed and the local forwarding value.
We have the constructor.
We have the final values for our ini settings.
We have therefore abandoned that approach.
We have three cases: the scalar case, the paren case, and the tuple literal case.
We have three thread modes: Normal, Sticky, and Exclusive.
We have to be careful here.
We have to be careful with before/after here.
We have to block all incref motion through a PHP call, by observing at the max.
We have to build a new locator.
We have to build this in two phases because it contains relative pointers.
We have to check that nothing was added to newInsts because that's the only way we can tell simplification happened to a no-dest instruction.
We have to clean up ourselves.
We have to construct this generic function type.
We have to create the variable now (before we emit the global lists).
We have to do a non-take copy because someone else may be using the box (e.g. someone could have closed over it).
We have to do a retain because we are returning the pointer +1.
We have to do getAddrOfObjCClass ourselves here because the ObjC runtime base needs to be ObjC-mangled but isn't actually imported from a clang module.
We have to do this after SILParse creating the unfortunate double if statement.
We have to do this before defining the initializer since the entries will contain offsets relative to themselves.
We have to do this mapping before we might call getType on one of those archetypes, but after we've read all the generic parameters.
We have to do this with a full AST walk, because the freshly parsed pattern represents tuples and var patterns as tupleexprs and unresolved_pattern_expr nodes, instead of as proper pattern nodes.
We have to eval now to emulate this behavior.
We have to generate new dedicated BBs as landing BBs for all FailurePreds and all SuccessPreds.
We have to have a known heap metadata value, reject dynamically computed ones, or places
We have to lie and say we're done with parsing to make this happen.
We have to lie to RValue about the formal type (by using the lowered type) because we're emitting into an abstracted value, which RValue doesn't really handle.
We have to load the returned value from the alloc_stack.
We have to look up our exiting blocks each time around the loop since if we split a critical edge, the exiting block will have a new terminator implying a new successor list.
We have to lower these to ARM-suitable vasm opcodes before register allocation.
We have to make sure BOUND_GENERIC_SUBSTITUTION does not overlap with SIL-specific records.
We have to make sure the live FramePtr at the point of the DefLabel is the same as the one from the LdLocAddr, if that's the instruction we're trying to sink.
We have to merge the strings as litstrs to ensure namedentity creation.
We have to preserve the original order of the cases for string switches because of insane things like 0 being equal to any string that is not a nonzero numeric string.
We have to re-abstract payload if its a metatype or a function
We have to recompute the CFG and dominators because we changed things when we hoisted.
We have to return here, as otherwise the exception doesn't trigger before we return the hash at the end.
We have to take special care about floating point operations because of potential NaN values.
We have to update the frame pointer and the stack pointer, and load the return value into the return register so the trace we are returning to has it where it expects.
We have to use an AST Walker to find the VarDecls buried down inside of it.
We haven't implemented type-level storage in some contexts.
We haven't optimized the widening operator much, because it doesn't happen in practice right now.
We haven't seen this function before.
We haven't seen this member type before.
We haven't tried to import this macro yet.
We hit EOF, and not every brace has a pair.
We hit an application, find the constructor reference.
We hit this case e.g. if a table is imported from the stdlib.
We ignore additional output filenames.
We ignore empty witness table without normal protocol conformance.
We ignore patterns that aren't similar to the head pattern.
We ignore retains of self.
We ignore the values of statically nullish types.
We ignore ud2 so spill space is still allocated in core files.
We imported the factory method as an initializer, so record it as an alternate declaration.
We include it way down here because we want the user's section 1 to have been scanned first.
We initially fill in these fields with addresses taken from the ObjC runtime.
We inject code to print out expressions and / pattern bindings the are evaluated.
We insert a BigNode header at the front of the allocation in order to find these at sweep time (end of request) so we can give them back to libc.
We insert a swift_bufferDeallocateFromStack at the end of the buffer's lifetime.
We instantiate IR_OPCODES after defining all the various source forms to do type assertions according to their form (see ir-opcode.h for documentation on the notation).
We intentionally don't respect access control here, since everything is visible to the Objective-C runtime.
We intentionally use typeCheckStmt instead of typeCheckBody here because we want to contextualize all the TopLevelCode declarations simultaneously.
We interleave copies and loads in `edge_copies', so here and below we process them separately (and pass `true' to avoid asserting).
We introduce for the non-local case because these may have getters and setters (and these may be synthesized, so they might not even exist yet).
We invalidate the SILLoaderCaches here so that we can eliminate such functions.
We invalidate the SILLoaderCaches here so that we can eliminate the definitions of such functions.
We iterate from the back to the beginning.
We iterate through the pattern, searching for the matching ending delimiter.
We jmp directly to the func body---this keeps the return stack buffer balanced between the call to this stub and the ret from the callee.
We just assume this might happen.
We just buffer them up / until the end of the file.
We just cleared our BB State so we have no more possible effects.
We just do a quick loop to try to bail out of this case.
We just do it to be absolutely sure that we don't crash.
We just don't know how to handle this.
We just ignore them here.
We just interpreted a bytecode that decided we need to return to an address in the TC rather than interpreting up into our caller.
We just need a slightly better destructor analysis to prove / that it only releases elements.
We just need any number that is guaranteed to be larger than every other argument.
We just need to conservatively throw away slots that aren't tracked on all preds.
We just need to give up our retain count on it.
We just need to grab the fp/rip of the original frame that we saved earlier, and sync rvmsp().
We just pass in the address since archetypes are address-only.
We just put a C on the stack, so we need to get it to be an F.
We just removed the last token from the last slab.
We just smashed all of those callers-- treadmill the free to avoid a race (threads executing callers may end up inside the guard even though the function is now unreachable).
We just want to emit a module, so pass -emit-module without any other mode options.
We just want to know if we have something to talk to, irregardless of RP
We keep an entry for each tracked SpillFrame in this map, so we can check its ALocBits
We keep the file handle open in order to ensure we can still write on request shutdown
We keep the file handle open in order to ensure we can still write on tracing stop
We keep track of an offset, relative to the depth of the stack at the first instruction of the block
We keep uses at the end of the first split because we know that `r' is free up to /and including/ that position.
We know all Objective-C protocols have unique names.
We know enough about the property to perform direct access.
We know exactly what it is, so mark exactly.
We know exactly which FileUnits may have SIL those in the main module.
We know for sure we're going to be in an object property.
We know from the lexer that this is all-numeric.
We know how to handle cond_br and switch_enum .
We know how to propagate through BBArgs only.
We know it has to name a class only if there's no type alias with this name.
We know it is stdClass, and everything is public (and dynamic).
We know it's not boxed (setRef above handles that), and the helper has already decref'd the old array and incref'd newArr.
We know s_HTTP_RAW_POST_DATA is the last system global.
We know that V1 is a GEP, but we don't know anything about / V2.
We know that a dedicated checked_cast_br check is generated for each direct subclass by tryToSpeculateTarget.
We know that accesses to this element only access this element, / cross element accesses have been scalarized.
We know that all arguments are literal insts.
We know that all of our sub blocks have the correct interesting insts since we did one scan at the beginning and are updating our interesting inst list as we move around retains/releases.
We know that at this point we have at most one store per block.
We know that c1 is Uninit in this branch but we have to encode this in the IR.
We know that main always comes from MainFile.
We know that our loads happen before stores, so we need to first check for Phi nodes in the first block, but stores first in all other stores in the idom chain.
We know that self is a box, so get its address.
We know that the argument is not dead, so add it to the worklist for recursive processing.
We know that the destructor has no side effects so we can remove the deallocation instruction too.
We know that the incoming arguments from all predecessors are the same, so just use them directly and remove the basic block parameters.
We know that the profiler is not attached, so either we failed the request init checks or it was turned off during runtime.
We know that this is safe because unescaped strings are always shorter than their escaped forms (in a valid string).
We know that this will always result in RCIdentical values without additional analysis.
We know that we have at least one element in the array so we don't have to do an initial bounds check.
We know the direction this conditional branch is going to take thread it.
We know the dynamic type of the operand.
We know the key doesn't exist, but aren't making use of that fact yet.
We know the mod-ref behavior of various runtime functions.
We know the one or two types have been subjected to the "isBuiltinTypeOverloaded" predicate successfully.
We know the result Set will simply be a copy of this Set, so we can just call Clone() and return early here.
We know the resulting Map will be empty, so we can return early here.
We know the resulting Map will simply be a copy of this Map, so we can just call Clone() and return early here.
We know the resulting Set will be empty, so we can return early here.
We know the resulting Set will simply be a copy of this Set, so we can just call Clone() and return early here.
We know the setcc was the only use of the phidef's old dest, so this is safe.
We know the witness thunk and the corresponding set of substitutions required to invoke the protocol method at this point.
We know their size, and pass them as values in SIL and IRGen.
We know there can't be FPI regions and it can't be a generator body because it's a builtin frame.
We know they cannot be the same integer.
We know this will always succeed.
We know we Foo:Foo() since we are in this if statement Now, if the PHP 7 runtime option is set and the class: 1.
We know we must have at least one result and it must be on the Left.
We know we're on the "current" thread, so we can process any active flow command, stop if we're at a breakpoint, handle other interrupts, etc.
We know we're working with a lowered type here.
We know when we have one of these because it has to be freed through a different entry point.
We know where the new fpValue is pointing (relative to the spValue, which we aren't changing).
We lack a SIL instruction to nondestructively project data from an address-only enum, so we can only do so in place if we're allowed to take the source always.
We lazily / create ObjC protocol_t records for protocols, storing references to the / record into the __objc_protolist and __objc_protorefs sections to be / fixed up by the runtime.
We leak ExtraArgs in other similar situations for this too (e.g. if called via FCallArray and then a stack overflow happens).
We leave this struct type intentionally opaque, because the compiler basically never needs to access anything from one.
We let it diagnose any issues with malformed tokens or other problems.
We let the VM shutdown continue and it will advance us to the next state.
We limit I/O waiting to the time currently remaining in the request (see AsioSession::getLatestWakeTime).
We limit the size of the AA cache to 2**14 because we want to limit the memory usage of this cache.
We limit the size of the MB cache to 2**12 because we want to limit the memory usage of this cache.
We limit the size of the MB cache to 2**14 because we want to limit the memory usage of this cache.
We limit the total stack depth during inlining, so this is the deepest we'll ever have to worry about.
We look at the type sugar directly, so that one can suppress this warning by adding parentheses.
We look both at relative branches and the pattern: move r10, IMMEDIATE call r10
We look through some simple things that get in between the overload set and the apply.
We lose buf's position as we iterate, so we need buf_start to save it.
We lower Switch to a series of comparisons if any of the successors are in included in the region.
We lower vinvoke in two phases, and `inst' is overwritten after the first phase.
We make a simple difference and add the needed elements
We make no attempt to use the best DebugLoc, because in all known cases, we only have one.
We make no guarantee that the Fix-It, when applied, will result in semantically valid code -- but, at a minimum, it should parse.
We make this function bare so we don't have to worry about decls in the SILArgument.
We make up a unique usr for each extension by combining a prefix and the USR of the first value member of the extension.
We make use of this fact to increase object lower bounds.
We managed to hit phijmps to both of our target phidefs before hitting this phijcc.
We mark nothrow with a nullptr, which will assert during unwinding, use a separate marker here to indicate the catch has been erased
We mark the head/tail as unknown control flow regions since in CFGs like the following:
We mark this block as unlikely in order to coax the emitter into ordering this block last.
We match the behavior of clang to not report deprecation warnings inside declarations that are themselves deprecated on all deployment targets.
We matched a single character, the EOB, so treat this as a final EOF.
We matched some text prior to the EOB, first process it.
We may be able to add the LSLocation to the vault, but it gets complicated very quickly, e.g. we need to resize the bit vectors size, etc.
We may be able to hoist it more in another pass but don't currently iterate.
We may be able to simplify DestBB now that it has one fewer predecessor.
We may be parsing this closure expr in a matching pattern context.
We may be stopped at a place with no source info.
We may check packed array bounds on profiled arrays for which we do not statically know that they are of kPackedKind.
We may consider purge_all() here, too.
We may eventually change this to work without the extra data structure, but that's how it works right now.
We may eventually want to use this information, but def it out for now
We may have a SrcKey to a deleted function.
We may have a known type even without an SSATmp for an available value, or that is more refined than an SSATmp knownValue's type.
We may have an aliasing append.
We may have cached the fully resolved type in a previous request.
We may have changed either dst.value or dst.type in a way that could fail to preserve LocationState invariants.
We may have inferred a TSStr or TSArr with a value here, but at runtime it will not be static.
We may have previously sunk a child DefInlineFP into an exit block, so make sure to sink the parent here.
We may have pushed IncRefs past CheckTypes, which could allow us to specialize them.
We may have read an EOF because someone deliberately called close() in which case they may call shutdown() or we may already be inside shutdown()
We may have unnecessarily allocated an ExtraData, but whatever.
We may in such a case, be too conservative with our other predecessors.
We may need to bitcast the address if the field is of a generic type.
We may need to merge different-sized memory stacks, because a predecessor may not touch some stack memory that another pred did.
We may need to support this at some point, but currently only imported objc methods are returns_inner_pointer.
We may not be able to find a declaration to search if the ReferenceRange is invalid (i.e., we are in synthesized code).
We may not execute the cond_fail speculatively.
We may not go to dominated blocks outside the loop, because we didn't check for safety outside the loop (with ABCAnalysis).
We may not have TombHash at the end if the chunk is used up.
We may not have a DefCls PC if we're a closure, or a non-top-level class declaration is DCE'd.
We may not have optimized these functions yet, and it could be beneficial to rerun some earlier passes on the current function now that we've made these direct references visible.
We may still remove some stores during this visit if they are locally proven dead, however.
We may visit the same closure expr multiple times in some cases, for instance, when closures appear as in-line initializers of stored properties.
We may want to be more precise here in the future or emit a diagnostic.
We may want to diverge at some point.
We may want to revisit this.
We may wind up with a NULL here if there simply aren't any results
We may, alternatively, want to use a type variable in that case, and possibly infer the type of the variable that way.
We measure the cost of inlining each callstack and stop when it exceeds a certain threshold.
We merely setup the remaining live stores, but do not materialize in IR yet, These stores will be materialized before the algorithm exits.
We might be able to get more performance by just getting the number and doing to string conversion ourselves.
We might be able to stick code into SILBuilder that has this behavior.
We might be at tok::eof now, so ensure that consumeToken() does not assert about lexing past eof.
We might consider making stack flavors have subtypes and adding this to the opcode table.
We might have added internal control flow above.
We might have cloned there might be critical edges that need splitting.
We might have looked up a contextual member whose result type disagrees with the expected result type.
We might load a module.
We might need an extra bit to check if self was consumed.
We might need to bitcast the results.
We might not have a parent type.
We might not have interesting initialization to do.
We might really be asking for information associated with a more refined associated type declaration.
We might reasonably get called by generic code, like a demangler that produces type objects.
We might side-exit inside the callee, and interpret a return.
We might still have a bunch of tokens to match, though, because of possible backing-up.
We might still have a dependently typed payload though, namely a class-bound archetype.
We mirror the compiler and don't set the TypeResolver during SIL processing.
We model destroy_addr as a release of the entire value.
We model this with the constraint
We moved instructions.
We must allocate space for it, because its default ctor will write to it.
We must always have the same spValue.
We must avoid that we are going to change a block twice.
We must be processing an unreachable part of the cfg with a cycle.
We must convert to mixed, but can call addVal since the key must not exist.
We must do this before we do anything, because it can throw, and we can't start tearing down the AFWH before that or the unwinder won't be able to react.
We must do this immediately rather than defer it in order to avoid problems with cloning dead instructions when doing recursive specialization.
We must give TypeStructure::resolve() the same ArrayData* we tested up above, to avoid reading an already-resolved (by another thread) ArrayData* from cns.
We must have originated at the call argument.
We must have seen both a store to and a load from the slot to deshadow on every exit BB.
We must have the same context archetypes as the unthunked function.
We must hoist them so that we preserve memory safety.
We must make sure the value stored at the handle is correct before setting m_sPropCacheInit in case another thread tries to read it at just the wrong time.
We must not acquire a reference if it in that state.
We must not do anything that would cause an attempt to decode characters outside the ASCII printable range.
We must not move initializers around availability-checks.
We must store the requested locale on object creation
We must then continue iterating in case the actual fixed point is higher than the result of widening.
We must treat the boxed value as +0 since it may be shared.
We must use an "unsafe" mutex in this pathway since the normal "safe" mutex calls fatalError when an error is detected and fatalError ends up calling us.
We must use the following (undocumented) APIs because pthread_attr_getstack returns incorrect values on OSX.
We mustn't destroy any callbacks until we're done with all of them.
We necessarily prefer potential archetypes rooted at parameters that come from outer generic parameter lists, since those generic parameters will have archetypes bound in the outer context.
We need 5 chars (4 hex + the 'u') or its not valid
We need VM interrupts if we're in a state that requires the debugger to be interrupted for every opcode.
We need a : prefix to resolve a name to a parameter number
We need a bitcast if we're dealing with an opaque class.
We need a definition for that, so record all the variable definitions along with their specification, which we can consult later.
We need a predecessor who is capable of holding outgoing branch arguments.
We need a preheader - this is also a canonicalization for follow-up passes.
We need a single backedge and the latch must not exit the loop if it is also the header.
We need a temporary table of updates which we apply after running this iteration of the fixed point.
We need a try_apply to call a function with an error result.
We need an alloc_stack as a replacement for the indirect parameter.
We need an extra incref for the push onto the stack.
We need an initStorage extension method to initialize this storage.
We need an instantiation function if the base conformance is non-dependent.
We need at least one case to have a raw value.
We need at least two overloads to make this interesting.
We need both the class to match any object that this function may have been invoked on, and we need the class from the function execution is stopped in.
We need either a default argument or a variadic argument for the first declaration to be more specialized.
We need enough bits to store the largest payload plus extra tag bits we need.
We need it if there is a labeled break out of the if statement or if there is an if/then/else.
We need its structure to determine whether we'll be bridging or upcasting the base type.
We need one pointer for each archetype or witness table.
We need only a few extra variables to hold the errors immediately around the current column.
We need put to a null on the stack in the catch trace in place of our input, since we've already shuffled that value into the heap to be owned by the waitHandle, so the unwinder can't decref it.
We need return type if it is not Void.
We need signed shifts here.
We need special initialization of metadata objects to trick the ObjC runtime into initializing them.
We need tags for each of the payload types, which we may be able to form using spare bits, plus a minimal number of tags with which we can represent the empty cases.
We need the block argument of the DomSuccessBB.
We need the file path, so there has to be a location.
We need the length of the year to figure this out, so find Tishri 1 of the next year.
We need the length of the year to figure this out, so find Tishri 1 of this year.
We need the loop in case the first pattern-character in the candidate is not the first character in the pattern.
We need the orinal image with each safe neoghb.
We need the reply object in order to abort it later on.
We need the same accessor on both.
We need the start of a value here now...
We need their structure to determine whether we'll be bridging or upcasting the key and value.
We need this even if there is no function body to detect argument name duplication.
We need this initialization to be done late so that ICU's dynamic initializers have had a chance to run, which is important if we've linked against a static libICU.
We need this to make sure that we insert a release in the appropriate locations to balance the +1 from the creation of the partial apply.
We need to access the type metadata for the fields, which could lead to infinite recursion in recursive types if we build the field type accessor during metadata generation.
We need to add logic to tracelet analysis to deal with this properly.
We need to advance the start offset, and continue.
We need to allocate it in such a way that a single efree(varargs) in the caller will free all relevant memory.
We need to allocate the object ourselves.
We need to apply all argument clauses.
We need to ask for the right kind of specialization, so grab it from origTc.
We need to assert this up here before we possibly call compact (which will cause m_used to change)
We need to balance the consumed argument of the new partial_apply in the specialized callee by a retain.
We need to be able to install a handler (from any extension, generally) as we also need to be able to print stack traces on errors/exceptions.
We need to be able to perform qualified lookup into the given declaration context.
We need to be able to perform qualified lookup into the given type.
We need to be able to perform unqualified lookup into the given declaration context.
We need to be able to reclaim the function prologues once the unit associated with this function is treadmilled-- so record all of the callers that will need to be re-smashed
We need to be careful about mapping 'raw' argument type variables to parameter tuples containing default args, or varargs in the first position.
We need to be known safe over all increments/decrements we are matching up to ignore insertion points.
We need to be smarter about whether there's enough structure in the type to produce an interesting binding, or not.
We need to blot pointers we remove after processing an individual pointer so we don't process pairs after we have paired them up.
We need to borrow the base here.
We need to change the calling convention later.
We need to check AttrTrait on the function in case it came from a pre-flattened trait (that doesn't count as a constructor).
We need to check for a dynamic property with this name.
We need to check whether we are switching to a database that was not part of the connection string.
We need to cleanup the MatchedRelease on return.
We need to consider how reachability from the heap can affect this.
We need to construct a linked list of GenericParamList.
We need to construct the pc of the fcall from the return address (which will be after the fcall).
We need to convert the source element to the destination type.
We need to create a semaphore and a thread.
We need to create an executable with the repo embedded in it.
We need to create an object without initialization (constructor call), and set the fetched fields as dynamic properties on the object prior calling the constructor.
We need to deduce a file name.
We need to determine if this function is a static function or a member function.
We need to determine if we performed any partial merging of insertion points.
We need to do the calculation instead of just setting it to jeAllocated because of the MaskAlloc capability.
We need to do the same.
We need to do this before a native function calls into a C library compiled with -fomit-frame-pointer with the intention of having it call back.
We need to do this before trying to remove any dead arguments that we added since otherwise the number of incoming values to the phi nodes will differ from the number of values coming
We need to do this in case a __destruct method reenters and accesses this Vector object.
We need to do this in forward order before we decref in backward order because extendStack will end up with values that are of type StkElem TODO(#6156498).
We need to either decref or release.
We need to emit the debug info for the function arguments after the function prologue, after the initialization.
We need to ensure these units end up mergeOnly, at runtime there are things that assume this (right now no other HHBBC units end up being merge only, because of the returnSeen stuff below).
We need to exclude interfaces like ConstSet.
We need to expand all implied conformances before we can find those conformances that pertain to this declaration context.
We need to expand all implied conformances to find the complete set of protocols to which this nominal type conforms.
We need to expand and resolve all conformances to enumerate them.
We need to figure out the left/right padding lengths.
We need to fill this with the length
We need to finish the previous chunk by writing a TombHash at the end, if there is enough space.
We need to fix up the main trace-- if a function can reenter we need to be sure that we've adjusted its BC marker so that it doesn't stomp on the stack
We need to fixup the parameter numbers on the parameters.
We need to form an argument label, despite there being no argument
We need to free the state unnamed local in order to fall through any future finallies correctly
We need to get things into an appropriate state for handleStackOverflow to be able to synchronize things to throw from the PC of the caller's FCall.
We need to handle PatternBindingDecl as a special case here because its attributes can only be retrieved from the inside VarDecls.
We need to handle dynamic member references, which wrap the function type in an optional.
We need to handle the Self return type.
We need to handle the special case where attributes semantically attach to enum element decls while syntactically locate before enum case decl.
We need to handle this.
We need to have an array element type that is not calling a deinit function.
We need to have generic parameters here.
We need to independently retain the value.
We need to initialize ObjC protocols in inheritance order, parents first.
We need to initialize it before anyone tries to use it.
We need to insert a store later.
We need to inspect the right hand side and figure out what it was first.
We need to intercept the start routine in order to make sure each thread has a MemoryManager.
We need to iterate through the pattern, searching for the ending delimiter, but skipping the backslashed delimiters.
We need to iterate to find out the actual size, since kNamedLocalDataType elements in the array may have been set to KindOfUninit.
We need to keep going because ctx may define a private property with this name.
We need to keep going because ctx might define a private method with this name.
We need to keep track of both the frame actrec and our current depth in case the client passed us a depth
We need to know how to replace the call by reference counting instructions.
We need to know that the cast will succeed.
We need to let the ObjC runtime clean up any associated objects or weak references associated with this object.
We need to look at the destination block to figure this out.
We need to look for a default constructor.
We need to loosen_statics and loosen_values on instance properties, because the class could be unserialized, which we don't guarantee preserves those aspects of the type.
We need to lower function and metatype types within tuples.
We need to maintain the invariant that if there are any strong iterators bound to arrays, one of the bindings is in slot zero.
We need to make a stored rawValue or storage type, and a computed one of bridged type.
We need to make an array containing all the arguments passed by the caller and put it where the second argument is.
We need to make sure that the array container is not aliased in ways that we don't understand.
We need to make sure the Objective-C runtime has initialized our class.
We need to make sure they have the right scope.
We need to mark DefInlineFP as both loading and storing the entire stack below its frame because it may have been pushed.
We need to merge the type for every property in the class hierarchy.
We need to move proxy-array.cpp to ext_zend_compat/hhvm before the Zend headers can be included.
We need to move the stackpointer in case LdObjMethod calls a destructor.
We need to move the stackpointer incase LdArrFuncCtx calls a destructor.
We need to open a new file under a mutex.
We need to open-code if there's an abstraction difference in the result address.
We need to pad the strings out like a real matrix.
We need to perform a final type analysis before we do anything else.
We need to place Phis for this block.
We need to pop the cell that was on the stack for the conditional jump.
We need to preserve any phidefs in the forwarding block if they're present in the original destination block.
We need to preserve them in the new pre_header, so we have to keep the same instruction.
We need to process it _only_ if we decide to break.
We need to produce the value at +1 if it's going to be consumed.
We need to pull the generic parameters from the callee's interface type back into context because NecessaryBindings speaks in terms of archetypes.
We need to push the unwinder value and then side-exit to the next instruction.
We need to put this where the first argument is
We need to replace this with the *value* of the incoming block(s).
We need to reprocess these exits if we end up pushing parentFp into its respective exit traces.
We need to retain the parameter if: - we received at +0 (either) and are passing as owned - we received as unowned and are passing as guaranteed
We need to return a pair of values here: - the first one is the actual result of the devirtualized call, possibly casted into an appropriate type.
We need to revisit the hasPrivateAncestor code if we start being able to look up methods on interfaces (currently they have empty method tables).
We need to run the iterative data flow on the function.
We need to save any of its parameters that we care about in the second phase ahead of time.
We need to save the original Apply-Witness users because we'll be adding new users and we need to make sure that we can find the original users.
We need to see a store back to the inout on every exit path.
We need to separately store the value type because we always / use the same type to store the weak reference struct.
We need to set /some/ target for them, so point them here.
We need to set the EOF at r_paren, to prevent the Lexer from eagerly trying to lex the token beyond it.
We need to sink the instruction, then add arguments for each predecessor.
We need to spill the return registers around the assert call.
We need to split any edge from a non cond_br basic block leading to a exit block.
We need to split the critical edge to create a frontier instruction.
We need to step over this opcode, then grab the created AsyncFunctionWaitHandle and setup stepping like we do for OpAwait.
We need to store the child calls so we don't have to find them again in writeCacheGrindFrame.
We need to store to a local after doing some user-visible operations, so don't go down this path for pseudomains.
We need to take special care not to directly contract parameter binding constraints if there is an inout subtype constraint on the type variable.
We need to throw an exception, so this needs to be sent manually
We need to transitively ensure that any stores initializing the result that are visible to us are visible to callers.
We need to translate into a temporary.
We need to turn on InSILBody to parse SILDeclRef.
We need to turn on InSILBody to parse the function reference.
We need to turn things into R flavors since opcode that followed the call are going to expect that flavor.
We need to unique by both size and alignment.
We need to unset the state unnamed local in order to correctly fall through any future finally blocks.
We need to update SSA if a value duplicated is used outside of the duplicated block.
We need to update ssa if a value is used outside the duplicated block.
We need to update the callsite to pass in the correct / arguments.
We need to use the lvalue logic.
We need to verify that the result type is the same in the dominating checked_cast_br, but only for non-exact casts.
We need to walk the original parameter types in parallel because it only counts for 'rethrows' purposes if it lines up with a throwing function parameter in the original type.
We never ask for anything else than DOUBLE, LONGLONG and STRING so in the case we get something else back something is really wrong
We never emit constructors in protocols.
We normally maintain the invariant that the region surrounding the current brk is mapped huge, but we don't know yet whether huge pages are enabled for low memory.
We normally reject unbound types in IR-generation, but there are several occasions in which we'd like to mangle them in the abstract.
We now have the path to the shared lib, move to the parent 'lib' path.
We now know closest, but first try to allocate exact
We now know that all incoming values, other than NoPayloadEnums, are FirstIV after trivially stripping RCIdentical instructions.
We now know this protected method is accessible, but we need to keep going because ctx may define a private method with this name.
We now know this protected property is accessible, but we need to keep going because ctx may define a private property with the same name.
We now that the block is guaranteed to be executed.
We occasionally end up with disjunction constraints containing an original constraint along with one considered with a fix.
We omit the code completion token if it immediately follows the module identifiers.
We only accept a user if it is an ARC object that can be removed if the object is dead.
We only accept single uses.
We only actually return callToExit to our caller if that caller is dispatchBB().
We only allow a single trailing closure on a call.
We only allow specialization on classes that can't be overridden for now.
We only apply this rule when it isn't a back_edge_preds because we always want a Phi involved in loops.
We only break once per location.
We only call iter_rewind() if m_pos is not the canonical invalid position.
We only care about Objective-C protocols.
We only care about a subset of extended type constaints: typevar, nullable, soft, return types.
We only care about consistency if there is a possible return from this function along the path starting at this successor bb.
We only care about designated initializers.
We only care about intra-module dependencies.
We only care about nested types that haven't been resolved.
We only care about required or designated initializers.
We only care about the representative.
We only care about the stack component, since we only optimize the case where we don't need to reenter.
We only change the condition to be NewEITI instead of all uses since EITI may have other uses besides this one that need to be updated.
We only checked that our delegate is an object, but we can't get into this situation if the object itself isn't a Generator
We only consider ObjectData* for equality (not a Class*) so if either is an object these are not considered equal.
We only consider the argument effects if the argument aliases V.
We only do it once here (unlike in the fast path) because the scheduler drops the other reference.
We only do one of 1) or 3), but we have to do them in the right order with respect to 2).
We only do the optimization for stack promoted object, because for these we know that they don't have associated objects, which are _not_ released by the deinit method.
We only do this as a second pass because the first pass we just did may return something of obviously non-function-type.
We only do this check while compiling, or if any of the magic files were not compiled.
We only do this to remove dead arguments.
We only emit aliases for definitions.
We only emit diagnostics for API unavailability, not for explicitly weak-linked symbols.
We only emit one error per location as a policy decision.
We only ever look into singleton tuples on the RHS if we're certain that the LHS isn't also a singleton tuple.
We only execute this for opcodes which invoke more PHP, and that does not include switches.
We only handle StructInst and TupleInst being stored to a global variable for now.
We only handle a single SILBasicBlock for now.
We only handle a very simple pattern here where there is a single predecessor to the block, and the predecessor instruction is a try_apply of a throwing delegated init.
We only handle functions from here on.
We only handle load and copy_addr right now.
We only handle loadable types.
We only handle pointers to objects.
We only handle simplification of static function references.
We only handle strong_release and destroy_addr here.
We only handle structural errors here.
We only handle the "if let" case right now, since it is vastly the most common situation that people run into.
We only handle the case where one or more bind expressions are subexprs of the optional evaluation.
We only handle the most common cases.
We only handle the simplest decl binding.
We only handle the situation where there is exactly one candidate here.
We only handle those cases.
We only have a single instruction, so just become it.
We only have a witness/requirement pair if exactly one of the declarations comes from a protocol.
We only have tag bits if we spilled extra bits.
We only have to do that if it's a type from another file, though.
We only hoist out of loops if 'all' array.props call can be hoisted for a given loop nest.
We only know how to hoist inout, owned or guaranteed parameters.
We only know how to split structs and tuples...
We only know we can simplify if the switch_enum user is in the block we are trying to jump thread.
We only look at autogenerated copy_addr's.
We only look at value witnesses.
We only move instructions with a single use.
We only need a different failure block if the cast consumption requires us to destroy the source value.
We only need materializeForSet in type contexts.
We only need the retain/release for the guaranteed parameter if the call could release self.
We only need to apply the payload operation if the enum contains a value of the payload case.
We only need to check the class constraint for metatype casts where no protocol conformance indirectly requires the constraint for us.
We only need to clone the BB if not all of its predecessors are in the same group.
We only need to do something here if the declaration context is somehow generic.
We only need to do this because the implicit constructor is added before all the properties are type checked.
We only need to do this if m_pos is nonzero and is not the canonical invalid position.
We only need to do this when the underlying type is not an object, since only int and string can be enums.
We only need to emit witness tables for base NormalProtocolConformances.
We only need to handle this for self props, because we don't track static-ness on this props.
We only need to perform this check for classes.
We only need to schedule the string.concat invocations.
We only need to set interface vtables for classes that can be instantiated and implement more than 0 interfaces.
We only need to set this flag so Repo::global will let us access it.
We only pair mutators for now.
We only populate s_funcIdToClassMap when EvalPerfDataMap is true.
We only process basic blocks for now.
We only really need to do this when there's a non-trivial set of conformances, but we can't determine that just from this decl: the associated type might gain conformances in a refining protocol.
We only require IEEE, IBM, or VAX double-precision arithmetic (not IEEE double-extended).
We only reuse an existing project_box if it directly follows the alloc_box.
We only store the min and max offsets, and we will take a decision later, when the base value will be known.
We only substitute for substitutable types and dependent member types.
We only substitute into archetypes for now for protocols.
We only support NEAREST for MULTIPLE right now
We only support a maximum 32-bit instance size.
We only support classes.
We only support simple closures where a partial_apply or thin_to_thick_function is passed a function_ref.
We only take this path for That means everything except non-generic nominal types.
We only trace through unconditional jumps and conditional jumps with const inputs while inlining.
We only track two kinds of uses for delegating initializers: calls to self.init, and "other", which we choose to model as escapes.
We only traverse the type-checked form, unless we haven't populated it yet.
We only try to remove mid-block unreachable code if we're not in an FPI region, because it's the easiest way to maintain FPI region invariants in the emitted bytecode.
We only want positive step values.
We only want to look at explicit constructors.
We only want to perform closure specialization if we know that we will be able to change a partial_apply into an apply.
We only want to return an incomplete object as a last resort, so let's look for any possible definitions of this type elsewhere.
We originally planned to do this from the get-go, but threading that through turns out to be kind of annoying and of questionable value, so just doing this for now.
We override more than one declaration.
We override this function to avoid assertion failures.
We pad ephemeral stubs unconditionally.
We paired up decls from two different modules, so either we still infer as a getter with no setter, or we cannot be a property
We parse it last, though, to make sure that it can use decls from other files in the module.
We parsed the brace statement as a closure.
We parsed the condition as a CallExpr with a brace statement as a trailing closure.
We pass in false here since we need to signal to eraseInstFromFunction to not add this instruction's operands to the worklist since we have not initialized the worklist yet.
We pass the Offset in the third argument register.
We perform dead store elimination in the following phases.
We perform redundant load elimination in the following phases.
We perform these coercions first because they are often the first step in a multi-step coercion.
We pop from the end of the list to avoid tricky iterator invalidation issues.
We populate the name and nullable field of the alias directly from the specified type constraint and derive the AnnotType from the compute AnnotType in the constraint.
We populate this set when / we compute the genset and killset.
We post initOnJSVMThread here so that the owner doesn't have to wait for initialization on its own thread
We pre-allocate a couple of important cases.
We prefer to print the type separately.
We preregister all the labels occurring in the provided statement ahead of the time.
We preserve loop info and the dominator tree.
We preserve the dominator tree.
We print all comments before the first line of Swift code.
We print tuples as "(x, y)".
We process an "extended" loop at a time: all the natural loops that share a particular header block.
We process the loop tree preorder (top-down) to hoist over the biggest possible loop-nest.
We processed this succ and its fp is already the same as pred
We produce better diagnostics when we don't force the self type down.
We profile generic IncRefs to see which ones are unlikely to see refcounted values.
We provide macros for accessing buffer states in case in the future we want to put the buffer states in a more general "scanner state".
We pulled a lookahead token, we need to remove it from the lookahead store
We purposely process the inlined body after inlining, because the inlining may have exposed new inlining opportunities beyond those present in the inlined function when processed independently.
We push the right hand side on the stack only if the base is an array, object or emptyish.
We put a fake return value on the stack for the same reason that returning from a resumed function does.
We put retranslate requests at the end of our slab to more frequently allow conditional jump fall-throughs
We put the 'newValue' argument before the subscript index list as a micro-optimization for Objective-C thunk generation.
We put the version info first, so future versions can easily change header info.
We raise a notice to let the user know that there was a type mismatch and that an implicit conversion was performed.
We raise the refcount around the call to __destruct().
We ran off the end of the buffer, but no end label has been found.
We re-use the histogram space as an "inverse color map", essentially a cache for the results of nearest-color searches.
We reached a user of CurrentDef.
We reached the EndBlock but didn't find a place for the deallocation so far (because we didn't find all uses yet or we entered another stack alloc-dealloc region).
We really don't like matches that don't start at a token.
We really don't like not matching at token starts, but if it's a long match give some credit.
We really want to eliminate unchecked_take_enum_data_addr.
We recommend keeping 6 bits for G and 5 each for R and B.
We recompute the final post dom release since we may have moved the final post dominated releases.
We recover the witness table from the substitution that was used to produce the substituted callee type.
We recursively walk down the LHS, building up index chains and copying them into the top-level list as we reach the leaves of the tree.
We reduce the benefit if the caller is too large.
We reduce the number of possible / inputs by replacing values that are unlikely to be a canonical values.
We refer to / this map to determine the appropriate parent TRC to use when / walking the accessor function.
We referenced an lvalue.
We registered the control target before.
We reject putting a label on something inappropriate in parseStmt().
We relook up our the states for our predecessors to avoid memory invalidation issues due to copying in the dense map.
We rely on Loop canonicalization to separate such loops into separate nested loops.
We rely on the SIL CFG here, because unemitted shared case blocks might fallthrough into this one.
We rely on the region selector to decide which arcs are appropriate to include in the region.
We rely on this side-effect in RepoAuthoritative mode right now, since the stat information is an output-param of resolveVmInclude, but we aren't really going to call stat.
We remember the applyinst as the super.init site, not the upcast.
We remove common factors of powers of 2 from relevant quantities.
We remove the IncRef before the control flow split, and insert new copies on the next and taken sides.
We remove the IncRefs for each incoming node, and insert a new one after the join point.
We replace / values that come from basic block arguments with the caller values and / strip casts.
We represent this with the PostElem base location with locType TTop.
We require SIL instructions to be at the start of a line to assist recovery.
We require a valid range in order to be able to query for the TRC corresponding to a given SourceLoc.
We require objectType to be a pointer type so that the GEP will scale by the right amount.
We require substitutions.
We require the memory stack is always at least as big as the irSPOff, unless irSPOff went negative (because we're returning and have freed the ActRec).
We reserve the bottom page of each stack for use as the surprise page, so the minimum useful stack size is the next power of two.
We reset it as not all options set a string as replset name
We reset the empty-input-file flag for each image, but we don't clear the input buffer.
We reset the name as the server responded with a different name than what we thought it was
We resolved this type witness one way or another.
We retain the brace statement that the user wrote, but actually model this as if they wrote:
We return ints (and, sometimes, actual doubles).
We returned from the top VM frame in this nesting level.
We reuse the same storage for the return value as the yield (`m_value`), so doing a blind read will cause `current` to return the wrong value on a finished generator.
We reuse these variables, they iterate over all pixels in the row.
We reuse this variable, it iterates over all pixels in the row.
We rotated a loop if it has the following properties.
We run multiple trials so that "a_b_c_abc" / matching "abc" is matched on the "abc" part / instead of the "a_b_c" part.
We run multiple trials so that "a_b_c_abc" matching "abc" is matched on the "abc" part instead of the "a_b_c" part.
We run one pessimistic data flow to do dead store elimination on the function.
We run this before any other passes because it allows code-gen to create things like self-copies or self-lea's without affect on optimizations downstream.
We save m_file in m_prevFile and leave it open for an entire period.
We saved the lexer position after it, so we should not be getting it.
We scale relevant quantities using O(log2(k)) rather than O(k) multiplications.
We scheduled all of the files that have actually changed.
We search exception edges first in a weak attempt to put exception blocks later in the final reverse-postorder numbering, but it shouldn't matter and anyone counting on that has a bug.
We separate the work in two phases: analyse and transform.
We serialize shared_external linkage as shared since:
We set ad's internal cursor to point to the next element to conform with PHP5 behavior
We set it now, based on PATH_TRANSLATED.
We set m_shutdown here because if the transport reenters and attempts to write we will put the socket in a very bad state and fail all in flight data.
We set the "debugger interrupt" flag to ensure we interpret code rather than entering translated code, and we set the "debugger signal" surprise flag to pop out of loops in translated code.
We set the initial state of unreachable block to 0, as we do not have a value for the location.
We set the low bit for two reasons: the Class* will never be a valid Class*, so we'll always miss the inline check before it's smashed, and handlePrimeCacheInit can tell it's not been smashed yet
We set the store bit at the end of the basic block in which a stack allocated location is deallocated.
We set this function to highly profitable if we have a O2G on one of its parameters or results.
We set to Uninit all locals beyond any params and any closure use vars.
We share type infos for different instantiations of a generic type when the archetypes have the same exemplars.
We shift and cap it to be in the range the Android logging method expects.
We should (a) see if there's a cheaper way to keep it up to date, and/or (b) see if we can fast-path cases where there's no ObjC involved.
We should always be able to find the parent.
We should always have a global data section in RepoAuthoritative mode, or the repo is messed up.
We should always have a value here.
We should be able to enforce that these arguments are always still expressions.
We should be able to recursively delete all of the remaining instructions.
We should be able to use DECLARE_FRAME_POINTER here, but that fails inside templates.
We should be looking at the SDKSettings.plist.
We should be using "void *" but there are still machines that don't understand it.
We should bring it back when we have those optimizations.
We should consider adjusting our current approach to unlock more opportunities for subtype contractions.
We should either be returning to enterTCExit, or to a jmp to enterTCExit.
We should either create a new kind or rename the code-completion kind to something more general.
We should either have parentheses or a tuple.
We should explicitly add the swift AA pass after the other ones.
We should fall back to display the original PHP text, if there.
We should figure out how to safely / put extension methods into the class vtable.
We should have already emitted these diagnostics when we process the callee function prior to inlining it.
We should have another way to specify a build record and where to put intermediates.
We should have checked earlier that AI has an owned result value.
We should have handled the cases where there are no significant conditions in the early exit.
We should have handled the payload case either in extra inhabitant or in extra tag dispatch by now.
We should have one canonical representation of Bottom.
We should have set up the conformance during validation.
We should have skipped this conditional destroy by now, oops
We should have the location populated by the enumerateLSLocation at this point.
We should have visited all its children when we marked it as dead.
We should implement our own version that we can rely on to continue to work that way.
We should include the Decl* in the DiagnosticInfo and have a way for Xcode to handle this "points-at-a-decl-from-module" location.
We should just implement visitOverloadedDeclRefExprs and nuke this.
We should know about archetypes corresponding to opened existential archetypes.
We should never be emitting a metadata accessor for resilient nominal types outside of their defining module.
We should never break out of a function, therefore there should always be a parent
We should never have any registered RequestEventHandlers.
We should never have null func pointers to deal with
We should never import an ObjC method as returning a tuple which would get broken up into multiple results like this.
We should never require phis going into a catch block, because they may not have multiple predecessors in HHIR.
We should never see the OpenCL builtin types at all.
We should never see these unadorned.
We should never try to initialize one in the compiler.
We should not be called with ForDefinition for nominal types that require in-place initialization.
We should not be doing more serious work along this path.
We should not be emitting accessors for partially-substituted generic types.
We should not end up here if the enum constructor call is fully applied.
We should not have the case which retains have to be anchored topdown and releases do not have to be bottomup, or vice-versa.
We should only end up in this path for local and global variables, i.e. ones whose lifetime is assured for the duration of the evaluation.
We should only ever const prop for FPassL right now.
We should only ever get ObjC pointers, not underlying objects.
We should only ever get function pointers.
We should output to a temporary file, since we're not at the top level.
We should probably have a nominal type for these, just for type safety reasons.
We should probably unify this checking for deployment-version API unavailability with checking for explicitly annotated unavailability.
We should query a (lazily-built, cached) module graph to determine shadowing.
We should really change the test so that prints out the path elements top down the path, rather than constructing all of these intermediate paths.
We should really just change that, but that's an annoying change to make to Clang right now.
We should really just have a PatternBindingStmt.
We should retain the associated type throughout.
We should return NULL instead
We should seek a more holistic fix for this.
We should treat both open and close brackets equally
We should understand what effect that may have on code completion.
We should use WitnessTableBody.
We should use an optimized PartialSolution structure for that use case, which would optimize a lot of stuff here.
We shouldn't be inlining profiling translations.
We shouldn't care about this, because we shouldn't have to do this at all.
We shouldn't emit global value witness tables for fixed-layout types.
We shouldn't emit global value witness tables for generic type instances.
We shouldn't emit value witness symbols for generic type instances.
We shouldn't ever register disjunction choices multiple times, but saving and re-applying solutions can cause us to get multiple entries.
We shouldn't ever register opened types multiple times, but saving and re-applying solutions can cause us to get multiple entries.
We shouldn't get two synthesized conformances.
We shouldn't have anything else left in our name for typeID
We shouldn't have to import everything to get at the individual constants.
We shouldn't try to coerce existential when there is no existential upcast to perform.
We simplify cases where there is a single use of the argument that is an extract from a struct or tuple and where the predecessors all build the struct or tuple and pass it directly.
We simply assume that by the end of the delay no threads should be still referencing m_prevFile and we can safely close it.
We simply return as a OF_CLASS with class name set to 'callable'.
We simply use the top of stack of the previous VM frame (since the ActRec, locals, and iters for this frame do not reside on the VM stack).
We skip the SpecializationPassID since it does not contain any information that is useful to our users.
We skipped over the only VM frame, we're done.
We sometimes call this while curFunc() isn't really the builtin, so make sure to record the sync point as if we are inside the builtin.
We sometimes want to inline this slow path, too.
We sometimes want to print the accessors abstractly instead of listing out how they're actually implemented.
We special case super.init calls since they are part of the object lifecycle.
We spell normal metatypes of existential types as .Protocol.
We split these out into alteredAnt, and alteredAvl.
We split this out into AvlLoc (can be moved to the end), and DelLoc (can be deleted if its anticipated out).
We splitted critical edges.
We start by builing up a vector of Label* that we'll use for the Switch instruction and/or for conditional branches.
We statically know whether we have extra tag bits.
We still get correct behavior in these cases, so it works out okay.
We still have to add the last parser host/port combination though:
We still have to tell the underlying DateTime the timezone incase they call setTimestamp or something else later
We still model these specifiers as attributes.
We still need a discriminator, so keep going.
We still need to check if ctx defines a private property with the same name.
We still need to clear the bit so handleSlowPath can tell it was smashed, though.
We still need to consume the original block if it was owned.
We still need to update the type of the local for new minstrs, and for the exception edge of old minstrs.
We still want the fallthrough and prediction logic, though.
We still want to allow unavailable references, though.
We still want to respect the global translation limit and other restrictions, though.
We store the free list pointers right at the start of each object (overlapping whatever it's first word holds), and we also clobber _count as a free-object flag when the object is deallocated.
We store these locally so that we do not continually check if the function is external or not.
We strip off the first colon, but aside from that we do not mangle the XHP name.
We subtract one since this will be the number of the first new argument AFTER* we remove the old argument.
We subtract the number of parameters with default value at the end
We successfully translated the instruction, so update env.sk.
We support having either a SourceLocTable or a LineTable.
We suppress this warning when compiling for playgrounds because the developer cannot cannot explicitly set the minimum deployment target to silence the alarm.
We swap out the Closure object stored in m_this, and replace it with the closure's bound Ctx, which may be either an object or a class context.
We sync the VM registers here, then optionally use a landing pad, which is an exit trace from hhir with a few special instructions.
We take advantage of this during the parse phase to reduce very simple expressions down to a single scalar and keep the parse tree smaller, especially in cases of long chains of binary operators.
We take advantage of this in pure_load to bump the lower bound to at least one (if they weren't all in one set, we'd not be able to do that without violating exclusivity of lower bounds).
We take bits starting from the most significant.
We take format as a variant in order to get the right conversion failure notice (as opposed to parameter typehint warning)
We take over recursive walking of assignment expressions in order to walk the destination and source expressions in different member access contexts.
We take the first value.
We the unresolved member has an argument, turn it into a subpattern.
We then add some extra slack for safety.
We then teleport the object onto the stack as the first local after the params.
We then try to remove the original closure.
We thus take an optional of the properties type.
We timed out without receiving events.
We track the highest position at which a spill slot was owned, and only reassign it to a Vreg if its lifetime interval (including all splits) is strictly above that high water mark.
We translate each unit's filename to a canonical format, which is slow, but necessary.
We treat "unowned" as "assign" (even though it's more like "safe_unretained") because we want people to think twice about allowing that object to disappear.
We treat ::class as a class constant in the AST and the parser, but at the bytecode and runtime level it isn't one.
We treat class initializers as part of the constructor for profiling.
We treat it as a foreign class (like a CF type) because it doesn't have a real public class object.
We treat ref_element_addr like a load (see NodeType::Content).
We treat the condition as part of the true args.
We treat the declaration as deprecated if it is deprecated on all deployment targets.
We treat the new inner type as a prediction because it will be verified the next time we load from the box.
We treat type-checking a PatternBindingDecl like type-checking an expression because that's how the initial binding is checked, and they have the same effect on the file's dependencies.
We tried to override a convenience initializer.
We truncate to FBSYSTRACE_MAX_SECTION_NAME_LENGTH just to make sure we can avoid the overflow check even if the caller passes in something bad.
We try every route and assert they are all the same here.
We try to reuse the type checker associated with the ast context first.
We turn this on in case we'd be omitting a warning after constant-folding array_fill_keys.
We typically generate more efficient code with separate jump-on-overflow.
We understood all terminators, return true.
We update the parameter list to remove the parameter for the / closure argument and to append the variables captured in the closure.
We update the predicted type for boxed local values in some special cases to something smart.
We use "index chains" to deal with nested list assignment.
We use 'constexpr' to verify that this is / emitted as a constant.
We use -1 as an invalid id.
We use 2 instead of 1 to avoid an immediate realloc on the next call.
We use 32 bits to represent offset into a chunk, so don't make it too large.
We use SILOneValueOneOperandLayout where the field decl is streamed as a ValueID.
We use SelfObjectOfProtocol because an existential Boolean is allowed as a condition, but Boolean is not self-conforming.
We use UnboundGenericType to find the normal conformance.
We use VarDecls and SubscriptDecls to produce completions that refer to getters and setters.
We use a DFS order, always processing the left leafs first so that we match the order in which we will lay out arguments.
We use a DenseMap over what are essentially StringRefs instead of a StringMap because we don't need to actually copy the string.
We use a MapVector to keep the / diagnostics emission in deterministic order.
We use a StateVector because we can add new blocks during optimize().
We use a different command type for an async stack trace, so we can both send and receive different data and still keep the existing Where command unchanged.
We use a do-while loop so that we write at least 1 digit
We use a dummy type since we don't have a convenient type for 'nil'.
We use a fast path translation with a hashtable if none of the cases are numeric strings and if the input is actually a string.
We use a malloced pointer here so we don't need to expose ARCBBStateInfo in the header.
We use a malloced pointer here so we don't need to expose the type to the outside world.
We use a non-standard name for the type that states the association requirement rather than the concrete type.
We use a quick pcre_fullinfo() check to see whether cache is corrupted, and if it is, we flush it and compile the pattern from scratch.
We use a set (instead of an unordered_set) because we want a fixed and well-defined iteration order while we're accumulating the hash below.
We use a very simple protocol for communicating over libafdt: One byte for the protocol version and a second code byte.
We use a worklist for iteration to visit the blocks in dominance order.
We use an approach that tries to minimize side-channel leaks of password information - that is, we mostly use fixed-cost bitwise operations instead of branches or table lookups.
We use an assert boolean return here since in release builds we want to conservatively return false and in debug builds assert since this is a logic error.
We use an auto-generated SILLocation for now.
We use casts where findAllNonFailureExitBBs should have made sure that this is true.
We use endswith here since if we specialize fatal error we will always prepend the specialization records to fatalName.
We use explicit sizes and alignments here just in case the C ABI under-aligns any or all of them.
We use it to suppress potential unavailability and deprecation diagnostics on code that definitely will not run with the current platform and minimum deployment target.
We use it to test for regressions in the deserialization API.
We use line1 here because it seems to be working better than line0 in a handful of cases for our bytecode-source mapping.
We use line1 here because it works better than line0 in our bytecode-source mapping.
We use null patterns to mean artificial AnyPatterns.
We use null to represent a synthetic wildcard.
We use our own post-dominator tree instead of PostDominatorAnalysis, because we ignore unreachable blocks (actually all unreachable sub-graphs).
We use projection path to analyze the relation.
We use the French for closure because using the English crashes gcc in the implicit lambda capture below.
We use the RPO number of a BB as its Index in our data structures.
We use the class name in this case to ensure that the ordering is dependent only on the source program (Class* or something like that seems less desirable).
We use the column-specialization algorithm described in specializeInPlace.
We use the context emit-into initialization only for the outermost call.
We use the first argument register for the TV data because we might pass it to the native release call.
We use the first conflicting declaration in each set to perform the sort.
We use the heap object extra inhabitants over the class pointer value.
We use the original convention, except that we have an invariant that direct trivial parameters are always unowned.
We use the original convention, except that we have an invariant that direct trivial results are always unowned.
We use the selected database to construct the namespace
We use the third and fourth as scratch registers.
We use the type of the closure here since we allow for the closure to be an external declaration.
We use the version of insert() which takes an initializator list because it is more efficient.
We use these equivalence classes during register allocation to try to assign the same register to all the variables in a phi group (at least at those positions where the phi instructions occur).
We use these later to dynamically load certs, so make copies.
We use this / function to determine whether the concrete syntax already has an / availability attribute.
We use this function to determine if a subtype constraint is set / between two (possibly sugared) type variables, one of which is wrapped / in an inout type.
We use this funky loop since predecessors are stored in a linked list but we want array like semantics.
We use this lazily-filled SmallVector to do so.
We use this return value to fill the `free_until' PosVec in allocate() below.
We use this struct to track where we need to add moves to maintain continuity.
We use this to compute whether classes are defined at top-level.
We use this to detect if a variable is multiply assigned or left unassigned.
We use this to make sure that we do not handle call sites with multiple closure arguments.
We use this workQ containing (prev, cur) to delay one side.
We use tiling approach to work-around Qt software rasterizer bug when dealing with very large paint device.
We visit all instructions starting at the allocation instruction.
We visit the loop nest inside out via a depth first, post order using this worklist.
We wait to raise warnings until after all the locals have been initialized.
We walk the use chains of the self MUI to find any accesses to it.
We walk through statements.
We walked all the way up to the root without finding the declaration, so this is not a capture.
We want "dynamicCastFailure" to appear in crash logs even we crash  during the diagnostic because some Metadata is invalid.
We want a string now...
We want all instances of a generic enum to share an implementation strategy.
We want all our pointers to be kMinBytes - 1 byte aligned.
We want const qualifiers on various index data structures for php object pointers, but during index creation time we need to manipulate some of their attributes (changing the representation).
We want factored exit edges from the fault funclets to any of these enclosing catch blocks (or other enclosing funclet blocks).
We want it to look like a substitution of the appropriate clause from the original type.
We want the above, conformance-based result to be the only viable path.
We want the branch to point to whichever side has not been explored yet.
We want the flow command to complete on the thread that starts it.
We want the frame of our callee's callee
We want the ini map to be freed after processing and loading the options So put this in its own block
We want them to be replace even if we can't fully propagate the constant.
We want to add a new use of `t1' and delete the LdLoc.
We want to avoid full typechecking for all files.
We want to be able to associate the parent of this expression with the ultimate callee.
We want to break any ties in favor of green, then red, blue last.
We want to copy the elements and the hash separately, because the array may not be very full.
We want to decompose the parameters to handle them separately.
We want to determine whether our own extension has already been included in the lookup table.
We want to do this as early as possible because any allocations before-hand will get a generic unknown type type-index.
We want to do this first so that we can treat the rest of the bindings as inherently successful if we don't have a guard.
We want to duplicate small blocks that contain a least on release and have / multiple predecessor.
We want to emit the arguments as fully-substituted values because that's what the specialized emitters expect.
We want to ensure that all code blocks are close to each other so that we can short jump/point between them.
We want to get bb2 as immediate post-dominator of bb1.
We want to give the old server plenty of time to shut down all of its satellite servers.
We want to handle stacks partially specially, because they can be expanded in some situations even if they don't have an ALocMeta.
We want to import the signature of the exit(3) libc function as "func exit(Int32)", not as "func exit(CInt)".
We want to inline away as much of this as we can
We want to inline the argument to an array.uninitialized call, because this argument is most likely a call to a function which contains the buffer allocation for the array.
We want to keep profiling translations to basic blocks, inlining shouldn't happen in profiling translations
We want to keep this data structure small since we need a huge number of them during a profiled run.
We want to know when it starts happening:
We want to maintain the canonical form of a single return where possible.
We want to minimize the PHP code we run while propagating fatals, so we do this check here on a very common path, in the relatively slower case.
We want to parse them anyways for proper diagnosis.
We want to print a newline before doc comments.
We want to process (name bind, type check, etc) decls one at a time to make sure that there are not forward type references, etc.
We want to raise the exception from the caller's FCall instruction in the second case, and in the first case we have to raise in a special way inside this re-entry.
We want to recognize most of these types by name.
We want to recompile if the llvm pipeline of the compiler changed.
We want to remove "file://" if it exists.
We want to replace dead terminators with unconditional branches to the nearest post-dominator that has useful instructions.
We want to start fresh.
We want to synchronously shut down our satellite servers to free up ports, then asynchronously shut down everything else.
We want to track if the generic context is represented by a class-bound existential so we won't inappropriately wrap the self type in an inout later on.
We want to treat distinct but IEEE-equal values as not equal.
We want to use this native / thunk where we expect to be calling an allocating entry point for an ObjC / constructor.
We want token IDs to remain stable regardless of how we change the internals of the parser.
We we pretend that the query was positional even if it was named so that we fall into the named rewrite case below.
We were able to fold, so all users should use the new folded value.
We were called via re-entry.
We were looking up __construct and failed to find it.
We were not able to remove the condfail.
We were told to output nothing, so get the last mode option and use that.
We will always allocate the table, even though there may be no named subpatterns.
We will be adding foreign results (from another sink) into TargetSink.
We will be also discarding stack temps.
We will be doing an intersection with all of the other BB.
We will check in checkSafeArrayAddressUses that all initialization stores to this variable are safe (i.e the store dominates the loop etc).
We will check later if the actual callee passes self at +1 later when we know its actual type.
We will combine the version ranges from these annotations with the TRC for the valid location to overapproximate the running OS versions at the original source location.
We will compute the state of this loop now.
We will dedupe with last-one-wins semantics by walking backwards and including only those whose dedupe key we have not seen yet, then reversing the list
We will definitely be consuming at least one operator.
We will emit a diagnostic about the property itself.
We will end up with one index chain per expression we need to assign to.
We will give it a pointer to the pref member of the TypedValue which is stored on the HHVM stack.
We will handle --help and --version ourselves in phantom.cpp
We will have no choice but to anchor the release instructions in the successor blocks.
We will have to list them all here for proper static initialization.
We will hit this case for top-level elements that do not themselves introduce DeclContexts, such as extensions and global variables.
We will inline the original function as a thunk.
We will insert release of the captured arguments here.
We will just inline them and specialize each one of the individual functions that these sorts of functions are inlined into.
We will look at all the outgoing edges from the conditional branch to see whether any other uses of the condition or uses of the condition along an edge are dominated by said outgoing edges.
We will need a phi at this block if we want to reuse this value.
We will need to delete the instruction later on.
We will never sink the hoisted releases from predecessors since the hoisted releases will be on the enum payload instead of the enum itself.
We will not do anything to it so nothing bad should happen.
We will not remove mutators if we have a might be decremented value that is not known safe.
We will probably need a struct type for that at some point too.
We will re-import and set only the constants that have been now bound to their proper value.
We will reset this value to the correct value once we return from the recursion below.
We will restrict this optimization to needles that are strings, and haystacks that have only non-numeric string keys.
We will specialize the outermost loopnest that has 'array.props' instructions in its preheader.
We will turn the latter into DebugValue.
We will unique this after we have finished processing all predecessors.
We will want to support these eventually, but we haven't figured out how this will interact with Definite Initialization, deinitializers and resilience yet.
We will warn on conflicting non-private declarations in both files.
We won't actually emit the block until we finish with the destructor body.
We won't emit the block until after we've emitted the body.
We won't emit this until after we've emitted the body.
We won't handle XLBoxes
We won't know until we see the load though.
We won't need the counters anymore.
We won't need them anymore
We won't need to create more DefInlineFP's after this, and if they're completely unused in any of these traces DCE will clean it up.
We work around that by making sure we trigger this function statically before main() starts.
We would have marked a delayed conformance as "last emitted" when it was delayed.
We would have registered a delayed function as "last emitted" when we enqueued.
We would have to do more alias analysis to be able to safely ignore one of those.
We would have to prove that something in this function is holding the weak value live across the promoted region and that isn't desired for a stable diagnostics pass this like one.
We would insert the deallocation too early, which may result in a use-after-free problem.
We would need to be smarter in our moving to handle such cases.
We wouldn't be able to perform a dynamic cast that required any ABI adjustment without a JIT though.
We'd have to buffer the response completely to compute the MD5, which defeats the purpose of chunking.
We'd infer this anyway when we look at the bytecode body (NativeImpl) for the HNI function, but just initializing it here saves on whole-program iterations.
We'd like the dump routine to be present in all builds, but it's a pretty large amount of code, most of which is not sensitive to the actual key and value data.
We'd like to look at the elements of arrays and dictionaries.
We'd like to take a look at implicit closure params, so store them.
We'd need a protocol change to have the client give us more info when it attaches.
We'd only do that anyway for types that don't guarantee the existence of a non-unique access function, and that should never be true of a resilient type with external availability.
We'd rather not have to check this.
We'll allocate it in the request local rds::s_constants instead.
We'll append the lowered capture types here.
We'll apply user conversions for operator arguments at the application site.
We'll change the parent to the function later after we've created that declaration.
We'll clean this up when the old pass is gone.
We'll copyProp and get rid of this in a later pass.
We'll diagnose these in semantic analysis.
We'll emit a Parent opcode because it can handle this error case.
We'll eventually change that.
We'll first find the enclosing CallExpr, and then do further analysis.
We'll follow strategy 2.
We'll forward the rest in the handler.
We'll generate the getter and setter when we see their FuncDecls.
We'll have already raised a notice in convert_for_pow so avoid re-raising the notice here.
We'll increment it after all that finishes.
We'll indent with 4 spaces
We'll invalidate the analysis that are used by other passes at the end.
We'll just end up passing extra arguments.
We'll just look for the first codestream at the root of the box structure and handle that.
We'll just pass undef in cases like this.
We'll keep track of how many things are in the bindings struct with its own count in the capture descriptor.
We'll leave it to DI analysis to insert the initializer call at the right place.
We'll make the IR entry block jump to this block.
We'll manually manage the argument's lifetime after the call.
We'll need to check the initializer.
We'll need to know the location of this jump later so we can patch it to new translations added to the chain.
We'll need to make this the first argument
We'll only utilize this information in the case of a potential ambiguity.
We'll pull a proxy out of the queue, ask it to cleanup which will wait for threads it owns to exit, then drop our shared reference to it.
We'll queue up all the function transforms that we see in a row and then run the entire group of transforms on each function in turn.
We'll rebuild it on demand.
We'll reconstruct the support_map vector after merging each aset.
We'll reflowTypes after we're done with all of this to get everything downstream specialized.
We'll relex from that point.
We'll resolve this somehow later.
We'll satisfy this via our handling of default definitions.
We'll set discriminator values on all the autoclosures in a later pass.
We'll set size and pos later.
We'll split the edge later.
We'll stay here until we get a command that should cause the thread to continue.
We'll treat this like a liveness problem where the alloc_box is the def.
We'll treat this like a liveness problem where the value is the def.
We'll type-check to make sure the property type matches later after validation.
We'll use that same representation type for the enum so that it's ABI-compatible.
We'll use the custom scanner if there's no guards, or if at least one of the guards is interesting.
We'll use this information during planning.
We'll use this later.
We'll visit blocks with lower reverse post order ids first.
We'll visit nested types separately if necessary.
We'll visit the EnumElementDecls separately.
We'll want to parse the #if block, but not wrap it in a top-level code declaration immediately.
We'll want to parse this from the TypeRepr when SILFunctionType loses its context params.
We're ORing with zero, do nothing
We're about to resume executing our generator, so make sure we're in the right state.
We're about to send the client an interrupt and start waiting for commands back from it.
We're about to start executing more PHP.
We're about to typecheck the index list, which needs to be processed with self already applied.
We're after the edited line range, let's test if we're synced up.
We're all done with the tails now, so throw them out
We're already checking this protocol, which means we have a cycle.
We're already running a magic method on the same type here.
We're always already a static array.
We're assigning a register to an interval with multiple ranges, but the vreg isn't live out of the first range.
We're at the end of the level "cont_level" continuations.
We're building a derived accessor on top of whatever this / class provides.
We're building a setter or something around an underlying / implementation, which might be storage or inherited from a / superclass.
We're conservative with unsets on array types for now.
We're constructing a value of nominal type.
We're constructing something else.
We're converting a pre-live actrec to a live actrec, which effectively changes some stack AliasClasses to not exist anymore.
We're converting between C function pointer types.
We're creating a dense map for a single substitution.
We're dealing with three or more containers.
We're done if there is a 'where' clause, 'else' or any other noncomma.
We're done iterating these elements.
We're done recording the solution.
We're entirely before the edited range, no update needed.
We're evaling some code for internal purposes, most likely getting the default value for a function parameter
We're exiting, so there should not be any live faults.
We're free try to choose a good position inbetween, for example block boundaries and cold blocks.
We're going to build an RValue here, so make sure we translate indirect arguments to be scalar if we have a loadable type.
We're going to capture this, compute flags for the capture.
We're going to overwrite what was there.
We're going to pretend this instruction occured in the caller, so update its marker to use the same SrcKey as the call.
We're going to produce an error below.
We're going to set the 'break' flag on our XDebugServer, and pause ourselves.
We're going to smash the return address.
We're halfway through a bytecode
We're in a fault funclet.
We're in an error path after performing a self.init or super.init delegation.
We're in the resumable we expect.
We're in the wrong thread for making a StringData so stash it in a std::string until we get to unserialize
We're increasing ref count by calling toArray, need to adjust it later
We're just using swift_once to guarantee thread safety.
We're making the expr have a function type, whose result is the same as our contextual type.
We're mapping into a type context.
We're matching one element to another.
We're more likely to see new, modern headers added to OSServices.
We're never being asked to do anything with *formal* indirect results here, just the possibility of a direct-in-SIL result that's actually being passed indirectly.
We're not actually going to modify it, so this is "safe".
We're not calling statically, so this result is unhelpful Also, it's never produced by lookupObjMethod, so it'll never happen, but we must handle all enums
We're not changing spValue while we inline, but we're changing fpValue, so this needs to change.
We're not constructing a new String, we're just using the one in traceFileVar, so this is safe.
We're not copying the tombstones over to the new array, so the positions of the elements in the new array may be shifted.
We're not getting a DeclContext everywhere we should.
We're not going to deal with requires at merge time, so drop them here, and clear the mergeOnly flag for the unit.
We're not mapping this as a member of anything.
We're not synced up, continue replacing syntax map data on this line.
We're now at the end of the string
We're now at the state before this instruction, so the stack sizes must line up.
We're only generating the module as an intermediate, so put it next to the primary output of the compile command.
We're only interested in the porperty name that points to our target
We're out of note headers.
We're parsing a conditional binding.
We're passed the affected range and already synced up, just return.
We're past the end of the buffer.
We're paused if the request thread is handling commands right now.
We're performing a single compilation (and thus no merge module step), so prefer to use -emit-module-path, if present.
We're performing a single compile and don't have -emit-module-path, but have been told to treat the module as a top-level output.
We're potentially spilling to a different depth than the unwinder would've expected, so we need an eager sync.
We're prepared to generate translations for known non-object types, but if it's Gen/Cell we're going to PUNT because it's natural to translate that case with control flow TODO(#2020251)
We're responsible for freeing the return value if we exit with an exception.
We're scanning a new file or input source.
We're starting with a SIL-lowered tuple type, so the elements must also all be SIL-lowered.
We're still at the closure definition site.
We're subtracting one in order to look up the line associated with the FCall/FCallArray instruction.
We're synced up, mark the affected range and return.
We're trying to handle this case correctly as far as the type inference here is concerned, but the runtime doesn't actually behave this way right now for declared properties.
We're trying to produce the same bytecode as runtime parsing.
We're unwilling to unify with interfaces, so just return Top.
We're using a repo generated in WholeProgram mode, but we're not using it in RepoAuthoritative mode (this is dodgy to start with).
We're using some other instruction's output.
We're working with optional types, so perform a conditional checked downcast.
We've added some members to our containing class, add them to the members list.
We've added some members to our containing class/extension, add them to the members list.
We've added some members to our containing context, add them to the right list.
We've aligned and sized the stack so that the high order bits of valid cells are all the same.
We've already completed the request at this point anyways.
We've already destroyed any instance variables initialized by this constructor, now destroy instance variables initialized by subclass constructors that delegated to us, and finally free the memory.
We've already determined we should be able to inline this, so we expect it to have happened.
We've already incReffed the array above so we don't need to do it here.
We've already inserted the requisite sync here, and have reencountered the Call while sinking a parent frame.
We've already marked the blocks reachable from the main entry point.
We've already seen at least part of this base.
We've already visited this function.
We've already walked all the children we care about.
We've been asked to skip the function body (fb_intercept).
We've been told to dump the AST (either after parsing or type-checking, which is already differentiated in CompilerInstance::performSema()), so dump or print the main source file and return.
We've been told to emit SIL after SILGen, so write it now.
We've been told to emit a module, but have no other mode indicators.
We've been told to exit.
We've been told to write canonical SIL, so write it now.
We've changed the pre-header and invalidated the dominator tree.
We've come across a protocol that is in our original list.
We've constructed a concrete value for the covering value.
We've copied all the data out, so close it out.
We've created all our regions, but we need to sort them instead of trying to get the UnitEmitter to do it.
We've done a lot of optimizations on this function, attempt to FSO.
We've encountered a redeclaration of the property.
We've exited the epilogue sequence, try to find out which parameter we have all the epilogue releases for and which one we did not.
We've found a non-option argument.
We've found a retain on this path.
We've handled the self and _cmd arguments, so when we deal with generating explosions for the remaining arguments we can skip these.
We've hit a breakpoint and now need to make sure that breakpoints won't be hit again for this site until control leaves this site.
We've hit one internal breakpoint at a useful place, or decided we don't, need them, so we can remove them all now.
We've hit the result type.
We've just been told to perform a parse, so we can return now.
We've kept our own copy of the Fault, because m_faults may change if we have a reentry during unwinding.
We've loaded the file.
We've modified the original result, so build a new one.
We've noticed that the socket has closed.
We've popped a stack element, so inform the unwinder of the current stack depth.
We've potentially created some SSATmp's (that are defined by DefLabels), which have types that depend on their own types.
We've reached a fixed point.
We've reached a null byte, now check if we're actually at the end of the string.
We've run out of replacement strings, so use an empty one
We've seen part of this base, but this is a part we've have not seen.
We've sent the client a command, and we expect an immediate response.
We've setup locales to be thread local, so this is no problem at all.
We've split critical edges so we can't preserve CFG.
We've split critical edges, so `next' and 'taken' blocks can't have other predecessors.
We've split up the release into zero or more primitive operations, delete it now.
We've strengthened the bound, so update superclass conformances.
We've unwound to the top level, so inform the consumer and drain the consumer syntax map queue.
Weak and Unowned properties are (weak).
Weak ownership implies optionality.
Weak storage types are handled with their underlying type.
Weaken protected property to public.
WebPEncode: Takes a Y, U, V data buffers (with color components U and V subsampled to 1/2 resolution) and generates the WebP string  4.
Weird hacky special case.
Weird one-off case where CGFloat is bridged to NSNumber.
Welcome to refcount-opts.
Well, first factor out this code into a separate check and report method and report from there.
What actually matters is whether it can be an empty string at all.
What really matters is a number of 2MB pages in-between.
What the user expects is a "step-in" into pseudo-main, but the implementation otherwise would just step over it.
What they actually meant is to write "is SomeType", so we rewrite it to that pattern for good QoI.
What this analysis state tells us is that every path through the program to the point of this LdLoc has provably stored `t1' to that local.
What this handles is recording the evaluation stack state at instruction boundaries so that jumps know what their stack state will be at the destination.
What this means depends on how the builtin is dealing with parameter coersion: new-style HNI builtins try to do a tvCoerceParamTo*, while older ones use tvCastTo* semantics.
What to do in state STATE-NUM.
What to ideally do for truecolor images depends, alas, on the image.
What we know for sure: B is a superclass of D1 D1 is a superclass of D2.
What we really want is to have substituted the base type into the declaration reference, so that we can compare the actual types to which two type declarations resolve.
What we save in GlobalVars is actually the offsetted value.
What's going on is we're going to have a m_lineTable if this UnitEmitter was loaded from the repo, and no m_sourceLocTab (it's demand-loaded by unit.cpp because it's only used for the debugger).
What's left is the result type.
Whatever is depending on this, shouldn't.
Whatever is the last value is what should be set
When A is first used we autoprime it, and therefore also autoprime C as well.
When ArrayIterator is cast to an array, it returns its array object, however when it's being var_dump'd or print_r'd, it shows its properties
When EvalJitEnableRenameFunction is false, the translator may wire non-AttrInterceptable Func*'s into the TC.
When HardTypeHints isn't on, AllFuncsInterceptable is on, or any InterceptableFunctions are listed, we don't require the constraints to actually match, and relax all the HNI types to Gen.
When ICU clones the UText, it does not copy the buffer, so we have to keep the string buffer around by holding a reference to its zval.
When NSUInteger is used as an enum's underlying type or if it does not come from a system module, make sure it stays unsigned.
When Pack_32 is not defined, we store 16 bits per 32-bit Long.
When a closure follows a call, it becomes the last argument of that call.
When a function with these semantics returns a new array, the new array is already incref'd.
When a header has multiple values, we always take the last one.
When a load instruction is encountered, remove the loaded location and /    any location it may alias with from the BBWriteSetMid.
When a local is definitely-written, it is removed from the set.
When a local may be read, it is added to the live set.
When a must-alias-set has any memory support bits set, it is going to be analyzed more conservatively than if it doesn't.
When a new active node is pushed, begin an EHEnt, and when it's popped, it's done.
When a new instance of HPHP has taken over our page server socket, stop our admin server and satellites so it can acquire those ports.
When a query timeout happens, the connection is invalid and SQuangLe layer closes it for precaution.
When a store instruction is encountered, the stored location is tracked.
When a task finishes, we need to reevaluate the other commands that might have been blocked.
When a value is deleted from the hash, it is written to the current output buffer.
When all is said and done, we should have a single value here to return.
When all registers are in use, find a good interval (possibly `current') to split and spill.
When an EOF's been seen but there's still some text to process then we mark the buffer as YY_EOF_PENDING, to indicate that we shouldn't try reading from the input source any more.
When an HHIR region is exited, there's always some instruction we can use to indicate via memory_effects what may be read (e.g. EndCatch, RetCtrl, ReqBindJmp, etc).
When an allow string is passed in we keep track of the string in state 1 and when the tag is closed check it against the allow string to see if we should allow it.
When an assignment to an expression is detected and the destination is / invalid, emit a detailed error about the condition.
When an instruction is removed from a BB, clear the parent pointer.
When an instruction reads from memory in an unknown way, the BBWriteSet /    bit is cleared if the instruction can read the corresponding LSLocation.
When an interval is split and the second part is spilled, possibly split the second part again before the next use-pos that requires a register, and enqueue the third part.
When asserts are disabled, this should be a NoOp.
When both types are strict subtypes of TObj or TOptObj or both are strict subtypes of TCls we look for a common ancestor if one exists.
When boxing an Object, if the inner class does not have AttrNoOverride, drop the class specialization.
When building the name for debugging purposes, include the protocol into which the associated type was resolved.
When building the stdlib we intend to serialize unusual comments.
When called by FuncEmitter, the least significant bit of m_paramCounts are not yet being used as a variadic flag, so numParams() cannot be used
When called from imagewbmp() the quality parameter stands for the foreground color.
When called from the jit, populate the correct return address
When checking if a key is present in the Set, any key that is not an integer or string is cast to a string, and we convert int-like strings to integers.
When checking if a key is present in the Set, any value that is not an integer or string is cast to a string, and we convert int-like strings to integers.
When checking if a value is present in the Set, any value that is not an integer or string is cast to a string, and we convert int-like strings to integers.
When choosing a register, prefer the one available furthest into the future.
When compared to an object, null is treated as false, and the object as true.
When complaining about conversion to a protocol type, complain about conformance instead of "conversion".
When convenient, preferable to doing skipWhitespace/expect manually to keep the line number in the error prior to the whitespace skipped.
When converting floating-point integers less than 1e16, we use floating-point arithmetic rather than resorting to multiple-precision integers.
When copying down an entry for a non-private method that has static locals, we want to make a copy of the Func so that it gets a distinct set of static locals variables.
When creating a CompilerInvocation, ensure that the driver creates a single frontend command.
When data is right(), expire is not valid to read, instead it's a lock.
When declarations are added they are added / under all variants of the name they can be found under.
When deep is false Element nodes still require the attributes Following taken from libxml as xmlDocCopyNode doesnt do this
When destructuring wildcard patterns, we also use / nullptr to represent newly-constructed wildcards.
When detaching the global scope, we leak any live objects (and let MemoryManager clean them up).
When filter assertions is on, we use this to avoid putting stack assertions on some "obvious" instructions.
When forming the resultant string, will call appendUniq to skip repeated words at the boundary.
When gd 1.x was first created, floating point was to be avoided.
When generating JIT'd code, we need to call sel_registerName() to force the runtime to unique the selector.
When given a null buffer, swift_demangle_getDemangledName should still be able to return the size of the demangled string.
When inlining is on, we may modify markers to weird values in case reentry happens.
When inserting the leaf node, stop inheriting the "allow" value from ancestor nodes.
When inside a class, this state is active.
When interface types prevail, this should be removed.
When intersecting a constant value with another type, the result will be the constant value if the other value is a supertype of the constant, and Bottom otherwise.
When it appears that there is already code for the call present, just complete values and/or argument labels.
When later compared with the data, the sign extension must have happened.
When looking at the current node, of course we want to enter it.
When m_evalStackIsUnknown, it means we have hit a place in the bytecode where the offset cannot be reached via fallthrough, but no forward jumps targeted it either.
When m_worker stops the server has stopped accepting new requests, there may be pedning vm jobs.
When matching retains to releases we must not match the same release twice.
When metatypes are accessed opaquely, they always have a "thick" representation.
When mirroring an initializer, make it designated and required.
When more than one copy occurs in a position, they are parallel-copies (all sources read before any dest is written).
When no override determined the Objective-C name, look for requirements for which this declaration is a witness.
When no registers are available, choose either the current interval or another one to spill, trying to free up the longest-available register.
When parsing the top level executable code for a module, if we parsed some executable code, then we're done.
When printing a type interface, this is the type to print.
When processing the first predecessor, record the arguments.
When profiling is enabled, we call the return hook, and follow the slow path return (uncommon case).
When received via Thrift, m_breakpoints points to a copy that is placed in m_bps.
When regions exactly overlap, the parent is less than the child.
When resuming from restart doing some install-like operation, try to find the package that forced the restart.
When selecting a *mongos* node, readPreferences make no sense as we don't have a "primary" or "secondary" mongos.
When set a condition into a Conditional Statement, inform each of the variables bound in any patterns that this is the owning statement for the pattern.
When splitting based on a preposition, whether we should place the / preposition on the argument label (vs.
When such collisions exist, we pick the
When supported, string hash functions using SSE 4.2 CRC32 instruction will be used, so we don't have to check every time.
When surprise flag is set, the slow path is always used.
When suspending, the compressor will back up to a convenient restart point (typically the start of the current MCU).
When suspending, the decompressor will back up to a convenient restart point (typically the start of the current MCU).
When synthesizing extensions, this is the target nominal.
When that changes, this code will need to be updated and a MaxLargeIndex will need to be used here.
When that happens, update topFunc.
When the Unwind instruction was executed in the funclet, the eval stack must have been left empty again.
When the app crashes, don't print the abort message and don't call Dr.
When the base is a tuple rvalue, the member is always an rvalue.
When the base is actually a subtype of array, we handle it in the callers of these functions.
When the base of a "." expression is ignored, look at the member.
When the base of a tuple lvalue, the member is always an lvalue.
When the buffer fills up empty it and start over.
When the call returns, jump over the data.
When the debugger is loading its configuration, there will be some cases where Extension::ModulesInitialised(), but the name appears in neither s_user_callbacks nor s_system_ini_callbacks.
When the expected name is empty, we claim the next argument if it has no name.
When the factory method has an "instancetype" result type, we can import it as a convenience factory method.
When the loop below finishes or when an exception is thrown, make sure that posLimit() get set to the correct value and that m_pos gets set to point to the first element.
When the main thread will be executing PHP rather than just managing a server, make sure its stack is big enough.
When the name and initial linkages of all the types was generated, the relationship between templates, their parameters, and nested classes is recorded in m_linkage_dependents, which is used here.
When the request ends, destroy all remaining Zend resource wrappers by freeing them.
When the requirement is an IUO, all is permitted, because we assume that the user knows more about the signature than we have information in the protocol.
When the source expression might produce a non-optional reference that could legitimated be nil, such as with an initializer, allow this workaround to capture that nil:
When the source is cancelled, libdispatch will make sure all pending event handlers have finished before invoking the cancel handler.
When there are any characters after the first NUL
When there are archetypes, recurse to profile the type itself.
When there are multiple partial solutions for a given connected component, rank those solutions to pick the best ones.
When there are no names, recover as if there were no parentheses.
When there is a conflict, the add() API is supposed to replace the existing element with the new element in place.
When there is a conflict, the addFront() API is supposed to replace the existing element with the new element in place.
When there is a variable table already, we will keep the ordinary compact() call.
When they return folly::none it is not a conservative thing: it implies the array is definitely not packed, packedN, struct-like, etc (we use this to return false in couldBe).
When this happens to the frame that is m_currentFrame, we need to reset m_currentFrame to m_mainFrame, *immediately* (hence Qt::DirectConnection), and without touching any members of m_currentFrame.
When this happens with an explicitly-written super.init or self.init invocation, return early if we did get nil.
When this restriction is removed, the assert here will fire.
When throwing from a constructor, we normally want to avoid running the destructor on an object that hasn't been fully constructed yet.
When translation punts due to hitting limit, will generate one more translation that will call the interpreter.
When true many of the threaded tests log activity to help triage issues.
When unserializing an element of a Set, we use Mode::ColKey for now.
When updating a tracked location, the visitor below will kill any potentially conflicting locations in the availability mask without updating them.
When updating this logic, also update RebindSelfInConstructorExpr::getCalledConstructor.
When used as a / tuple element in a function signature, such names become part of / the type.
When using Objective-C allocation, convert the metatype argument to an Objective-C metatype.
When using a subgenerator we don't actually read the values of the m_key and m_value of our frame generator (the delegating generator).
When visiting expressions, sometimes we need to emit self before we know / what the actual callee is.
When walking down the tree, we traverse until we have found a node inside the target range.
When walking the use list, if we index into a struct element, keep track / of this, so that any indexes into tuple subelements don't affect the / element we attribute an access to.
When walking the use list, if we index into an enum slice, keep track / of this.
When we actually see the EOF, we change the status to "new" (via hphprestart()), so that the user can continue scanning by just pointing yyin at a new input file.
When we actually see the EOF, we change the status to "new" (via yyrestart()), so that the user can continue scanning by just pointing yyin at a new input file.
When we already have some bits in our internal buffer concatenate both inputs first.
When we are doing code completion, make sure to emit at least one diagnostic, so that ASTContext is marked as erroneous.
When we are lexing a subrange from the middle of a file buffer, we will run past the end of the range, but will stay within the file.
When we are timed out, and we're SELECT-ing, we're potentially running a long query on the server without waiting for any results back, wasting server resource.
When we ask the ObjC runtime to lay out this class, we need the RO-data to point to the field offset vector, even if the layout is not dependent.
When we break from a loop, we need to adjust the exit count.
When we call builtin functions, we need to make sure that we don't change the return value of VRefParam::isReferenced on any possibly-KindOfRef arguments.
When we call the event hook, it might tell us to skip the callee (because of fb_intercept).
When we choose to "support" invalid salts, nevertheless disallow those containing characters that would violate the passwd file format.
When we combine the partial_apply and this apply into a new apply we need to retain all of the closure non-address type arguments.
When we come back from the dominator tree recursion we need to remove checks that we have seen for the first time.
When we destroy the execution context will call destructors on any objects in the userErrorHandlers and userExceptionHandlers vectors.
When we did see a colon, this is a selector.
When we didn't see a colon, this is a nullary name.
When we do that, all of this code will disappear.
When we emit a forward jump to a block we haven't seen yet, we write down where the jump was so we can fix it up when we get to that block.
When we erase an instruction, we use the map in the worklist to check if the instruction is in the worklist.
When we find a component that we weren't supposed to subtract, just restore lhs's original value.
When we find it, substitute the appropriate base type.
When we find the nearest color for a cell, its colormap index plus one is recorded in the cache for future use.
When we fork we need to unregister the parents hash so we don't accidentally destroy it
When we form the bound generic type, make sure we get the substitutions.
When we get it, return it.
When we have a candidate that differs by a single argument mismatch, we / keep track of which argument passed to the call is failed, and what the / expected type is.
When we have a rope buffer, could be implemented in terms of getLocOffsetInBuffer().
When we have an associated type, the base type conforms to the given protocol, so use the type witness directly.
When we have an open existential, open it and then emit the member reference.
When we have known args, we only need to add one of the entry points to the initial state, since we know how many arguments were passed.
When we have something like:
When we have type context, we still show literals that are keywords, but we treat them as keywords instead of literals for prioritization.
When we hit m_warmupReqThreshold, add additional threads to the server.
When we hit this point, we're committed to the set of potential conversions recorded thus far.
When we hoist a release to the predecessor block this release would block hoisting further releases because it looks like a ARC decrement in the predecessor block.
When we initially add them here, no attempt is made to determine if the edge is actually possible to traverse.
When we leave a synthesized extension, clear target's USR.
When we make a new connection to a machine, we have to wait for it to interrupt us before we can send it any messages.
When we need multiple entrance path, we factor the paths with a shared block.
When we return, we may need to adjust some loop condition counts.
When we see a PEI, we need to start over on the killBeforePEI set, and the local-liveness must take into account the fact that we could take an exception edge here (or'ing in the liveOutExn set).
When we see a forward jump to a block, we record the stack depth at the jump site here.
When we see a reference to the 'super' expression, capture 'self' decl.
When we see a variable binding, emit its global accessor.
When we see an expression in a TopLevelCodeDecl in the REPL, process it, / adding the proper decls back to the top level of the file.
When we see control flow splits, we need want to process both paths.
When we start iterating, we'll appropriately mark things as read based on these.
When we start print a synthesized extension, record the target's USR.
When we upgrade boost, we can remove this and also get rid of the parent try statement and move opts back into the original try block
When we're analyzing a delegating constructor, we aren't field sensitive at all.
When we're building the IR, we append a conditional jump after generating its target block: see emitJmpCondHelper, where we call makeExit() before gen(JmpZero).
When we're doing a function or method body, this state is active.
When we're emitting a standard implementation, use direct semantics.
When we're examining the parameter itself, it is the local name that is the name of the variable.
When we're inlining a NativeImpl opcode, we know this is the only opcode in the callee method body aside from AssertRATs (bytecode invariant).
When we're not using jemalloc this check won't do anything so avoid the extra overhead.
When we're performing Objective-C dispatch, we don't have an allocating constructor to call.
When we're ready to resume, we need to replace the fault to reflect any state changes we've made (handledCount, etc).
When we're type checking a single-expression closure, we need to reset the DeclContext to this closure for the recursive type checking.
Where 0 stands for Sunday, 1 for Monday, etc.
Where are we on the stack now vs.
Where file commando is used it's not essential as the CLI process ends, multiple loading within the same process wouldn't work.
Where nullability information should be printed.
Where the new search starts
Where there is more than one potential conversion, create a disjunction so that we'll explore all of the options.
Where to get hi to lo bytes from
Where to get lo to hi bytes from
Where to insert spills.
Where we have an unneeded phi node (i.e. all incoming values are the same / argument).
Whether a Vinstr is a register swap.
Whether any block in the loop contains a php call.
Whether any of the given optional adjustments is an error (vs.
Whether it is the same pointer value or not is not specified.
Whether or not the context class has a private method with the same name as the the method we're trying to call.
Whether or not this is the last loop to break out of, we will be freeing the current iterator
Whether or not we modified the map should be the same in both implementations.
Whether the bindings of this type involve other type variables.
Whether the decl is from a module who requested import-as-member inference
Whether the expr is of statically inferred metatype.
Whether the function is marked 'rethrows'.
Whether the given Objective-C type can be imported as an optional type.
Whether the given word is a plural s
Whether the object with the given type-index should be recorded as an "unknown" object.
Whether the provided name is API by default depends on the parameter context.
Whether the result is a function name.
Whether the row will be irrefutable after this specialization.
Whether the solutions are identical.
Whether there is a range that includes `pos', or a use at `pos'.
Whether there is an existing read-only subscript for which we have now found a setter.
Whether this is a SIMD value.
Whether this is a parameter adjustment (with an index) vs.
Whether this map has been added to another array or map and no longer has a valid map value
Whether this speeds things up or slows things down depends on the machine and the number being converted.
Whether this type is known to be empty.
Whether this type variable has literal bindings.
Whether this type variable is fully bound by one of its constraints.
Whether this type variable is only bound above by existential types.
Whether this variable is a constant, and its constant value.
Whether to consider protocol members or not.
Whether to hoist releases or sink retains.
Whether to quote additional delim char
Whether to return non-matching entries
Whether to try to fill the input buffer when we reach the end of it.
Whether we "own" the buffer - i.e., we know we created it, and can realloc() it to grow it, and should free() it to delete it.
Whether we have data to read.
Whether we have found any types that are bridged.
Whether we remove the cached AST from libcache, by default, false.
Whether we see a "once" call to callees that we currently don't handle.
Whether we should make a variadic method with the given selector / non-variadic.
Whether we should short-circuit a disjunction that already has a / solution when we encounter the given constraint.
Whether we will explode the argument or not.
Whether we're considered to be at the beginning of a line.
Whether we're storing a ResourceData or a Zend resource.
Whether we've already complained about problems with this conformance.
Whether we've found an unbound type.
Which can expose opportunity for simplifcfg.
Which connection we return depends on the type of connection we want
Which mouse button (if it's a click)
Which we should be able to turn into just "inc-2".
Which would cause us to report the TypeRepr twice.
While emitting bytecode, we keep track of where the DefCls opcodes for each class are.
While emitting bytecode, we learn about some metadata that will need to be registered in the FuncEmitter.
While importing the DeclContext, we might have imported the decl itself.
While it's possible we pushed the DefInlineFP into the catch trace it will be after the BeginCatch.
While loop is to handle a single function taking a long time and passing several sampling intervals
While not required for correctness adding these slots to the kill set will hopefully avoid some extra stores.
While this data is still in the the map we consider this data dying.
While this function is quite general wrt.
While this is technically valid in an email address, these parts aren't actually part of the address itself.
While walking over the blocks in layout order, we track the set of "active" exnNodes.
While we could try to walk the body and update any Decls, ClosureExprs, etc within the body of the ClosureExpr, it is easier to just turn it into BraceStmt(CallExpr(TheClosure, VoidTuple)).
While we have a constraint in the worklist, process it.
While we see non-uppercase letters, keep moving back.
While we would have liked to simply fix the bug and move on, we have to provide a backwards compatibility feature (essentially the bug) for some systems and a safety measure for some others.
While would could compact to make room, it's better for Hysteresis if we grow capacity by 2x instead.
White-listing and forbidden templates are determined by just checking the name against explicit lists.
Whitelist certain types even if Foundation is not imported, to ensure that casts from AnyObject to one of these types are not optimized away.
Whitespace it out to the same column as the previous item.
Whoever updates highest_ever is responsible for hinting all the intervening regions.
Whole program optimizations need to assume they can see all the code.
WiXHelper.pch will be the pre-compiled header stdafx.obj will contain the pre-compiled type information
Widest type for this MustAliasSet, used for computing may-alias information.
Will assert invariants on the way out:
Will be diagnosed as an unterminated string literal.
Will be set again below if still needed.
Will be set by LdObjMethod
Will be simplified to a constant later on.
Will break out of loop below.
Will delete itself when it gets a closing callback
Will return a PropInfo with an offset of -1 if the mapping from baseClass's name to the Class* can change (which happens in sandbox mode when the ctx class is unrelated to baseClass).
Will throw PHP catchable Exception in case the connection isn't valid.
Will turn into either an int or a double in zend_convert_scalar_to_number.
Will use the static empty mixed array to avoid allocation.
Win XP specific, Unicode
Win XP specific, Unicode, not to be confused with SubjectDistance and SubjectLocation
Win32 doesn't have a working poll(), so we use the old select() branch.
Windows actually does core dump size and control at a system, not an app level.
Windows doesn't accept POSIX as a valid locale, use C instead.
Windows hates argument registers.
Windows sleep takes milliseconds
Wire up stdout and stderr to our own string buffer so we can pass any output back to the client.
Wire up the Clang importer.
Wire up the archetypes.
Wire up the overrides.
Wire up this BB as an "initial predecessor" of all of its successors and make each of its successors a successor for the region.
Wishlist:  - It might be nice if you could refer to iterators by name instead of by index.  - DefCls by name would be nice.
With -embed-bitcode, save a copy of the llvm IR as data in the __LLVM,__bitcode section and save the command-line options in the __LLVM,__swift_cmdline section.
With IEEE arithmetic, ties are broken by the IEEE round-even rule.
With SIL optimizations this is not guaranteed and a variable can end up in two allocas (for example, one function inlined twice).
With any escapes tallied up, we can work through all the uses, checking for definitive initialization, promoting loads, rewriting assigns, and performing other tasks.
With closure captures it is actually possible to have two function / arguments that both have the same name.
With each predecessor, also keep the level number of the predecessor in the post-dominator tree.
With identical-code-folding enabled in the linker, __jit_debug_register_code tends to get folded with a bunch of other functions, some of which are called a lot.
With jemalloc, the usage can go negative (see memory_get_usage)
With multi-threading we need a backend job for each output file of the compilation.
With primary, there is only going to be one node, with primary the set contains only secondaries and with nearest we do not prefer a secondary over a primary or v.v.
With slave_okay being false, the RP is switched to PRIMARY.
With slave_okay being true or absent, the RP is switched to SECONDARY PREFERRED but only if the current configured RP is PRIMARY - so that other read preferences are not overwritten.
With the current meaning of structs, if the keys are different, we can't do anything better than going to a map type.
With the exception of a second call to start being made this should be safe as any place we mutate m_socket is done within the event base.
With the main cursor, skip over the block and continue.
With this in mind, we'll discuss all four cases: Unknown target, Zero LB: We flag all must-alias-sets as "pessimized".
Without ObjC interop, ErrorProtocol is native-refcounted.
Without Objective-C interop, foreign classes must still use Swift native reference counting.
Without an associated context we cannot perform any access-based optimizations.
Without jemalloc we have to do that by hand.
Without profiling data, we assume destroy is unlikely.
Without truecolor this results in far too many color indexes.
Witness 'Self' arguments are added as a special case in EmitPolymorphicArguments::emit.
Witness methods have some extra parameter types.
Witness table entries for constructors always refer to the allocating constructor.
Witness tables are pointers and have pointer spare bits.
WitnessTablePrivateSizeInWords
WitnessTableSizeInWords
Witnesses in classes never have mutating conflicts.
Witnesses take 'self' at +0, so we still need to consume the +1 argument.
Witnesses that are currently being resolved.
WndProc - standard windows message handler.
Work around a bug in headers on Digital Unix.
Work around a bug in webscalesql where setting a read or write timeout causes most mysql connections to fail (depending on the exact timing of packets).
Work around that for now.
Work around this by referring to the aliasee instead.
Work out number of chunks.
Work out start/end chunks
Work out the lowered function type of the SIL witness thunk.
Work out which enum element is the true branch, and which is false.
Workaround this by using a slow path through Java in that case.
Worker was already terminated
Working with generators requires Optional.
Worklist for visiting all blocks.
WorklistList is the actual list that we iterate over (for determinism).
WorklistMap keeps track of which slot a BB is in, allowing efficient containment query, and allows efficient removal.
Worse, it may be aliased.
Worse, it throws it away without any check.
Worst case, every remaining byte is invalid, taking a 3-byte substitution.
Wrap CF pointers up as unmanaged types, unless this is an audited context.
Wrap a local or stack ID into a Location.
Wrap a type in the Optional type appropriate to the import kind.
Wrap all Clang imports under a Swift import decl.
Wrap class, class protocol, function, and metatype types in an optional type.
Wrap retainable struct fields in Unmanaged.
Wrap that in a struct if necessary.
Wrap that up in a Selector and return it.
Wrap the bitstream in a module object file.
Wrap the function in its original form.
Wrap the interface type in the right kind of optional.
Wrap the result in an optional.
Wrap the source value into an optional first.
Wrap the string in an array to allow the JSON_parser to handle things like unicode escape sequences, then unwrap to get result
Wrap this up in XML, as that's what we'll use for documentation comments.
Wrap up in an Optional if called for.
Wrapper fixes up negative starting positions.
Wrapper fixes up negative/zero length.
Wrapper for camel_case::toLowercaseWord that uses string scratch space.
Wrapper for sending and wrapping in a safe op
Wrapper names should have a prefix to distinguish them from the actual runtime functions.
Wrappers for generating test cases for various addressing modes.
Wrappers for the different collection types
Wrappers to query the value state of the location in this BlockState.
Wrapping should be in the same line.
Wraps .swiftmodule files inside an object file container so they can be passed to the linker directly.
Wraps a dot node label string to multiple lines.
Wraps calling an (autoload) PHP function from a CufIter.
Write 16 bit unsigned value to data
Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality QUALITY.
Write an .eh_frame section that covers the whole TC.
Write an Image separator
Write an instruction that looks exactly like a conversion: all / important information is encoded in the operand and the result type.
Write any data remaining in the buffer
Write down the index of the address point.
Write each child call
Write false until we rev the protocol.
Write functions until we reach the LineLimitPerFile.
Write inherited conformances.
Write less data on purpose, to get the server to choke on deserialization
Write our local statistics back to the overall statistics.
Write out DefaultWitnessTables.
Write out VTables first because it may require serializations of non-transparent SILFunctions (body is not needed).
Write out a Zero-length packet (to end the series)
Write out a word to the I/O context pointer
Write out extension for transparent colour index, if necessary.
Write out fragile WitnessTables.
Write out the Background colour
Write out the Global Colour Map
Write out the code so far to the end of b.
Write out the epilog.
Write out the frame's info
Write out the initial code size
Write out the screen width and height
Write out whether or not the image is interlaced
Write real header, as we are confident the output is complete.
Write the # of children then short-circuit if we are too deep
Write the GIF file terminator
Write the Image header
Write the Magic header
Write the body parameters.
Write the body's context archetypes, unless we don't actually have a body.
Write the categories, if there are any.
Write the contents of the buffer.
Write the current frame at this level
Write the declarations and macros.
Write the generated bitstream to "Out".
Write the globals-as-members table, if non-empty.
Write the hash as a hex string.
Write the input parameters into the temporary:
Write the result out to stderr avoiding errs() because raw_ostreams can call report_fatal_error.
Write the return value to the stack and the AFWH object.
Write the standard header.
Write to the tail component.
Write up generic parameters and check the generic parameter list.
Writers of suspendable-input applications must note that skip_input_data is not granted the right to give a suspension return.
Writes SIL out to the given file.
Writes an in-memory decl table to an on-disk representation, using the / given layout.
Writing data to a socket that has been closed will leave it in a very bad state.
Writing image to the buffer, using PNG encoding
Writing shouldn't change the EOF status, but because we have a transparent buffer, we need to do read operations on the backing store, which can.
Written (or, at least, moved) 1999, Philip Warner.
Written 2004, Phil Knirsch.
Written/Modified 1999, Philip Warner.
X might not be strong_retain/release'able.
X-scaled Sinc(x) function.
X/Y/Z often used as coordinates and should be the labels.
X3.64/ECMA-43 "next line" character
X509_REQ_free(nullptr) is a no-op
X: X, etc to allow for multiple instances
XAP: Extensible Authoring Publishing, obsoleted by XMP: Extensible Metadata Platform
XDEBUG_CC_UNUSED and XDEBUG_CC_DEAD_CODE not supported right now primarily because the internal CodeCoverage class does support either unexecuted line tracking or dead code analysis
XDebug Implementation
XDebug is disabled by default.
XDebugCommand implementation
XDebugServer still thinks we're running because we haven't run XDebugServer::breakpoint yet.
XDebugServer::breakpoint will send the response for the command before the break command, but we first need to send a response for the break command.
XDebugThreadBreakpoints Implementation Adding a breakpoint.
XED callback function to get a symbol from an address
XHP functions: They are defined here, so different parsers don't have to handle XHP rules at all.
XHP-specific entities
XML node printing routines Exports the given xml key value pair as an xml child of the given parent node
XML_Parse can reenter the VM, and it will do so after we've lost the frame pointer by calling through the system's copy of XML_Parse in libexpat.so.
XML_XINCLUDE_END node will be a sibling of XML_XINCLUDE_START
XXX - The 16-bit string compare probably needs to be done differently, especially if the flags are to be supported.
XXX - the actual Single UNIX Specification says that "L" means "long", as in the C data type, but we treat it as meaning "4-byte integer".
XXX - the actual Single UNIX Specification says that "long" means "long", as in the C data type, but we treat it as meaning "4-byte integer".
XXX - these two should not need
XXX 5.14 at least introdced 100 ns intervals, this is to do
XXX Add assert in debug build to make sure W is not getting written or overwritten by something else
XXX I *thought* this should return IDCANCEL, and have verified that that's what WixStandardBootstrapperApplication.cpp::OnExecuteMsiMessage returns.
XXX NOT THREAD SAFE (is safe under win32)
XXX This is wrong, since it will print out "A(array(1,2))" instead of "A(1,2)"...
XXX We're probably not getting warnings totally correct here
XXX allow caller to set timestamp, if none set, then default to "now"
XXX avoid scratch register somehow.
XXX disabling default magic loading so the compiled in data is used
XXX for auth type, need to make sure that the auth type is actually supported before setting
XXX good candidate for refactoring
XXX line numbers are bogus
XXX maybe find a better way to generate a nonce...
XXX the maxmagic has to be reset each time we load some new magic file.
XXX this functionality is excluded in php, enable it in apprentice.c:340
XXX this should be dynamic
XXX validate that this is a lossless conversion.
XXX(jezng): I'm not sure how to test this, so leaving unimplemented for now
XXX(t10347945): This causes our data section to own a pointer to heap memory, and we're putting bindaddrs in said heap memory.
XXX(t3879280) This happens immediately before calling an extension function that takes an optional Object argument.
XXX(t4592459): This will return 2 for TNull, even though it only needs 1 register (one for the type, none for the value).
XXX: Changing this to empty_string causes problems, something is writing to this upstream but I'm not sure what and since it's unlikely to provide significant gain alone I'm leaving it for now.
XXX: OSX doesn't support realtime so we ignore which_clock
XXX: Should respect ini_get("precision").
XXX: This can take the lock even when we want to pause the thread.
XXX: This changes the refcounts of the object's properties.
XXX: This should respect ini_get("precision").
XXX: This was originally done before remapping scriptName but that seemed wrong as the value of docRoot may change.
XXX: VM process initialization is handled through a function pointer so libhphp_runtime.a can be linked into programs that don't actually initialize the VM.
XXX: Zend does not allow isset() on the result of a function call.
XXX: const castaway, via strchr
XXX: is this useful ...
XXX: it seems weird we have to do this even though we already ran resolveVmInclude.
XXX: should do something better here
XXX: this is horrible memory-usage-wise, but we only expect to do this on small pieces of form data.
XXX: this needs to be optimized to work with blocks of 'safe' chars
XXX: this should not be static
XXX: verify that overlapping address come from jmp fixups
XXX: we may be sweeping- so don't create a smart pointer
Xenon data is gathered for logging per request, "if we should" meaning that if Xenon's Surprise flag has been turned on by someone, we should log the stacks.
Xenon needs to be started once per process.
XenonForceAlwaysOn is active - it doesn't need a timer, it is always on.
Xml encode the passed string.
Y if followed by a vowel
Y, U, V: the input data buffers 4.
YAML parser and emitter PHP extension  Copyright (c) 2007 Ryusuke SEKIYAMA.
YUV420toRGBA: Converts from YUV (with color subsampling) such as produced by the WebPDecode routine into 32 bits per pixel RGBA data array.
YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.
YYFINAL -- State number of the termination state.
YYINITDEPTH -- initial size of the parser's stacks.
YYLAST -- Last index in YYTABLE.
YYLEX -- calling `yylex' with the right arguments.
YYLOC is available though.
YYMAXDEPTH -- maximum size the stacks can grow to (effective only if the built-in stack extension method is used).
YYNNTS -- Number of nonterminals.
YYNRULES -- Number of rules.
YYNRULES -- Number of states.
YYNTOKENS -- Number of terminals.
YYRHS -- A `-1'-separated list of the rules' RHS.
YYSTR is taken from yytname.
YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.
YY_LOCATION_PRINT -- Print the location on the stream.
Yep, throwing away const here (for now) for API compatibility.
Yes this does seem beyond strange, but that is what the PHP parser does when it sees a function declared inside a namespace, so we too have to pretend there is no namespace here.
Yes, there is a color map
Yes, this should be an array
Yet, the previous php_rand only returns 31 at most.
Yield is followed by the label where execution will continue.
You can also easily create Units with illegal metadata.
You can do layout / with this, but the type isn't copyable, so most of the value / operations are meaningless.
You can get this if you cast an array to object.
You can set it afterwards.
You can specify a range like 'a..z', it needs to be incrementing.
You can't call this function from MINIT, sorry
You need ToMixedCopy in cases where the old array needs to remain un-modified (usually if `copy' is true).
You should have received a copy of the GNU General Public License along with this program.
You should have to opt into this, since they are even less namespaced than usual.
You will notice that the lengths alternate between 30 and 31 days, except for three anomalies: both July and August have 31 days, both December and January have 31, and February is less than 30.
ZF, SF, PF set accordingly
Zap BI and move all of the instructions from DestBB into this one.
Zap all of the instructions.
Zap any obvious duplicates along the way.
Zend deletes properties here, but we delete properties in the ObjectData destructor.
Zend doesn't define the STD* streams in server mode so we don't either
Zend doesn't modify the order of the list if the handler is already registered.
Zend doesn't support streams in realpath
Zend has a very specific include order, so I can't do this class' header before zend.h sadly
Zend have some extra that is just maps to some other type
Zend lets such fatals propagate, so don't bother catching exceptions here.
Zend puts the number of args as the last thing on the stack
Zend resource destructors receive a ZendResourceData as their sole parameter.
Zend returns true for random data types...
Zend would check here if this is a write operation, but HHVM always handles that with offsetSet so we just want to return nullptr here.
ZendCompat implies ActRec, no FCallBuiltin
ZendResourceData contains the index into the Zend resource table where these are stored.
Zero for size is correct, because when this APCCollection was unreferenced it already included the size of the inner handle.
Zero is returned when the input date is detected as invalid or out of the supported range.
Zero is returned when the input date is detected as invalid.
Zero means it was monomorphic (or never executed).
Zero means the default is an error.
Zero out the indices from here to the end.
Zero out the private storage area.
Zero the error slot to maintain the invariant that it always contains null.
Zero the histogram or inverse color map
Zero the histogram or inverse color map, if necessary
Zero-extend the bool from a byte to a quad.
Zero-parameter initializers with a long selector.
Zero-parameter methods.
Zeroing out the error slot only in the error block increases the chance that it will become a dead store.
Zeroize sensitive information.
Zext out to the size of the existential.
_ is different from the #, which is used for many closures in the same func in ParserBase::newClosureName
_BridgedNSError is in the Foundation module.
_BridgedNSError._nsErrorDomain
_PROTOCOL_METHOD_TYPES_ does not have the first two entries.
__FILE__ and __DIR__ are special unary ops that don't have expressions
__attribute__((annotate(swift1_unavailable)))
__attribute__((availability))
__attribute__((deprecated))
__attribute__((unavailable)
__call cannot be static, this should be enforced by semantic checks defClass time or earlier
__dtoa() doesn't allocate space for 0 so we do it by hand
__jit_debug_register_code() needs to be defined in a separate file from the one it is called from.
__lambda_func will be the only hoistable function.
__set takes 2 args, so it uses its own function.
__swift_assign_existentials_N is the well-known function for assigning existential types with N witness tables.
_direct type metadata for Swift._EmptyArrayStorage
_forceBridgeFromObjectiveC returns `Self`, so we can just return it directly.
_silgen_name'd accessors don't need bodies.
`InteriorAddress` is true if the current address projection already includes a struct/ref/tuple element address.
`QProcess` doesn't properly handle the situations of `cmd` not existing or failing to start...
`connections_requested` - This number helps with comparing how many connection would have been made if the there were no pooling.
`deallocateStack` emits the lifetime.end marker for us.
`getReturn` needs to know whether a generator finished successfully or whether an exception occurred during its execution.
`memcpy8()' could overrun the buffer by at most 7 bytes, so we allocate 6 more bytes here, which (together with the trailing 0) makes it safe.
`pos' must be a valid position for this array.
`r' is free for the first part of current.
`recursive` determines whether we enter just the top generator or whether we drop down to the lowest running delegate generator.
`safe' read for sockets and pipes.
`safe' write for sockets and pipes.
`this' is being torn down now---be careful about where/how you dereference this from here on.
`to' is uninitialized here, so we need to tvWriteNull before possibly causing stack unwinding.
`v' must not be KindOfUninit.
`yyls': related to locations.
`yyvs': related to semantic values.
a / result or value type adjustment (no index needed).
a LSLocation is an / abstraction of an object field in program.
a base computation that was already emitted.
a certificate to use for authentication
a character width specification, to be more consistent with
a chunk of whitespaces
a code_int must be able to hold 2**GIFBITS values of type int, and also -1
a constant for arrayobjects that changes the way the array is converted to an object
a helper will decref it but the translated code doesn't care about the type
a label inside a loop cant be reached from outside the loop
a non IntlCalendar was specified, we want to keep the timezone
a single char was given
a space or some other separator character, we simply skip over
a static string is passed in, resolve with a constant.
a static variable at global scope is the same as non-static
aStart field of tr.bcmapping may point to cold range, so we need to explicitly form mappings for main code and cold
abbreviated month name
abbreviated month name (non-standard)
abbreviated weekday name
abcdefghijklmnopqrstuvwxyz
abort so we catch it as a crash.
abort() so it shows up as a crash, and we can diagnose/fix the exception
abstract constants are not added to the constant table and don't have any values to propagate.
accept the rare collision on keys (requires probe collision too)
accepts the data connection, returns updated data buffer
according to ICU sources, this should never happen
according to exif2.1, the thumbnail is not supposed to be greater than 64K
account for the sentinel
acknowledge receipt so that client can quit.
acquire: also returns true if we are already the writer.
acronym, lower casing because could just be capitalized word
activate the converter
active (normal) connection
actually execute the regular expression
actually generate the MongoId
adapted from Zend php_var_export and php_addcslashes
add 1 to the number b.
add a byte for minus sign
add a range covering the whole block to every live interval
add a reference to retval's internal counter
add all functions this class has
add chunks collection as a property
add extra fields required for files: - filename - upload date - length these fields are only added if the user hasn't defined them.
add funciton return type
add function name attribute to function DIE
add function return value
add http header with oauth parameters
add one, because Z is always NUL-terminated
add the embedded line end to the field
add the header to the hash.
add the original filename for flattened traits
add thread to m_sandboxThreadInfoMap
add to the map the newly created values
add upper PC bound to function DIE
add user-defined fields
addToScope - Register the specified decl as being in the current lexical / scope.
addToWorklist - Add the specified block to the work list if it isn't / already present.
added by gerrit thomson to fix ldap_add using ldap_mod_add
adding negative length
adding negative start
additional http headers can be passed
addr-spec / phrase route-addr
address instances where the session read fails due to an invalid id
address within callee's body
address within caller's body
address_to_pointer is a mutable escape, which we model as an inout use.
addressof expects an lvalue argument.
adjust how many args we have left and restart loop
adjust so point is on the right boundary
adjust timeout for next attempt
adjust x0 to be on the left boundary (ie to be zero), and y0 to match
adjusted stk addresses (sp+offset on each path)
advance errorptr to current column
advance u1 to the first use position in child, then copy u1..end to child.
after argnum comes modifiers
after bcopy, update count
after force restart skip packages until after the package that caused the restart.
after modifiers comes width
after our pointer arithmetic jump back to the first element
after width and argnum comes precision
agentInfo part of the query
ah illegal: char after COM section not 0xFF
alafim (thousands) case
all other servers invoke waitForEnd on stop
all patterns are longer than the source
all remaining bits on the current unsigned char are set to zero.
all these instructions lower to parallel copyplans, which know how to load directly from constants or spilled locations
all vector methods should work w/out touching the hashtable
allNodes is sorted by function name.
alloc the data structure
alloc the ftp structure
allocate a database handle.
allocate a new chunk of counters if necessary
allocate a new stream for a particular ops
allocate and bind the buffer
allocate array of modifications
allocate at least kNumBytes bytes, and make sure we end on a kNumBytes aligned boundary.
allocate buffer to hold asynchronous watch info
allocate buffer to hold directory change information
allocate buffer we'll pass to odbc
allocate memory and init the stream resource
allocate output buffer
allocate space for the PNG image data
allocate space for the values as part of this modification
allocate storage for the parameter, keyed by its "canonical" name
allocate the data struct
allocate the modification struct
allocating constructors have metatype 'self'.
allow empty param lists
allow for arrays with one element, no allowance for arrays with none but probably not required, gerrit thomson.
allow for thousand separators
allow multiple '/' for readability
allow room for a space
allow the script to capture the peer cert and/or the certificate chain
allows the driver to report about an invalid session id and request id regeneration
alpha 0 is opacity, so be sure to invert at the end
already accounted for
already copied srcPosBytes
already determined to be nonempty
already handled as part of the var decl.
already handled with redirection or 404
already read 0xff in filetype detection
already set to be dynamic
already walked what we needed.
also checks invariants
also copy the tailing 0
also frees localCache and atomic-dec APCArray
also including the default value.
also maybe atomic-dec APCString
also used as tmp1 by MacroAssembler
alteredAvl : prevents a store from being moved forward through this block, and prevents it from being killed by a later store.
always a slow lookup.
always at least ((), SelfType)
always direct for now
always emit 'tok::equal' to avoid trickle down parse errors
always one delimiter less than count of items
amai: Darrel Hankerson did the changes described here.
an IntlCalendar was provided to the constructor
an array can be passed to prime special oauth parameters
an array of php stacks
an assignment to a property of an object counts as a mutation of that object
an exception was thrown that prevented proper shutdown.
an incref is needed to compensate for discarding from the stack
an unidentified / store) is classified as mayModify.
analyze until livein reaches a fixed point
analyzed, but we know nothing (m_everything_bad case)
and 6 stands for Saturday.
and a minus sign, if needed
and add signature to the oauth parameters
and any continuations that match
and appending the captured arguments.
and erase the allocation.
and here it means "this thing does not exist".
and increment it so it becomes non-zero .
and increment the usage count.
and it has a return type which is itself a function
and make sure they have no unsubstituted generics.
and no availability semantics calls
and no error propagated to row below yet
and now go through the instructions in the block in reverse order
and now remove them from the stack
and one of the automatically-created "directory" entries.
and recompute its volume and population
and replace its uses with
and return true so that we can stop the epilogue walking sequence.
and set endHighlightLine/Column so that it is just past the end of the spew, and all code up to the truncation will be highlighted.
and shrink back if that was incorrect
and the Swift project authors Licensed under Apache License v2.0 with Runtime Library Exception
and the last inliner.
and then any putenv() changes take precedence
and then pass this to abi::__cxa_demangle to get the demanged name: HPHP::jit::interpOneIterInit()
and this should probably be handled by the normal cycle detection.
and we already have an archetype for that ID, return it.
and we want to recover from this very well.
android's asset manager does not work with paths that start with a dot
anon namespace / Helpers
anon namespace Run a DFS over the heap, remember the first pointer id to each reachable node, aka its "parent".
anonymous namespace This is a separate function so that it shows up in stack traces.
another block was merged into this
another pass through the heap, this time using the PtrMap we computed in init().
another test involving a 3-cycle plus one leaf.
any other event is an error
any other problem is a fatal error
any other value will be considered as background and will not be written out:    the stream where to write
anything else isn't interesting
anything, or overrides something that complain.
apache rewrite rules don't require initial slash
appease -Wuninitialized
appease StringData::checkSane()
append bit length of hashed data:
append bytes to the end of a dynamic pointer
append/set post data with oauth parameters
appendWithRef bumps the refcount and splits if necessary, to compensate for the upcoming pop from the stack
appendWithRef bumps the refcount to compensate for the eventual decref of arrayArgs.
appendWithRef bumps the refcount: this accounts for the fact that the extra args values went from being present on the stack to being in (both) ExtraArgs and the variadic args
apply callbacks to the collected node
apply change right away
apply instructions do not capture the pointer when it is passed indirectly
apply strip_high and strip_low filters
apply the Miyaguchi-Preneel compression function:
apply the r-th round transformation:
apprentice - make one pass through /etc/magic, learning its secrets.
apptype() uses the filename if given, otherwise a tmp file is created with the contents of buf.
ar is a pre-live ActRec in fp's scope, and pushOff is the offset of the corresponding FPush* opcode.
arc or fixup metadata
arg is the (constant) type of a known-typed value.
argArray was exhausted, so there are no "extra" arguments but there may be a deficit of non-variadic arguments, and the need to push an empty array for the variadic argument ...
argPos controls the position of the constant argument.
argument tuple, result type
argument_unpacking RFC dictates "containers and Traversables"
arithmetic intrinsics
arm64 has no special objc_msgSend variants, not even stret.
arm64 requires ISA-masking.
arm64 requires marker assembly for objc_retainAutoreleasedReturnValue.
armv7k has opaque ISAs which must go through the ObjC runtime.
array for GETALL, SETALL
array stream_stat ( )
array with autogenerated numeric keys
array.isNativeTypeChecked might be shared among several get_element calls.
array.uninitialized may have a first argument which is the allocated array buffer.
as a modified form of the old Roman republican calendar which was based on lunar cycles.
as if just "list" fall through
as is the end, so the line misses the window
as is the end, so the line never cuts the window
ask for a passive connection if we need one
ask the driver to perform any normalization it needs on the parameter name.
assert invalid instruction form
assert that end event is next in stream
assert that we will make some progress in this iteration
assert_impl already defined in util/assertions.h
asserting here to ensure that key is  a scalar type that can be converted to a string.
assign formattables to varargs
assign id to 86metadata local representing frame metadata
assign ids to 0Closure and use parameters (closures)
assign ids to local variables
assign ids to parameters (all methods)
assigned to the return value for this call when nothing exists
associated_type AssociatedTypeName: ConformingType
associatedtype _ObjectiveCType : class
assume a VarEnv* is a unique ptr, and scan it eagerly.
assume a raw integer char code was given
assume it is a known command.
assume long is not wider than 64 bits
assume minimal collisions
assume we won't resolve source and that is unexpected.
assumes content is at most 1024 characters
assumes not all bits are used patterns is already ordered by hash.
assumes specialized conformance is always fully specialized
assumes we always have sendmail installed
assuming syncvmsp uses lea.d
assuming we are in "catch"
async functions use callToExit stub
at least one 0xff is needed before marker code
at least one of charListData chars was null, so there must be room:
at this point we are free to do whatever we'd like with the transport.
at this point, m_nvTable is destructed, and GlobalsArray has a dangling pointer to it.
attaching to default sandbox
attribute default and required
attributes don't have attributes
autoTypecheckRequestInit() and autoTypecheckRequestExit() work together to ensure a couple of things.
autoclosure implies noescape.
autoload, and it writes part of the new actrec
automatic allocateable buffer for additional header
autoseek for resuming
auxiliary for emit(call) and emit(callr)
avail_in on the entry block (with no preds) will be set to all 1 below.
avail_outs all default construct to zeros.
avoid contamination of the value that was strongly bound
avoid div by 0 Print contents of all blocks in pure text format.
avoid infinite recursion
avoid lint complaining
avoiding trigraph errors
b) Size-tracked small allocations.
b) T2 is the head (first translation) of a region.
back to blocking mode
backtrace_symbols requires that we free the array of strings but not the strings themselves.
backwards compatibility
bad record, don't set anything
base may be from inside a RefData inside a stack/local, so to determine setRef we must check the actual value of the stack/local.
baseClass can change on us in between requests and it is not related to ctx, so bail out
baseClass can change on us in between requests, but since ctx is an ancestor of baseClass we can make the weaker assumption that the object is an instance of ctx
based on test_demovfs.c and test_multiplex.c in sqlite3
basic block arguments).
basically duplicated from as.cpp but is maybe too janky to be a common routine somewhere...
be sure calculation temps are big enough
because emitImmReg tries the xor optimization
because now A and D go on the maybe-hoistable list B goes on the never hoistable list, and we fatal trying to instantiate D before B
because strong_iterators_exist()
because the first one was in funcs above
before beginning of unix epoch or behind end of unix epoch
before iter is modifed
begin in header parsing mode
begin standard C headers.
beginning of action switch
being a Swift extension).
below assumes this is already in local cache
bidirectional references
binary file - doesn't make much sense but well...
binary number syntax "0b" is not supported by strtoll
binary test if pattern is not text
bind data arrays to the parameters in the prepared query
bind to a local address
bindJmp --  Runtime service handler that patches a jmp to the translation of u:dest from toSmash.
bit 0 set: file probably ascii text
bit 1 set: header CRC present
bit 16 set iff "diff" was non-zero (on non-match)
bit 2 set: extra field present
bit 3 set: original file name present
bit 4 set: file comment present
bits are left-justified on b.
bits of precision in B/R histogram
bits of precision in G histogram
bits of precision in R/B histogram
block became unnecessary
block compression parameters -- after all codes are used up, and compression rate changes, start over.
block further optimization
block had some type guard relaxed
block order doesn't matter, but only visit reachable blocks.
body transfar encoding
bool ExistsInt(const ArrayData*, int64_t key)  Returns true iff this array contains an element with the supplied integer key.
bool ExistsStr(const ArrayData*, const StringData*)  Return true iff this array contains an element with the supplied string key.
bool IsVectorData(const ArrayData*)  Returns true if this array is empty, or if it has only contiguous integer keys and the first key is zero.
bool stream_truncate()
booleans in arithmetic and bitwise operations get cast to ints
both edges have same target, change to jmp
both parts will be non-empty
both servers have to finish
both subobj(A) and subcls(A) of no_override class A change to exact types
both types are TypeDecls:
both types are ValueDecls:
bound-check asserts in offsetOf
boundary case -- decrement exponent
boundary case -- increment exponent
br is a forwarding use for its arguments.
brackets nesting level
break -i # Pauses a running request "as soon as possible".
break and return the current value if the number is not well-formed that's what Linux strtol() does
break down type that "contains" other types and check them each.
break intentionally missing
break is missing *intentionally*
break is missing intentionally
break is omitted intentionally
break missing intentionally
break omitted intentionally
break on error or EOF
break ref() from previous section
break the recursive cycle, so the elements can be freed by the MM.
breakpoint could be deleted
breakpoint_get -i # -d ID Returns information about the breakpoint with the given id
breakpoint_list -i # Returns all the registered breakpoints
breakpoint_remove -i # -d ID Removes the breakpoint with the given id
breakpoints holds a list of fresh new BreakPointInfo objects that have been deserialized from the client's list of breakpoints.
bring the palette colors in im2 to be closer to im1
buf_start is used for debugging  If the deserializer runs into bson it can't parse, it will dump the bytes to that point.
buffer for IPC_STAT, IPC_SET
buffer isn't completely full, fail
buggy scan() or refcount is too low.
build environment pair list
build map from function names to sections
build the array of objects
build the old IMAPG(folders) variable to allow old imap_listmailbox() to work
build the old simple array for imap_listsubscribed()
build the output buffer
build up a the new array of objects
buildIntervals() uses the sets in a single backwards pass to build precise Intervals with live range holes, and  2.
builtin function and static method
builtin-functions has to happen before zend_API since that defines getThis()
builtins/systems always have a user of anybody
busy wait until value is updated.
but also don't have the underlying type computed, then we are recursing into interface validation while checking the body of the type.
but if it does, use stderr.
but it is not apparent how to do that for schema's
but let's leave it in, in case we bring it back.
but m_timerActive is still set, so we haven't processed the signal yet.
but normal workers should proceed.
but not variadic ones.
but sometimes there will be
but strip off the requirements.
but the internal parameter name was right.
but we are not supposed to change this
but we do need to know the file size.
by the Gregorian calendar).
by-ref argument passed
bytes allocated in heap
byteswap a single magic entry
c) Size-untracked small allocation  Many callers have an easy time telling you how big the object was when they need to free it.
c_Vector* or c_ImmVector*
cache full - replace least-recently-used
cache hit, no need to grab write lock
cache lookup for absolute path
cache miss, need to grab write lock
cache still growing - add new elem
cacheDirectory/ModuleName
cached to avoid locked map lookup in the common case
calculate how many required args are at the end of the specifier list
calculate length after match
calculate pow(long,long) in O(log exp) operations, bail if overflow
calculate the free space in the buffer
calculate the length of the return buffer
calculate the slope of the line
calist is an array containing file and directory names.
call a function to parse all the text, so that we can use the same function to parse text from other sources
call back into JS with each change.
call by loading the address using rip-relative addressing.
call setCached after adding to the class list, otherwise the target-cache short circuit at the top could return a class which is not yet on the clsList().
call the user function
callToExit is special: it's a return helper but we don't treat it like one in here in order to simplify some things higher up in the pipeline.
call_user_func extensions Linked in via fb.json.idl for now - Need OptFunc solution...
callable type hint is considered builtin
callback for the passphrase (for localcert)
callback signaled from file watching threadproc that allows us to asynchronously post changes back to JS
callbacks for creating arrays out of ini
called from the verifier so m_cls is not set yet
called only if extra args are used
calleeAR m_soff is 0 in the re-entry case, so we'll set pc to the func base.
caller has already incremented pos but encountered a tombstone
caller raises exception
calls to this method are expected to come as a result of an error due to a requirement coming from traits or interfaces
can be delayed and combined with surprise flags check
can be nullptr for default constructor.
can decref ExtraArgs or VarEnv and Locals
can raise an error if class is undefined
can throw, otherwise - true means the map was updated.
can translation occur
can't be converted to an int: match default case
can't be converted to an int: match first nonzero case
can't do a near jmp - use rip-relative addressing
can't do a near jmp and a rip-relative load/jmp would require threading through extra state to allocate a literal.
can't happen know without bigger problems before
can't happen now without bigger problems before
can't nuke structs until done with palette
can't throw when you pass zero
can't use ARRAY because it's a reserved word
can't use FUNCTION because it's a reserved word
can't use xchg if one of the registers is SIMD
canInlineAt() helpers.
cancel the previous alarm if not triggered yet
cannot allocate new edges
cannot continue execution after deleting self
cannot end in : without previous :
cannot safely unset upper range.
cannot split before first_use
canonicalize asserts that we don't have nulls
canonicalize handles Windows paths too.
canonicolize path Grab and 0-index the begin line
case CURLOPT_DNS_USE_GLOBAL_CACHE: not thread-safe when set to true
case FIELD_TYPE_NEWDECIMAL:
case MYSQL_TYPE_NEWDECIMAL:
case PHP_ICONV_ENC_SCHEME_BASE64:
case PHP_ICONV_ENC_SCHEME_QPRINT:
case TAG_FMT_BYTE: case TAG_FMT_SBYTE:
case T_I08: // same numeric value as T_BYTE
case T_TRAIT_C: Note: T_TRAIT_C is translated at parse time
case T_UTF7: // aliases T_STRING
case nil is equivalent to .None when switching on Optionals.
case-sensitive unicode can still early-exit
cast as a POSIX fd or socketd
cast as a stdio FILE *
cast as fd/socket for select purposes
cast for 8-bit char's
cast is due to xml api
cast tests Bad types and null pointers should throw.
cast_or_null tests Bad types should throw, null pointers are ok.
caution: the Hebrew format produces non unique result.
certain schemas like mailto: and zlib: may not have any / after them this check ensures we support those.
chPtr is the int for the result
change it to "true" if at least 1 cookie was set
change the offset also in the chunk
changeUnsetElementsTo - If any elements of this availability set are not / known yet, switch them to the specified value.
changed already handled by unneeded
channel extrema/range
charListData must be null-terminated
character appears in ISO-8859 text
character appears in non-ISO extended ASCII (Mac, IBM PC)
character appears in plain ASCII text
character never appears in text
character-set, transfer-encoding
chdir failed, the working directory remains unchanged
cheap enough, do it always
check 1 or 2 digit day
check 1 or 2 digit hour and separator
check 1 or 2 digit time zone hour
check 1 or 2 month and separator
check 2 digit minute and separator
check 4 digit year and separator
check EH regions and targets
check Strings with embedded nulls
check against dynamic content cache
check against static content cache
check all functions this class has
check and set generator/async flags
check before calling this function
check each element in tuple
check emitSetCc is called only once
check extended opcode
check flag to see if do_mod was called to perform full add, gerrit thomson
check for bundled IPv4
check for dates before SDN 1 (Jan 2, 4713 B.C.)
check for dates before SDN 1 (Nov 25, 4714 B.C.)
check for defined classes
check for dynamic constant and volatile function/class
check for dynamic properties
check for empty and invalid collection names
check for empty private key
check for invalid dates
check for login and password
check for nullptr buffer in case of memory error in xmlEncodeEntitiesReentrant
check for numeric (int or float)
check for soft line break according to RFC 2045
check for the old child and whether the new child is already a child
check for unparsed characters at end of exp
check for username:password
check function parameter that can occur in lval context
check if MAP_UNITIALIZED is supported
check if a string based key is used
check if already started
check if bound parameter is already available
check if it is a replicaset
check if length is too large
check if match is a suffix
check if onIOWaitEnter callback unblocked any wait handles
check if shm is already initialized
check if suffix is a sub path
check if the buffers are already bound
check if the data we get is a port this allows us to correctly parse things like a.com:80
check if there is already more data
check if value exists, if yes append to that
check if we are above below water mark
check if we are above low water mark
check if we can write more data
check if we have a valid host, if we don't reject the string as url
check if we need to add any fields
check optional fraction
check session name for invalid characters
check static contents that were generated by dynamic pages
check that every allocation in heap has been freed before reset
check that exp starts with a file or method name
check that exp starts with a name
check that headers have a "sensible" state during sweeping.
check that no connection pools exist
check that offset is within range
check that this isn't a system ns
check that type from object and type are the same (obnoxious test)
check that we haven't nuked the SSATmp
check the apc array list
check the apc string list
check the highest numbered descriptor
check the inheritance clause of a type declaration or extension thereof.
check the number of columns in resultset
check time zone offset sign
check union_of and commonAncestor API
check union_of union of subCls
check whether its last access was more than maxlifet ago
check whether the current request was referred to by an external site which invalidates the previously found id
check whether this stmt generates a resultset
checkByRef() returns true if the parameter specified by argNum is pass by reference, otherwise it returns false.
checkCLASS does nothing by default.
checkCls must be the TCls for className (but it doesn't have to be constant).
checkDefiniteInitialization - Check that all memory objects that require / initialization before use are properly set and transform the code as / required for flow-sensitive properties.
checkForForbiddenPrefix is for testing purposes.
checkPartialApplyBody - Check the body of a partial apply to see / if the box pointer argument passed to it has uses that would / disqualify it from being promoted to a stack location.
checkSafeArrayAddressUses will check that the / store is a simple initialization outside the loop.
checkType(ty, fail): verify that the param is of type ty, and branch to fail if not.
checking whether the following line is part of a folded header
checks GOTO label syntax
child failed, raise the exception inside the async function
child failed, raise the exception inside the async generator
child replace stdin or stdout with the appropriate end of the pipe
child succeeded, pass the result to the async function
child succeeded, pass the result to the async generator
choice point, seeing what to do next.
choose an efficiently fread'able size
choose an efficiently fwrite'able size
churn through str, generating array entries as we go
cipher list varies according to SSL library, and "ALL" is for OpenSSL
clang::isIdentifierHead and clang::isIdentifierBody are deliberately not in this list as a reminder that they are using C rules for identifiers.
class AsyncMysqlConnectResult
class AsyncMysqlConnection
class AsyncMysqlConnectionPool
class AsyncMysqlErrorResult
class AsyncMysqlQueryErrorResult
class AsyncMysqlQueryResult
class AsyncMysqlResult
class AsyncMysqlRowBlock
class AsyncMysqlRowBlockIterator
class AsyncMysqlRowIterator
class EncodingDetector
class ImagickPixelIterator
class IntlBreakIterator
class IntlDateFormatter
class IntlDatePatternGenerator
class NumberFormatter
class ReflectionClass
class ReflectionFuncHandle
class ReflectionProperty
class ReflectionTypeAlias
class ReflectionTypeConstant
class name with PHP keyword
class-name constructor
class_method that refers to an initializing constructor is a method lookup for delegation, which is ignored.
classes containing counted pointers
classes containing exact pointers
clean up all the child ends and then open streams on the parent ends, where appropriate
clean up once event is processed
clean up once we finish canceling event
clean up the data block and return it
clean up varargs array if it was used
cleanly shuts down the file watching thread
cleanup our temp variables
cleanup temporary file and render to stdout or stderr
clear all the sub levels and mark all slots NULL
clear extended sign (64bits number.
clear extended sign that should not be set (32bits number.
clear http input identification.
clear lower 32bits on destination move lower 32bits to destination and keep the higher 32bits
clear lower byte on destination move lower byte to destination and keep the other 56 bits
clear sign bit, which we ignore
clear the Variant's copy
clear the ready status
client is gone, just eat the msg
clip if out of bounds
close listening sockets, this will initiate draining, including closing idle conns
close those descriptors that we just opened for the parent stuff, dup new descriptors into required descriptors and close the original cruft
close() can be called twice in some circumstances
close() may call destroy()
close() may destroy() us, so we have the destructor guard
closes the connection an frees structures
closes the data connection, returns NULL
closure function's variable table (not containing function's)
cmd is now part of cursor, so it shouldn't be dtored until cursor is
cns() would ODR-use these
coalesce per file arrays into a single one
code generation functions
code in trail, and vowels unless they separate
code that breaks a block ...
code wasn't correctly set by http client, treat it as not found
codepage 1252 is a Windows extension to iso-8859-1.
coerce the stream into some other form
coerceToType may have updated the element type of the ParenExpr in place.
collect WorkItem to run
collect info to be shared with the worker thread
collectClassSelfUses - Collect all the uses of a 'self' pointer in a class / constructor.
collectDelegatingClassInitSelfUses - Collect uses of the self argument in a / delegating-constructor-for-a-class case.
collections of scannable fields
colormap allocated at init time
colorspace of input image
column is only valid if an input buffer exists.
combinedLCG() returns a pseudo random number in the range of (0, 1).
comment, do not parse
commit the current transaction
compare element names
compare element numerically
comparison match reduce strength
compile the regular expression from the supplied regex
complete extension tests
component-wise summing-up of color values
compress stdin to stdout  Algorithm:  use open addressing double hashing (no chaining) on the prefix code / next character combination.
compress.zlib:// stream wrapper
compressed images only
compression is better then 2:1, need to allocate more memory
compute adjustedTarget before altering the smash address, because it might be a 5-byte nop
compute dest types of each instruction in forwards order 3.
compute next intersection/use of inactive regs to find what's free longest
compute next use of active registers, so we can pick the furthest one
computeTupleElementAddress - Given a tuple element number (in the flattened / sense) return a pointer to a leaf element of the specified number.
comunication with DebuggerProxy
concat_is will incRef the output string
concat_si will incRef the output string and decref its first argument
concat_ss will will incRef the output string and decref its first argument
concatenate all adjacent text and cdata nodes
concatenate the root search path and the file notification path
concatenation and increments
concrete classes should already have all of their methods present
condfail instructions that obviously can't fail are dead.
conditional allocation
conditionallyUnreachable is a no-op by itself.
connecting to the database
connection timeout: set in ms (current default 1 sec)
consistent with php_mysql_do_query_and_get_result
const TypedValue* NvGetInt(const ArrayData*, int64_t key)  Lookup a value in an array using an integer key.
const TypedValue* NvGetStr(const ArrayData*, const StringData*)  Lookup a value in an array using a string key.
const char *fn: list of magic files and directories
const-cast is okay since we are not freeing the passed attribute.
constants for Jewish date formatting
constants for easter calculation
constants for jddayofweek
constants for jdmonthname
constructor and destructor
constructors and destructor
constructors/destructors
consume a code point, or fail if there was none to consume
consume the input value.
consumes a ref on counted values
consumes s2 reference
container_size indicates number of bytes to be left blank at the beginning of p_out buffer to accommodate for a container header.
contains INI value of whether to use trans-sid
containsUnknownElements - Return true if there are any elements that are / unknown.
content_length is a reasonable nonnegative size.
contextParams will point to the last deserialized list, which is the innermost one.
continously running until /stop is received on admin server, or takeover is requested.
continue foreach loop
continue resolution anyway but don't save result in the cache
continue with the received result on the stack
continuing from the previous line
control flow sensitive types:  Things are also slightly complicated by the fact that we are analyzing some control flow insensitve types along side precisely tracked types.
convenience initializers are only allowed on classes and in extensions thereof.
conversion to string can throw
convert *nix paths (eg.
convert ID back to base cell indexes
convert UNC paths (eg.
convert Vptr to MemOperand
convert a palette image to true color
convert angle to radians
convert chars to upper case and strip non-letter chars
convert cmpli to cmpqi or ldimmq + cmpq by cmpqi's lowering
convert escape sequences
convert fields back to Strings to get lengths
convert from decimal to int
convert it to unsigned d.
convert offset from milliseconds to minutes
convert palette to libpng layout
convert the 7-bit alpha channel to an 8-bit alpha channel.
convert the full pathname to utf8
convert to the encoding number and check encoding
convert usage to MB..
convert windows drive paths (eg.
convert_function is required to be an ABI-compatible conversion.
converted string is longer than out buffer
converted super globals
converts jpeg/png images to wbmp and resizes them as needed
copied and re-factored from addr2line
copied and re-factored from demangle/c++filt
copied from ProtocolConformanceRecord::getCanonicalTypeMetadata()
copied from cmemory.h, which is not public
copied from hphp_switch_to_buffer.
copied from yy_switch_to_buffer.
copies will go at end of b
copies will go at start of successor
copy belongs on successor edge
copy declared return type (hack)
copy document count to var user sent in
copy doesn't set any flags
copy doesn't set any flags.
copy each element of our input array to the buffer
copy out the dir from response
copy out the pwd from response
copy over any stragglers
copy propagation on inst source operands
copy replacement and backrefs
copy result into our return var
copy str, replacing '.' with '_'
copy the MergeKind::Done marker
copy the decimal places.
copy the numbers before the decimal point, adding thousand separator every three digits
copy the old data into it
copy the part of the string before the match
copy the rest of p, the NUL is NOT copied
copy the value string for work
copy to image, mapping colors
copy_addr is ok, but counts as a mutation if the use is as the destination or the copy_addr is a take.
copy_addr without initialization can cause a release.
corrected date of the Paschal full moon
could be POLLERR or POLLHUP but can't tell without probing
could do this in a simplify pass
could get here and we only have parts of an SSL packet
could not resolve address(es)
couldBe is symmetric and reflexive
couldSimplifyUsers - Check to see if any simplifications are possible if / "Val" is substituted for BBArg.
couldn't convert to string and back
couldn't/wouldn't detect tag type, assume string
count does not include NUL
count each document as we pass
count is constant numNonDefault
count the number of listed encoding names
count the variables(separators) contained in the "res".
counts nesting for ( and T_UNRESOLVED_OP
counts nesting for T_TYPELIST_LT
cppext functions/methods have their own logic for raising warnings for missing arguments, so we only need to do this work for non-cppext functions/methods
crash at this specific address so that we can find our crashes easier
crc32 of current working directory
create MongoBinData object
create a bson code with scope  type: 15 4 bytes total size 4 bytes cstring size + NULL cstring bson object scope
create a bson date  type: 9 8 bytes of ms since the epoch
create a bson int from an Int32 object
create a bson long from an Int64 object
create a bson regex  type: 11 cstring cstring
create a certificate store and add those certs to it for use in verification.
create a fake palette and check for single-shade transparency
create a packed array of the waithandles
create a sandbox info with no path for now.
create a section for the preamble that precedes the first boundary
create a socket for this address
create a temp file for the data
create a top level DIE (debug information entry) all subsequent DIEs' will be children of this DIE
create an empty array to hold results
create an entry for each column of the resultset
create an id for the file
create an initial item representing the file with all uuencoded parts removed
create anchor to refer to this structure
create base query object
create bson binary data  type: 5 4 bytes: length of bindata 1 byte: bindata type bindata
create bson timestamp  type: 17 4 bytes seconds since epoch 4 bytes increment
create chunks collection
create cursor, with RP inherited from us
create files collection
create foreground color
create function/method statement
create instance of default object class
create new multipart_buffer structure
create regex pattern buffer
create temporary file for OS that have no /dev/stdout or /dev/stderr.
create the background color
create the class variable and change the location to point to the parameter location for error reporting
create the file if it doesn't exist already
create the full path..
create the message for the exception
create wbmp ----------- create an empty wbmp
createNominalType - Create a new nominal LLVM type for the given / protocol composition type.
createNominalType - Create a new nominal type.
createSchema() successfully wrote to the database, so no further verification is necessary.
creates a new per-prio queue if necessary
cross the context boundary
ctx is a pointer to some context information that will be passed through to tryFile.
ctx is not related to the class that first declared this protected method, so this method is not accessible.
ctx is not the class that declared this private method, so this private method is not accessible.
ctx is not the same, an ancestor, or a descendent of baseClass, so the property is not accessible.
curFunc is null when called from conjureBeginInlining
curN holds the error propagated from the previous pixel on the current line.
current distance in inner loop
current error or pixel value
current instruction in the Label.
current maximum object identifier
current position in input buffer
current position inside buffer
currently letting libxml2 set the version string
currently unknown portion of vmSize
cut ALL traling zeros only if the number of chars is greater than precision otherwise cut only extra zeros
cvtsi2sd doesn't modify the high bits of its target, which can cause false dependencies to prevent register renaming from kicking in.
cwd_length can be 0 when getcwd() fails.
d8-15 are callee-saved
dSYM actions are never treated as top-level.
dSYM outputs are based on the image.)
data isn't an array or object, so we're done
data wrapper can come with or without a double forward slash
data: is always supported since it doesn't reference data outside of the current document.
date only format requires YYYY-MM-DD
day of the month (with leading space -- non-standard)
day of the month (with leading zero)
day of the week (0-6)
day of the year (with leading zeroes)
db connection resource
deactivate - common for server/client
dealloc_box the self box if necessary.
dealloc_ref on self can be ignored, but dealloc_ref on anything else cannot be eliminated.
dealloc_stack can be ignored.
debug_file is the file to output debug messages to.
debugger and code coverage instrumentation
debugging and info/stats support
decRefGeneric is called via callfaststub, whose ABI claims that all registers are preserved.
decodeLLVMAtomicOrdering - turn a string like "release" into the LLVM enum.
decref after awaitResult is on the stack
decref after we hold reference to the exception
decref apc arrays referenced by this request.
decref apc strings referenced by this request
decrefs context object in iter
decrefs src, but src is a string
decrefs src, may read obj props
def gets populated here
default format for stdout and stderr
default handlers Informs the client of all argument strings that may follow this command name.
default implementation of virtual functions
default implementation scans for ambiguous pointers.
default to 'openssl.cnf' if no environment variable is set
default to 50s (to match libevent)
default to UTF-8 encoded files
default to cached value
default to regular inet (see below)
default witness count
define('HPHP_VERSION', 'XX.YY.XX') define('HHVM_VERSION', 'XX.YY.XX')
defined here because memory-manager.h includes sweepable.h
defined in ext_simplexml.cpp
defined/not-defined state of each iter var.
delay deletion into the event loop, direct deletion can trigger crashes
delete any other parameter registered with this number.
delete files/directories that are only in dest
delete mismatched types so to copy over new ones
delete on a null pointer is defined to be a noop.
delete the converter if it is the last feed.
delete the converter just in case.
delete the ones to delete
delete the temporary directory if not needed
departure from PHP: we got rid of dependencies on spprintf() here.
deprecation warnings disabled
dereferencing s_request_wrappers will call requestInit, and register a request shutdown event handler 3.
des submitted this bugfix: gdFree the memory.
desired fd number in child process
destroy event and its private data
destroy_addr is a release of the entire value.
destroy_addr(p) is strong_release(load(p)), try to promote it too.
destroy_addrs commonly exist in a block of dealloc_stack's, which don't affect take-ability.
destroyaddr on the box is load+release, which is treated as a release.
destructors of value types always have an implicitly inout self.
detach -i # Detaches the xdebug server.
detect event type and get tag
detect filetype from first bytes
determine the status for the current cert
determine whether location is relative
determine whether token should be used to sign the request
determine whether we should compress response
diagnoseProblems - After a function is fully parse, emit any diagnostics / for errors and return true if there were any.
diagnoseRedefinition - Diagnose a redefinition error, with a note / referring back to the original definition.
did not receive "expect" header, but too much post data.
didn't find boundary, abort
didn't find the boundary
diff/intersect helpers
differs from upstream where gdGetBuf return 0 instead of EOF
directory, like /usr/bin/
disallow access with an absolute path
discard the now-processed entry
discard the part that has been already decoded.
disp is loaded on a register.
dispatch arbitrary declaration to relevant circularity checks.
dispatchExtra translates from runtime values for the Opcode enum into compile time types.
do a check for mod_proxy_fcgi and remove the extra portions of the string
do not delete intermediate files
do not inform about in debug
do not recompute length here
do not return the shape fields and keys
do not use oauth_parse_str here, we want the result to pass through input filters
do nothing Stored type variables in a generic context need to logically occur once per instantiation, which we don't yet handle.
do nothing and continue to conservative scan for now.
do nothing but avoid the toString conversion notice
do nothing here, as everything will be collected by MemoryManager
do regular backreference copying
do regular substitution
do the default on invalid input
do the same as for all other expressions
do uri matching on the relative path
doIt - returns true on error.
document consists of next element
does not have an explicit constructor with __construct 2.
does not modify flags
dom_import_xml() is one way for this to happen.
don't allow numeric keys
don't bother copying the character iterator, getText() is deprecated
don't canonicalize to the right, OP might not be commutative
don't care about other event types
don't clone the function statement or the vars, since they are shared with the function scope
don't do the read, it's not guaranteed to return an EOF, just force an EOF
don't ever resolve to the color that has been designated as the transparent color
don't format doubles as integers.
don't free global VarEnv
don't have the sandbox on file yet.
don't include ( and ) in the output string
don't include : before ipv4 unless it's a ::
don't let DOMElements get free'd out from under us while preparing to create a new document
don't let XMLNode try to cleanup
don't let bfd_cache_ptr malloc behind the scenes in this case
don't mark the symbol as overridden
don't need this till we fully implement error reporting ...
don't need to do anything
don't need to worry about overwritten list, because this is definitely the first time we're setting this property.
don't return empty string
don't reuse addq and addqi as they need a SF
don't serve the request if it's been sitting in queue for longer than our allowed request timeout.
don't treat strings ending with a period as numbers
don't try to write REQUEST_COMPLETE again There may still be a pending eventCount from an onComplete call from the open tranport.
don't try to write the data twice
don't use cmpqim because of smashableCmpqImm implementation.
don't want to confuse with primed keys
done if matches up to capacity of buffer
dont allow leading : without another : following
double free on failure
double indirection to have the zend engine destroy the new zval that results from separation
downscaling using the fixed point implementations are usually much faster than the existing gdImageCopyResampled while having a similar or better quality.
draw_bitmap - transfers glyph bitmap to GD image
drop ownership by pending event (see initialize())
drop the message into place
dropped if after C else K
dropping double_encode parameters and see runtime/base/zend-html.h
dst must be the first in its cluster
dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
due to bug #40743, we have to set the time zone again
dump all buffered output
dump starting from the hot region
dvInit pointers are consistent in the parameters vector and on the func.
dynPropTable is a req::hash_map, so this will req::free junk
dyn_cast tests Bad types are ok, null pointers should throw.
dyn_cast_or_null Bad types and null pointers are ok.
dynamically check if we have a This pointer and call emitGetCtxFwdCallWithThisDyn below
e.g. it is / not safe to store to an element in the array because we may be storing an / alias to the array storage.
e.g., -1 means start with the last code point.
e.g., defined("self::ZERO")
eIPrev will actually be used, so properly initialize it with the previous element before pos (or an invalid position if pos was the first element).
each byte is " xx" (3 chars)
each catch block is reachable from b
each catch target for eh is reachable from b
eagerly rename all SFs
eat up the passed in storage even if it won't be filled in with varargs
eek -- this is just a clean-up notification because the connection's been closed, but we already dealt with it in onConnectionClosed
eg: when describing a table that contains an enum column.
eh is the innermost fault funclet reachable from b.
either an int or a dbl, but can't tell
either else branch or if (true) branch without further declarations
elementToData() may need to modify the value.
else call string version
else fallback to default
else ignore the dependency...it'll show up as a linker error.
else leave offsetp NULL
else there's nothing more we can do in non-interactive mode
else timed out, then we have a chance to check m_stopped bit A chance for some housekeeping...
else we have negative limit and delimiter not found
else we've reached the end of the enum, nothing more is required
else, we're done with meta
emit a call to willThrow
emit code to create generator object
emit nop for a balanced li32 with 2 instr
emit nop for a balanced li32un with 3 instr
emit nops to fill a standard li64 instruction block this will be useful on patching and smashable operations
emit surrogate object and tag
emitBBMapForSelectEnum set up a continuation block and phi nodes to receive the result.
emitBBMapForSelectEnum set up a phi node to receive the result.
emitBranchAndCleanups - Emit a branch to the given jump destination, / threading out through any cleanups we might need to run.
emitBuiltinCall - Emit a call to a builtin function.
emitClassDecl - Emit all the declarations associated with this class type.
emitConversionToSemanticRValue always produces a +1 strong result.
emitConvertSecondToCell() should never be used for symbolic flavors other than C or L
emitInitializeFieldOffsetVector will do everything in the full case.
emitLazyCacheAccessFunction will see that the value was loaded from the guard variable and skip the redundant store back.
emitOptimizedOptionalEvaluation - Look for cases where we can short-circuit / evaluation of an OptionalEvaluationExpr by pattern matching the AST.
emitOrDeleteBlock - If there are branches to the specified JumpDest, / emit it per emitBlock.
empty callback url specified, treat as 1.0a
empty region Modes that create a region by inspecting live VM state
empty string given as pattern
empty variable name, or variable name with a space in it
emulate it by fetching and discarding rows
emulate poll(2) using select(2), safely.
enable data conn encryption
enableDiagnosticVerifier - Set up the specified source manager so that / diagnostics are captured instead of being printed.
enabling mutex profiling, but it's not turned on
encode each as a 3 byte surrogate value
encoding handled by property on doc
encoding is a 0 or 1 and str is a string of length less than or equal to 32.
end Olympus specific tags
end SHUFFLE_EXTRA_ARGS_PRELUDE
end additional , gerrit thomson
end anonymous namespace
end anonymous namespace / Apply a merge function to two optional versions, returning the result / in Inferred.
end anonymous namespace / Checks operands of a string concatenation operation to see if / optimization is applicable.
end anonymous namespace / Code motion that does not releases into diamonds.
end anonymous namespace / Emit a global initialization.
end anonymous namespace / Emit all the top-level code in the source file.
end anonymous namespace / Emit global structures associated with the given protocol.
end anonymous namespace / Estimate the cost of inlining a given basic block.
end anonymous namespace / Given an expression and its context, the analyzer tries to figure out the / expected type of the expression by analyzing its context.
end anonymous namespace / If we find the specified diagnostic in the list, return it.
end anonymous namespace / Merge in the state of the successor basic block.
end anonymous namespace / Perform a copy or init operation from an array of ManagedValue (from an / RValue) into an initialization.
end anonymous namespace / Perform top-down syntactic disambiguation of a pattern.
end anonymous namespace / Plan the reabstraction of a call result.
end anonymous namespace / Return the ArchetypeTypeInfoBase information from the TypeInfo for any / archetype.
end anonymous namespace / Return true if the witness table requires runtime instantiation to / handle resiliently-added requirements with default implementations.
end anonymous namespace / Return true if there are any users of V outside the specified block.
end anonymous namespace / Returns true if this particular ValueDecl is overloadable.
end anonymous namespace / Sink Retains.
end anonymous namespace / Skips a single record in the bitstream.
end anonymous namespace / The main entry point.
end anonymous namespace / Used to deserialize entries in the on-disk decl hash table.
end anonymous namespace / addElementUses - An operation (e.g. load, store, inout use, etc) on a value / acts on all of the aggregate elements in that value.
end anonymous namespace.
end llvm namespace / Determine whether the given declaration can inherit a class.
end namespace FatalErrorFlags
end namespace comments
end namespace options
end namespace version
end of nested comment sequence
end of scanning one token
end standard C headers.
end tables serialization structures and prototypes
end unnamed namespace
end user quitting debugger
endCatchHelper only expects rvmtl() and rvmfp() to be live.
endian neutral extractions of RGBA from a 32 bit pixel
ensure index on chunks.n
ensure that any reusable stubs are updated for the relocated code
ensure that if we clear any spill frame bits, we clear them all.
ensure that localized results don't have another result
ensure that there's no request-allocated memory
ensure that we don't have spaces or dots in the variable name (not binary safe)
ensure that we free any previous unfetched results
ensure the cancel button is enabled before starting.
ensure we only return 0 for FILE_DEFAULT
enter new asio context and set up guard that will exit once we are done
entity is 16 bytes, allocated statically below default in PHP
entries are null-terminated, so extract them and push them into the set.
entry and update the cache
entry has no dominator.
enum elements and function parameters are not instance members.
enums marked as 'indirect' are safe
eof if we are out of bytes, or if we hit the final boundary
erase it from its parent.
erase unreachable blocks and get an rpo sorted list of what remains.
eraseFromParent - This method unlinks 'self' from the containing basic / block and deletes it.
error - print best error message possible
error encountered parsing input
error for below/prev col
error for pixel below cur
error occurred changing cwd back
error-recovery path, only
error_log() should not invoke the user error handler, so we use Logger::Error() instead of raise_warning() or raise_error()
error_message will be free()d, but errmsg was allocated by PHP and needs efree()
errors stores all keys corresponding to entries that could not be cached
especially, SSA block order doesn't matter, but only visit reachable blocks.
esstsett, thorn, n-tilde, c-cedilla, s-caron, ...
evaluate expression passed to await
evaluate key passed to yield, if applicable
evaluate value expression passed to yield
even if it's empty, still need to call for warmup
even if line is bad command, we still want to remember it, so people can go back and fix typos
even if we had an m_conn immediately above, it may have been cleared out by onConnectionClosed().
even if you notify it.
even position requiring a copy must be on edge
event has finished, but process() was not called yet
exact prefix match bonus
exactly half-way between
exception are IFD pointers
exception would have been thrown already
execinfo.h is not available on Android.
execute arbitrary ftp command
execute serverside command
execute the stmt itself
executes a previously prepared query
executes a query and open the cursor
executes a query and returns an ODBCCursor obj
exit without an expression is treated as exit(0)
expand to 1 byte per pixel
expecting a charset name
expecting a chunk of whitespaces
expecting a delimiter
expecting a encoding scheme specifier
expecting a non-encoded word
expecting an encoded portion
expecting any character
expects a language specifier.
expirePaths() is only called in situations where the entire subtree needs to be completely invalidated.
exponent has 7 bits, but 8 is the right value in b2d
exponential format (e.g. 1.2345e+13)
expose the mysql field types
expose the mysql flags
exposed to runtime/base/ini-setting.cpp
expr-anon-closure-argument: /     dollarident
expr-literal: /     string_literal
expression separators
ext/intl error handling
extend byte sign compare immed only with the byte extracted
extend the sign bit if the comparison is to be signed
extend url request with oauth parameters
extension class methods
extension in this module
extern "C" function should not be throwing exceptions...
external thread transitioned from empty to non-empty while grabbing lock
extra bit of validation for instances when same params are bound more then once
extract an error from a handle
extract lower byte clear lower 32bits on destination
extract ones in the array
extract only this file
extract public key from X509 cert
extract the address part of the content-id only
extracts the error msg from a particular handle
fail fast if the post is too large, but only bother resolving host if content_length is larger than the minimum setting.
fail if headers have already been sent
fail if there is no transport
fail on any non-basic code point
failed creating the child process
failed to decompress the file, will try reading the rest of the file
failed to read statm file
fake a MongoCollection object
fake a MongoDB object
fake a quoted string for this last token
fake event grouping all dTLB misses
fake event grouping all dcache misses
fake event grouping all iTLB misses
fake event grouping all icache misses
fall through if not KindOfString
fall through to SORT_REGULAR case
fallback to normal popen
fallback, when a vasm is not lowered
falls through if that condition was false
falls through if that condition was true
fallthrough for a normal obj
fastpath/slowpath attrs are untested because the inliner luckily inlines them before the downstream calls.
fcallHelper asserts native stack alignment for us.
fclose() should prevent this from being called on a closed stream
fd_set can only hold sockets from 0 to 1023, anything higher is ignored by FD_SET() avoid "unexplained" behavior by failing outright
fds for pipes in parent/child
feature_get -i # -n NAME
feature_set -i # -n NAME -v VALUE
fetch all on demand, this seems easiest if we've been here before bail out
fetch more rows into the buffers
fetch one row of the cursor
fetch the relevant data
fetch zend object from zval "object" into "to"
fetchToken() will return the first token in the lookahead store (if the lookahead store has tokens) or it will get a new token from the frontier
field name is too long
figure out the GMT offset
figure out the best c data type based on the sql data type we have
figure out the result set format, if any
figure out where the message part starts/ends
figure out which Vregs are constants and stash their values.
file current position
file error after info
file location without anything else
file: URLs may be disabled.
filename can be a filename or a stream
filename is the actual data
fill buffer if needed
fill in the basic info
fill in the standard set of oauth parameters
fill this out if people need it
fill up the WBMP structure
fill up the buffer with client data.
filled in by instantiator function
filter jumps to prologues of other funcs
filter jumps to prologues of other funcs for now
filter out types that should not be exposed to the runtime
final on classes marks all members with final.
final sorted list of cluster ids
finalize endpoint url
finally, get the error message
find a caller node with the given address, or make a new one.
find address and figure out binding type
find all the stores, so we can determine whether a phi is actually required for each src (also, we need a candidate store to clone)
find and apply the evaluation function
find and apply the filter function
find antialised color
find decimal point, if expected
find earliest common predecessor of p1 and p2 (lower RPO ids are earlier in flow and in dom-tree).
find instruction boundaries and make sure no branches escape
find out which PHP function to call with what params
find parent in the same context
find the best successor, which is the one to which cid has the highest weight among the ones that haven't been visited yet
find the entry in the array
find type of descriptor
find type of named file
findUnexpectedBoxUse - Validate that the uses of a pointer to a / box do not eliminate it from consideration for promotion to a / stack element.
finish current transaction (commit or rollback)
finish default implementation
finish populating cursor
finish processing live ranges for constants
finished if we found the boundary
first case-sensitive match
first character cannot be ' or -, unless explicitly allowed by the user
first code of JIS-8 pair
first getImm is suppose to get the sign
first letter of a non-encoded word
first letter of an encoded chunk
first look for argnum
first look in _SERVER
first step: decode '+' to spaces
firstUse:      The first use in `this'.
fix timestamp format for PHP4
fixed type from ExtraData
fixed type from ctx class
fixup code references in the corresponding cold block to point to the new code
fixupBlockJumps() breaks the given block after any jccs, making the unit valid again.
fixupWork() takes an `ar' argument and syncs VM regs for the first TC frame it finds in the call chain for `ar'.
flag SP offset as unknown for all but the first block
flag for full add operation so ldap_mod_add can be put back into oper, gerrit THomson
flag optional arrays not allocated
flag that says to auto-release.
flag to remember which row we are on
flags are not used by MemoProfiler::MemoProfiler
flatten continuation StatementList into MethodStatements
flex integer type definitions
floating point string
floating-point conversions
floor it just in case
flush so if php crashes us we still have this output so far
flush the shift-out sequences
foldConst() is callable from the parse phase as well as the analysis phase.
foldSequence - Take a sequence of expressions and fold a prefix of / it into a tree of BinaryExprs using precedence parsing.
folly::symbolizer isn't supported on all the platforms that HHVM is, so we deliberately exclude it in our CMake setup, which makes this feature FB-only for now.
foo If we are parsing a refutable pattern and are inside a let/var pattern, the identifiers change to be value bindings instead of decl references.
foo doesn't actually match because we jump straight to the last 'O'.
for "big boy" drivers, we need to allocate memory to fetch the results into, so lets do that now
for HardBreakPoint, default the frame to the caller
for all SuccessPreds.
for all other already-processed predecessors p2 of block
for apc, we know the key can't exist, but ignore that optimization
for builtin calls, since we don't push the ActRec, we must determine the reffiness statically
for calendar calculation purposes.
for cleaner valgrind output when gethostname() fails
for each block after start, in reverse postorder
for each block in reverse postorder: 2.
for each function, add DIE entries with information about name, line number, file, etc
for each modification
for each raw comment: column number of the first line, length of each raw comment and its text.
for each tracelet, register tracelet address ranges in an FDE (Frame Description entry)
for exponent conversion
for fresh type variables T0 and T1, which pulls out a static member, i.e., an enum case or a static variable.
for hard breakpoint, the fp is for an extension function, so we need to construct the site on the caller
for heb_number_to_chars
for internal use by copyStatic() and copyMixed()
for multithreading mode
for now only store TypeAnnotation info for type constants
for now, it's the same as Jcc
for now, only store the vanilla names (strings) as part of the access list
for now, we don't bother with the address whitelist
for php_memnstr, used by php_stream_get_record()
for pointers to histogram cells
for reading from input
for rsrc, only write NULL in arrayHeader
for specialized object tests to get some real VM::Class
for the NUL terminator
for the initial timer, we want to stagger time for large installations
for the modification hashtable...
for this operation to succeed, we need room for the entry we're adding, two realloc entries, and two entries to mark the end of the trace.
for this perpouse we allocate additional PHP_IMAP_ADDRESS_SIZE_BUF bytes by default this buffer is 10 bytes long
for xml_parse_into_struct
force arr to escalate (if necessary) by getting an lvalue to the first element.
force tail calls at -O0
force this to be used
force use of sf_used.
force_error_reporting
forces fill_input_buffer on first read
foreach also advances the index after the last iteration, so I see no problem in incrementing the index here unconditionally
forget the source for systemlib.php unless we are debugging
fork again, to avoid blocking because both pipes filled
fork failed, join now.
format date as iso-8601 string
found a registered callback for this class
found freed heap node that fits allocation and doesn't need to split
found if checking both, check value
found match for the exact child class
found the main thread-local section
found what we needed to find, stop walking.
fp1 should only be NULL if fp0 is the top-level pseudo-main
frame pointer offset in previous frame
free but still reachable
free error string received during previous iteration (if any)
free heap space freed nodes are stored in address ordered freelist
free old palette buffer
free stuff without running destructor or decrefing contents
free the bvalue struct
freeList is address ordered first fit
freewbmp -------- gdFrees up memory occupied by a WBMP structure
from immutable typeParam
from patchBctr: It has to skip 6 instructions: li64 (5 instructions) and mtctr
from section 3.6.1 of UTR #36: "In a reported illegal byte sequence, do not include any non-initial byte that encodes a valid character or is a leading byte for a valid sequence."
from the gnu manual: gethostname stores the beginning of the host name in name even if the host name won't entirely fit.
from the path, so we know we can be sure we are at a good place for this check.
fromType is a struct with fewer elements.
fromType's overlapping elements are compatible.
fs points to the end of the threadlocal area.
fsmagic - magic based on filesystem info - directory, special files, etc.
fsock: treating sockets as "file"
fsync forces "w" to be at least 1, so don't touch it if it's already set to something else above while parsing "w" (and "safe")
ftello is 64-bit by default under OSX, and ftello64 doesn't exist.
full date spec (non-standard)
full mmap'd rds section.
full time and date spec
full time spec (non-standard)
func _unimplemented_initializer(className: StaticString).
funcPrologue --  Given a callee and a number of args, match up to the callee's argument expectations and dispatch.
function entry breakpoint
function type: decl-ctx + type FIXME: we should just be able to demangle the DeclCtx and resolve the function this is fragile and will easily break
function/method declaration
function_ref inside fragile function cannot reference a private or hidden symbol.
furc_get_bit -- the bitstream generator  Given a key and an index, provides a pseudorandom bit dependent on both.
future work - #3098509 streamline code, vectors vs linked lists, etc - #3098685 Optimize lifetime splitting - #3098739 new features now possible with XLS
g_context is request allocated, and has some members that need cleanup, so destroy it before its too late
gap in sequence found
gcc 4.9 has a bug where it will spit out a warning:
gd 2.0.11: gdSeek returns TRUE on success, not 0.
gd 2.0.2: watch out for negative indexes (thanks to David Marwood).
gd 2.02: whoops, was - b (thanks to David Marwood)
gd 2.0: we now support truecolor.
gd 2.0: we support this rather thoroughly now.
gd has only 7 bits of alpha channel resolution, and 127 is transparent, 0 opaque.
gd interface to freetype library
gd is intentionally imperfect and doesn't spend a lot of time fussing with such things.
gdAffineexpansion: Find the affine's expansion factor.
gdAntiAliased passed as color: use the much faster, much cheaper and equally attractive gdImageAALine implementation.
gdDPExtractData is the exception to this: it will return the pointer to the internal data, and reset the internal storage.
gdIOCtx JPEG data sources and sinks, T.
gdImageConvolution does not exist in our libgd.a, copied from php's libgd/gd.c
gdImageCreateFromWBMPCtx ------------------------ Create a gdImage from a WBMP file input from an gdIOCtx
gdImageStringFT -  render a utf8 string onto a gd image
gdMalloc'd storage for the above
gdTcl_UtfToUniChar is borrowed from Tcl ...
gd_gd2.c  Implements the I/O and support for the GD2 format.
gd_getin -------- Wrapper around gdGetC for use with readwbmp
gd_jpeg.c: Read and write JPEG (JFIF) format image files using the gd graphics library (http://www.boutell.com/gd/).
gd_putout --------- Wrapper around gdPutC for use with writewbmp
gd_security.c  Implements buffer overflow check routines.
gd_topal, adapted from jquant2.c  Copyright (C) 1991-1996, Thomas G.
gdcache.c  Caches of pointers to user structs in which the least-recently-used element is replaced in the event of a cache miss after the cache has reached a given size.
gdkanji.c (Kanji code converter)
generally not thread safe, but it *is* thread safe under win32
generate a huge chunk
generate mmap flags for contiguous heap
generate sig base on the semi-final url
generate: var indexVar
generateLayout can call itself recursively in order to compute a layout for the abstract type.
generic argument list
generic signature, type
get PHP's output if "output" is NULL
get a connection pool
get a lower-case version of the first token
get color values of neighbouring pixels
get current autocommit behavior
get iso-8601 format specifier
get length of string if buffer if less than buffer size or buffer size
get lines of text, or CRLF_CRLF
get marker byte, swallowing possible padding
get marker byte, swallowing possible padding some software does not count the length bytes of COM section one company doing so is very much envolved in JPEG...
get offset, then skip over it
get pixel location in gd buffer
get pixel value and index into the cache
get pixel value and index into the histogram
get raw directory listing
get ready for the next iteration
get rid of decimal places
get the collection we just created
get the converter output, and return it
get the font (via font cache)
get the id from a specified key or create new shared memory
get the kind out of the finder.
get the length of the message
get the length of the true salt
get the list of variables users can override on the command line
get the public keys we are using to seal this data
get the significant edge points affecting the pixel
get the system.indexes collection
get the user-entered settings for this pool, if there are any
get/address default to non-mutating.
get/set source/dest encodings
getASTContext() doesn't actually mutate an already-canonical type.
getAccessPathRoot - Given an address, dive through any tuple/struct element / addresses to get the underlying value.
getAddrOfWitnessTableOffset - Get the address of the global / variable which contains an offset within a witness table for the / value associated with the given function.
getAddrOfWitnessTableOffset - Get the address of the global / variable which contains an offset within a witness table for the / value associated with the given member variable..
getBBForDefinition - Return the SILBasicBlock for a definition of the / specified block.
getBBForReference - return the SILBasicBlock of the specified name.
getBuiltinBaseName - Decode the type list of a builtin (e.g. mul_Int32) and / return the base name (e.g. "mul").
getCanonicalType - Return the canonical version of this type, which has / sugar from all levels stripped off.
getDecl - Return the underlying variable declaration associated with this / allocation, or null if this is a temporary allocation.
getEffects would assert since these haven't been lowered yet.
getElementForScalarInit - If a tuple of this type can be initialized with a / scalar, return the field number that the scalar is assigned to.
getElementTypeRec - Return the swift type of the specified element.
getExtraInhabitantIndex
getGlobalNameForDefinition - Given a definition of a global name, look / it up and return an appropriate SIL function.
getGlobalNameForReference - Given a reference to a global name, look it / up and return an appropriate SIL function.
getIdentifier - Return the uniqued and AST-Context-owned version of the / specified string.
getInfixData - If the specified expression is an infix binary / operator, return its infix operator attributes.
getInstructionKind - This method maps the string form of a SIL instruction / opcode to an enum.
getLastError can return an error here
getLivenessAtInst - Compute the liveness state for any number of tuple / elements at the specified instruction.
getLoc - Return the caret location of the pattern.
getLocalValue - Get a reference to a local value with the specified name / and type.
getNamedElementId - If this tuple has a field with the specified name, / return the field index, otherwise return -1.
getOperandNumber - Return which operand this is in the operand list of the / using instruction.
getOrEraseBlock - If there are branches to the specified JumpDest, / return the block, otherwise return NULL.
getSelfConsumedAtInst - Compute the liveness state for any number of tuple / elements at the specified instruction.
getSourceRange - Return the full source range of the pattern.
getTupleType - Return the uniqued tuple type with the specified elements.
getUnderlyingObject will ignore that, while findAddressProjectionPathBetweenValues wont.
getUnderlyingPath and findAddressProjectionPathBetweenValues disagree on what the base pointer of the two values are.
getValue - Return the APInt for the underlying integer literal.
get_include_file_path will check relative to the current file's dir as long as the first char isn't a /
gethostname may not null-terminate
gets the next CRLF terminated line from the input buffer.
getters and setters funcdecls will be handled by their parent var/subscript.
give entry an extra predecessor to prevent cloning it.
give gdb users some love
given a choice of blocks, choose the one with higher post-order id to avoid cycles
given a method defined as func ...
glibc does not have localeconv_l, and so we need to do some shenanigans.
global environment overrides the hdf
global pattern matching
go back to dirty (see the comments of sync_regstate_to_caller)
go through the k/v pairs and serialize them
go to the preclass to find the unresolved TypeStructure to get the original assigned type text
got expect 100-continue, but content_length is too big.
government, the Government shall have only "Restricted Rights" in the software and related documentation as defined in the Federal Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).
grab a uint32_t from a possibly unaligned address, and return it in the native host order.
gregorian or julian month
grow (or shrink) dynamic pointer
guarantee our math with kLi64InstrLen is working
guess weight for non-inferred arcs
hack to get LLC counters on perflab frc machines
hacky, but transforming to a single token is quite convenient
han2zen() was derived from han2zen() written by Ken Lunde.
handle #if directives.
handle Location header
handle a compiled file.
handle an mmaped file.
handle any left overs of files without new lines
handle enclosure delimited field
handle for the server
handle generic PDO-level attributes
handle single line of status code
handleLoadUseFailure - Check and diagnose various failures when a load use / is not fully initialized.
handleSelfInitUse - When processing a 'self' argument on a class, this is / a call to self.init.
handleSuperInitUse - When processing a 'self' argument on a class, this is / a call to super.init.
handled as a special case in expand()
handled by KindOfIfStatement
handlers could cause other handlers to be registered, so need to repeat until done
happens with optional types
hard coding the name of 'HPHP::TypedValue'
has interlace argument
has newline(s), make sure they are preserved
has query in 404 string
has to be before zend_API since that defines getThis()
has to happen before zend_API since that defines getThis()
hasAnyDefaultValues - Return true if any of our elements has a default / value.
hasEscapedAt - Return true if the box has escaped at the specified / instruction.
hash as used in CA directories to lookup cert by subject name
hash sqlstate to error messages
hashes for storing parameter info/checks
have already seen the -
have an hdf value, that it maintains its edge as beating out
having job reaper should not affect anything other threads are doing.
header length isn't tracked
header transfar encoding
helper classes for setting/resetting globals within a method call
helper for __construct
helper for __construct: caller throws exception when return value is false
helper for getAbstractConstantNames
helper for getAssignedTypeText
helper for getClosureScopeClass
helper for getConstants
helper for getMethods: returns a Set
helper for getParameters
helper for getReturnTypeText
helper for getStaticVariables
helper for getTypeConstants/hasTypeConstant
helpers for PDO class
helpers for usage logging Log the execution of a command.
here it means "it's a PHP file"...
hex string, under UNIX strtod() messes it up
hidden in ext/ext_sqlite.cpp
histogram cell c0/c1/c2.
histogram is garbage now
hitIntKey() should only be called on an Elm that is referenced by a hash table entry.
hitStringKey() should only be called on an Elm that is referenced by a hash table entry.
hoist the sync instructions from t0 to before the jcc, and replace the jcc with bindjcc1st.
holder is needed to make sure none of the Keys get deleted prematurely.
holding it for the entire request life time, so soapserver and soapclient can use encodeMap* without being deleted
holding it for the entire request life time, so soapserver and soapclient can use sdl* without being deleted
hopefully m_counters set is small, so a linear scan does not hurt
horizontal segment of scan line y
how many bytes are not included in capacity()'s return value.
how many times faster
how often to display the warning (1 / rate)
hphplex_destroy is for both reentrant and non-reentrant scanners.
hphplex_init is special because it creates the scanner itself, so it is the ONLY reentrant function that doesn't take the scanner as the last argument.
hphplex_init_extra has the same functionality as hphplex_init, but follows the convention of taking the scanner as the last argument.
http authentication options
http method not explicitly given, choose default one
http://gcc.gnu.org/onlinedocs/gcc-4.0.4/gcc/C_002b_002b-Attributes.html
http://php.net/zlib.configuration.php
http://sourceforge.net/p/icu/mailman/message/27427062/
http://www.linuxinsight.com/proc_sys_vm_drop_caches.html
https://github.com/facebook/hhvm/issues/2186 If not UTF8, and we are converting to HTML entities, use known entity equivalent of the character, if possible.
https://github.com/facebook/hhvm/issues/3331
https://github.com/google/brotli/issues/274 We should also allow 6 extra bytes for an empty meta-block at the end of each chunk to force "flush".
https://tools.ietf.org/html/rfc7231#section-6.1
https://wiki.php.net/rfc/remove_php4_constructors Check for PHP 4 style constructors.
hzhao: mismatched version of conf file may have attributes that are not recognizable, and I don't think it should be treated as fatal errors.
hzhao: not sure how we support class serialization
i'm done with this job
i.d is not Vreg but Vreg16, so it can't be a SIMD.
i.e. a joint block with 1 predecessor being an unreachable block.
i.e. a store the struct followed by a load from the / struct.
i.e. clear, enable, disable, or toggle.
i.e. if there is no downward visible / value that can reach the end of a basic block, then we know that the genset / and killset for the location need not be set.
i.e. if there is no upward visible store that can / reach the beginning of a basic block, then we know that the genset and / killset for the stored location need not be set for the basic block.
i.e. it is / still possible that 2 LSLocations with different bases that happen to be / the same object and field.
i.e. the 2 / releases must have the symmetric property.
i2 can be unallocated if the tmp is a constant or is spilled.
iconv supports errno.
icu::RuleBasedBreakIterator is stateful -- it cannot be used by multiple threads simultaneously without causing data corruption and crashes.
id maps to AnyObject.
id of the RDS bit for whether the Unit is included
ideas from comp.graphics discussions.
identifier, identifier
identifier-or-none for the first name
ie, 'static inline' functions for which we must ask Clang to emit a body for explicitly
if "from" position is negative, count start position from the end of the string
if "length" position is negative, set it to the length needed to stop that many chars from the end of the string
if "start" position is negative, count start position from the end of the string
if I can get the function type from it
if PHP_FILEINFO_UNCOMPRESS
if _id field doesn't exist, add it
if a match is found it is set to 1
if a new entry is added in blacklist
if allow_self_signed is set, make sure that verification succeeds
if any base is volatile, the class is volatile
if autoresume is wanted ask for remote size
if autoresume is wanted seek to end
if between watermarks, free based on request count and usage
if buffered, pre-fetch all the data
if checkType and convertParam returned non-null values, param.value will have been updated with a phi of their results.
if entry needs expading ifd cache and entry is at end of current ifd cache.
if expr is null, just continue
if false, we'll never reach this block
if fg is specified by a negative color idx, then don't antialias
if file cannot be found, resolve it using search paths
if first character, init BB corner values
if first instruction is a li, it's using 16bits only
if hasCallToGetArgs() or if mayUseVV
if initial_opt is not set, this shouldn't be recorded as a per request fetch of the file.
if it does not, return None so we keep searching up the domtree.
if it is a space, check if it is at the line boundary, copy and insert a break, or just keep track of it
if it is already set, skip this
if it is useful, keep a pointer to it in the mime part
if it starts with file:// interpreted as path to key file 4.
if it's already an object, we don't have to worry
if its not highly profitable to optimize this function.
if main entry matches, print it...
if missing style, part, make it a double
if more than zero code points were consumed then consume one more (which will be the last delimiter)
if n is a basic code point then fail
if name is an absolute filename then test directly
if no charset had previously been set, either through inheritance or by an explicit content-type header, default to us-ascii
if no display name has been given, use the address
if no suffix is found, just add the wildcard
if non-null, the count of arguments
if non-null, this is the path to a temporary file that is to be deleted when the stream is closed
if not already most-recently-used
if one or the other is an interface return true for now.
if our descriptor has an error
if our descriptor is ready break out
if param_type is PDO_PARAM_ZVAL the driver has to provide correct data
if parsing was successful, update the mappings for spath and rpath (if it exists).
if partial is true, partial matches are allowed at the end of the buffer.
if qualified name, prepend current namespace
if query or fields weren't passed, make them default to an empty array
if relative path, prepend directory
if something failed, then shutdown and cleanup
if subject is an array
if subject is not an array
if the call just passes back ini_ret because either they are
if the callee isn't persistent, its still ok to use it if its defined at the top level in the same unit as the caller
if the callee's class is not persistent, its still ok to use it if we're jitting into a method of a subclass
if the cert passed the usual checks, apply our own local policies now
if the current position is reachable, emit code to return null
if the current word puts us over width w, copy back up until the last space, insert a break, and move up the laststart
if the document root isn't in the url set document root to /
if the function was invoked dynamically we can't be sure
if the given filename is an EGD socket, don't write anything back to it
if the input to these functions is known to be integer or double, the result will be a double.
if the key is null it will not be found so just return the default
if the pointers match then only subtract the length of the path
if the query isn't supported by the protocol, fallback to emulation
if the quote is escaped, remain in ParseState::QUOTED.
if the shape field name is a class constant, its name is double colon delimited clsName::cnsName
if the socket is in non-blocking mode and there's no data to read, don't output any error, as this is a normal situation, and not an error
if the string is all ASCII up to size+1 - or str_len whichever is first - then we are done.
if the type also conforms to _ConditionallyBridgedToObjectiveC, make sure it bridges at runtime
if the value may involve object, consider the variable as "needed" so that objects are not destructed prematurely.
if there are more accesses, keep resolving
if there are no conformances, don't hold this handle open.
if there are no elements, don't bother saving
if there is a log file variable then we'll assume the log file exists.
if there is a new peak, store it
if there is no content type, default to text/plain, but use multipart/digest when in a multipart/rfc822 message
if there is only one branch left, return stmt.
if there was an error in the fetch then don't cache
if this function is from an unseen file, register file name and get index to file name
if this is a function...
if this is defined in a type...
if this is not a valid string, stop
if this is not the first one, add a comma
if this reference contains a db name, we have to switch dbs
if this unit isnt mergeOnly, we're done
if this were to come from a closure, there may be no decl - just a module
if unpacking, any regularly passed arguments on the stack in excess of those expected by the function need to be discarded in addition to the ones held in the arry
if unresolved, ignore wrapper
if we are applying case conversions on column names, do so now
if we are checking a generic argument, don't make it a starting point of a circularity.
if we are cutting, and we've accumulated enough characters, and we haven't see a space for this line, copy and insert a break.
if we are in an API which issues a request token, there are is no token handler called
if we are setting constants, we must be setting system settings
if we can read a complete key/value then we are ready to be extracted
if we can't tell which redec class, then don't use the redec name
if we did not manage to read the seed file, we should not write a low-entropy seed file back
if we don't have a PWD, try to append it
if we don't have a UID, try to append it
if we don't understand the MIME version, discard the content-type and boundary
if we dont have buffered rows, fetch more
if we find a semicolon, then it's not just a DSN
if we get here, we can be sure that we have enough bytes to copy safely
if we got a database name, add that, too
if we have a cached connection, we need to pump the event loop to clear any "connection closed" events that may be sitting there patiently.
if we have a cursor_id, we should have a server
if we pass a widening type to a label, loop again.
if we read any data...
if we realloc, we need an offset, not an abs pos (phew)
if we removed any whole blocks that ended in Jmp instructions, reflow all types in case they change the incoming types of DefLabel instructions.
if we want to support finfo as a resource as well, do it here
if we were killed, bail out immediately
if we're only looking for a certain number of points, stop looking once we hit it
if you prepare and then execute passing an array of params keyed by names, then this will trigger, and we don't want that
ignore autoresume if autoseek is switched off
ignore cert expirations
ignore everything after the #
ignore frames in the StackTrace class
ignore if s or d is nullptr
ignore if the new value equals the old one
ignore leading spaces in the variable name
ignore partial string matches
ignore sequences of consonants with same soundex
ignore some frames that are always present
ignore that field, but don't abort parsing
ignore unreachable block
ignoreTopLevelInjection
im1 must be True Color
image width and height respectively Output: 5, 6, 7.
immediate has 32 bits set
immediate has only low 16 bits set, use simple load immediate
immediate has only low 32 bits set
immediate has only low 48 bits set
immediate-memory operations
immediate-register operations
impact perf a bit, but not that much.
impl convention, type
impl function attribute
implAwaitE pushes a null before calling the event hook, so we don't want to update the marker here.
implement RequestEventHandler
implemented in runtime/ext/ext_hotprofiler.cpp
implementing PageletServer
implementing RequestHandler
implicit label position per block
import child into the current context, throw on cross-context cycles
import this wait handle to the newly created context throws if cross-context cycle found
import/export ImagePixels
in PPC we don't have anything like a RIP register RIP register uses an absolute displacement address.
in a manner that could cause us to change states.
in any case, this disables it, and generates no code in O3 builds
in case an unknown error occurred in the completion port, skip to the next change notification
in case it's a tables-only JPEG stream
in case obStart was called without obFlush
in case postsend/cleanup output something PHP5 always provides _START.
in most cases bz2 offers at least 2:1 compression, so we use that as our base
in order to use strcspn, remove all null byte(s) from char_list
in the (illegal) case of multiple Content-Encoding headers, any one with the value 'gzip' means we treat it as gzip.
in the middle of it etc.
in-memory cache entry is expired
include the jump out of the try-catch block in the exception handler address range
includeInaccessibleMembers
included for future-proofing
includes mail.h and rfc822.h
includes zlib.h and setjmp.h
inconsistent size information.
increment access counted for hash
increment cursor position
increment pen position
increment the result length by how much we've added to the string
increment, check for overflow and undo increment if so.
index for the candidate property
index of leftmost source unsigned char containing data (1 to 8 bits).
index_addr is only expected at the top level.
indexed by FuncId, keeps it's current cluster
indicate error if an empty command was received
indicate that we didn't push a value onto the stack
individual test suites
information and calculations
ini parser is not thread-safe We are parsing something new, so reset this flag
ini parsing treats "None" as ""
ini settings settable anywhere -- PHP_INI_ALL
ini_get() is now enhanced to return more than strings.
init methods are always instance methods.
init methods must be classified as such by Clang.
init to max poss dist
init with -MAX_WBITS disables the zlib internal headers
init_closure doesn't move stack
init_existential instruction used to initialize this alloc_stack.
init_existential_addr is modeled as an initialization store.
init_priority is a gcc extension, so we can't use it on other compilers.
initial distance values
initial live set is the union of successor live sets.
initial values for increments
initialise MIME type to none
initialize a Hole header in the unused memory between m_front and m_limit
initialize a JS wrapper around this object
initialize a few bytes in the case the next function fails
initialize font library and font cache on first call
initialize nodes by iterating over PtrMap's regions
initialize response code
initialize scope array
initialize state at all entry points
initialize the FreeNode header on all freelist entries.
initialize the tzinfo cache.
initialize wrapper to call back into JS
initializing constructors of value types always have an implicitly inout self.
initially parse the heap to find valid objects and initialize metadata.
initiate engine shutdown
inject_enum_addr is modeled as an initialization store.
inlining may not change spValue
innerExtents will point at this
inotify saw this path change.
inotify_init1() directly supports the fcntl() settings, but it's only available starting in Linux 2.6.27.
inout is only valid for function parameters.
inout types are a special case for lowering, because they get completely removed and represented as 'address' SILTypes.
inout uses are generally straight-forward: the memory must be initialized before the "address" is passed as an l-value.
inout uses, escapes, and assignments only happen when some kind of init made the element live.
input string is in the form charset//options where the //options part is optional.
insert copies on edges
insert n into output at position i
insert serialized variable into shared memory
insert the inc right before succ if we advanced any instruction
inspectArgs contains addImage*Block function and the section name
instance for empty matches
instance methods and properties
instantiation of ICU object
instantion of ICU object
instrNumPops() returns the number of values consumed from the stack for a given push/pop instruction.
instrNumPushes() returns the number of values pushed onto the stack for a given push/pop instruction.
instructions that mutate memory, physical registers, or status flags are considered useful.
int literal symbolic flavor
integer safety for string allocations
intentionally not returning
intercept constant, non-string ord() here instead of OrdStr simplify stage.
intercepted functions need to pass all args through to the interceptee
interfaces to C-client
intermediate results do not have headers and code
interpOne syncs regs manually
interpreted as the data from the cert/key file and interpreted in same way as openssl_get_privatekey() 5.
intra-BB retain/release merging.
invName should only be non-null if we are calling __call or __callStatic.
invalid compression format
invalid search type, but no need to complain here
invalid signal number
invalid vptr means no syncvmsp was matched.
invalidate the current buffer
invalidating read buffer
invariant returns null if used in an expression, void according to the typechecker.
invert the true/false parameters, as only the bp.bi field is used
invoke function pointer
invokeFunc() must always check the native stack for overflow no matter what.
invoking a file through rpc
invoking a file, with NO json encoding "int(100)" is printed twice, one from warmup, and the other from include
io.c  Implements the simple I/O 'helper' routines.
io_dp.c  Implements the dynamic pointer interface.
io_file.c  Implements the file interface.
io_ss.c  Implements the Source/Sink interface.
iopWrapper is used to normalize the calling convention for the iop* functions, since some return void and some return TCA.
iplist's destructor is going to destroy the InstList.
is "interesting" (see below), conservative scan.
is an empty list, always conservative scan.
is not in a namespace (namespaced classes treat methods with the same name as the class as just normal methods, not a constructor) then we give the deprecation warning.
is returned back from from an HDF get call, which it will be
is the end of the current segment
is the length of the result path
isAscii flag for UTF8-encoded string literals.
isCopyToOrFromStack - Check to see if the specified use of an inout / argument is a copy_addr to/from an alloc_stack.
isSelfInitUse - Return true if this apply_inst is a call to self.init.
isStartOfStmt - Return true if the current token starts a statement.
isStartOfUTF8Character - Return true if this isn't a UTF8 continuation / character, which will be of the form 0b10XXXXXX
isStriclyInteger() puts the int value in newVal as a side effect.
isStructInit() is like isPackedInit(), but returns true if the keys are all static strings with no duplicates.
isSuperGlobal is not wanted here.
isSuperInitUse - If this "upcast" is part of a call to super.init, return / the Apply instruction for the call, otherwise return null.
is_a() finishes here.
is_subclass_of() needs to check that the LHS doesn't have the same class as as the RHS.
is_tar() -- figure out whether file is a tar archive.
isa and enum-element patterns are refutable, at least in theory.
isset returns false for null values.
it as potentially ending a block comment.
it is fine for the ASTContext to be null, so don't actually even lldbassert there
it will be swept Don't bother running the dtor ...
it's a constant, so it is nowhere
it's an X509 file/cert of some kind, and we need to extract the data from that
it's copied from xpath.c
it's dangerous to return pointers to string buffer of referenced variable, because it can be clobbered throug magic callbacks
it's only the display name if there are quoted strings or comments in there
it's unlikely a class is in the cache so check first without write lock
it, and then it will call recordJumpTarget
itRef will be set to true if the iterator was initialized with MIterInit*, false if the iterator was initialized with IterInit*.
iter should now be exhausted
iter_value_cell* will increment the refcount of the current value if appropriate.
iter_value_cell* will store a copy of the current value at the address given by 'out'.
iterate funcs in offset order, checking for holes and overlap
iterate over all but the guaranteed hoistable classes fataling if we fail.
iterate over all rounds:
iterate over all the potentially hoistable classes with no fatals on failure
iterate through first character matches
iterate thru each queued file watching entry
iterate until both sweep lists are empty.
iterate watching for directory changes until we're signalled to stop
ither by passing in the already created xmlnode or passing in the node name
its maximum squared-distance to any point in the update box.
its ok to do this before munging, because it only looks at the end of the string
javascript invokation of a single char
job reaper would block.
join multiple To: or Cc: lines together
json_decode() options
json_encode() options
jump to end of template
just a hack to free resources allocated by glibc in __res_nsend() See also: res_thread_freeres() in glibc/resolv/res_init.c __libc_res_nsend()   in resolv/res_send.c
just a shorter name for the current buffer
just call addslashes quotes
just for cgLdObjMethod
just in case long path gets truncated and not null terminated
just in case pstr points in the middle of a character, move forward to the start of the next char
just return 0 if we hit the end-of-file
just return if the converter is not activated.
just take note of the error code and let things continue.
just to be paranoid, make sure dbname is a string
just to be safe while subtracting unsigned ints
just to make valgrind cleaner
kVPackedKind warnings
keep a record of the starting position as an offset, in case the memory is resized
keep going until we have less than 24 bits
keep in mind that image_info does not store editor value
keep it in the unknown retain/release list for now.
keep the arg as binary, since the encoding is not known
keep track of last marker
keep trying to consume before waiting again.
key MUST be a non-reference string or int
key is a long long int in cygwin
key is already inserted.
keyed off a tca, so there needs to be exactly one
kill the local to which this instruction stores iter's value
kill the locals to which this instruction stores iter's key and value
kill unreachable code and remove any traces that are now empty
kinda weird this is on the wrapper not the file
l_in, r_in, l_out, and r_out are in pseudo-"big-endian" format.
labels don't matter for layout
last character cannot be -, unless explicitly allowed by the user
last position in input that hasn't been copied over yet
lazy getters are mutating on an enclosing value type.
lazy is not allowed on a lazily initialized global variable or on a static property (which is already lazily initialized).
lazy is not allowed on a protocol requirement.
lazy may only be used on properties.
lazy must have an initializer, and the pattern binding must be a simple one.
lc holds the last significant character read and br is a bracket counter.
ld.so doesn't support relative relocations at load time, which interferes with our metadata formats.
ldimmb is for Vconst::Byte, which is treated as unsigned uint8_t
ldimml is for Vconst::Long, which is treated as unsigned uint32_t
leading '..' must not be removed in case of relative path
leaks prior conformances
leave it alone if we don't understand the representation
legacy entry point, no longer used.
len is garbage if EOF but the loop below will quit anyway
length excluding ipv4
length includes itself
length of evaluation stack.
length of state vector
let async modifier be mandatory
let constructor params override any values that may have been found in auth headers
let release_sysvsem_sem know we have removed the semaphore to avoid issues with releasing.
let the compiler know we won't reach the end of the function
let's bypass trying to load vdso
let's keep the nul-terminate tradition
let's quote all the values
let's see if this string has a matching dsn in the php.ini
let's see if we have one cached....
lexCharacter - Read a character and return its UTF32 code.
lexOperatorIdentifier - Match identifiers formed out of punctuation.
lfchars must be encoded in ASCII here
lhs contains the encoding rhs, if it exists, contains the qvalue
li64 always emits 5 instructions i.e. 20 bytes of instructions.
libbfd on cygwin is broken, stub dgettext to make linker unstupid
libc++ has the class "CLNGC++".
libdwarf allocates its own unaligned memory so it doesn't play well with valgrind
libdwarf uses a very low-level janky C-style interface, so provide a simple wrapper class to make some of the common operations easier.
libedit needs this to ensure correct allocation
libevent is not exposing this data structure, but we need it.
libgcc exports these for registering EH information for dynamically-loaded objects.
libiconv disagrees with glibc iconv on some charsets.
libiconv sometimes defines the second parameter of its main function as (char**), and sometimes as (const char**) but provides no means to detect this.
libmemcached behavior options
libmemcached result codes
libnuma is only partially aware of taskset.
libproxygen will only add it for keep-alive connections
libxml headers use their own variant of documentation comments that Clang does not understand well.
libxml/xpathInternals.h defines CHECK_ERROR, we need to undef it first
light process available there is no need to do any locking, because the forking is delegated to the light process
light process is not really there
like fwrite(), fclose() can error when fflush()ing
linear interpolation between w and v
lineno is only valid if an input buffer exists.
link in the cram-md5 authenticator
link in the dummy driver
link in the gss authenticator
link in the imap driver
link in the log authenticator
link in the mbx driver
link in the mh driver
link in the mmdf driver
link in the mtx driver
link in the news driver
link in the nntp driver
link in the phile driver
link in the plain authenticator
link in the pop3 driver
link in the tenex driver
link in the unix driver
lint doesn't need analysis
list of patterns and replacements
listAssignmentVisitLHS should have handled this
little bits about characters for metaphone
liveness of member base register
llvm::hash_value(StringRef) is, unfortunately, defined out of line in a library we otherwise would not need to link against.
load a T value from *pc without incrementing
load classes in hierarchy
load directory or file
load extension constants, classes and dynamics
load glyph image into the slot (erase previous one)
load next chunk to return the exact requested bytes
load the needed chunk from mongo
load the palette and mark all entries "open" (unused) for now
load the renamed function
loadModule() should be more modular, rather than emitting diagnostics itself.
loading APC from archive files
loc_name ends with '-x-'
localeconv(): A thread-local struct lconv is maintained and it is filled by making multiple calls to nl_langinfo() which is thread-safe.
localizes all the field info
localizes all the rows
locals are preferred in unions to iters
location of c-client quota functions
log*() functions return a newly-created log expression to be inserted after or instead of the expression they're looking at.
logic hacked from ext/standard/datetime.c
longer patterns must be sorted first
longest sane line length
look ahead to determine if we are dealing with a group
look at options in the stream and set appropriate verification flags
look for LF in the data
look for a potential boundary match, only read data up to that point
look for argument promotion in ctor
look for more mailboxes in this group
look through Type node
look up clsName::cnsName
look up for a delimiter
look up target config, and compare value
looks like proxygen HTTP parser understands a few more methods than libevent: TRACE, COPY, MOVE, MKACTIVITY, CHECKOUT, MERGE, MSEARCH, NOTIFY, SUBSCRIBE, UNSUBSCRIBE, PATCH
looks like some other type to us, make sure it's quoted
lookup qualified name in thread-local constants
lookup the prototype in the interfaces
lookup unqualified name in thread-local constants
lookupImmutableMethod will return Funcs from AttrUnique classes, but in this case, we have an object, so there's no need to check that the class exists.
loop chunks to find BMHD chunk
loops until end-of-file is reached
lower left corner of update box
lowerRawSILOperations - There are a variety of raw-sil instructions like / 'assign' that are only used by this pass.
lseek instead of seek to be consistent with read
lunar cycle      The period of time between mean conjunctions of the sun and moon (new moon to new moon).
m_aux.u_deepInit is true for properties that need "deep" initialization
m_breakpoints is initially set to the breakpoints collection of the client (in validate, which indirectly calls sendImpl).
m_btpointers_cnt must be an upper bound on the number of filenames then *2 for tolerable hash table behavior
m_documentRoot is a bitfield
m_dwarfProducer is the handle used for interaction for libdwarf
m_fpOff does not include the space taken up by locals, iterators and the AR itself.
m_hasDeepInitProps indicates if there are properties that require deep initialization.
m_hash is computed soon.
m_lastToken holds the last "signficant" token, so don't update it for comments or whitespace
m_op is from other now
m_op is null if this object is directly created.
m_savedRip will point here.
m_spl_stack_inited will be re-initialized by the next requestInit m_handlers will be re-initialized by the next requestInit
m_tl should be NULL if createInstance fails but better safe than sorry.
m_type is not KindOfPersistentString anymore
m_worker.wait is always safe to call from any thread at any time.
macro for commonlizing X-/D-form of load/store instructions
main Execute the initial connection protocol with a machine.
main entry didn't match, flush its continuations
main loop to parse JPEG 2000 JP2 wrapper format structure
main loop to parse TIFF structure
mainFrame.javaScriptWindowObjectCleared We have found out that, despite our understanding, the event #1 above fires BEFORE the event #2 when loading a url.
make *exact type* and *sub type* types and objects for all loaded classes
make a connection attempt
make a copy of the substring
make a fresh copy each time - strtok corrupts it.
make a new array to hold aliases
make a new array to hold mapping
make a new tweenColorCache on every call because caching colormappings between calls is not safe.
make a short string describing an object
make explain use a hard limit
make it an 8 bit conditional branch
make it possible to quickly reuse the port
make it zero-based internally
make mongoclient object uncloneable, and with its own read_property
make sometypes and objects
make sure file exists
make sure it doesn't work on some non-doubles/ints
make sure no other callback is specified
make sure not sign-extended
make sure that the temporary file is removed
make sure that there's an index on chunks so we can sort by chunk num
make sure the DN contains no NUL bytes
make sure the map is left in a consistent state
make sure there wasn't an error
make sure this sorts last
make sure to process initilized vars only
make sure we wake up all pending responses, such that mg_stop() can be called without deadlocking
make sure we write everything to disk before reading
make sure we're not getting crazy data
make sure we're not horked from the get-go
make sure we've computed the type.
make the center of rotation at (0, 0)
make the circular-lists empty.
make the new db the current one
make the return an array
makeBlock might reallocate unit.blocks
makeUTF16 should have following parameters: (start: RawPointer, utf16CodeUnitCount: Word) makeUTF8 should have following parameters: (start: RawPointer, utf8CodeUnitCount: Word, isASCII: Int1)
make_mutable hoisting.
make_relative_path so we do not try to put files or dirs in bad places.
make_unique hoisting by looking at the operations (no uniquely identified objects).
makes no representations concerning either the merchantability of this software or the suitability of this software for any particular purpose.
malloc alignment guarantee
manipulate m_jobs timestamp to simulate time passing.
manipulate maxCount to match PHP behavior
manual call to Logger instead of logError as we need to use evalFileName and line as the exception doesn't track the eval()
manually append NULL terminator
map from the dests of StringGet instructions, to the list of uses.
map the FILE_NOTIFY_INFORMATION 'Action' to a node fs-event.c 'enum uv_fs_event' type
map the buffer to a block:
map the modification type
maps block to current cluster
mark a TypedValue or TypedValueAux.
mark as outside range and get buffer
mark p if it's an interesting kind.
mark the ResumableFrame prefix, but enqueue the ObjectData* to scan
mark the beginning of varargs
mark the descriptor close-on-exec, so that it won't be inherited by potential other children
mark the object at p, return true if first time.
mark_function_escape just gets zapped.
mark_uninitialized is never dead.
mark_uninitialized just becomes a noop, resolving to its operand.
mask     the highest   bit of u
mask all but highest   bit of u
mask all but lowest    bit of u
masking bits, we could count them too
match against full uri
match against relative url
match is at start of string, return empty string
match on the end of filename instead of the beginning, if necessary
match the behavior of PHP5
matched it and printed type
matched xchg+xchg that cancel each other
matches almost anything penalize
matches anything penalize
materializeForSet has a funny type signature.
materializeForSet is final if the storage is.
materializeForSet is mutating and static if the setter is.
max and min keys are used only for sharding, and cannot be resaved to the database at the moment
max uppercase match score
max2 is only called for 2 operands
maximum code, given n_bits
maximum length of the destination buffer
maximum number of bytes we are reading
maximum size of colormap
maximum valid sizes for wbmp (although 127x127 may be a more accurate one)
may be null if call is not a method
may branch to scheduler and suspend execution
may happen if scheduled in multiple contexts
may happen if wh was scheduled in multiple contexts
may need more than 16 bits
may not be initialized if file could not be created
may reenter for __destruct
may replace at runtime
may self-assign if size is 1, but that's ok.
mayDecrement reference count stops code motion.
maybe add scan() to tsrm_resource_type in addition to ctor/dtor
maybe better to teach heap-trace and IMarker about hphp_hash_set/map
maybe modify the action state if the bundle is or is not already installed.
maybe() is a symmetric relation
mbstowcs seems to misbehave on android
mcrouter defines op names as foo-bar, but PHP wants constants like foo_bar
mem files are read-only
mem2reg's invariants get unhappy if we don't try to initialize a loadable result.
memcpy is safe even if it's a self append---the regions will be disjoint, since rN.data() can't point past the start of our source pointer, and rN.size() is smaller than the old length.
memcpy(dst, src, count)
memory-register operations
memory_order_release guarantees that the new chunk is already present in m_chunks when we reset m_current.
memoryaddress of shared memory
memrchr is a GNU specific extension Emulate for wide compatibility
meot (hundreads) case
merge the clusters by append the blocks in dstC to srcC
metatype (which may be thin)
metatype representation, type
methods (object oriented style) and functions (procedural style)
methods with a cls() and functions
metonic cycle    A 19 year cycle which determines which years are leap years and which are common years.
middle chunks should never be zero size
might be a non-static call.
might not work for EBCDIC
might use Sys V memset(3) here
min distance to colormap entry i
min2 is only called for 2 operands
mini hack: the parser sometimes relies in this
minimum pattern length
minimum witness count
minstrBaseIdx returns the src index for inst's base operand.
mirror thrift log in plain text
misnomer, it means we have made decision on compression, transport should not attempt to compress it.
missed at least one counted pointer, or refcount too high no assert, because without gc the only effect is a leak.
mix of names and numbers
mode flags for opening fds
mode for proc_open code
molad            The date and time of the mean conjunction of the sun and moon (new moon).
mongo current chunk is kept in memory
mongo_options are the same options as the connection_string, while driver_options is additional PHP MongoDB options, like stream context and callbacks.
month as two digit number (with leading zero)
mop things up if we ended on a boundary
most likely a string, but just make sure that we are dealing with something that can be converted to a string
mostly from vm_call_user_func
mostly here to catch the degenerate case of `.` as input
motorola is easier to read
movb r,r is a nop, however movl is not since it zeros upper bits.
move beyond the second '/' in /foo/bar
move entire register to reset higher 56bits
move hi bit of u to hi bit of v
move lower byte to destination and keep the other 56 bits
move on to first character in field
move only the byte result to the destination, keeping the higher 56bits
move strong iterators to the previous element
move the non-benign sign extension flag to bit 16
move us to the parent context
multiple options specified as one (exclude long opts)
multiplexed connections are not implemented
multiply by m and add a
must be a 32-bit conditional branch
must be a 32-bit unconditional branch
must be called for Func-nulling side effects
must be in this order (or have the cal adopt the tz)
must come before zpp because zpp would convert the args in the stack to 0
must conform to the NSCopying protocol.
must first call update to flush data.
must have catch block
must occur before setting up locals
must run before setODAttributes
mutable_variant only makes sense for non-mutating methods where it's possible to have a mutating variant.
mutex to synchronize access to the queue
myFoo.doThing(42, b: 19)
mysql connection from ext/mysql/mysql_common.h
mysql lied about the column width
n is partially here to make simple cases tail-recursive, but it also gives us a simple opportunity to bail out early when we see an always-refutable pattern.
nProp should include the current property being unserialized.
name is an arbitrary sequence of bytes.
name is checked as class name
name must be copied because it is a substring of a string that will be garbage collected in a sec
nameOverride is to be used only when there's an exact function to be called ...
nameToAnnotType() never returns Object
names for leap (13-month) year
names for regular year
namespace / A singleton object that handles the two Xenon modes (always or timer).
namespace / Clone a constant value.
namespace / If this is a call to a global initializer, map it.
namespace HPHP::ExtensionRegistry
namespace HPHP::Native
namespace HPHP::SystemLib
namespace Return true if the callee has self-recursive calls.
namespace ServiceData.
namespaceURI argument is unused in PHP5 XSL extension.
nativeDataWakeup is called last to ensure that all properties are already unserialized.
nbytes passed for regularity, maybe need later
need a brand new pdbh
need space for variable name and value
need to do slightly different things, based on client/server method, so lets remember which method was selected
need to hook up a global variable to set this
need to make sure the last reference is deleted in this thread The VM thread is done, any outstanding push txns need aborts.
need to make sure this is NULL, in case a fatal errors occurs before it's set inside really_register_bound_param
need to register the constant before AnalyzeAll, so that DefinedFunction can mark this volatile
need to set pipes to a new empty array, ignoring whatever it was previously set to
need to shift things up to make room
need to silence even with the AlwaysLogUnhandledExceptions flag set
need to start from 0 for komodo
need to sync vmpc() to pc for backtraces/re-entry
need to test multiple bits
needed if any date part is missing
needs to be null-terminated before the reserve call
negate it (becomes positive) c.
negate the condition and swap t/f operands so we dont clobber i.t
neither does AnyObject
never null, sometimes counted
new C() inside trait or pseudomain
new chunk of base size
new line safety check
new parent() inside a trait, code statically not inside any class, or a class with no parent
new scope, new statics
new self() inside a trait or code statically not inside any class
new style delimiter: locale id follows
newTc shouldn't be any more specific than origTc.
new_iter_array creates an iterator for the specified array iff the array is not empty.
new_iter_object decrefs its src object if it propagates an exception out, so we use SyncAdjustOne, which adjusts the stack pointer by 1 stack element on an unwind, skipping over the src object.
new_iter_object_any creates an iterator for the specified object if the object is iterable and it is non-empty (has properties).
new_miter_object decrefs its src object if it propagates an exception out, so we use SyncAdjustOne, which adjusts the stack pointer by 1 stack element on an unwind, skipping over the src object.
next expected param number
nextLookahead skips over whitespace and comments.
nextLookahead() advances an iterator forward in the lookahead store.
no break here, so we can continue to match more overwrites
no check necessary -- if NULL will fail ahead
no clue about it, use it raw
no conversion necessary.
no ctor no args is also ok
no decimal point was found
no digits, fcvt style
no equals, so either 'base64' or its bad
no external thread events received, synchronization needed
no generic requirements
no incref is needed, since extra values are being transferred from the stack to the last local
no infinite redirects
no info found about that header.
no instructions conservatively using rcid in a manner that ...
no interpolation needed here
no magic values get here
no magic values on rhs
no mapping, so handle raw
no matches, token required
no more command can come in
no more data to fetch
no more skipping now.
no need for filtering.
no need for further argument munging
no need to calloc it, we overwrite all pxl anyway
no need to check the rest of options and arguments
no need to do the initialization for a second time
no need to escape these
no need to explicitly clean either pointer
no need to record duplicate names
no other exceptions should be seen here
no point in continuing if we can't open the file
no reason to check bounds
no scheme, look for port
no static context class, so this will raise an error
no supplementary characters, build jstring from input buffer
no timeout by default
no useful writeback diagnostics at this point
no_read becomes 2 in the second pass, and if this is nonblocking, we should return..
node has been visited before
noescape/autoclosure are valid as a decl attribute and type attribute (in parameter lists) but we disambiguate them as a decl attribute.
non unique types are funny because we cannot really make any conclusion about them so they resolve to "non precise" subtype relationship
non-free nodes in the heap
non-free reachable nodes
non-int-string assertions should go upstream of the ArrayData api.
non-methods (which only happens with operators).
non-numeric key found
non-persistent check below will always succeed
non-shortest form or outside range
non-spec code for PHP errors
non-zero for error chdir failed, the working directory remains unchanged
none of these interfaces support Uninits
nop if already called before
normal delimiter: encoding scheme follows
normal string: do it fast
normal text without encoding
normalizeDir may be called before very early one, such as in Runtime option parsing, when MemoryManager may not have been initialized
not a Class, but clear low bit
not a X509 certificate, try to retrieve public key
not a class, interface, trait, enum, or alias
not allowed, so fall through
not configured to cache
not counted but can be marked.
not counted but marked when embedded object is marked
not counting null terminator
not doesn't set any flags
not doesn't set any flags.
not exif_iif_add_str : this is a buffer
not found (i.e., undefined)
not going to bother with string division etc.
not in a context being exited
not marked mayhavesideffects
not meaningful in type-checker
not mod_php, look in _SERVER and _ENV for Authorization header
not processing any requests.
not safe to continue after we delete ourselves
not supported before Windows 7
not supported, but could be later.
not sure how to check for DARWIN's __Z here.
not sure, if we need this...
not the matching package, so skip it.
not the same when in for-loop
not thread safe - needs a lock when called from the main process.
not to run the 1st file if compiled
not used for string switches
note it's important to add to scope, not a pushed FunctionContainer, as a function may be declared inside a class's method, yet this function is a global function, not a class method.
note that the U, V upsampling in height is happening here as the U, V buffers sent to successive odd-even pair of lines is same.
note that we really just look for LF terminated lines.
note we assume that fill_input_buffer will never return FALSE, so suspension need not be handled.
note: diagOpt has references to this
note: diagOpt has references to this If we had any wrong labels, or we have both missing and extra labels, emit the catch-all "wrong labels" diagnostic.
nothing else to look at
nothing to queue since strings don't have pointers
nothing, but kids can overwrite
now clear the inst.d if the CR's EQ bit is set, else set it
now copy the chars after the point
now correctly move the decimal point
now deal with the tail end of things
now enable ssl if we need to
now execute the statement
now for the signature stuff
now go back and set the type bit
now invalidate all un-used labels
now mutate instructions
now no more jobs are expired.
now ready to start the child process
now run through properties that are only going to be returned from a server, not text headers
now set the first job to be expired.
now set the inst.d if the CR's EQ bit is set, else clear it
now that we've inserted the chunks, use them to calculate the hash
now the rest, first see if it becomes an array
now visit the remaining ones
now walk the charset map and look for the codeset
now we can add our information
now we expect to find a type specifier
now we have the directory we can look how long it should be
now we know exactly how long it is
now we should get a job from the beginning of the queue even though we are in lifo mode before request expiration is enabled.
now, draw to our target surface
now, perhaps, adjust the end of the line
now, perhaps, adjust the far end of the line as well
null for Xenon signals
null if no sugar found, set when sugar found
null if there is no Unit for this path
null iff charset was not recognized
null line, garbage, etc
nullptr tvRef pointer, representing an instruction that doesn't use it.
num1 is set if str1 and str2 are strings.
numSelfInsts + the callee-instructions inlined into this function.
numVars    The number of variables passed to the scan command.
num_rows_fetched's address was bound before
number of antialias color lookups cached
number of antialised colors for indexed bitmaps
number of arc traversals
number of args of the set() overload
number of bytes read from a datafile
number of candidate colors
number of characters read into yy_ch_buf
number of characters read, or YY_NULL, is returned in "result".
number of fonts cached before least recently used is replaced
number of keys and elements
number of params (prepared stmts only)
number of raw comments,
number of rows left inside the buffer
number of rows returned by the ODBC call
number of rows to fetch per ODBC call
o Both of these things may be relevant to the same catch block.
o Convert instructions that check types of values in memory to use values in SSATmp virtual registers, if we know that we have a register that contains the same value as that memory location.
o For hoisting Check instructions: we only can do this for Checks that occur before any side-effects.
o For loads of invariant locations, we're using information from the full flow-insensitive pass over the loop in analyze_loop that identified which locations are invariant.
o HNI-style param coerce modes can force the entire function to return false or null if the coersions fail.
o If we were going to free the ExtraArgs structure, we'd need to make sure we can re-enter the VM right now, which means performing a manual fixup first.
o In some situations, executing an instruction that could decref pointers that live in memory, for example by re-entering and running arbitrary php code.
o Insert phis iff it allows us to do any of the above.
o Instructions that "produce references" (generally instructions that allocate new objects).
o More kinds of checks for hoisting (CheckType, CheckTypeMem).
o Remove instructions that check the type of memory locations if we proved the memory location must hold that type.
o Run the simplifier on every instruction.
o Some situations with loads from memory (described later).
o This lets us re-merge all predecessors into a block's stateIn while doing the dataflow analysis.
objc_msgSend for now).
objc_release(null) is a noop, zap it.
object is still here, we can rely on it to call this again and destroy this object
object property and method calls
objects with unknown type_scan type
obsoleted by ExtraSamples
obsoleted by SampleFormat
of factory initializers.
offset for ifd values outside ifd directory
offset functions: cannot inline these due to dependencies
offset is imm number 0
offset might have been incremented, but without further successful matches
offset of fpush (can get num_params from this)
offset range +/- 32KB
offset shared lib's base address
offset to next ifd (points to thumbnail or NULL)
old non-POSIX version
older openssl libraries can assert if the passed in password length is less than keylen
on EINTR, retry - this resets the timeout however to its full length
on failure, and throw an exception.
on no results, return an empty array
on the "Failure" page, show error message and check if the restart button should be enabled.
on the "Install" page, ensure the install button is enabled/disabled correctly.
on the "Success" page, check if the restart or launch button should be enabled.
onConstant will always be called before onEntry, so we can check here
onOpcode handles function exit breakpoints, this just handles stack-related manipulations.
one time initialization
only Jmp can branch to a join block expecting values.
only accept paths with the glob:// prefix
only allow parameter modifiers (public, private, protected) on constructor for promotion
only cond_br terminators
only constants and physical registers can be live-into the entry block.
only for STDIN, STDOUT, STDERR
only get here if both points are inside the window
only here if we can't change the cwd back
only hmac-sha1 is supported at the moment (it is the most common implementation), still need to lay down the ground work for supporting plaintext and others
only in C-locale isalnum() would work
only incremement callid if contains valid callid as callid is optional
only inherit non-private properties
only int and string values allowed for enums.
only looks at the interfaces if the method is public
only media type (type/subtype,data)
only need to call traverseData() on the toplevel array
only need to do this once...
only one cursor to be freed
only one of these should ever be specified
only print to thread local log once
only print warning if not working with *
only return after cleanup
only scheme is available
only set the sqlite return value if we are a scalar function, or if we are finalizing an aggregate
only the 1st chunnk got it
only the entry block may have no ProfTransID
only the strings "", and "0" convert to false, all other strings are converted to true
only use wordsame on 8-byte aligned addresses
only used here, let do a generic fixed point integers later if required by other part of GD
op.subop (OODeclExistsOp) would be useful with resolution of the class
open a temporary file
open the directory to watch
open_existential_addr is a use of the protocol value, so it is modeled as a load.
opens up a data stream
optimization functions
optimizeExits does two conversions to eliminate common branch-to-exit flows.
optimizePhis() performs limited tail duplication in a few specific situations where the resulting code is strictly better than before.
optional objc class methods
optional objc instance methods
optional sub and exact obj mixed
optional time zone minute
options not implemented case LDAP_OPT_SERVER_CONTROLS: case LDAP_OPT_CLIENT_CONTROLS: case LDAP_OPT_API_INFO: case LDAP_OPT_API_FEATURE_INFO:
options used to just be "condition" but now can be "condition" or "finalize"
options with boolean value
options with control list value
options with int value
options with string value
or _ or numeral is just output with no special behavior
or a multi-character token with the first character being the one that we want to consume as a separate token.
or all stored properties are safe types.
or const char * is not safe
or enums with enum data.
or if the stack args have been explicitly been prepared (e.g. via entry as part of invoke func).
or it should be UnicodeScalarLiteralConvertible.
or moved into the ExtraArgs datastructure.
or the birth of Jesus Christ, did not come into use until several centuries later when Christianity became a dominant religion.
order by instruction index, area then instruction range.
order functions and merge cluster
ordinary basic block boundaries
ordinary counted objects
original Zend name is _estrndup
other channel statistics
other collection types are unsupported: - mapping collections require a key - immutable collections don't allow insertion
other collections are not supported: - Maps and Sets require associative sort - Immutable collections are not to be modified
other collections are not supported: - Vectors require a non-associative sort - Immutable collections are not to be modified
other end is outside to the left
other end is outside to the right
others (treat as a string)
otherwise crop the prior segment
otherwise file is actually a file, so we actually extract.
otherwise not freed from memory
otherwise populate post data
otherwise there may be huge holes between two entries
otherwise use the class given by this instruction's input
otherwise we assume a raw integer char-code was given
otherwise we just have one last element to add to the array
otherwise we wait for EOM
otherwise, a leaks when exn propagates
otherwise, there must
out of order on purpose
out of range for timestamps
output any remaining alerts at E_NOTICE level
output any remaining errors at their original error level
output im must be truecolor
output in octal notation
output readable address
outside_error may be NULL
outside_error may be NULL (for static functions/constructors)
overflow in same direction, comparison will be inaccurate
overjump leading space
overlay becomes quite opaque.
overload resolution will prefer the static method.
overriding ResourceData
overwrite Windows GDI define in case of windows build
overwrite jmp with copy of s
p is a static local, initialized by RefData::initInRDS().
pack() returns false if there was an error, String otherwise
pad due to the spaces between the inode number and the mapname
pad with zero bits to complete (N*WBLOCKBITS - LENGTHBITS) bits:
page in read-only segments that correspond to a file on disk
paired with decRefCount() at below
paired with worker's decRefCount()
parameter number validation / variant determination
parameter was not defined
parameterType can be null, and isEqual doesn't handle this.
parameters copied and re-factored from clearsilver-0.10.5/cgi/cgi.c
parent EHEnt better enclose this one.
parent close the pipe we're not using
parent:: in a class without a parent.
parent::Constant inside trait or pseudomain
parse a file or directory of files const char *fn: name of magic file or directory
parse commandline arguments
parse out the IP and port
parse out the timestamp
parse phase shouldn't handle anything else
parse the data source name
parse the header line
parse the heap once to create a PtrMap for pointer filtering.
parseAnyIdentifier - Consume an identifier or operator if present and return / its name in Result.
parseBraceItemList - A brace enclosed expression/statement/decl list.
parseExprArray - Parse an array literal expression.
parseExprCollection - Parse a collection literal expression.
parseExprDictionary - Parse a dictionary literal expression.
parseExprList - Parse a list of expressions.
parseExprOperator - Parse an operator reference expression.
parseExprSelector / /   expr-selector: /     '#selector' '(' expr ')' /
parseGenericWhereClause - Parse a 'where' clause, which places additional / constraints on generic parameters or types based on them.
parseInput will initialize cmd_str and args.
parseMatchingToken - Parse the specified expected token and return its / location on success.
parseStmtCatch promises to return non-null unless we are completing inside the catch's pattern.
parseStmtDefer / /   stmt-defer: /     'defer' brace-stmt /
parseStmtThrow / / stmt-throw /   'throw' expr /
parseToken - The parser expects that 'K' is next in the input.
parseTypeArray - Parse the type-array production, given that we / are looking at the initial l_square.
parseTypedValueRef - Parse a type/value reference pair.
parseValueName - Parse a value name without a type available yet.
parseValueRef - Parse a value, given a contextual type.
parsed the last (perhaps only) call in a function call chain
parser error handling
parser functions / static analysis functions
parser functions / static analysis functions / code generation functions
parsing ensures that the variadic capture param can *only* be the last param.
part before the match
partial_apply instructions do not allow the pointer to escape when it is passed indirectly, unless the partial_apply itself escapes
partial_apply which is being processed.
partial_apply without any substitutions or arguments is just a thin_to_thick_function.
partially a lie: vmpc() isn't synced
pass as long as it doesn't blow up.
pass the entire chunk through the converter
passing in cls will short-circuit the accessibility checks, but does mean we'll allow a private or protected s_TSPEC.
passing in nullptr would do the correct checks.
passive connection handler
patched later Augmentation data length.
path outside document root or / is document root
path should be absolute.
pc is measured in bits for monochrome images
pcre_cache_entry implementation
peek through an extract of Bool.value.
pending onComplete() received Check if we were waiting to shutdown
perf_event_open(struct perf_event_attr *hw_event_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags)
perform copy propagation on every instruction
perform test operation
performGeneralOptimizations - This does a forward scan over basic blocks, / looking for interesting local optimizations that can be done.
performNameBinding - Once parsing is complete, this walks the AST to / resolve names and do other top-level validation.
performStoreOnlyObjectElimination - Scan the graph of uses of the specified / object allocation.
performance optimizations by Phong Tran
phar:// stream wrapper
phase 1: look for args
phijmp/phijcc+phidef handled by resolveEdges
phonize one letter We don't know the buffers size in advance.
php doesnt have an unset expression, but hphp's optimizations sometimes introduce them
php notice: integer overflow detected
php's glob always produces an array, but Variant::Variant(CArrRef) will produce KindOfNull if given a req::ptr wrapped around null.
php5 special cases this.
php5 xdebug adds "constant" facet, but this is not in the spec
php5 xdebug allows 'special' semantics to select the symbol.
php5 xdebug does not throw an error if only one of the two are provided
php5 xdebug does this, the spec does not specify this.
php5 xdebug doesn't do anything here with this value, but it is doesn't throw an error, either
php5 xdebug doesn't do anything in this case, but we should probably notify the user
php5 xdebug doesn't do anything in this case, but we should probaly notify the user
php5 xdebug doesn't do anything, so we just cleanup
php5 xdebug doesn't enable profiling if we cannot open the file, so we need to open it now as opposed to when we actually do the writing in order to ensure we handle this case.
php5 xdebug doesn't enable tracing if we cannot open the file, so we need to open it now as opposed to when we actually do the writing in order to ensure we handle this case.
php5 xdebug includes names for each type of include, we don't have access to that
php5 xdebug main function string equivalent
php5 xdebug only accepts multiple breakpoints of the same type for line breakpoints.
php5 xdebug returns false when tracing already started.
php5 xdebug throws an unimplemented error when no valid match is found
php_getopt want to identify the last param
php_magic_database is a const, performing writes will segfault.
php_mongo_get_reply() throws exceptions
php_signal using sigaction is derived from Advanced Programing in the Unix Environment by W.
phpprof is enabled, don't let PHP code override it
pixdata: the output data buffer.
pixdatainput rgba data buffer 2.
pixwpl: the desired words per line corresponding to the supplied output pixdata.
place it at the successors.
plain scalar with no specified type
platform:  identifier
png_set_strip_16() not yet in effect
point at our new starting point
point in the phonization we're at.
point to buffer's start
pointer into main cache array
pointer to next byte to read/write
pointer to the histogram
poison released bytecode
poll() timed out, or errored.
polled, so no need to wait any more
pop caller's return address.
popWorklist - Return the next basic block to look at, or null if the / worklist is empty.
pops the entry off the head of the queue
populate oauth_args with given parameters
populate to from object
port cannot be longer then 5 characters
position and count for address part of a name
position of the original array element
position of the phijmp or phidef
post a signal to send this back to JS
postSort() runs after the sort has been performed.
ppOut is empty for a block with no succs (since placement is definitely not possible in any of its successors), and its initialized to empty, so nothing to do.
ppc64 can handle these address modes.
pre-compressed responses are always gzip
pre-conversion encoding
preSort() does an initial pass over the array to do some preparatory work before the sort algorithm runs.
preSort() does an initial pass to do some preparatory work before the sort algorithm runs.
preface the message with the name of the offending function
prefixes hashes by pat suffix hash order
prepare and validate function modifiers
prepare next iteration
prepare oauth arguments to be signed
prepareAccessorArgs will copy it if necessary.
prepareArrayArgs will push arguments onto the stack
prepareForCatch() in the ifThen() above messed with irb's marker, so we have to update it on the fallthru path here.
prepares a query for further binding and execution
prepares a query for further execution
preround the result (tmp_value will always be something * 1e14, thus never larger than 1e15 here)
presume minimum collisions ...
presume minimum key collisions ...
pretend we don't have any argument
pretend we don't support this hash type
pretty unlikely, but if it was we must clear CLOEXEC, and the only way to do that is to dup it to a new fd, and then dup2 it back
prev is null here, and dwarf_child returns the first child if given a previous DIE of null.
prev is pointing to the tail of the list, current is pointing to null.
prevRegion is already huge, so bump the region we're hugening by 1.
prevState must not be Uninit.
prevent SCOPE_EXIT sweeps
prevent the next loop from visiting the variadic param and testing its optionality.
preventing instantiation
preveprev becomes new end of list
primary body Get instruction boundaries and check branches within primary body and each faultlet.
primed keys never say true to expired()
print encoding, like in objdump
print path from root to n
print per-TCRegion information header
print phi pseudo-instructions
print silly verbose header for USG compat.
print.c - debugging printout routines
print_crash_message includes a call to fflush(stderr).
print_string will decRef the string
printwbmp --------- print a WBMP to stdout for visualisation
private helper for getClass
private helper for getDeclaringClass
private helper for getPrototype
private helper method since C++ does not have extensions...
private key resource from openssl_get_privatekey() 2.
proceed to next shutdown phase
proceed to remaining data:
process data in chunks of 8 bits (a more efficient approach would be to take whole-word chunks):
process it using the bit position.
process memory statistics
process run of digits
process the next change
process the remaining bits:
process the watched directory change
processInOutValue - Walk the use-def list of the inout argument to find uses / of it.
processNonTrivialRelease - We handle two kinds of release instructions here: / destroy_addr for alloc_stack's and strong_release/dealloc_box for / alloc_box's.
processREPLTopLevel - This is called after we've parsed and typechecked some / new decls at the top level.
processREPLTopLevelPatternBinding - When we see a new PatternBinding parsed / into the REPL, process it by generating code to print it out.
produce the clang type INTF * if it is imported ObjC object.
project_box of captured boxes can be eliminated.
promoteDestroyAddr - DestroyAddr is a composed operation merging / load+strong_release.
prompt the user or force the cancel if there is no UI.
prompt to change the source location.
property names and getter names (by choosing to only have a property).
property_value The dbgp spec specifies property_value as property_get, except that the entire value is always returned.
protocol compositions are order-invariant
protocol conformance, entity
protocol conformance, identifier
proxy any URLs that not specified in ServeURLs
proxygen will send onTimeout if we don't receive data in this much time
pseudo marker for start of image(byte 0)
ptr can only interact with clsSpec if lhs.m_bits has at least one kGen member of kClsSpecBits.
public slots: Attributes
pull data buffer into tmpfile
pull out the tag and surrogate object
push a sentinel bcMapping so that we can figure out stop offsets later on
pushClsMethodImpl will take care of decReffing name
pushes a new entry to the tail of the queue
put down forbidden flag since we are redirecting
putmbi ------ Put a multibyte intgerer in some kind of output stream I work here with a function pointer, to make it as generic as possible.
qualify the filename to prevent extraneous searches
query functions Zend returns strings and NULL only, not integers or floats.
query matches native syntax
quick test whole path exists
r0 is used in function linkage as rfuncln r11 is used as a scratch register (rAsm) r12 is used in function linkage
r1 is used as rsp r27 is used as rone (value 1) r28 is used as rvmfp r29 is used as rvmsp r30 is used as rvmtl
r1,e1 span all of current
r2,e2 span the tail of other that might intersect current
rAsm is a scratch register.
raise_warning_unsampled can help when migrating warnings to errors.
raises an error if function not found
randomMT() returns 32 random bits...
rarg(2) is set at the stub callsite.
rcmd contains a list of variables only.
rdar://problem/21375421 - pod_indirect_initializeBufferWithTakeOfBuffer should move ownership of a fixed-size buffer.
rdar://problem/22674524 If we intend to relatively address this string, don't mark it with unnamed_addr to prevent it from going into the cstrings section and getting coalesced.
re-enqueue changed scopes, regardless of rescheduling exception.
re-enters on CountableClass
re-enters to call getInstanceKey() in some cases
re-merge of all pred states
re-negotiation, or perhaps the SSL layer needs more packets: retry in next iteration
re-raise the signal and pass it to the default handler to terminate the process.
re-use the same initial timeout.
re-using definition of O below.
reached end of stream without finding what we wanted
reached end-of-string.
read all PNG info up to image data
read all the app markes...
read and fill StatM structure
read and parse this file
read from Extract_MeteorFiles
read the count + scaling values  It is not necessary to stop an event to read its value
read the required number of bytes
read until a boundary condition
read values not stored in directory itself
readDataAvailable() - This is the primary entry point for FastCGI records.
readEOF will call shutdown() which may free this out from under us, we could add a DestructorGuard, but we'd only end up calling shutdown() ourselves.
readline frees this using free(), so we must use malloc() and not new
reads a line the socket , returns true on success, false on error
reads an ftp response, returns true on success, false on error
readwbmp ------- Actually reads the WBMP format from an open file descriptor It goes along by returning a pointer to a WBMP struct.
readwbmp and writewbmp(stdout)
real dTLB miss events
real dcache miss events
real iTLB miss events
real icache miss events
realize(): return the SSATmp* needed by CallBuiltin for this parameter.
reallocate into a smaller buffer so that we don't waste memory
really a stack Queue up the entry block, for which the invariant trivially holds.
realpath will return an empty string for nonexistent files
reasonable circa 2006
rebuild url from scratch
recall how many parameters have been provided
record anchors in current alias table
record current glyph index for kerning
record request for debugging purpose
recordFailableInitCall - If I is a call of a throwing or failable / initializer, add the actual conditional (try_apply or cond_br) to / the set for dataflow analysis.
recordFailureBB - we have to detect if the self box contents were consumed.
recordRange will do that for us, so just make sure we have the right address setup.
recreate the hardware counters for the main thread now that we know whether to include subprocess times
recursively move all wait handles blocked by us
recvfrom doesn't fill this in
redeclared class is also volatile
redeclared classes/interfaces are automatically volatile
ref might be visible to other threads
ref_element_addr P, #field lookups up a field.
refcounting is only set in the else branches
reference implementation, only optimized for memory usage, not speed
referenced from constructors and destructors.
reffiness of the variadics must match
refine_public_statics never called
region with a whole method
register above rules in a CIE (common information entry)
register all the named locals of function
register compacted chunk with gdb
register end address of function
register frame base of function
register line number info for each tracelet in function
register line number information for function: 1.
register rebind procedure
register start address
register top level DIE
register-memory operations
register-register operations
regular file, check next possibility  If stat() tells us the file has zero length, report here that the file is empty, so we can skip all the work of opening and reading the file.
reinitialize pcre table
relative path to containing file's directory
relative path to document root
release attrp if unused
release nextp if unused
release node if unused
release the extra ref
release xincnode if unused
release(null) is a no-op.
release/destroy and deallocate introduced temporaries.
releaseRefs can be called more than once
releases of self are tracked as a release (but retains are just treated like a normal 'load' use).
relink to top of list
rely on opendir failing for nondirectory objects
remainder as described on divd documentation:
remainingProps should include the current property being unserialized.
remember first valid char
remember stream position
remember that we did this
remember the restart result so we return the correct error code no matter what the user chooses to do in the UI.
remember to set application/x-www-form-urlencoded content-type later on lest the php streams guys come and beat you up
remove '..' and previous directory
remove all inserted chunks and main file document
remove double slashes and '.'
remove entry if destroy_addr got deleted.
remove entry if load got deleted.
remove everything before the first / which is host:port
remove explode()'s last empty line
remove oauth_signature if it's in the hash
remove previous shutdown function
remove the "f_" prefix
remove the possible leftover
remove the proxy:type + :// from the start.
remove trailing space, if present
remove xinclude processing nodes from recursive xincludes
removeFromParent - This method unlinks 'self' from the containing basic / block, but does not delete it.
removeFromWorklist - Remove the specified block from the worklist if / present.
removeUnreachable erases unreachable blocks from unit, and returns a sorted list of the remaining blocks.
removes all empty text, comments and other insignoficant nodes
removes the "zombie" process, so not to interfere with later waits
removing comments, which can be wrong actually if some string field's value has /* or */ in it.
reparent jsNetworkRequest to make sure that it will be destroyed with QNetworkReply
replace default logger with thrift-logger
replace invalid sequences
replace jcc with fallbackcc and jmp
replace sufix with wildcard
replace the connection incase we get a different one back (persistent)
replace the old cache.
replace the old popular API.
replaced by a memory buffer.
replay the same command
repo litstrId is checked on load then discarded.
req::malloc api entry points, with support for malloc/free corner cases.
request memory has already been freed
requestShutdown has already been called 2.
request_params can be either NULL, a string containing arbitrary text (such as XML) or an array
required by emitInterpRet():
required objc class methods
required objc instance methods
requirements are applied to abstract/concrete classes when they use a trait / implement an interface
requirements cannot spontaneously generate
requires rcid to stay live.
reschedule if still in a context
reserve workspace for building each individual field
reserve xmm15 to break shuffle cycles
reserving 1, 2, 3 for STDIN, STDOUT, STDERR
reset RuntimeOption::AllowedDirectories to empty because if the Hdf version of this test is run at the same time, we don't want to append the same directories to it.
reset RuntimeOption::AllowedDirectories to empty because if the INI version of this test is run at the same time, we don't want to append the same directories to it.
reset all per-connection data structures
reset all per-request data structures
reset cursor to original state
reset iteration pointer, just in case
reset load and store counters.
reset path_translated back to the transport if it has it.
reset the HTTP_HOST header from apache.
reset the POLLIN flag
resize to buffer to the "right" size
resolve relative path
resolveEdges() uses the sets to discover which intervals require copies on control flow edges due to having been split.
resolveVmInclude callbacks
resolve_include() needs some way of checking the existence of a file path, which for hphpc means attempting to invoke it.
resolving home directory
resources allocated from now on
resources have a separate id space
restore read preferences from backup
restore the old signal mask, thus unblock those that should be
restore value inferred above
result is not used, only flags
result of AwaitAllWaitHandle does not matter
ret will be false if varname isn't a valid ini setting
retain(null) is a no-op.
retain_value of an enum with a trivial payload or no-payload is a no-op + RAUW.
retain_value of an enum_inst where we know that it has a payload can be reduced to a retain_value on the payload.
retrieve column information from odbc
retrieve info about columns
retrieve kerning distance and move pen position
retrieve the number of column in the current resultset
retrieves parameter value from the _GET or _POST superglobal
retrieves the entry at the head of the queue
return -1 if server is not yet started, e.g., when not running in server mode.
return array with the text's bounding box
return byte count on invalid sequence
return data as a dynamic pointer
return entire buffer as a partial line
return false if a callback has already been set.
return if there were 0 elements
return statements are never emitted as conditional branches.
return string to free storage
return the column name
return the completed message digest:
return the days after March 21
return the last error code extracted
return the last error msg extracted
return the next outermost handler or 0 if there aren't any
return the number of bytes copied
return the number of the rows in the resultset
return the serialized string directly
return the size of the data buffer needed by this column
return the size of the whole buffer needed by this column
return the wrapper for it.
return the wrapper for that.
return true if the store set / changes.
return true if this block is inside a loop.
return true iff the pseudomain needs to be executed.
return type is the first of the typeArgs
return val should be array
return value is null if args are invalid
return value is only used as a simple string, so mis-aligned parts inside the Bigint are not at risk on strict align architectures
return value of function types is the first element of type list
return whatever's there
return_value param is being changed, therefore we will always return NULL here
returns 0 for ok, 1 for error
returns 1 if you need to copy result, 0 if it's already a copy
returns FAILURE on failure
returns NULL if not found, or a pointer to the start of the first match.
returns TRUE if a is an ID separator FALSE otherwise
returns number of bytes added to buffer.
returns the next CRLF terminated line from the client
returns the type metadata for the type named by typeName
returns the type metadata for the type named by typeNode
reuse -h for help command if possible
reuse this curl handle if we're pooling
reusing db param from Mongo::drop call
rewriteAllocBoxAsAllocStack - Replace uses of the alloc_box with a / new alloc_stack, but do not delete the alloc_box yet.
rgb_line1, rgb_line2 - input rgba rows 3.
rgb_sat: pointer to the output rgb row.
ripemd128 basic transformation.
ripemd128 block update operation.
ripemd128 finalization.
ripemd128 initialization.
ripemd160 basic transformation.
ripemd160 block update operation.
ripemd160 finalization.
ripemd160 initialization.
ripemd256 basic transformation.
ripemd256 block update operation.
ripemd256 finalization.
ripemd256 initialization.
ripemd320 basic transformation.
ripemd320 block update operation.
ripemd320 finalization.
ripemd320 initialization.
rodata, which is always dependent
rollback the current transaction
rotate bounding rectangle
round to next pixel row
routines to handle JPEG data
rsrc is not a native collection
rsrc points to native collection
rule 12 can match eol
rule 128 can match eol
rule 129 can match eol
rule 135 can match eol
rule 146 can match eol
rule 15 can match eol
rule 161 can match eol
rule 162 can match eol
rule 163 can match eol
rule 164 can match eol
rule 171 can match eol
rule 172 can match eol
rule 178 can match eol
rule 180 can match eol
rule 181 can match eol
rule 182 can match eol
rule 184 can match eol
rule 188 can match eol
rule 191 can match eol
rule 192 can match eol
rule 193 can match eol
rule 194 can match eol
rule 195 can match eol
rule 197 can match eol
rule 201 can match eol
rule 205 can match eol
rule 208 can match eol
rule 21 can match eol
rule 215 can match eol
rule 218 can match eol
rule 219 can match eol
rule 22 can match eol
rule 220 can match eol
rule 221 can match eol
rule 224 can match eol
rule 23 can match eol
rule 26 can match eol
rule 29 can match eol
rule 30 can match eol
rule 31 can match eol
rule 32 can match eol
rule 56 can match eol
rule 57 can match eol
run -i # Runs the program until a breakpoint is hit or the script is finished
run and verify output
run never responds immediately
run queues until we are finished
run the full blown machinery
run this twice to test lvalBlackHole
run through the whole string, converting as we go
running MethodCreateHook may add methods to builder
running position of non-rotated string
running position of rotated string
runtime/base threw an exception, perhaps bad operands
rvalue MemberRefExprs are produced in two cases: when accessing a 'let' decl member, and when the base is a (non-lvalue) struct.
rvmtl() was preserved by the callee, but rvmsp() and rvmfp() might've changed if we interpreted anything.
s and e are integers modulo 360 (degrees), with 0 degrees being the rightmost extreme and degrees changing clockwise.
s0 must be a different register than s1 so we don't clobber it.
s_saved_defaults should be clear at the beginning of any request
s_stackLimit is already aligned
s_treadmill forces any Funcs that are being destroyed to go through a treadmill pass, to make sure we won't try to dereference something that's being pulled out from under us.
safe because we've fixed up the args
safe to clear used elements after we've forked the document
safeRangeUnderApprox now holds the safe range.
same for TypeConstraint
same width, just copy it
samples that happen precisely at this node
sanity check liveness computation
sanity check parameter number range
sanity check the cipher
save absolute path in the cache
save away the results
save copy of mapping start event
save copy of sequence start event
save header for possible continuation
save ptr before aligning it align up to (extra + 1) bytes
save the type variables (generics)
sbs url encoded so XSS shouldn't be an issue here
scale G distances by this much
scale R distances by this much
scale is now normalized.
scale, round and offset brect
scan JPEG in thumbnail (memory)
scan for recursive objects
scan over it and pull out the certs
scan through modifiers
scanToken() will always get a new token from the frontier regardless of whether there are tokens in the lookahead store
scanf.c -- This file contains the base code which implements sscanf and by extension fscanf.
scanners can tell us where the pointers are seated.
scope for the zero variable initialization
scopes that call this scope (callers)
scopes that this scope calls (callees) TODO(stephentu): this list only contains *user* functions, we should also include builtins
search for a string in a fixed-length byte string.
search for the end of the boundary
search for the lowest position covered by current and other
search, replace, and subject can all be arrays.
secondary hash (after G.
seconds since the epoch (GNU non-standard)
sections_str DOES start with , and SPACES are NOT allowed in names
see hphprealloc() for (char *) cast
see if it makes sense to use simple division to round the value
see if we encountered an error
see implementation of RuleBasedBreakIterator::createBufferClone()
see yyrealloc() for (char *) cast
see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
seed segment (popped 1st)
select db.system.namespaces collection
select this collection
self and parent are "forwarding" calls, so we need to use FPushClsMethodF instead
self is the empty tuple outside of a type.
self.init() calls require that self.init has not already been called.
self:: works dynamically for everything in a trait except for self::CLASS where it returns the trait name.
self::Constant inside trait or pseudomain
send the site command
sends an ftp command, returns true on success, false on error.
separator may contain multiple separator chars.
sequence of key events: will generate all the single keydown/keyup events
serialize a normal object
service request-y things
session will handle locking
session will terminate the request if we don't receive data in this much time
set a lower artificial limit on this in the interest of security and resource friendliness 255 arguments should be more than enough.
set based tests with many suites
set by GenericType case
set current class as the first declaring prop
set current class as the first declaring prop private props' mangled names contain the class name, so regenerate them
set custom HTTP headers
set default class members
set default timeout values
set flag for normal, old mailbox list
set hash code range bound
set http_response_code to error value
set interleave for early code.
set keyCount to 1 if an invalid string is passed
set non-blocking so we can do timeouts
set protection buffersize to zero
set rotation transform
set sign for everything, including 0's and NaNs
set the Declaration context here instead of all over this file - this phase is the first to run
set the individual row_pointers to point at the correct offsets
set the pixel at (x,y) and its 4-connected neighbors with the same pixel value to the new pixel value nc (new color).
set the thumbnail stuff to nothing so we can test to see if they get set up
set this flag so that no diagnostics will be emitted on delete.
set to largest number
set up communication between our file watching thread and a callback to post changes back to JS
set up communication channels between watcher and our thread
set will decRef any old value that may have been overwritten if appropriate
set, it will fix up any instructions that reference
set/clear intercept for RPC thread
setLocalValue - When an instruction or block argument is defined, this / method is used to register it and update our symbol table.
setSelfParam bumps the callDepth, but we aren't really past the 'self' call depth in this case.
setState(STATE_RUNNING)
set_sockaddr raises its own warning on failure
setjmp() must be called in every non-callback function that calls a PNG-reading libpng function
setlocale(): The implementation uses newlocale() and uselocale().
sets the ftp transfer type
setting parameters and static variables
setup string-variable and serialize
setup the version number: version 1
sf_var is the physical SF register, computed from the union of VregSF registers by computeLiveness() and buildIntervals().
sgrimm note: not sure AllowFirst is relevant with my implementation since we always search for the narrowest matching rule -- it really just sets whether we deny or allow by default, I think.
shadow process doesn't use g_procs
shared_external linkage is just a hack to tell the optimizer that a shared function was deserialized.
sharing globals is *evil*
shift the existing data if necessary
shift the extra to the front
short version string length
should NEVER generate this code
should be less than sizeof(uint16_t)
should be line1 one day
should be only 16bits available
should be only 8bits available
should compile to a load
should not already exist in the map
should not already exist in the map here.
should not reach here as optional shape fields are not supported in strict mode
should probably notify about errors
shouldEmitError - Check to see if we've already emitted an error at the / specified instruction.
shouldInline() helpers.
shouldn't happen, but keep the code here anyway.
show a generic error message box.
shrink the buffer down to what we really need since this can be 16 times greater than we actually need.
shuffleMagicArgs deals with everything.
shuffled into a packed array stored in the variadic capture param on the stack
shutdown the thread, if it's running
shutting down servers, so need to terminate all Keep-Alive connections
side exits if misses in the RDS
signal handler / Types
signed to catch underflow errors
silence operator support
simple xml also needs one time init
simplify() rules are not allowed to add new uses to SSATmps that aren't known to be available.
simplifyArgs does use the dominator tree, though.
simplifyBranchBlock - Simplify a basic block that ends with an unconditional / branch.
simplifyBranchOperands - Simplify operands of branches, since it can / result in exposing opportunities for CFG simplification.
simplifyCondBrBlock - Simplify a basic block that ends with a conditional / branch.
simplifySwitchEnumBlock - Simplify a basic block that ends with a / switch_enum instruction that gets its operand from an enum / instruction.
simplifySwitchEnumUnreachableBlocks - Attempt to replace a / switch_enum_inst where all but one block consists of just an / "unreachable" with an unchecked_enum_data and branch.
simplifySwitchValueBlock - Simplify a basic block that ends with a / switch_value instruction that gets its operand from an integer / literal instruction.
simplifyUnreachableBlock - Simplify blocks ending with unreachable by / removing instructions that are safe to delete backwards until we / hit an instruction we cannot delete.
simply skipping this new line
since 5.0.3, the default for this option is 0 if not specified.
since Zend auto allocates space for vars, this is no
since the cleanup state changes performed by ArgUnforwarder will occur too late.
since this buffer can be quite big
since we allow null (e.g. nullOkay is true in the call into type-resource), we have to check if the resource data is null before we try to get a connection.
since we don't support multibyte chars other than utf-8
since we have metadata for it, it must have a valid header.
since we only support win 7+ capturestackbacktrace is always available in kernel
since we're just storing the value in a local, this function doesn't care about the type of the value.
single keyboard events
single memory operations
single pattern matching
single register operations
single string parameter, used by xbox to avoid any en/decoding
single-entry, multiple-exits region that ends on conditional branches or when an instruction consumes a value of unknown type
sink_incs() is a simple pass that sinks IncRefs of values that may be uncount past some safe instructions.
sizeof(struct class_t)
skip (and measure) the data, but discard it.
skip StackTrace methods and the Count() call.
skip ahead the length of the regex match
skip any other marker silently.
skip everything else.
skip field number, I16
skip first 4 bytes to leave room for size
skip if already marked.
skip invalid variable names, as in PHP
skip leading delimiters
skip leading newlines
skip next if carriage return
skip optional separator space
skip over leading spaces or zeros
skip over the rest and go directly to additional records
skip registers we've visited already.
skip subarray without named element
skip the .gz file comment
skip the name string and the sequence ID, we don't care about those
skip the original file name
skip to the branch instruction in order to get its condition
skip unimportant stuff
skip uninteresting fields.
skipSlashStarComment - /**/ comments are skipped (treated as whitespace).
skipUntil also implicitly stops at tok::pound_endif.
skipheader ---------- Skips the ExtHeader.
skipping "tags" files
skipping emacs leftovers
skipping linux interpreter declaration
skipping the first colon
skipping the padded spaces
skipping to the last error we have
slaveOkay implicitly sets read preferences.
sleep handle was cancelled, everything is taken care of
small-string path: make a flat copy.
snprintf expects a the buffer capacity including room for the null terminator, writes the null termintor, and returns the full length not counting the null terminator.
so can index -MAXJSAMPLE ..
so it is not seen as "unused" in release builds.
so list command can default to current frame
so lower level transports can ignore incoming "Connection: keep-alive"
so no repetitive logging
so no resize would happen
so point to rightmost pixel
so pointer math below works
so reports about my children are gone
so that curl_global_init() is called ahead of time, avoiding crash
so that we always have a range
so the definition of dummy isn't optimized out
so these can't match.
so this means "I just gave you compressed data".
so to avoid "-0" output
so to generate a starter for people
so we accept too by the way: some of those companies changed their code now...
so we can assign values to them, instead of seeing CVarRef
so we can dtor this later
so we can report errno by mysql_errno()
so we don't annotate it again
so we don't have to decompress during sendImpl()
so we don't have to fetch it all the time
so we fall back to 500 return
so we initialize runtime properly
so we tab, we're done
socket had an error earlier, we need to close it, remove it from persistent storage, and create a new one (in that order)
softmagic - interpret variable magic from MAGIC
softmagic - lookup one file in parsed, in-memory copy of database Passed the name and FILE * of one file to be typed.
some broken mailers include the content-type header but not a mime-version header.
some clocks do weird stuff
some defines for the different JPEG block types
some drivers might need to describe the columns now
some drivers return a a new line at the end of the msg
some files have their values in other parts of the file
some leading directories may be unaccessable
some schemas allow the host to be empty
some servers don't open a ftp-data connection if the directory is empty
some software does not count the length bytes of COM section one company doing so is very much envolved in JPEG...
some style invalid/unknown to us
something we didn't think of
sometimes points into rds
sometimes we'll have a cursor_id but there won't be any more results
sort arcs in decreasing weight order
sort array based on string comparison
sort so we can use upper_bound to find the right prefix, rather than using a linear scan (and so we can remove duplicates, etc below)
source is palette based
space if previous printed
space in the beginning means same header
space padding, the default
spec doesn't specify this, but php5 xdebug sends back breakpoint info
special case -- power of FLT_RADIX to be
special case for Jewish calendar
special case for main() frame that's only ended by endAllFrames()
special case for trailing space
special case for years, because of leading zeros
special colours for gd
specification is found at http://yaml.org/type/int.html.
specifies row-wise and the size of a single row
specifies the number of rows returned in a single fetch call
split and decode the query
split into surrogate pair
split on commas, search and bind ini settings for each pool
split the critical edge.
split up input parameter
splitBlockForFallthrough - Prepare for the insertion of a terminator.
sprintf 0-terminates the string
spurious load if we're not returning
sqlite3_open_v2() will silently open in read-only mode if file permissions prevent writing, and there is no apparent way to detect this other than to attempt writing to the database.
src is definitely not the target type.
src is the target type or better.
src might be visible to other threads
src must be the last in its cluster
ssize_t IterAdvance(const ArrayData*, size_t pos)  Returns the position of the element that comes after pos, or the canonical invalid position if there are no more elements after pos.
ssize_t IterBegin(const ArrayData*)  Returns the position of the first element, or the canonical invalid position if this array is empty.
ssize_t IterEnd(const ArrayData*)  Returns the canonical invalid position for this array.
ssize_t IterLast(const ArrayData*)  Returns the position of the last element, or the canonical invalid position if this array is empty.
ssize_t IterRewind(const ArrayData*, size_t pos)  Returns the position of the element that comes before pos, or the canonical invalid position if there are no elements before pos.
stLoc needs to IncRef the value so it may constrain it further.
stable_maps is meaningless
stack of filled segments
stack_depth -i # Returns the current stack depth
stackaddr is not base, but top of the stack.
start of line is left of window
start of line is right of window - complement of above
start of search region
start takes milliseconds, Period is a double in seconds
start value for TSC counter
start with max key length
start with the union of the successor blocks
start() returns the index in UnicodeString, which normally means the index into an array of 16-bit code "units" (not "points").
starting a new format specifier, reset variables
starting bit of the consecutive range.
starts up the file watching thread
stat info has changed since it was cached.
stat is used, if it made here then the link is broken
state at the start of the block
static analysis functions
static array initilization
static func declarations in classes are synonyms for `class final func` declarations.
static handlers delegating work to instance ones
static or uncounted array
static or uncounted string
static things shouldn't be in the heap.
static variable use is safe here since simple store or fetch operations are atomic and because the actual probe process is not in danger of collisions or race conditions.
statically compute X / Y
statics aren't part of individual instances
statics used by the Xenon classes
status -i # Returns the status of the server
status holds the string size, or SQL_NULL_DATA
std::is_constructible doesn't test what we want it to.
std::map#insert doesn't overwrite the value, therefore we need to clean values for keys that already exists before merging dest map into source map
std::move AllVisibleValues into a temporary to destroy its contents.
stdclass converts to 1
stderr -i # This "required" dbgp-core feature is not implemented by php5 xdebug :)
stdin must be handled specially.
step_into -i # steps to the next statement, if there is a function call involved it will break on the first statement in that function
step_out -i # steps out of the current scope and breaks on the statement after returning from the current function.
step_over -i # steps to the next line.
stick that last bit of string on our output
still dealing with a group.
still mark the symbol as overridden
still zero iff exact match
stk4's slot is immediately below stk3's range, but stk5 is the last slot of its range.
stmt-guard: /     'guard' condition 'else' stmt-brace /
stop -i # Stops execution of the script by exiting
stop at type attributes
stop before corrupting unioned data
stop before hitting compressed data
stop processing of JavaScript code by loading a blank page
stop skipping 0 for M_COM
stop skipping non 0xff for M_COM
stopped by the dummy sandbox thread itself
stopped by worker thread
store information about data types the db is expecting
store parameters info (prepard stmts only)
store the link's read preference to backup, and overwrite with the cursors's read preferences
store the new resource type in the resource sizes table
store the number of parameters in this stmt
store, memcpy, memmove *to* the object can be dropped.
store_unowned doesn't take ownership of the input, so cancel it out.
store_weak doesn't take ownership of the input, so cancel it out.
stores our calculations
stores the last diagnostic message
stores the lock state
str is the UTF8 next character pointer
str1 is string but not numeric string just convert it to utf8.
str_replace() reduces all the valid combinations to multiple string_replace() calls.
stream socket functions
strict after the open tag.
string concat to avoid space at end of line after retq
string_data_hash and string_data_same both crash/assert on null.
strings with special characters will need to be quoted, as a safety measure we add 2 bytes for the quotes just in case.
strip high/strip low ( see flags )
strip off /EXTRA from prot://addr:port/EXTRA
strip out namespaces for func_get_args and friends check
strtod for IEEE-, VAX-, and IBM-arithmetic machines.
strtod() will return the nearest possible FP value for that string.
struct_element_addr P, #field indexes into the current element.
subpats_order is pre-set to pattern mode so we change it only if necessary.
subtract Move word to d and do not touch the higher 32bits
subtract immediate move byte to destiny and do not touch higher 56bits
subtype is antisymmetric and reflexive
succ already has a label but it cannot contain an inlined fp because if it did we would have stored it in the fpMap
succeeded, notify condition
successfully created the child process
successfully forked, so don't join until waitpid.
successfully read statm file
sufficient test for here
sum of all previously read chunks
summon memory to hold the row
super, which is dependent if the superclass is generic
super.constructor references an instance method (even though the decl is really a 'static' member).
super.init also requires that all ivars are initialized before the superclass initializer runs.
super.init() already called, just release the value.
super.init() calls require that super.init has not already been called.
super.init() has not been called yet, proceed below.
super.init() may or may not have been called yet, we have to check.
super_method always looks at the metatype for the class, not at any of its stored properties, so it doesn't have any DI requirements.
support some of the 1999 data types
support windows drive letters as in: file:///c:/somedir/file.txt
supporting a fallback doesn't make sense
supportsProfiling() can be called from any thread.
suppose binary format
suppress all initializers
suppress assert in setClass
surprise flag support
suspend eager execution
suspend resumed execution
swallow errors silently
sweep functions are allowed to access g_context, so we can't destroy it yet
swift encodes octal differently from C
swift.type is already a pointer type, having a shadow copy doesn't add another layer of indirection.
swift_dynamicCast performed no memory management.
swift_dynamicCast took or destroyed the value as per the original request We may still have an opaque existential container to deallocate.
swift_newtype-ed declarations may have common words with the type name stripped.
swift_once wants this as an i8*.
swift_retain(obj) Ignore retains of the "self" object, no resurrection is possible.
swiped from ext/curl/interface.c to help with consistency
switch the byte order, if necessary
switchObjHelper can throw exceptions and reenter the VM so we use the catch block here.
switch_enum instruction to be replaced.
syck does a check to see if the array is small and all scalars if it is then it outputs in inline form
syminitialize and symcleanup should really be once per process
sync up gdb Dwarf info so that gdb can do a full backtrace from the core file.
syncPrediction() is called after we update the predictedType and/or value for a LocationState.
synchronous requests will be finished at this point
system time of children
t / t here is an ArchetypeType.
t0 and t1 must pass the match_bindjmp test, have compatible stack pointer adjustments, and be for the same function.
t7621182 Don't merge different spillframes for now, because code-gen doesn't handle phi'ing an Obj and a Cls.
table clear for block compress
table for clamping the applied error
table mapping hash to allowed shift
table mapping hash to pos in patterns
tag and emit serialized version of object
take a byte from the source:
take a guess and double buffer size when over: still wasting, and it may not save that much.
take a substring after the first "."
take care of negative indexes
take value of num_index instead
taken: the param type does not match
takenBlk is in a zombie now, it will be removed later.
takenBlk is probably still reachable from other blocks.
takes an unmangled header name
taking tv by value would exclude aux.
tally the length of the added data:
task #1756122: warning and returning null is what we /should/ always do in call_user_func_array, but some code depends on the broken behavior of casting the list of args to FCallArray to an array.
tclUtf.c --  Routines for manipulating UTF-8 strings.
teleport the references in here so we don't incref
tell the ODBC driver how many rows we have in the array.
tell the driver that it is going away
tell the driver we just created a parameter
tell the main thread that pid has been set.
tell the thread to quit
tell typeCheckExpression that it is ok to produce an ambiguous result, / it can just fill in holes with UnresolvedType and we'll deal with it.
terminate the string, remove CRLF
terminateOwnedWebWorker mutates m_ownedWorkers so collect all the workers to terminate first
test iterating objects in slabs
test self-assignment.
tested in test_pagelet_server_task_result()
tested in test_xbox_task_result()
that came from a factory method.
that work is left to prepareFuncEntry.
the "Domincal number"
the "Dominical number" - finding a Sunday
the API contract is that you can call getPostData repeatedly until you call getMorePostData
the PHP io_streams stores a php_stream*)  Returns an integer (masquerading as a void*) on success, NULL on failure.
the RefData constructor steals it's input.
the Vreg that is used or def'd in the phi
the WebP bytes There can be extra chunks after the "VP8 " chunk (ICMT, ICOP, ...) All 32-bits sizes are in little-endian order.
the actual work is done in move_forward and rewind
the allocated size is always the next power of two (or zero) so we just need to reallocate when we hit a power of two
the backslash comes from namespaces.
the beginning and end of the comment.
the bug is that uenum_next doesn't set the length
the caller should already have checked
the collection setter either threw or created a reference to value, so we can use a cheaper decref.
the current period has finished
the destination weighting is substantially reduced as the
the executor is only destroyed after it is unregistered 2.
the executor is unregistered on this queue 3.
the failure condition is likely since we punt to this opcode in the JIT when the state is failed.
the fd is now owned by the main process, close our copy
the fetch method takes precedence so figure it out after we've added the OAuth params
the final case - the start of the line is inside the window
the first element is an empty table
the first instruction is a vasm ldimml, which is a li32
the first null is the first character in char_list
the first null is the last character in char_list
the following regex is also used at http://oauth.googlecode.com/svn/code/php/OAuth.php to help ensure uniform behavior between libs, credit goes to the original author(s)
the fully qualified name for this function exists, nothing to do
the images are meant to be the same dimensions
the initializing constructor).
the instructions we have seen so far.
the last (variadic) param is included in numParams (since it has a name), but the arg in that slot should be included as the first element of the variadic array
the last vector item is the default case
the liboniguruma docs say this isnt needed, but the implementation of init is not thread safe due to bugs
the list of request event handlers is a req::vector, so it gets lost at the end of the request.
the loop header to contain an ExitPlaceholder, optionally preceded by a DefLabel.
the mechanism is to force them all to start interpreting all of their code in an effort to gain control in phpDebuggerOpcodeHook().
the method does nothing if passed null
the most frequent case is bad_alloc, thrown because we've run into a system-imposed hard upper limit on memory allocation.
the native error code, specific to the data source
the next character class
the next line seems false but here IFDlength means length of all IFDs
the normal release() methods of refcounted classes aren't usable because they run dtors.
the number of UTF-16 code units is not larger than that of UTF-8 code units, + 1 for the terminator
the number of UTF-8 code units is not larger than that of UTF-16 code units * 3
the offset might have been incremented, but without further successful matches
the onUnblocked handler may free cur
the original unresolved type structure came from a type constant (instead of a type alias), and may have this/self/parent.
the print helpers decref their arg, so don't decref pop'ed value
the replacement was constructed during the recursive walk.
the same or the hdf option associated with this name does
the sandbox indicated by newId is already attached by another proxy
the solar and lunar corrections
the specified URI holds connection details
the static type itself).
the string was already proved to be valid UTF-8
the stuff from start_tok to i - 1 is the display name part
the taken branch is the fall-through block, invert the branch.
the timer has gone off...
the two slots are reserved for internal use
the type of interrupt, practically the type will be one of the following: - ExceptionThrown - ExceptionHandler - BreakPointReached - HardBreakPoint
the unit was not committed to the Repo, probably because another thread did it first.
the usefulness of padding with zeroes eludes me, it might even cause problems
the value and header are written together in writeField
the variable hasn't been unset
the various stores all had the same inputs so nothing to do.
the version of the high frequency function that is not inlined
the way this is used *is* thread safe
then use IT as our source of archetypes
then we have a self.init call.
then we have seen a redundant release.
there are cases where the length reported by mysql is too short.
there is a mismatch for this frame, but the calling frame may match so carry on.
there is a race condition in the first call to makeStaticString.
there is no 'right' char
there may be an active this, but we can just fall through in that case.
there was an error related to the compiler arguments.
there was no 'left' char
there's no support for relative time in ICU yet
these are jump offsets, but must be handled specially
these are promoted to int, so no break
these can be made stack relative
these commonly occur along with type guards
these functions operate on in-memory dynamic pointers
these hold the DEFAULT logger
these methods all spring from the base class
these refine the type
this Vptr doesn't need patch
this buffer, and we should throw it away when we're done.
this can return FAILED if there is just no more data from db
this clause is dead code, since we cancelled the "choose an install directory" screen.
this closes the previous utext, if any
this command is processed entirely locally
this covers both closures and functors
this does not re-enter
this does not re-enter set will decRef any old value that may have been overwritten if appropriate
this function has side effects, and it's supposed to
this gets rid of the ref, if it was one
this gives us a better chance of getting a scalar result.
this hash is much faster than initializing and most codebases likely only have a few constant sets with more than a thousand patterns.
this is a hack to preserve some dynamic entry points
this is a hard limit in the db server (util/messages.cpp)
this is a no-op, and can happen when we triggered VM shutdown from the timeout code path, but the connections drain while waiting for shutdown.
this is because we might have made changes to other scopes which we do not undo, so we need to announce their updates
this is for sure not allowed
this is hacky, what we need is LValueWrapper
this is not an error -- we let opendir call stat for us
this is not an error here
this is not really an error, so it is allowed.
this is now the original code by Michael G Schwern: i've changed it just a slightly bit (use emalloc, get rid of includes etc) - thies - 13.09.1999
this is technically a lie, since sleep failed
this is the case for e.g. sendEvent("...", 'A') but also works with sendEvent("...", "ABCD")
this is the child process
this is the first body if it wasn't set and buf is unset
this is the first execute
this is the innermost fault funclet reachable from b.
this is to shrink the allocation, since we probably over allocated
this is unfortunate, but is needed because we're digging into the literals to get information about them, instead of accepting general expressions.
this is used for creating images in main memory
this is where the match starts
this is where the match starts as size_t
this isn't thread-safe, but probably not a huge deal
this means string, not array
this method is only meaningful in a pagelet thread
this movzbq is only needed because callers aren't required to zero-extend the type.
this needs extra checks, so skip the optimisation
this object is no longer valid
this only happens for calls that have been morphed into bytecode e.g. idx(), abs(), strlen(), etc..
this optimization is only for 2 ints/doubles
this order must match the conversion table below
this returned type structure is unresolved.
this rule, and ST_IN_PHP_OPEN_TAG are specifically for the case where a file
this should be a thumbnail IFD
this sucks for threaded environments
this used to be "metachar.h"
this used to be "metaphone.h"
this version takes exactly two arguments.
this was the default read timeout in LibEventServer
this will free data ptr
this works around a bug in internet explorer for the macintosh which sends mime boundaries that are only LF terminated when you use an image submit button in a multipart/form-data form.
thread-local cached coverage info
thread-safe network functions
threadproc used to maintain the file watcher and any file changes it finds
throw an exception if the doc was too big
throw away all buffered output so far, so we can send back a clean soap resposne
throw away duplicate response
throw exception if serialization crapped out
throws if cross-context cycle found
throws on context depth level overflows and cross-context cycles
time separator is T or whitespace
to an invalid one so that we don't put extra strings into the default argument generator function that is not going to be ever used anyway.
to avoid wrong CodeError
to copy anything, but do anyway.
to test cpy is still working fine
to the current instruction.
todo: t2539893: check if value is already a static string
toggle AUTOCOMMIT status
toggle autocommit behavior on/off
tok::unknown is a sentinel that means "don't skip".
token required if no match was found
tokens may be NULL, in which case the number of tokens are counted, allowing the caller to allocate enough room
too few parameter bound
too many links or broken symlinks
top level DIE for each function
totalSubs  The number of variables that will be required.
traced too many exact ptrs.
trailing ', ' except for last element
transfar text charset
transform glyph image
transform*() return their input if it's unmodified, or a modified copy of their input otherwise.
transition from empty to WAITING
translate "self" or "parent"
translated path of the file
trash the native data but leave the header and object parsable
treat as normal comment
treat as normal ini line, including comment that doesn't start with #include
treat implicit pointers the same as real pointers
treat it as kBase to avoid a kIndex_Disp asm handling.
treat it as kBase_Disp to avoid a kIndex_Disp asm handling.
treat this as more likely unrelated to the previous crash.
treatRequirementsAsExplicit
tries to connect to the database
trigger callback hook for parameters
triggers acceptStopped/sets acceptor state to Draining
trim pointer so that its real and logical sizes match
trimExtraArgs is called from the prologue of the callee.
trivial for packed arrays.
true if a unique sugar mapping found
true iff size not zero
true is equal to any non-zero integer, so to preserve php's switch semantics we have to remember the first non-zero case to appear in the source text
true multithread-shared globals
truncate file, if the amount of new data is smaller than the existing data set.
try again - false means we should stop applying autoloaders (only affects classes) - anything else means keep going
try cache handle for unqualified name
try looking at the first HOWMANY bytes
try possible families (v4, v6) until we get a connection
try receive external thread events without grabbing lock
try still use relative path to containing file's directory
try to avoid breaking words
try to change the pages.
try to discover text encoding
try to evaluate if thumbnail data is present
try to get from _GET/_POST
try to get the error message from the error code.
try to map the name to the column
try to sink past Check* instructions
try to transition from WAITING to non-empty
tryFile is a pointer to a function that resolve_include() will use to determine if a path references a real file.
tryJumpThreading - Check to see if it looks profitable to duplicate the / destination of an unconditional jump into the bottom of this block.
tryToRemoveDeadAllocation - If the allocation is an autogenerated allocation / that is only stored to (after load promotion) then remove it completely.
trying to compute the length
tuple_element_addr P, 42 indexes into the current tuple element.
turn a Op b Op c, namely (a Op b) Op c into a Op (b Op c)
turn free blocks into holes, restore original freelists
turn into cascaded concat
turn keys into a string
turn on verification callback
turn the first argument into MongoCode
turning this off clears the errors
tweencolor cache functions
ty is unspecialized and we don't support guarding on CountedArr or StaticArr, so widen any subtypes of Arr to Arr.
type for the 2nd-level pointers
type for top-level pointer
type metadata cache should always be sufficiently initialized by this point.
type predictions should be added in order of location
type, protocol conformance
type, protocol name, context
typedefs for the array
typemap_get -i # Returns the types supported as well their corresponding xml schema Taken from php5 xdebug Fields are common name, lang name, and schema
unable to create class entry
unchecked_ref_cast_addr may accept nonreference static types (as a result of specialization).
unconditionally keep this for later reference
uncorrected date of the Paschal full moon
underlying file descriptor
undo effects of setting up yytext
undo the effects of YY_DO_BEFORE_ACTION
undo the safety (for comparison)
unexpected end of header
uninitialized variant
union of subCls and clsExact mixed
union of subObj and objExact mixed
union_of is commutative
unknownRelease(null) is a no-op.
unknownRetain(null) is a no-op.
unless it was from a factory method, for historical reasons.
unless the old capacity is too small, in which case we use the smallest capacity that is large enough to hold the current number of elements.
unless there are uninitialized stored properties.
unless we allow an arbitrary number of diagnostics, in which case we want to reprocess this.
unless we can delete *that* entire object as well.
unlimited (0) is the default, if max_persistent is -1
unload prev errs into array
unnamed namespace / Parse a pattern-matching clause for a case or catch statement, / including the guard expression: / /    pattern 'where' expr
unpack operator and/or still remaining in argArray
unqualified name in global namespace
unreachable for known expression kinds
unregister chunk from gdb and free chunk
unregister rebind procedure
unresolvable paths are all considered as unsafe
unsigned wrap Implicitly imported sub-modules get the same depth as their parent.
unsupported RIFF header
unused for now TODO: store any required conditional-conformance information in the private data.
unwrap optionals, check again.
unwrap the JS wrapper
up to 64 codes on the stack
update "oldest in flight" or kill it if there are no running requests
update carcs: merge c1arcs to c2arcs
update proxy's sandbox info from what is on file
update the body/part end positions.
update the buffer length
update the max store set using the bit / position.
update those bound column variables now
updateInstructionForInitState - When an instruction being analyzed moves / from being InitOrAssign to some concrete state, update it for that state.
ures_getByKeyWithFallback is a silly function.
urls are special too.
use 'int' for calculation temps
use -ve ids for translations we don't want to relocate (currently just profiling trs).
use AEmpty if you want that
use UTF-8 mapping from ASCII
use a bogus constant to store the name
use a cur pointer so we still have ai to be able to free the struct
use add/findForNewInsert
use an indirect jump through a register
use builtin print for GEN_OTHERNAME, GEN_X400, GEN_EDIPARTY, GEN_DIRNAME, GEN_IPADD and GEN_RID
use fg color directly.
use pclose instead of fclose
use read instead of fread to handle EOL in stdin
use temp in32_t because ostream thinks int8_t is a character
use temp uin32_t because ostream thinks uint8_t is a character
use the number of properties remaining as an estimate for the total number of dynamic properties when we see the first dynamic prop.
use the numeric one for calculations.
use the original file or directory name as it wasn't found
use to specify stdin.
use token where applicable
use wid for horizontal stroke
use wid for vertical stroke
use write instead of fwrite to be consistent with read o.w., read-and-write files would not work
use_realpath is 0 in the call below coz path is absolute
usec is already 0, if not set above
used in later initializations / The set of cleanups to be called when the ASTContext is destroyed.
used later for comparison with water marks
user thrown exception
user time of children
uses AttrNoOverride functions
uses the subclass lists
using chown() isn't portable if it is a symlink
using special extension to treat redirects as regular document (requires patch in php)
v /            EnumCase/ThreadedSuccessorIdx
v InlineReturn Splitting critical edges allows us to be certain that any exit head will have only callee main block predecessors, making it safe to add DefInlineFP to the start of every exit-head.
v29 reserved for Vxls::m_tmp
val is false so we're passing tmp's type.
val is teleported from the stack to the array, so we don't have to do any refcounting.
valgrind treats memory from RAND_bytes as uninitialized
valid as single byte character or leading byte
valid characters are a..z,A..Z,0..9
valid headers consist of at least three tokens, with the first being a string and the second token being a ':'
valid response, time to get out of this loop
valid would return FAILURE now
validate input parameters.
validate the next char
validateUTF8CharacterAndAdvance - Given a pointer to the starting byte of a / UTF8 character, validate it and advance the lexer past it.
validation was successful
value is either a single ref or a simple array of refs
value ptr of tiff directory entry
value was converted to an int: match normally
valuePtr's object will get destroyed when we go out of scope.
variant with the hash unrolled eight times
vasm-xls can fail if it tries to allocate too many spill slots.
vcallarray can only appear at the end of a block.
verification is turned off
verifyFile - After the file has been processed, check to see if we / got all of the expected diagnostics and check to see if there were any / unexpected ones.
version Null-terminated augmentation string.
via a "self.property" reference.
view the wbmp on stdout
visible externally, we mark the whole method as alive.
visit each tmp, assign 1 or 2 registers to each.
visit instructions to find tmps eligible to use SIMD registers
visitCLASS calls visitPARENT and checkCLASS.
visitIfCondition() serves as a helper method for visiting the condition of an "if" statement.
visitSILBasicBlocks checks BBMap before it clones a block.
visiting each argument
vixl's literal pools don't work well with our codegen pattern, so if that would happen, emit the raw bits into a GPR first and then move them unmodified into a SIMD.
void Asort(int sort_flags, bool ascending)  Sort an array and maintain index association.
void Ksort(int sort_flags, bool ascending)  Sort an array by its keys, keeping the values associated with their respective keys.
void NvGetKey(const ArrayData*, TypedValue* out, ssize_t pos)  Look up the key for an array position.
void OnSetEvalScalar(ArrayData*)  Go through an array and call Variant::setEvalScalar on each value, and make all string keys into static strings.
void Release(ArrayData*)  Free memory associated with an array.
void Renumber(ArrayData*)  Renumber integer keys on the array in place.
void Sort(int sort_flags, bool ascending)  Sort an array, by values, and then assign new keys to the elements in the resulting array.
volatile so we can gdFree it on return from longjmp
volatile so we can gdFree them after longjmp
wait for UI thread to terminate
wait for the thread to quit
wait for transition from WAITING to non-empty
wait until HTTP server is up and running
wait until the user-specified timeout for an available handle
wait() is always safe to call regardless of thread
walk out through all the closures
walk the descriptor spec and set up files/pipes
walk the oauth param names
walk up the class hierarchy.
walking to next column
wand is empty, create a 1x1 pixel image to use as a temporary canvas
want to destroy both even if destroying one fails.
warm up the s_filter_request_data
warning: if you turn off any stores using this bisector, you need to disable the corresponding deletes (or simpler, all deletes) using store_delete.
watch out, "ret", not "retval"
we add 1 or 2 to the pointers so we don't end up with all 0s, as the interesting stuff is at the end for big endian systems
we allow 1-arg calls and we allow the params to come in any order.
we already added the first one
we already know they aren't the same
we already read the 8 signature bytes
we already scanned p's body as part of scanning RDS.
we always do pre/post opt no matter the opt level
we always return success here and let OnApplyComplete() deal with the error.
we are above high water mark...
we are completely hosed now
we are going to write a new APP13 marker, so don't output the old one
we are in a generator, skip CreateCont / RetC / PopC opcodes
we are not having a cache for file stats, so do nothing here
we are not touching a file that was not successfully loaded earlier
we are priming, so we are not checking existence or expiration
we botched the k estimate
we can be called from Unit::merge, which hasnt yet setup the frame (because often it doesnt need to).
we can create an io context
we can fill as many others as we wish.)
we can ignore it if it can not decrement the reference count of the return value.
we can ignore unknown store instructions if we are computing the AvailSetMax.
we can remember the null byte
we can't call m_dispatcher.stop() from the event loop, because it blocks all I/O.
we can't possibly get here if it was a boolean "false" that's supposed to be serialized as a char
we can't really call bc_init_numbers() that calls into this constructor
we cannot optimize away the code inside if statement, because there may be a goto that goes into if statement.
we cannot use strlcpy - here the problem is that we have to copy NUL chars up to byte_count, we also have to add a single NUL character to force end of string.
we check branch offsets in checkSection().
we compute the genset and killset for every basic block.
we compute the max store set at the beginning of the basic block.
we compute the real forwardable value at a given point.
we convert numbers to integers and treat them as a string
we could also skip the cinit function here, but that would mean storing it somewhere else.
we could create a second info struct here (end_info), but it's only useful if we want to keep pre- and post-IDAT chunk info separated (mainly for PNG-aware image editors and converters)
we could go nuts here, but it's likely not worth it.
we could run optimistic DSE on functions with less than 64 basic blocks / and 64 locations which is a sizeable function.
we could run optimistic RLE on functions with less than 64 basic blocks / and 64 locations which is a sizeable function.
we didn't find any circularity, clean up.
we differ here with the TCL implementation in allowing for
we do not know the order of sections
we don't add multipart files to the params
we don't add property names and class names (or Class*) in Prop assuming that is static data not owned or accounted by the APCObject
we don't get here if any parameter before the last has isUnpack() set, so the last one had better match containsUnpack().
we don't have a timer, and we don't have a timeout
we don't perform any cleanup, if dirdepth is larger than 0.
we don't reserve(), because we don't know how selective callback will be
we don't reserve(), because we don't know how selective fn will be
we don't support openbasedir so you can access anything
we don't use chunk encoding to send anything pre-compressed
we don't use d30 and d31 because BitSet can't represent them
we dont support V in M-vectors, so leave it as an R in that case
we either have a query that returned a result set or an error occurred lets see if we have access to a result set
we expect at least one parameter in varargs
we first want to extract the mangled name from it to get this: _ZN4HPHP2VM6Transl17interpOneIterInitEv
we forked/spawned and this is the parent
we found another match put a newline and '-' to do some simple formatting
we got a persistent guy from our cache
we handled static if present.
we have a projection to the next level children, create the next level children nodes lazily.
we have a release instruction.
we have already popped FPass's input, but not pushed the output, so this check doesn't count the F result of this FPass, but does count the previous FPass*s.
we have an explicit time zone or a non-object calendar
we have cleared all slots, good enough
we have multiple epilogue releases for this argument, check whether it has covered all fields with reference semantic in the argument.
we have perfect doc comment blocks, so we can re-adjust spaces
we have to adjust timing by removing loop cost, which is the 1st test
we have to go and check with the db
we have to inspect the func at runtime
we just confirmed that the executor hasn't been unregistered above
we just handle 3 octets of data
we just stay the course and keep stepping.
we know that char_list contains null bytes, being terminated because haystack has null bytes is just dandy
we know this is valid
we may have properties from traits
we may have shifted to align
we may need an object
we might be at tok::eof now.
we need someone to hold on to a reference to it even though we're not going to do anything with it
we need to combine the current collection name with the parameter passed in, get the parent db, then select the new collection from it.
we need to determine if the enclosure is 'real' or is it escaped
we need to do this everytime since GLOB_ONLYDIR does not guarantee that all directories will be filtered.
we need to figure out which chunk to load
we need to handle xml: namespace specially, since it is an implicit schema.
we need to initialize pcre cache table very early
we need to prune the list - cc
we need unserialize and serialize again because the format was APCSerialize
we only bump it up when we're in the middle of a transaction
we only do variable inspection on continuation wait handles
we only just allocated this id, which is supposedly process unique
we perform the redundant load elimination.
we prefer to rewrite it to:
we probably don't want to load a constant into a register at the start of a block where its not used.
we really shouldn't get here, but who knows.
we rely on other passes to clean up unreachable block.
we remove the dead stores.
we run the data flow for the last iteration and perform the DSE.
we run the data flow with the genset and killset until BBWriteSetIns stop changing.
we should be able to improve this.
we should be already be in non blocking mode for network socket
we should never emit this bytecode for non-waithandle
we should've escalated
we tolerate this in TraceProfiler.
we use file cache's file name to make stat() work
we want the old behaviour
we want the private key
we will wait forever until DebuggerClient sends us something
we won't use per-row status
we work backwards so that we can use atoi more easily
we'll then force interleave for a few regions, and switch to local for the threads
we're about to hit image data, or are at EOF.
we're building systemlib.
we're guaranteed that the key is an int
we're here courtesy of longjmp
we're linting, reset whatever logger settings and write once to stdout
we're not switching threads
we're okay to be zero based here
we're only guaranteed uniqueness of the class.
we're serving real traffic now, start batching log output
we're shutting down flush http logs
we've already checked that charset needs to be replaced by rep, so now check if we can just return rep as is, or if we need to graft the options back onto it.
we've found the return value, now iterate on the CFG to find all the post-dominating retains.
we've got an unterminated enclosure, assign all the data from the start of the enclosure to end of data to the last element
we've got something to kill, make a note
we've seen the same name before, uniquify
we've seen this before, so record address
we've validated start, we can return empty_string_variant now
web request died, destroy object
week number (weeks start on Monday)
week number (weeks start on Sunday)
well that didn't work out, so let's check out _ENV
when URL is rewritten, PHP decided to put original URL as SCRIPT_NAME
when flattening traits, their requirements get flattened
when not using an objc runtime.
when seting a dynamic property, do not write directly to the TypedValue in the MixedArray, since its m_aux field is used to store the string hash of the property name.
when supporting multiple unpacks at the end of the param list, this will need to disallow transitions from unpack to non-unpack.
when we hit an existing break, copy to new buffer, and fix up laststart and lastspace
when we set a new stack we need to reset the frame position if we go from regular to async or vice-versa since the lengths aren't necessairly the same
where Self : SomeProtocol`
where T is a fresh type variable.
where new box will go
where to return number of rows fetched
whether a character is a valid part of the extended sorts of names that HHVM uses for certain generated constructs (closures, __Memoize implementations, etc)
whether to avoid priting the separator
whether to enable trans-sid for current req
whether we need to initialize
which runs in type context, not instance context.
whitespace / last char in file
whoops: sockfd has disappeared
widening a branch makes the dest instruction bigger
width, height: the dimensions of the image whose data resides in Y, U, V.
will be null unless there was an error
will be printed in its source location, see above.
will be removed by compactMergeInfo but could be hit by other threads before that happens
will clear all extra logging when this function goes out of scope
will diagnose a duplicate declaration
will raise notice and push null
will shutdown when request completes
will start a second server, which should takeover
will warn/fatal at runtime
willBeRelativelyAddressed
willSet/didSet implementations are never exposed to objc, they are always directly dispatched from the synthesized setter.
windows gives a WSAEFAULT if you try to get more bytes
with curl 7.17.0 and later, we can use COPYPOSTFIELDS, but we have to provide size before
with ioctlsocket, a non-zero sets nonblocking, a zero sets blocking
with no objective-c runtime, just give an empty pointer with the swift bit set.
with the matching retain_value to the release_value in a predecessor basic block and the matching release_value for the retain_value_retain in a successor basic block.
with the matching strong_retain to the strong_release in a predecessor basic block and the matching strong_release for the strong_retain in a successor basic block.
within cell range so no contribution to min_dist
without calling res_init(), any call to getaddrinfo() may leak memory: http://sources.redhat.com/ml/libc-hacker/2004-02/msg00049.html
without the following downcast, the write will fail (i.e., will write a zero byte) for all big endian architectures:
without this, emitClass allows classes with interfaces to be hoistable
words per line corresponding to pixdata 3, 4.
work left to right in this row
work out remaining time
work right to left in this row
work-around for longtext and alike
workaround for ICU bug
workaround for a bug in gd 1.2
working in concert with the Clang importer.
works for both resolved and unresolved TypeStructures
wrapper around send/recv to handle timeouts
wrapper for local variable LA operand
wrapper for variable-size IVA operand
wrapper of realloc, the original buffer is freed on failure
write into the last (variadic) param
write out the PNG header info (everything up to first IDAT)
write the WBMP to a gd file descriptor
write to the output file
writes result into dest without decreffing old value.
wrong image file signature
wu manber cost is mostly in preprocessing the patterns into tables.
x64 INTEGER class argument registers.
x64 SSE class argument registers.
x86 uses objc_msgSend_fpret but not objc_msgSend_fp2ret.
x86-64 has every objc_msgSend variant known to humankind.
x86-64 requires ISA-masking.
xcmd_profiler_name_get -i # Returns the profiler filename if profiling has started
xhp names are mangled so we get them back to their original definition see the mangling in ScannerToken::xhpLabel
xor the bottom with the current octet
xpath query from xpath_array
xpgSize is guaranteed to be at least one larger than objIndex.
y is bound safe at this point
y_src, u_src, v_src - Pointers to input Y, U, V row data respectively.
y_width: width of the Y image plane (aka image width) Output: 5.
yield to allow other threads access to the machine spin-wait can starve other threads.
yy_bp points to the position in yy_ch_buf of the start of the current run.
yy_c_buf_p now points to the character we want to return.
yy_ch_buf has to be 2 characters longer than the size given because we need to put in 2 end-of-buffer characters.
yy_get_next_buffer() needs the text pointing at the data we want to keep in the buffer, and the cursor pointing off the end.
yy_get_previous_state - get the state just before the EOB char was reached
yy_hold_char holds the character lost when yytext is formed.
yylex_destroy is for both reentrant and non-reentrant scanners.
yyn is the number of a rule to reduce with.
zend does this, so so do we
zend has a -m flag but we're already using it for --mode
zend_error() does not return in this case
zero before decimal point
zero extend any boolean value that we pass to the helper in case the helper expects it (e.g., as TypedValue)
zero for the background color, nothig gets outside anyway
zero only the new slots.
zero-extending/truncating copies
zlib can read uncompressed files too.
zm_deactivate_dso_test
zm_globals_ctor_dso_test
zm_globals_dtor_dso_test
